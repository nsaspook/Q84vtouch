Disassembly Listing for mateQ84
Generated From:
/public/Q84vtouch/mateQ84.X/dist/default/production/mateQ84.X.production.elf
Oct 1, 2023 7:34:09 PM

---  /tmp/xcXHlaFbI/driver_tmp_1.s  ---------------------------------------------------------------------
1C802  0E46     MOVLW 0x46
1C804  6EF6     MOVWF 0xFF6, ACCESS
1C806  0EED     MOVLW 0xED
1C808  6EF7     MOVWF 0xFF7, ACCESS
1C80A  0E01     MOVLW 0x1
1C80C  6EF8     MOVWF 0xFF8, ACCESS
1C80E  EE04     LFSR 0, 0x1100
1C812  EE20     LFSR 2, 0x100
1C816  0009     TBLRD*+
1C818  C4F5     MOVFF TABLAT, POSTINC0
1C81C  50DD     MOVF 0xFDD, W, ACCESS
1C81E  50D9     MOVF 0xFD9, W, ACCESS
1C820  E1FA     BNZ 0xC816
1C822  50DA     MOVF __end_of_UART2_tx_vect_isr, W, ACCESS
1C824  E1F8     BNZ 0xC816
1C826  0EE6     MOVLW 0xE6
1C828  6EF6     MOVWF 0xFF6, ACCESS
1C82A  0E1C     MOVLW 0x1C
1C82C  6EF7     MOVWF 0xFF7, ACCESS
1C82E  0E00     MOVLW 0x0
1C830  6EF8     MOVWF 0xFF8, ACCESS
1C832  EE03     LFSR 0, 0xE80
1C836  EE20     LFSR 2, 0x2E
1C83A  0009     TBLRD*+
1C83C  C4F5     MOVFF TABLAT, POSTINC0
1C840  50DD     MOVF 0xFDD, W, ACCESS
1C842  50D9     MOVF 0xFD9, W, ACCESS
1C844  E1FA     BNZ 0xC83A
1C846  0E46     MOVLW 0x46
1C848  6EF6     MOVWF 0xFF6, ACCESS
1C84A  0EEE     MOVLW 0xEE
1C84C  6EF7     MOVWF 0xFF7, ACCESS
1C84E  0E01     MOVLW 0x1
1C850  6EF8     MOVWF 0xFF8, ACCESS
1C852  EE02     LFSR 0, 0xB00
1C856  EE20     LFSR 2, 0xFF
1C85A  0009     TBLRD*+
1C85C  C4F5     MOVFF TABLAT, POSTINC0
1C860  50DD     MOVF 0xFDD, W, ACCESS
1C862  50D9     MOVF 0xFD9, W, ACCESS
1C864  E1FA     BNZ 0xC85A
1C866  0E72     MOVLW 0x72
1C868  6EF6     MOVWF 0xFF6, ACCESS
1C86A  0E08     MOVLW 0x8
1C86C  6EF7     MOVWF 0xFF7, ACCESS
1C86E  0E00     MOVLW 0x0
1C870  6EF8     MOVWF 0xFF8, ACCESS
1C872  EE02     LFSR 0, 0x800
1C876  EE20     LFSR 2, 0x81
1C87A  0009     TBLRD*+
1C87C  C4F5     MOVFF TABLAT, POSTINC0
1C880  50DD     MOVF 0xFDD, W, ACCESS
1C882  50D9     MOVF 0xFD9, W, ACCESS
1C884  E1FA     BNZ 0xC87A
1C886  0E1E     MOVLW 0x1E
1C888  6EF6     MOVWF 0xFF6, ACCESS
1C88A  0E1E     MOVLW 0x1E
1C88C  6EF7     MOVWF 0xFF7, ACCESS
1C88E  0E00     MOVLW 0x0
1C890  6EF8     MOVWF 0xFF8, ACCESS
1C892  EE01     LFSR 0, 0x7C9
1C896  EE20     LFSR 2, 0x2B
1C89A  0009     TBLRD*+
1C89C  C4F5     MOVFF TABLAT, POSTINC0
1C8A0  50DD     MOVF 0xFDD, W, ACCESS
1C8A2  50D9     MOVF 0xFD9, W, ACCESS
1C8A4  E1FA     BNZ 0xC89A
1C8A6  0EAE     MOVLW 0xAE
1C8A8  6EF6     MOVWF 0xFF6, ACCESS
1C8AA  0E24     MOVLW 0x24
1C8AC  6EF7     MOVWF 0xFF7, ACCESS
1C8AE  0E00     MOVLW 0x0
1C8B0  6EF8     MOVWF 0xFF8, ACCESS
1C8B2  EE01     LFSR 0, 0x6DF
1C8B6  EE20     LFSR 2, 0x1F
1C8BA  0009     TBLRD*+
1C8BC  C4F5     MOVFF TABLAT, POSTINC0
1C8C0  50DD     MOVF 0xFDD, W, ACCESS
1C8C2  50D9     MOVF 0xFD9, W, ACCESS
1C8C4  E1FA     BNZ 0xC8BA
1C8C6  0EEA     MOVLW 0xEA
1C8C8  6EF6     MOVWF 0xFF6, ACCESS
1C8CA  0E10     MOVLW 0x10
1C8CC  6EF7     MOVWF 0xFF7, ACCESS
1C8CE  0E00     MOVLW 0x0
1C8D0  6EF8     MOVWF 0xFF8, ACCESS
1C8D2  EE01     LFSR 0, 0x560
1C8D6  EE20     LFSR 2, 0x50
1C8DA  0009     TBLRD*+
1C8DC  C4F5     MOVFF TABLAT, POSTINC0
1C8E0  50DD     MOVF 0xFDD, W, ACCESS
1C8E2  50D9     MOVF 0xFD9, W, ACCESS
1C8E4  E1FA     BNZ 0xC8DA
1C8E6  0E82     MOVLW 0x82
1C8E8  6EF6     MOVWF 0xFF6, ACCESS
1C8EA  0E27     MOVLW 0x27
1C8EC  6EF7     MOVWF 0xFF7, ACCESS
1C8EE  0E00     MOVLW 0x0
1C8F0  6EF8     MOVWF 0xFF8, ACCESS
1C8F2  0009     TBLRD*+
1C8F4  C4F5     MOVFF TABLAT, cc_mode
1C8F8  0009     TBLRD*+
1C8FA  C4F5     MOVFF TABLAT, 0x54C
1C8FE  0009     TBLRD*+
1C900  C4F5     MOVFF TABLAT, scroll_line_pos
1C904  EE04     LFSR 0, 0x1300
1C908  EE20     LFSR 2, 0xFF
1C90C  6AEE     CLRF 0xFEE, ACCESS
1C90E  50DD     MOVF 0xFDD, W, ACCESS
1C910  50D9     MOVF 0xFD9, W, ACCESS
1C912  E1FC     BNZ 0xC90C
1C914  50DA     MOVF __end_of_UART2_tx_vect_isr, W, ACCESS
1C916  E1FA     BNZ 0xC90C
1C918  EE04     LFSR 0, 0x1200
1C91C  EE20     LFSR 2, 0xFF
1C920  6AEE     CLRF 0xFEE, ACCESS
1C922  50DD     MOVF 0xFDD, W, ACCESS
1C924  50D9     MOVF 0xFD9, W, ACCESS
1C926  E1FC     BNZ 0xC920
1C928  50DA     MOVF __end_of_UART2_tx_vect_isr, W, ACCESS
1C92A  E1FA     BNZ 0xC920
1C92C  EE04     LFSR 0, 0x1000
1C930  0E80     MOVLW 0x80
1C932  6AEE     CLRF 0xFEE, ACCESS
1C934  06E8     DECF 0xFE8, F, ACCESS
1C936  E1FD     BNZ 0xC932
1C938  EE03     LFSR 0, 0xF00
1C93C  0EF0     MOVLW 0xF0
1C93E  6AEE     CLRF 0xFEE, ACCESS
1C940  06E8     DECF 0xFE8, F, ACCESS
1C942  E1FD     BNZ 0xC93E
1C944  EE03     LFSR 0, 0xE00
1C948  0E80     MOVLW 0x80
1C94A  6AEE     CLRF 0xFEE, ACCESS
1C94C  06E8     DECF 0xFE8, F, ACCESS
1C94E  E1FD     BNZ 0xC94A
1C950  EE03     LFSR 0, 0xD00
1C954  0EE9     MOVLW 0xE9
1C956  6AEE     CLRF 0xFEE, ACCESS
1C958  06E8     DECF 0xFE8, F, ACCESS
1C95A  E1FD     BNZ 0xC956
1C95C  EE03     LFSR 0, 0xC00
1C960  0EF0     MOVLW 0xF0
1C962  6AEE     CLRF 0xFEE, ACCESS
1C964  06E8     DECF 0xFE8, F, ACCESS
1C966  E1FD     BNZ 0xC962
1C968  EE02     LFSR 0, 0xA00
1C96C  0EE4     MOVLW 0xE4
1C96E  6AEE     CLRF 0xFEE, ACCESS
1C970  06E8     DECF 0xFE8, F, ACCESS
1C972  E1FD     BNZ 0xC96E
1C974  EE02     LFSR 0, 0x900
1C978  0EF7     MOVLW 0xF7
1C97A  6AEE     CLRF 0xFEE, ACCESS
1C97C  06E8     DECF 0xFE8, F, ACCESS
1C97E  E1FD     BNZ 0xC97A
1C980  EE02     LFSR 0, 0x881
1C984  0E74     MOVLW 0x74
1C986  6AEE     CLRF 0xFEE, ACCESS
1C988  06E8     DECF 0xFE8, F, ACCESS
1C98A  E1FD     BNZ 0xC986
1C98C  EE01     LFSR 0, 0x700
1C990  0E8A     MOVLW 0x8A
1C992  6AEE     CLRF 0xFEE, ACCESS
1C994  06E8     DECF 0xFE8, F, ACCESS
1C996  E1FD     BNZ 0xC992
1C998  EE01     LFSR 0, 0x600
1C99C  0EDF     MOVLW 0xDF
1C99E  6AEE     CLRF 0xFEE, ACCESS
1C9A0  06E8     DECF 0xFE8, F, ACCESS
1C9A2  E1FD     BNZ 0xC99E
1C9A4  EE01     LFSR 0, 0x5CB
1C9A8  0E19     MOVLW 0x19
1C9AA  6AEE     CLRF 0xFEE, ACCESS
1C9AC  06E8     DECF 0xFE8, F, ACCESS
1C9AE  E1FD     BNZ 0xC9AA
1C9B0  EE01     LFSR 0, 0x521
1C9B4  0E18     MOVLW 0x18
1C9B6  6AEE     CLRF 0xFEE, ACCESS
1C9B8  06E8     DECF 0xFE8, F, ACCESS
1C9BA  E1FD     BNZ 0xC9B6
1C9BC  0104     MOVLB 0x4
1C9BE  0E08     MOVLW 0x8
1C9C0  6F5D     MOVWF 0x5D, BANKED
1C9C2  0E00     MOVLW 0x0
1C9C4  6F5E     MOVWF 0x5E, BANKED
1C9C6  0E00     MOVLW 0x0
1C9C8  6F5F     MOVWF 0x5F, BANKED
1C9CA  0100     MOVLB 0x0
1C9CC  EF0C     GOTO 0x14618
---  /public/Q84vtouch/timers.c  ------------------------------------------------------------------------
1:             #include "timers.h"
2:             
3:             #pragma warning disable 520
4:             #pragma warning disable 1498
5:             #pragma warning disable 1090
6:             
7:             extern volatile uint16_t tickCount[TMR_COUNT];
8:             
9:             //**********************************************************************************************************************
10:            // Start one of the software timers
11:            
12:            void StartTimer(const uint8_t timer, const uint16_t count)
13:            {
14:            	tickCount[timer] = count << 1; //Interrupt is every 500us but StartTimer() takes multiple of 1ms so multiply by 2
17CE  0EFD     MOVLW 0xFD
17D0  0061     MOVFFL PLUSW1, wtemp5
17D2  F38C     NOP
17D4  F50B     NOP
17D6  0EFE     MOVLW 0xFE
17D8  0061     MOVFFL PLUSW1, 0x50C
17DA  F38C     NOP
17DC  F50C     NOP
17DE  90D8     BCF 0xFD8, 0, ACCESS
17E0  340B     RLCF 0xB, W, ACCESS
17E2  6E09     MOVWF 0x9, ACCESS
17E4  340C     RLCF 0xC, W, ACCESS
17E6  6E0A     MOVWF 0xA, ACCESS
17E8  0EFF     MOVLW 0xFF
17EA  50E3     MOVF 0xFE3, W, ACCESS
17EC  0D02     MULLW 0x2
17EE  0E00     MOVLW 0x0
17F0  24F3     ADDWF 0xFF3, W, ACCESS
17F2  6ED9     MOVWF 0xFD9, ACCESS
17F4  0E07     MOVLW 0x7
17F6  20F4     ADDWFC 0xFF4, W, ACCESS
17F8  6EDA     MOVWF __end_of_UART2_tx_vect_isr, ACCESS
17FA  0061     MOVFFL ltemp2, POSTINC2
17FC  F424     NOP
17FE  F4DE     NOP
1800  0061     MOVFFL ttemp3, POSTDEC2
1802  F428     NOP
1804  F4DD     NOP
15:            }
1806  52E5     MOVF 0xFE5, F, ACCESS
1806  52E5     MOVF 0xFE5, F, ACCESS
1806  52E5     MOVF 0xFE5, F, ACCESS
1806  52E5     MOVF 0xFE5, F, ACCESS
16:            
17:            //**********************************************************************************************************************
18:            // Check if one of the software software timers has timed out
19:            
20:            bool TimerDone(const uint8_t timer)
21:            {
22:            	if (tickCount[timer] == 0) { //Check if counted down to zero
1FE2  0EFF     MOVLW 0xFF
1FE4  50E3     MOVF 0xFE3, W, ACCESS
1FE6  0D02     MULLW 0x2
1FE8  0E00     MOVLW 0x0
1FEA  24F3     ADDWF 0xFF3, W, ACCESS
1FEC  6ED9     MOVWF 0xFD9, ACCESS
1FEE  0E07     MOVLW 0x7
1FF0  20F4     ADDWFC 0xFF4, W, ACCESS
1FF2  6EDA     MOVWF __end_of_UART2_tx_vect_isr, ACCESS
1FF4  50DE     MOVF 0xFDE, W, ACCESS
1FF6  10DE     IORWF 0xFDE, W, ACCESS
1FF8  A4D8     BTFSS 0xFD8, 2, ACCESS
1FFA  D002     BRA 0x2000
23:            		return true; //then return true
1FFC  0E01     MOVLW 0x1
1FFE  D001     BRA 0x2002
24:            	}
25:            	return false; //else return false
2000  0E00     MOVLW 0x0
2002  6E01     MOVWF __ptext283, ACCESS
26:            }
2004  52E5     MOVF 0xFE5, F, ACCESS
2004  52E5     MOVF 0xFE5, F, ACCESS
27:            
28:            //**********************************************************************************************************************
29:            // Simple delay for n milliseconds (blocking)
30:            
31:            void WaitMs(const uint16_t numMilliseconds)
1FBC  0EFE     MOVLW 0xFE
32:            {
33:            	StartTimer(TMR_INTERNAL, numMilliseconds); //Start software timer and wait for it to count down
1FBE  C4E3     MOVFF PLUSW1, POSTINC1
1FC0  F4E6     NOP
1FC2  C4E3     MOVFF PLUSW1, POSTINC1
1FC4  F4E6     NOP
1FC6  0E00     MOVLW 0x0
1FC8  6EE6     MOVWF 0xFE6, ACCESS
1FCA  ECE7     CALL 0x17CE, 0
1FCC  F00B     NOP
34:            	while (!TimerDone(TMR_INTERNAL)) {
1FCE  0E00     MOVLW 0x0
1FD0  6EE6     MOVWF 0xFE6, ACCESS
1FD2  ECF1     CALL 0x1FE2, 0
1FD4  F00F     NOP
1FD6  5001     MOVF __ptext283, W, ACCESS
1FD8  B4D8     BTFSC 0xFD8, 2, ACCESS
1FDA  D7F9     BRA 0x1FCE
35:            	} //Enter idle mode to reduce power while waiting
36:            } //(timer interrupt will wake part from idle)
1FDC  52E5     MOVF 0xFE5, F, ACCESS
1FDC  52E5     MOVF 0xFE5, F, ACCESS
1FDC  52E5     MOVF 0xFE5, F, ACCESS
37:            
38:            /*
39:             * runs in timer #4 interrupt from FM_io(void)
40:             */
41:            void timer_ms_tick(const uint32_t status, const uintptr_t context)
1FD72  52E6     MOVF 0xFE6, F, ACCESS
1FD74  52E6     MOVF 0xFE6, F, ACCESS
42:            {
43:            	MISC_SetHigh();
1FD76  82C2     BSF 0xFC2, 1, ACCESS
44:            	//Decrement each software timer
45:            	for (uint16_t i = 0; i < TMR_COUNT; i++) {
1FD78  0EFE     MOVLW 0xFE
1FD7A  6AE3     CLRF 0xFE3, ACCESS
1FD7C  0EFF     MOVLW 0xFF
1FD7E  6AE3     CLRF 0xFE3, ACCESS
46:            		if (tickCount[i] != 0) {
1FD80  0EFE     MOVLW 0xFE
1FD82  0061     MOVFFL PLUSW1, wtemp5
1FD84  F38C     NOP
1FD86  F50B     NOP
1FD88  0EFF     MOVLW 0xFF
1FD8A  0061     MOVFFL PLUSW1, 0x50C
1FD8C  F38C     NOP
1FD8E  F50C     NOP
1FD90  90D8     BCF 0xFD8, 0, ACCESS
1FD92  340B     RLCF 0xB, W, ACCESS
1FD94  6E09     MOVWF 0x9, ACCESS
1FD96  340C     RLCF 0xC, W, ACCESS
1FD98  6E0A     MOVWF 0xA, ACCESS
1FD9A  0E00     MOVLW 0x0
1FD9C  2409     ADDWF 0x9, W, ACCESS
1FD9E  6ED9     MOVWF 0xFD9, ACCESS
1FDA0  0E07     MOVLW 0x7
1FDA2  200A     ADDWFC 0xA, W, ACCESS
1FDA4  6EDA     MOVWF __end_of_UART2_tx_vect_isr, ACCESS
1FDA6  50DE     MOVF 0xFDE, W, ACCESS
1FDA8  10DE     IORWF 0xFDE, W, ACCESS
1FDAA  B4D8     BTFSC 0xFD8, 2, ACCESS
1FDAC  D016     BRA 0xFDDA
47:            			tickCount[i]--;
1FDAE  0EFE     MOVLW 0xFE
1FDB0  0061     MOVFFL PLUSW1, wtemp5
1FDB2  F38C     NOP
1FDB4  F50B     NOP
1FDB6  0EFF     MOVLW 0xFF
1FDB8  0061     MOVFFL PLUSW1, 0x50C
1FDBA  F38C     NOP
1FDBC  F50C     NOP
1FDBE  90D8     BCF 0xFD8, 0, ACCESS
1FDC0  340B     RLCF 0xB, W, ACCESS
1FDC2  6E09     MOVWF 0x9, ACCESS
1FDC4  340C     RLCF 0xC, W, ACCESS
1FDC6  6E0A     MOVWF 0xA, ACCESS
1FDC8  0E00     MOVLW 0x0
1FDCA  2409     ADDWF 0x9, W, ACCESS
1FDCC  6ED9     MOVWF 0xFD9, ACCESS
1FDCE  0E07     MOVLW 0x7
1FDD0  200A     ADDWFC 0xA, W, ACCESS
1FDD2  6EDA     MOVWF __end_of_UART2_tx_vect_isr, ACCESS
1FDD4  06DE     DECF 0xFDE, F, ACCESS
1FDD6  0E00     MOVLW 0x0
1FDD8  5ADD     SUBWFB 0xFDD, F, ACCESS
48:            		}
49:            	}
1FDDA  0EFE     MOVLW 0xFE
1FDDC  50E3     MOVF 0xFE3, W, ACCESS
1FDDE  0F01     ADDLW 0x1
1FDE0  6E01     MOVWF __ptext283, ACCESS
1FDE2  0EFE     MOVLW 0xFE
1FDE4  0061     MOVFFL ltemp0, PLUSW1
1FDE6  F404     NOP
1FDE8  F4E3     NOP
1FDEA  6A01     CLRF __ptext283, ACCESS
1FDEC  0EFF     MOVLW 0xFF
1FDEE  50E3     MOVF 0xFE3, W, ACCESS
1FDF0  2001     ADDWFC __ptext283, W, ACCESS
1FDF2  6E01     MOVWF __ptext283, ACCESS
1FDF4  0EFF     MOVLW 0xFF
1FDF6  0061     MOVFFL ltemp0, PLUSW1
1FDF8  F404     NOP
1FDFA  F4E3     NOP
1FDFC  0EFF     MOVLW 0xFF
1FDFE  50E3     MOVF 0xFE3, W, ACCESS
1FE00  E108     BNZ 0xFE12
1FE02  0EFE     MOVLW 0xFE
1FE04  0061     MOVFFL PLUSW1, ltemp0
1FE06  F38C     NOP
1FE08  F501     NOP
1FE0A  0E05     MOVLW 0x5
1FE0C  5E01     SUBWF __ptext283, F, ACCESS
1FE0E  A0D8     BTFSS 0xFD8, 0, ACCESS
1FE10  D7B7     BRA 0xFD80
50:            	MISC_SetLow();
1FE12  92C2     BCF 0xFC2, 1, ACCESS
51:            }
1FE14  0EF6     MOVLW 0xF6
1FE16  26E1     ADDWF 0xFE1, F, ACCESS
1FE18  0EFF     MOVLW 0xFF
1FE1A  22E2     ADDWFC 0xFE2, F, ACCESS
1FE1A  22E2     ADDWFC 0xFE2, F, ACCESS
52:            
53:            /*
54:             * microsecond busy wait delay, 90 seconds MAX
55:             * Careful, uses core timer
56:             */
57:            void delay_us(uint32_t us)
58:            {
59:            }
60:            
61:            void delay_ms(const uint16_t ms)
2626  0EFE     MOVLW 0xFE
62:            {
63:            	WaitMs(ms);
2628  C4E3     MOVFF PLUSW1, POSTINC1
262A  F4E6     NOP
262C  C4E3     MOVFF PLUSW1, POSTINC1
262E  F4E6     NOP
2630  ECDE     CALL 0x1FBC, 0
2632  F00F     NOP
64:            }
2634  52E5     MOVF 0xFE5, F, ACCESS
2634  52E5     MOVF 0xFE5, F, ACCESS
2634  52E5     MOVF 0xFE5, F, ACCESS
---  /public/Q84vtouch/modbus_master.c  -----------------------------------------------------------------
1:             #include "modbus_master.h"
2:             
3:             #define	ON	1
4:             #define	OFF	0
5:             
6:             volatile uint8_t cc_stream_file, cc_buffer[MAX_DATA], cc_buffer_tx[MAX_DATA]; // RX and TX command buffers
7:             
8:             volatile M_data M = {
9:                 .blink_lock = false,
10:                .power_on = true,
11:            };
12:            
13:            volatile M_time_data MT = {
14:                .clock_10hz = 0,
15:                .clock_2hz = 0,
16:                .clock_500hz = 0,
17:            };
18:            
19:            C_data C = {
20:                .mcmd = G_ID,
21:                .cstate = CLEAR,
22:                .modbus_command = G_ID,
23:                .req_length = 0,
24:                .trace = 0,
25:                .config_ok = false,
26:                .id_ok = false,
27:                .passwd_ok = false,
28:                .light_ok = false,
29:                .M.blink_lock = false,
30:                .M.power_on = true,
31:                .tm_ok = false,
32:            };
33:            
34:            volatile struct V_type V = {
35:                .StartTime = 1,
36:                .TimeUsed = 1,
37:                .pacing = 1,
38:                .pwm_update = true,
39:                .pwm_stop = true,
40:                .fault_active = false,
41:                .fault_count = 0,
42:                .dmt_sosc_flag = false,
43:            };
44:            
45:            /*
46:             * send and receive MODBUS templates for 3-phase energy monitor EM540
47:             * https://www.gavazzionline.com/pdf/EM540_DS_ENG.pdf
48:             * https://gavazzi.se/app/uploads/2022/03/em500-cp-v1r3-eng.pdf
49:             */
50:            const uint8_t
51:            // transmit frames for commands
52:            modbus_em_id[] = {MADDR, READ_HOLDING_REGISTERS, 0x00, 0x0b, 0x00, 0x01}, // Carlo Gavazzi Controls identification code
53:            modbus_em_version[] = {MADDR, READ_HOLDING_REGISTERS, 0x03, 0x02, 0x00, 0x01}, // Firmware version and revision code
54:            modbus_em_data1[] = {MADDR, READ_HOLDING_REGISTERS, 0x00, 0x00, 0x00, EM_DATA_LEN1}, // last number is 16-bit words wanted from the start register address 0x0000
55:            modbus_em_data2[] = {MADDR, READ_HOLDING_REGISTERS, 0x05, 0x00, 0x00, EM_DATA_LEN2}, // last number is 16-bit words wanted from the start register address 0x0500
56:            modbus_em_serial[] = {MADDR, READ_HOLDING_REGISTERS, 0x50, 0x00, 0x00, SERIAL_DATA_LEN}, // last number is 16-bit words wanted from the start register address 0x5000
57:            modbus_em_config[] = {MADDR, WRITE_SINGLE_REGISTER, 0x10, 0x02, 0x00, 0x02}, // System configuration, Value 2 = ?2P? (2-phase with neutral)
58:            modbus_em_passwd[] = {MADDR, WRITE_SINGLE_REGISTER, 0x10, 0x00, 0x00, 0x00}, // Password configuration, set to no password = 0
59:            modbus_em_light[] = {MADDR, WRITE_SINGLE_REGISTER, 0x16, 0x04, 0x00, 0x01}, // back-light timeout, 1 min
60:            // receive frames prototypes for received data checking
61:            em_id[] = {MADDR, READ_HOLDING_REGISTERS, 0x00, 0x00, 0x00, 0x00, 0x00},
62:            em_version[] = {MADDR, READ_HOLDING_REGISTERS, 0x00, 0x00, 0x00, 0x00, 0x00},
63:            em_data1[(EM_DATA_LEN1 * 2) + 5] = {MADDR, READ_HOLDING_REGISTERS, 0x00}, // number of 16-bit words returned, IN BYTES
64:            em_data2[(EM_DATA_LEN2 * 2) + 5] = {MADDR, READ_HOLDING_REGISTERS, 0x00}, // number of 16-bit words returned, IN BYTES
65:            em_serial[(SERIAL_DATA_LEN * 2) + 5] = {MADDR, READ_HOLDING_REGISTERS, 0x00}, // number of 16-bit words returned, IN BYTES
66:            em_config[] = {MADDR, WRITE_SINGLE_REGISTER, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
67:            em_passwd[] = {MADDR, WRITE_SINGLE_REGISTER, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
68:            em_light[] = {MADDR, WRITE_SINGLE_REGISTER, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00};
69:            
70:            EM_data1 em;
71:            EM_data2 emt;
72:            EM_serial ems;
73:            EM_version emv;
74:            
75:            static void half_dup_tx(const bool);
76:            static void half_dup_rx(const bool);
77:            static bool serial_trmt(void);
78:            static uint16_t modbus_rtu_send_msg_crc(volatile uint8_t *, uint16_t);
79:            static uint16_t crc16_receive(C_data *);
80:            static void log_crc_error(const uint16_t, const uint16_t);
81:            static void UART1_DefaultFramingErrorHandler_mb(void);
82:            static void UART1_DefaultOverrunErrorHandler_mb(void);
83:            static void UART1_DefaultErrorHandler_mb(void);
84:            
85:            static bool modbus_write_check(C_data *, bool*, uint16_t);
86:            static bool modbus_read_check(C_data *, bool*, uint16_t, void (* DataHandler)(void));
87:            static bool modbus_read_id_check(C_data *, bool*, uint16_t);
88:            static void em_data_handler(void);
89:            static void emt_data_handler(void);
90:            static void ems_data_handler(void);
91:            static void emv_data_handler(void);
92:            
93:            /*
94:             * add the required CRC bytes to a MODBUS message
95:             */
96:            static uint16_t modbus_rtu_send_msg_crc(volatile uint8_t *req, uint16_t req_length) {
1F042  52E6     MOVF 0xFE6, F, ACCESS
1F044  52E6     MOVF 0xFE6, F, ACCESS
97:                uint16_t crc;
98:            
99:                crc = crc16(req, req_length);
1F046  0EFA     MOVLW 0xFA
1F048  C4E3     MOVFF PLUSW1, POSTINC1
1F04A  F4E6     NOP
1F04C  C4E3     MOVFF PLUSW1, POSTINC1
1F04E  F4E6     NOP
1F050  0EFA     MOVLW 0xFA
1F052  C4E3     MOVFF PLUSW1, POSTINC1
1F054  F4E6     NOP
1F056  C4E3     MOVFF PLUSW1, POSTINC1
1F058  F4E6     NOP
1F05A  EC35     CALL 0x1DE6A, 0
1F05C  F0EF     NOP
1F05E  0EFE     MOVLW 0xFE
1F060  0061     MOVFFL ltemp0, PLUSW1
1F062  F404     NOP
1F064  F4E3     NOP
1F066  0EFF     MOVLW 0xFF
1F068  0061     MOVFFL ttemp5, PLUSW1
1F06A  F408     NOP
1F06C  F4E3     NOP
100:               req[req_length++] = crc >> (uint16_t) 8;
1F06E  0EFF     MOVLW 0xFF
1F070  24E1     ADDWF 0xFE1, W, ACCESS
1F072  6ED9     MOVWF 0xFD9, ACCESS
1F074  0EFF     MOVLW 0xFF
1F076  20E2     ADDWFC 0xFE2, W, ACCESS
1F078  6EDA     MOVWF __end_of_UART2_tx_vect_isr, ACCESS
1F07A  0EFA     MOVLW 0xFA
1F07C  0061     MOVFFL PLUSW1, wtemp5
1F07E  F38C     NOP
1F080  F50B     NOP
1F082  0EFB     MOVLW 0xFB
1F084  0061     MOVFFL PLUSW1, 0x50C
1F086  F38C     NOP
1F088  F50C     NOP
1F08A  0EFC     MOVLW 0xFC
1F08C  0061     MOVFFL PLUSW1, ltemp2
1F08E  F38C     NOP
1F090  F509     NOP
1F092  0EFD     MOVLW 0xFD
1F094  0061     MOVFFL PLUSW1, ttemp3
1F096  F38C     NOP
1F098  F50A     NOP
1F09A  500B     MOVF 0xB, W, ACCESS
1F09C  2409     ADDWF 0x9, W, ACCESS
1F09E  6EE9     MOVWF 0xFE9, ACCESS
1F0A0  500C     MOVF 0xC, W, ACCESS
1F0A2  200A     ADDWFC 0xA, W, ACCESS
1F0A4  6EEA     MOVWF 0xFEA, ACCESS
1F0A6  C4DF     MOVFF INDF2, INDF0
1F0A8  F4EF     NOP
1F0AA  0EFA     MOVLW 0xFA
1F0AC  50E3     MOVF 0xFE3, W, ACCESS
1F0AE  0F01     ADDLW 0x1
1F0B0  6E01     MOVWF __ptext283, ACCESS
1F0B2  0EFA     MOVLW 0xFA
1F0B4  0061     MOVFFL ltemp0, PLUSW1
1F0B6  F404     NOP
1F0B8  F4E3     NOP
1F0BA  6A01     CLRF __ptext283, ACCESS
1F0BC  0EFB     MOVLW 0xFB
1F0BE  50E3     MOVF 0xFE3, W, ACCESS
1F0C0  2001     ADDWFC __ptext283, W, ACCESS
1F0C2  6E01     MOVWF __ptext283, ACCESS
1F0C4  0EFB     MOVLW 0xFB
1F0C6  0061     MOVFFL ltemp0, PLUSW1
1F0C8  F404     NOP
1F0CA  F4E3     NOP
101:               req[req_length++] = crc & 0x00FF;
1F0CC  0EFA     MOVLW 0xFA
1F0CE  0061     MOVFFL PLUSW1, wtemp5
1F0D0  F38C     NOP
1F0D2  F50B     NOP
1F0D4  0EFB     MOVLW 0xFB
1F0D6  0061     MOVFFL PLUSW1, 0x50C
1F0D8  F38C     NOP
1F0DA  F50C     NOP
1F0DC  0EFC     MOVLW 0xFC
1F0DE  0061     MOVFFL PLUSW1, ltemp2
1F0E0  F38C     NOP
1F0E2  F509     NOP
1F0E4  0EFD     MOVLW 0xFD
1F0E6  0061     MOVFFL PLUSW1, ttemp3
1F0E8  F38C     NOP
1F0EA  F50A     NOP
1F0EC  500B     MOVF 0xB, W, ACCESS
1F0EE  2409     ADDWF 0x9, W, ACCESS
1F0F0  6ED9     MOVWF 0xFD9, ACCESS
1F0F2  500C     MOVF 0xC, W, ACCESS
1F0F4  200A     ADDWFC 0xA, W, ACCESS
1F0F6  6EDA     MOVWF __end_of_UART2_tx_vect_isr, ACCESS
1F0F8  0EFE     MOVLW 0xFE
1F0FA  C4E3     MOVFF PLUSW1, INDF2
1F0FC  F4DF     NOP
1F0FE  0EFA     MOVLW 0xFA
1F100  50E3     MOVF 0xFE3, W, ACCESS
1F102  0F01     ADDLW 0x1
1F104  6E01     MOVWF __ptext283, ACCESS
1F106  0EFA     MOVLW 0xFA
1F108  0061     MOVFFL ltemp0, PLUSW1
1F10A  F404     NOP
1F10C  F4E3     NOP
1F10E  6A01     CLRF __ptext283, ACCESS
1F110  0EFB     MOVLW 0xFB
1F112  50E3     MOVF 0xFE3, W, ACCESS
1F114  2001     ADDWFC __ptext283, W, ACCESS
1F116  6E01     MOVWF __ptext283, ACCESS
1F118  0EFB     MOVLW 0xFB
1F11A  0061     MOVFFL ltemp0, PLUSW1
1F11C  F404     NOP
1F11E  F4E3     NOP
102:           
103:               return req_length;
1F120  0EFA     MOVLW 0xFA
1F122  0061     MOVFFL PLUSW1, ltemp0
1F124  F38C     NOP
1F126  F501     NOP
1F128  0EFB     MOVLW 0xFB
1F12A  0061     MOVFFL PLUSW1, ttemp5
1F12C  F38C     NOP
1F12E  F502     NOP
104:           }
1F130  0EFA     MOVLW 0xFA
1F130  0EFA     MOVLW 0xFA
1F130  0EFA     MOVLW 0xFA
1F130  0EFA     MOVLW 0xFA
1F130  0EFA     MOVLW 0xFA
105:           
106:           /*
107:            * constructs a properly formatted RTU message with CRC from a program memory array to the data memory array buffer
108:            */
109:           uint16_t modbus_rtu_send_msg(void *cc_buffer, const void *modbus_cc_mode, uint16_t req_length) {
163E  0EFA     MOVLW 0xFA
110:               memcpy((void*) cc_buffer, (const void *) modbus_cc_mode, req_length);
1640  C4E3     MOVFF PLUSW1, POSTINC1
1642  F4E6     NOP
1644  C4E3     MOVFF PLUSW1, POSTINC1
1646  F4E6     NOP
1648  0EFA     MOVLW 0xFA
164A  C4E3     MOVFF PLUSW1, POSTINC1
164C  F4E6     NOP
164E  C4E3     MOVFF PLUSW1, POSTINC1
1650  F4E6     NOP
1652  0EFA     MOVLW 0xFA
1654  C4E3     MOVFF PLUSW1, POSTINC1
1656  F4E6     NOP
1658  C4E3     MOVFF PLUSW1, POSTINC1
165A  F4E6     NOP
165C  EC81     CALL 0x1E502, 0
165E  F0F2     NOP
111:               /*
112:                * add the CRC and increase message size by two bytes for the CRC16
113:                */
114:               return modbus_rtu_send_msg_crc((volatile uint8_t *) cc_buffer, req_length);
1660  0EFA     MOVLW 0xFA
1662  C4E3     MOVFF PLUSW1, POSTINC1
1664  F4E6     NOP
1666  C4E3     MOVFF PLUSW1, POSTINC1
1668  F4E6     NOP
166A  0EFC     MOVLW 0xFC
166C  C4E3     MOVFF PLUSW1, POSTINC1
166E  F4E6     NOP
1670  C4E3     MOVFF PLUSW1, POSTINC1
1672  F4E6     NOP
1674  EC21     CALL 0x1F042, 0
1676  F0F8     NOP
115:           }
1678  0EFA     MOVLW 0xFA
1678  0EFA     MOVLW 0xFA
1678  0EFA     MOVLW 0xFA
1678  0EFA     MOVLW 0xFA
1678  0EFA     MOVLW 0xFA
116:           
117:           /*
118:            * calculate a CRC16 from the data buffer
119:            */
120:           uint16_t crc16(volatile uint8_t *buffer, uint16_t buffer_length) {
1DE6A  0E05     MOVLW 0x5
1DE6C  26E1     ADDWF 0xFE1, F, ACCESS
1DE6E  0E00     MOVLW 0x0
1DE70  22E2     ADDWFC 0xFE2, F, ACCESS
121:               uint8_t crc_hi = 0xFF; /* high CRC byte initialized */
1DE72  0EFF     MOVLW 0xFF
1DE74  6E0C     MOVWF 0xC, ACCESS
1DE76  0EFE     MOVLW 0xFE
1DE78  0061     MOVFFL 0x50C, PLUSW1
1DE7A  F430     NOP
1DE7C  F4E3     NOP
122:               uint8_t crc_lo = 0xFF; /* low CRC byte initialized */
1DE7E  0EFF     MOVLW 0xFF
1DE80  6E0C     MOVWF 0xC, ACCESS
1DE82  0EFD     MOVLW 0xFD
1DE84  0061     MOVFFL 0x50C, PLUSW1
1DE86  F430     NOP
1DE88  F4E3     NOP
123:               uint8_t i; /* will index into CRC lookup */
124:               uint16_t crc16t;
125:           
126:               /* pass through message buffer */
127:               while (buffer_length--) {
1DE8A  D04C     BRA 0xDF24
1DF24  0EF7     MOVLW 0xF7
1DF26  0061     MOVFFL PLUSW1, ltemp0
1DF28  F38C     NOP
1DF2A  F501     NOP
1DF2C  0E01     MOVLW 0x1
1DF2E  5E01     SUBWF __ptext283, F, ACCESS
1DF30  0EF7     MOVLW 0xF7
1DF32  0061     MOVFFL ltemp0, PLUSW1
1DF34  F404     NOP
1DF36  F4E3     NOP
1DF38  0EF8     MOVLW 0xF8
1DF3A  0061     MOVFFL PLUSW1, ltemp0
1DF3C  F38C     NOP
1DF3E  F501     NOP
1DF40  0E00     MOVLW 0x0
1DF42  5A01     SUBWFB __ptext283, F, ACCESS
1DF44  0EF8     MOVLW 0xF8
1DF46  0061     MOVFFL ltemp0, PLUSW1
1DF48  F404     NOP
1DF4A  F4E3     NOP
1DF4C  0EF7     MOVLW 0xF7
1DF4E  28E3     INCF 0xFE3, W, ACCESS
1DF50  E19D     BNZ 0xDE8C
1DF52  0EF8     MOVLW 0xF8
1DF54  28E3     INCF 0xFE3, W, ACCESS
1DF56  A4D8     BTFSS 0xFD8, 2, ACCESS
1DF58  D799     BRA 0xDE8C
128:                   i = crc_hi ^ *buffer++; /* calculate the CRC  */
1DE8C  0EFE     MOVLW 0xFE
1DE8E  0061     MOVFFL PLUSW1, 0x50C
1DE90  F38C     NOP
1DE92  F50C     NOP
1DE94  0EF9     MOVLW 0xF9
1DE96  C4E3     MOVFF PLUSW1, FSR2
1DE98  F4D9     NOP
1DE9A  0EFA     MOVLW 0xFA
1DE9C  C4E3     MOVFF PLUSW1, FSR2H
1DE9E  F4DA     NOP
1DEA0  50DF     MOVF 0xFDF, W, ACCESS
1DEA2  180C     XORWF 0xC, W, ACCESS
1DEA4  6E0C     MOVWF 0xC, ACCESS
1DEA6  0EFF     MOVLW 0xFF
1DEA8  0061     MOVFFL 0x50C, PLUSW1
1DEAA  F430     NOP
1DEAC  F4E3     NOP
1DEAE  0EF9     MOVLW 0xF9
1DEB0  50E3     MOVF 0xFE3, W, ACCESS
1DEB2  0F01     ADDLW 0x1
1DEB4  6E01     MOVWF __ptext283, ACCESS
1DEB6  0EF9     MOVLW 0xF9
1DEB8  0061     MOVFFL ltemp0, PLUSW1
1DEBA  F404     NOP
1DEBC  F4E3     NOP
1DEBE  6A01     CLRF __ptext283, ACCESS
1DEC0  0EFA     MOVLW 0xFA
1DEC2  50E3     MOVF 0xFE3, W, ACCESS
1DEC4  2001     ADDWFC __ptext283, W, ACCESS
1DEC6  6E01     MOVWF __ptext283, ACCESS
1DEC8  0EFA     MOVLW 0xFA
1DECA  0061     MOVFFL ltemp0, PLUSW1
1DECC  F404     NOP
1DECE  F4E3     NOP
129:                   crc_hi = crc_lo ^ table_crc_hi[i];
1DED0  0EFD     MOVLW 0xFD
1DED2  0061     MOVFFL PLUSW1, 0x50C
1DED4  F38C     NOP
1DED6  F50C     NOP
1DED8  0EFF     MOVLW 0xFF
1DEDA  50E3     MOVF 0xFE3, W, ACCESS
1DEDC  6E09     MOVWF 0x9, ACCESS
1DEDE  6A0A     CLRF 0xA, ACCESS
1DEE0  0E69     MOVLW 0x69
1DEE2  2409     ADDWF 0x9, W, ACCESS
1DEE4  6EF6     MOVWF 0xFF6, ACCESS
1DEE6  0EF8     MOVLW 0xF8
1DEE8  200A     ADDWFC 0xA, W, ACCESS
1DEEA  6EF7     MOVWF 0xFF7, ACCESS
1DEEC  6AF8     CLRF 0xFF8, ACCESS
1DEEE  0E00     MOVLW 0x0
1DEF0  22F8     ADDWFC 0xFF8, F, ACCESS
1DEF2  0008     TBLRD*
1DEF4  50F5     MOVF 0xFF5, W, ACCESS
1DEF6  180C     XORWF 0xC, W, ACCESS
1DEF8  6E0C     MOVWF 0xC, ACCESS
1DEFA  0EFE     MOVLW 0xFE
1DEFC  0061     MOVFFL 0x50C, PLUSW1
1DEFE  F430     NOP
1DF00  F4E3     NOP
130:                   crc_lo = table_crc_lo[i];
1DF02  0EFF     MOVLW 0xFF
1DF04  50E3     MOVF 0xFE3, W, ACCESS
1DF06  6E0B     MOVWF 0xB, ACCESS
1DF08  6A0C     CLRF 0xC, ACCESS
1DF0A  0E69     MOVLW 0x69
1DF0C  240B     ADDWF 0xB, W, ACCESS
1DF0E  6EF6     MOVWF 0xFF6, ACCESS
1DF10  0EF7     MOVLW 0xF7
1DF12  200C     ADDWFC 0xC, W, ACCESS
1DF14  6EF7     MOVWF 0xFF7, ACCESS
1DF16  6AF8     CLRF 0xFF8, ACCESS
1DF18  0E00     MOVLW 0x0
1DF1A  22F8     ADDWFC 0xFF8, F, ACCESS
1DF1C  0008     TBLRD*
1DF1E  0EFD     MOVLW 0xFD
1DF20  C4F5     MOVFF TABLAT, PLUSW1
1DF22  F4E3     NOP
131:               }
132:           
133:               crc16t = (uint16_t) crc_hi << (uint16_t) 8 | (uint16_t) crc_lo;
1DF5A  0EFE     MOVLW 0xFE
1DF5C  50E3     MOVF 0xFE3, W, ACCESS
1DF5E  6E0C     MOVWF 0xC, ACCESS
1DF60  6A0B     CLRF 0xB, ACCESS
1DF62  0EFD     MOVLW 0xFD
1DF64  50E3     MOVF 0xFE3, W, ACCESS
1DF66  120B     IORWF 0xB, F, ACCESS
1DF68  0E00     MOVLW 0x0
1DF6A  120C     IORWF 0xC, F, ACCESS
1DF6C  0EFB     MOVLW 0xFB
1DF6E  0061     MOVFFL wtemp5, PLUSW1
1DF70  F42C     NOP
1DF72  F4E3     NOP
1DF74  0EFC     MOVLW 0xFC
1DF76  0061     MOVFFL 0x50C, PLUSW1
1DF78  F430     NOP
1DF7A  F4E3     NOP
134:               return crc16t;
1DF7C  0EFB     MOVLW 0xFB
1DF7E  0061     MOVFFL PLUSW1, ltemp0
1DF80  F38C     NOP
1DF82  F501     NOP
1DF84  0EFC     MOVLW 0xFC
1DF86  0061     MOVFFL PLUSW1, ttemp5
1DF88  F38C     NOP
1DF8A  F502     NOP
135:           }
1DF8C  0EF7     MOVLW 0xF7
1DF8C  0EF7     MOVLW 0xF7
1DF8C  0EF7     MOVLW 0xF7
1DF8C  0EF7     MOVLW 0xF7
1DF8C  0EF7     MOVLW 0xF7
136:           
137:           /*
138:            * callback for UART received character from MODBUS client
139:            * for each RX byte received on the RS485 serial port
140:            */
141:           void my_modbus_rx_32(void) {
142:               static uint8_t m_data = 0;
143:           
144:               INT_TRACE;
16C6  ACBF     BTFSS 0xFBF, 6, ACCESS
16C8  D002     BRA 0x16CE
16CA  0E01     MOVLW 0x1
16CC  D001     BRA 0x16D0
16CE  0E00     MOVLW 0x0
16D0  0AFF     XORLW 0xFF
16D2  6E0C     MOVWF 0xC, ACCESS
16D4  3A0C     SWAPF 0xC, F, ACCESS
16D6  460C     RLNCF 0xC, F, ACCESS
16D8  460C     RLNCF 0xC, F, ACCESS
16DA  50BF     MOVF 0xFBF, W, ACCESS
16DC  180C     XORWF 0xC, W, ACCESS
16DE  0BBF     ANDLW 0xBF
16E0  180C     XORWF 0xC, W, ACCESS
16E2  6EBF     MOVWF 0xFBF, ACCESS
145:               M.rx = true;
16E4  0E01     MOVLW 0x1
16E6  0106     MOVLB 0x6
16E8  6FF5     MOVWF DMAnSPTRH, BANKED
146:               /*
147:                * process received controller data stream
148:                */
149:               m_data = Srbuffer; // receiver data buffer
16EA  C2ED     MOVFF U5RXB, m_data
16EC  F5DD     NOP
150:               cc_buffer[M.recv_count] = m_data;
16EE  0E00     MOVLW 0x0
16F0  25E1     ADDWF 0xE1, W, BANKED
16F2  6ED9     MOVWF 0xFD9, ACCESS
16F4  6ADA     CLRF __end_of_UART2_tx_vect_isr, ACCESS
16F6  0E0C     MOVLW 0xC
16F8  22DA     ADDWFC __end_of_UART2_tx_vect_isr, F, ACCESS
16FA  C5DD     MOVFF m_data, INDF2
16FC  F4DF     NOP
151:               if (++M.recv_count >= MAX_DATA) {
16FE  2BE1     INCF 0xE1, F, BANKED
1700  0EEF     MOVLW 0xEF
1702  65E1     CPFSGT 0xE1, BANKED
1704  0012     RETURN 0
152:                   M.recv_count = 0; // reset buffer position
1706  6BE1     CLRF 0xE1, BANKED
153:               }
154:           }
1708  0012     RETURN 0
155:           
156:           uint8_t init_stream_params(void) {
157:               M.config = false;
158:               return 0;
159:           }
160:           
161:           /*
162:            * state machine hardware timers interrupt ISR functions setup
163:            */
164:           void init_mb_master_timers(void) {
1E4A  0EB6     MOVLW 0xB6
165:               TMR5_SetInterruptHandler(timer_500ms_tick);
1E4C  6EE6     MOVWF 0xFE6, ACCESS
1E4E  0E1C     MOVLW 0x1C
1E50  6EE6     MOVWF 0xFE6, ACCESS
1E52  0E00     MOVLW 0x0
1E54  6EE6     MOVWF 0xFE6, ACCESS
1E56  ECE3     CALL 0x21C6, 0
1E58  F010     NOP
166:               TMR5_StartTimer();
1E5A  ECA0     CALL 0x2740, 0
1E5C  F013     NOP
167:               TMR6_SetInterruptHandler(timer_2ms_tick);
1E5E  0EF6     MOVLW 0xF6
1E60  6EE6     MOVWF 0xFE6, ACCESS
1E62  0E19     MOVLW 0x19
1E64  6EE6     MOVWF 0xFE6, ACCESS
1E66  0E00     MOVLW 0x0
1E68  6EE6     MOVWF 0xFE6, ACCESS
1E6A  ECD2     CALL 0x21A4, 0
1E6C  F010     NOP
168:               TMR6_StartTimer();
1E6E  EC9A     CALL 0x2734, 0
1E70  F013     NOP
169:           }
1E72  0012     RETURN 0
170:           
171:           /*
172:            * helper functions
173:            * received CRC16 bytes from client
174:            */
175:           static uint16_t crc16_receive(C_data * client) {
1FE1E  52E6     MOVF 0xFE6, F, ACCESS
1FE20  52E6     MOVF 0xFE6, F, ACCESS
176:               uint16_t crc16r;
177:           
178:               crc16r = ((uint16_t) cc_buffer[client->req_length - 2] << (uint16_t) 8) | ((uint16_t) cc_buffer[client->req_length - 1] & 0x00ff);
1FE22  0EFC     MOVLW 0xFC
1FE24  0061     MOVFFL PLUSW1, wtemp5
1FE26  F38C     NOP
1FE28  F50B     NOP
1FE2A  0EFD     MOVLW 0xFD
1FE2C  0061     MOVFFL PLUSW1, 0x50C
1FE2E  F38C     NOP
1FE30  F50C     NOP
1FE32  0E03     MOVLW 0x3
1FE34  240B     ADDWF 0xB, W, ACCESS
1FE36  6ED9     MOVWF 0xFD9, ACCESS
1FE38  0E00     MOVLW 0x0
1FE3A  200C     ADDWFC 0xC, W, ACCESS
1FE3C  6EDA     MOVWF __end_of_UART2_tx_vect_isr, ACCESS
1FE3E  0061     MOVFFL POSTINC2, wtemp5
1FE40  F378     NOP
1FE42  F50B     NOP
1FE44  0061     MOVFFL POSTDEC2, 0x50C
1FE46  F374     NOP
1FE48  F50C     NOP
1FE4A  0EFE     MOVLW 0xFE
1FE4C  240B     ADDWF 0xB, W, ACCESS
1FE4E  6ED9     MOVWF 0xFD9, ACCESS
1FE50  0E0B     MOVLW 0xB
1FE52  200C     ADDWFC 0xC, W, ACCESS
1FE54  6EDA     MOVWF __end_of_UART2_tx_vect_isr, ACCESS
1FE56  50DF     MOVF 0xFDF, W, ACCESS
1FE58  6E0C     MOVWF 0xC, ACCESS
1FE5A  6A0B     CLRF 0xB, ACCESS
1FE5C  0EFC     MOVLW 0xFC
1FE5E  0061     MOVFFL PLUSW1, ltemp2
1FE60  F38C     NOP
1FE62  F509     NOP
1FE64  0EFD     MOVLW 0xFD
1FE66  0061     MOVFFL PLUSW1, ttemp3
1FE68  F38C     NOP
1FE6A  F50A     NOP
1FE6C  0E03     MOVLW 0x3
1FE6E  2409     ADDWF 0x9, W, ACCESS
1FE70  6ED9     MOVWF 0xFD9, ACCESS
1FE72  0E00     MOVLW 0x0
1FE74  200A     ADDWFC 0xA, W, ACCESS
1FE76  6EDA     MOVWF __end_of_UART2_tx_vect_isr, ACCESS
1FE78  0061     MOVFFL POSTINC2, ltemp2
1FE7A  F378     NOP
1FE7C  F509     NOP
1FE7E  0061     MOVFFL POSTDEC2, ttemp3
1FE80  F374     NOP
1FE82  F50A     NOP
1FE84  0EFF     MOVLW 0xFF
1FE86  2409     ADDWF 0x9, W, ACCESS
1FE88  6ED9     MOVWF 0xFD9, ACCESS
1FE8A  0E0B     MOVLW 0xB
1FE8C  200A     ADDWFC 0xA, W, ACCESS
1FE8E  6EDA     MOVWF __end_of_UART2_tx_vect_isr, ACCESS
1FE90  50DF     MOVF 0xFDF, W, ACCESS
1FE92  120B     IORWF 0xB, F, ACCESS
1FE94  0E00     MOVLW 0x0
1FE96  120C     IORWF 0xC, F, ACCESS
1FE98  0EFE     MOVLW 0xFE
1FE9A  0061     MOVFFL wtemp5, PLUSW1
1FE9C  F42C     NOP
1FE9E  F4E3     NOP
1FEA0  0EFF     MOVLW 0xFF
1FEA2  0061     MOVFFL 0x50C, PLUSW1
1FEA4  F430     NOP
1FEA6  F4E3     NOP
179:               return crc16r;
1FEA8  0EFE     MOVLW 0xFE
1FEAA  0061     MOVFFL PLUSW1, ltemp0
1FEAC  F38C     NOP
1FEAE  F501     NOP
1FEB0  0EFF     MOVLW 0xFF
1FEB2  0061     MOVFFL PLUSW1, ttemp5
1FEB4  F38C     NOP
1FEB6  F502     NOP
180:           }
1FEB8  52E5     MOVF 0xFE5, F, ACCESS
1FEBA  52E5     MOVF 0xFE5, F, ACCESS
1FEBC  52E5     MOVF 0xFE5, F, ACCESS
1FEBE  52E5     MOVF 0xFE5, F, ACCESS
1FEBE  52E5     MOVF 0xFE5, F, ACCESS
181:           
182:           static void log_crc_error(const uint16_t c_crc, const uint16_t c_crc_rec) {
183:               M.crc_calc = c_crc;
1C22  0EFE     MOVLW 0xFE
1C24  C4E3     MOVFF PLUSW1, 0x6E7
1C26  F6E7     NOP
1C28  0EFF     MOVLW 0xFF
1C2A  C4E3     MOVFF PLUSW1, 0x6E8
1C2C  F6E8     NOP
184:               M.crc_data = c_crc_rec;
1C2E  0EFC     MOVLW 0xFC
1C30  C4E3     MOVFF PLUSW1, 0x6E5
1C32  F6E5     NOP
1C34  0EFD     MOVLW 0xFD
1C36  C4E3     MOVFF PLUSW1, _eaDogM_WriteString
1C38  F6E6     NOP
185:               M.crc_error++;
1C3A  0E01     MOVLW 0x1
1C3C  0106     MOVLB 0x6
1C3E  27E9     ADDWF DMAnBUF, F, BANKED
1C40  0E00     MOVLW 0x0
1C42  23EA     ADDWFC DMAnDCNT, F, BANKED
1C44  23EB     ADDWFC DMAnDCNTH, F, BANKED
1C46  23EC     ADDWFC DMAnDPTR, F, BANKED
186:               M.error++;
1C48  4BE3     INFSNZ 0xE3, F, BANKED
1C4A  2BE4     INCF 0xE4, F, BANKED
187:           }
1C4C  52E5     MOVF 0xFE5, F, ACCESS
1C4C  52E5     MOVF 0xFE5, F, ACCESS
1C4C  52E5     MOVF 0xFE5, F, ACCESS
1C4C  52E5     MOVF 0xFE5, F, ACCESS
1C4C  52E5     MOVF 0xFE5, F, ACCESS
188:           
189:           /*
190:            * reorder 16-bit word bytes for int32_t
191:            * https://control.com/forums/threads/endianness-for-32-bit-data.48584/
192:            * https://ctlsys.com/support/common_modbus_protocol_misconceptions/
193:            * https://iotech.force.com/edgexpert/s/article/Byte-and-Word-Swapping-in-Modbus
194:            *
195:            * "Little Endian" slaves or "Big Endian" slaves
196:            * Byte endianness with Word endianness?
197:            * Lions and Tigers and Bears!
198:            */
199:           int32_t mb32_swap(const int32_t value) {
1F13A  0E05     MOVLW 0x5
1F13C  26E1     ADDWF 0xFE1, F, ACCESS
1F13E  0E00     MOVLW 0x0
1F140  22E2     ADDWFC 0xFE2, F, ACCESS
200:               uint8_t i;
201:               union MREG32 dvalue;
202:           
203:               // program it simple and easy to understand way, let the compiler optimize the expressions
204:               dvalue.value = value;
1F142  0EF7     MOVLW 0xF7
1F144  0061     MOVFFL PLUSW1, ltemp2
1F146  F38C     NOP
1F148  F509     NOP
1F14A  0EF8     MOVLW 0xF8
1F14C  0061     MOVFFL PLUSW1, ttemp3
1F14E  F38C     NOP
1F150  F50A     NOP
1F152  0EF9     MOVLW 0xF9
1F154  0061     MOVFFL PLUSW1, wtemp5
1F156  F38C     NOP
1F158  F50B     NOP
1F15A  0EFA     MOVLW 0xFA
1F15C  0061     MOVFFL PLUSW1, 0x50C
1F15E  F38C     NOP
1F160  F50C     NOP
1F162  0EFB     MOVLW 0xFB
1F164  0061     MOVFFL ltemp2, PLUSW1
1F166  F424     NOP
1F168  F4E3     NOP
1F16A  0EFC     MOVLW 0xFC
1F16C  0061     MOVFFL ttemp3, PLUSW1
1F16E  F428     NOP
1F170  F4E3     NOP
1F172  0EFD     MOVLW 0xFD
1F174  0061     MOVFFL wtemp5, PLUSW1
1F176  F42C     NOP
1F178  F4E3     NOP
1F17A  0EFE     MOVLW 0xFE
1F17C  0061     MOVFFL 0x50C, PLUSW1
1F17E  F430     NOP
1F180  F4E3     NOP
205:               i = dvalue.bytes[0];
1F182  0EFB     MOVLW 0xFB
1F184  0061     MOVFFL PLUSW1, ltemp0
1F186  F38C     NOP
1F188  F501     NOP
1F18A  0EFF     MOVLW 0xFF
1F18C  0061     MOVFFL ltemp0, PLUSW1
1F18E  F404     NOP
1F190  F4E3     NOP
206:               dvalue.bytes[0] = dvalue.bytes[1];
1F192  0EFC     MOVLW 0xFC
1F194  24E1     ADDWF 0xFE1, W, ACCESS
1F196  6ED9     MOVWF 0xFD9, ACCESS
1F198  0EFF     MOVLW 0xFF
1F19A  20E2     ADDWFC 0xFE2, W, ACCESS
1F19C  6EDA     MOVWF __end_of_UART2_tx_vect_isr, ACCESS
1F19E  50DF     MOVF 0xFDF, W, ACCESS
1F1A0  6E0C     MOVWF 0xC, ACCESS
1F1A2  0EFB     MOVLW 0xFB
1F1A4  0061     MOVFFL 0x50C, PLUSW1
1F1A6  F430     NOP
1F1A8  F4E3     NOP
207:               dvalue.bytes[1] = i;
1F1AA  0EFC     MOVLW 0xFC
1F1AC  24E1     ADDWF 0xFE1, W, ACCESS
1F1AE  6ED9     MOVWF 0xFD9, ACCESS
1F1B0  0EFF     MOVLW 0xFF
1F1B2  20E2     ADDWFC 0xFE2, W, ACCESS
1F1B4  6EDA     MOVWF __end_of_UART2_tx_vect_isr, ACCESS
1F1B6  0EFF     MOVLW 0xFF
1F1B8  C4E3     MOVFF PLUSW1, INDF2
1F1BA  F4DF     NOP
208:               i = dvalue.bytes[2];
1F1BC  0EFD     MOVLW 0xFD
1F1BE  24E1     ADDWF 0xFE1, W, ACCESS
1F1C0  6ED9     MOVWF 0xFD9, ACCESS
1F1C2  0EFF     MOVLW 0xFF
1F1C4  20E2     ADDWFC 0xFE2, W, ACCESS
1F1C6  6EDA     MOVWF __end_of_UART2_tx_vect_isr, ACCESS
1F1C8  50DF     MOVF 0xFDF, W, ACCESS
1F1CA  6E0C     MOVWF 0xC, ACCESS
1F1CC  0EFF     MOVLW 0xFF
1F1CE  0061     MOVFFL 0x50C, PLUSW1
1F1D0  F430     NOP
1F1D2  F4E3     NOP
209:               dvalue.bytes[2] = dvalue.bytes[3];
1F1D4  0EFE     MOVLW 0xFE
1F1D6  24E1     ADDWF 0xFE1, W, ACCESS
1F1D8  6ED9     MOVWF 0xFD9, ACCESS
1F1DA  0EFF     MOVLW 0xFF
1F1DC  20E2     ADDWFC 0xFE2, W, ACCESS
1F1DE  6EDA     MOVWF __end_of_UART2_tx_vect_isr, ACCESS
1F1E0  0EFD     MOVLW 0xFD
1F1E2  24E1     ADDWF 0xFE1, W, ACCESS
1F1E4  6EE9     MOVWF 0xFE9, ACCESS
1F1E6  0EFF     MOVLW 0xFF
1F1E8  20E2     ADDWFC 0xFE2, W, ACCESS
1F1EA  6EEA     MOVWF 0xFEA, ACCESS
1F1EC  C4DF     MOVFF INDF2, INDF0
1F1EE  F4EF     NOP
210:               dvalue.bytes[3] = i;
1F1F0  0EFE     MOVLW 0xFE
1F1F2  24E1     ADDWF 0xFE1, W, ACCESS
1F1F4  6ED9     MOVWF 0xFD9, ACCESS
1F1F6  0EFF     MOVLW 0xFF
1F1F8  20E2     ADDWFC 0xFE2, W, ACCESS
1F1FA  6EDA     MOVWF __end_of_UART2_tx_vect_isr, ACCESS
1F1FC  0EFF     MOVLW 0xFF
1F1FE  C4E3     MOVFF PLUSW1, INDF2
1F200  F4DF     NOP
211:               return dvalue.value;
1F202  0EFB     MOVLW 0xFB
1F204  0061     MOVFFL PLUSW1, ltemp0
1F206  F38C     NOP
1F208  F501     NOP
1F20A  0EFC     MOVLW 0xFC
1F20C  0061     MOVFFL PLUSW1, ttemp5
1F20E  F38C     NOP
1F210  F502     NOP
1F212  0EFD     MOVLW 0xFD
1F214  0061     MOVFFL PLUSW1, wtemp1
1F216  F38C     NOP
1F218  F503     NOP
1F21A  0EFE     MOVLW 0xFE
1F21C  0061     MOVFFL PLUSW1, ttemp1
1F21E  F38C     NOP
1F220  F504     NOP
212:           }
1F222  0EF7     MOVLW 0xF7
1F222  0EF7     MOVLW 0xF7
1F222  0EF7     MOVLW 0xF7
1F222  0EF7     MOVLW 0xF7
1F222  0EF7     MOVLW 0xF7
213:           
214:           int16_t mb16_swap(const int16_t value) {
0972  52E6     MOVF 0xFE6, F, ACCESS
0974  52E6     MOVF 0xFE6, F, ACCESS
0976  52E6     MOVF 0xFE6, F, ACCESS
215:               uint8_t i;
216:               union MREG dvalue;
217:           
218:               // program it simple and easy to understand way, let the compiler optimize the expressions
219:               dvalue.value = value;
0978  0EFB     MOVLW 0xFB
097A  0061     MOVFFL PLUSW1, ltemp0
097C  F38C     NOP
097E  F501     NOP
0980  0EFD     MOVLW 0xFD
0982  0061     MOVFFL ltemp0, PLUSW1
0984  F404     NOP
0986  F4E3     NOP
0988  0EFC     MOVLW 0xFC
098A  0061     MOVFFL PLUSW1, ltemp0
098C  F38C     NOP
098E  F501     NOP
0990  0EFE     MOVLW 0xFE
0992  0061     MOVFFL ltemp0, PLUSW1
0994  F404     NOP
0996  F4E3     NOP
220:               i = dvalue.bytes[0];
0998  0EFD     MOVLW 0xFD
099A  0061     MOVFFL PLUSW1, ltemp0
099C  F38C     NOP
099E  F501     NOP
09A0  0EFF     MOVLW 0xFF
09A2  0061     MOVFFL ltemp0, PLUSW1
09A4  F404     NOP
09A6  F4E3     NOP
221:               dvalue.bytes[0] = dvalue.bytes[1];
09A8  0EFE     MOVLW 0xFE
09AA  24E1     ADDWF 0xFE1, W, ACCESS
09AC  6ED9     MOVWF 0xFD9, ACCESS
09AE  0EFF     MOVLW 0xFF
09B0  20E2     ADDWFC 0xFE2, W, ACCESS
09B2  6EDA     MOVWF __end_of_UART2_tx_vect_isr, ACCESS
09B4  50DF     MOVF 0xFDF, W, ACCESS
09B6  6E0C     MOVWF 0xC, ACCESS
09B8  0EFD     MOVLW 0xFD
09BA  0061     MOVFFL 0x50C, PLUSW1
09BC  F430     NOP
09BE  F4E3     NOP
222:               dvalue.bytes[1] = i;
09C0  0EFE     MOVLW 0xFE
09C2  24E1     ADDWF 0xFE1, W, ACCESS
09C4  6ED9     MOVWF 0xFD9, ACCESS
09C6  0EFF     MOVLW 0xFF
09C8  20E2     ADDWFC 0xFE2, W, ACCESS
09CA  6EDA     MOVWF __end_of_UART2_tx_vect_isr, ACCESS
09CC  0EFF     MOVLW 0xFF
09CE  C4E3     MOVFF PLUSW1, INDF2
09D0  F4DF     NOP
223:               return dvalue.value;
09D2  0EFD     MOVLW 0xFD
09D4  0061     MOVFFL PLUSW1, ltemp0
09D6  F38C     NOP
09D8  F501     NOP
09DA  0EFE     MOVLW 0xFE
09DC  0061     MOVFFL PLUSW1, ttemp5
09DE  F38C     NOP
09E0  F502     NOP
224:           }
09E2  0EFB     MOVLW 0xFB
09E2  0EFB     MOVLW 0xFB
09E2  0EFB     MOVLW 0xFB
09E2  0EFB     MOVLW 0xFB
09E2  0EFB     MOVLW 0xFB
225:           
226:           /*
227:            * Simple MODBUS master state machine
228:            * this needs to run in the main programming loop
229:            * to handle RS485 serial I/O exchanges
230:            */
231:           int8_t master_controller_work(C_data * client) {
15186  52E6     MOVF 0xFE6, F, ACCESS
232:               static uint32_t spacing = 0;
233:           
234:               if (spacing++ <SPACING && !M.rx) {
15188  0061     MOVFFL spacing, ltemp2
1518A  FCC4     NOP
1518C  F509     NOP
1518E  0061     MOVFFL 0x732, ttemp3
15190  FCC8     NOP
15192  F50A     NOP
15194  0061     MOVFFL 0x733, wtemp5
15196  FCCC     NOP
15198  F50B     NOP
1519A  0061     MOVFFL 0x734, 0x50C
1519C  FCD0     NOP
1519E  F50C     NOP
151A0  0107     MOVLB 0x7
151A2  2B31     INCF 0x31, F, BANKED
151A4  0E00     MOVLW 0x0
151A6  2332     ADDWFC 0x32, F, BANKED
151A8  2333     ADDWFC 0x33, F, BANKED
151AA  2334     ADDWFC 0x34, F, BANKED
151AC  500C     MOVF 0xC, W, ACCESS
151AE  100B     IORWF 0xB, W, ACCESS
151B0  100A     IORWF 0xA, W, ACCESS
151B2  E109     BNZ 0x51C6
151B4  0E28     MOVLW 0x28
151B6  5C09     SUBWF 0x9, W, ACCESS
151B8  B0D8     BTFSC 0xFD8, 0, ACCESS
151BA  D005     BRA 0x51C6
151BC  0106     MOVLB 0x6
151BE  51F5     MOVF DMAnSPTRH, W, BANKED
151C0  B4D8     BTFSC 0xFD8, 2, ACCESS
151C2  EF5B     GOTO 0x15CB6
151C4  F0AE     NOP
235:                   return T_spacing;
236:               }
237:               spacing = 0;
151C6  0107     MOVLB 0x7
151C8  6B31     CLRF 0x31, BANKED
151CA  6B32     CLRF 0x32, BANKED
151CC  6B33     CLRF 0x33, BANKED
151CE  6B34     CLRF 0x34, BANKED
238:           
239:               client->trace = T_begin;
151D0  0EFD     MOVLW 0xFD
151D2  0061     MOVFFL PLUSW1, wtemp5
151D4  F38C     NOP
151D6  F50B     NOP
151D8  0EFE     MOVLW 0xFE
151DA  0061     MOVFFL PLUSW1, 0x50C
151DC  F38C     NOP
151DE  F50C     NOP
151E0  0E05     MOVLW 0x5
151E2  240B     ADDWF 0xB, W, ACCESS
151E4  6ED9     MOVWF 0xFD9, ACCESS
151E6  0E00     MOVLW 0x0
151E8  200C     ADDWFC 0xC, W, ACCESS
151EA  6EDA     MOVWF __end_of_UART2_tx_vect_isr, ACCESS
151EC  0E01     MOVLW 0x1
151EE  6EDF     MOVWF 0xFDF, ACCESS
240:               switch (client->cstate) {
151F0  EF29     GOTO 0x15C52
151F2  F0AE     NOP
241:                   case CLEAR:
242:                       client->trace = T_clear;
151F4  0EFD     MOVLW 0xFD
151F6  0061     MOVFFL PLUSW1, wtemp5
151F8  F38C     NOP
151FA  F50B     NOP
151FC  0EFE     MOVLW 0xFE
151FE  0061     MOVFFL PLUSW1, 0x50C
15200  F38C     NOP
15202  F50C     NOP
15204  0E05     MOVLW 0x5
15206  240B     ADDWF 0xB, W, ACCESS
15208  6ED9     MOVWF 0xFD9, ACCESS
1520A  0E00     MOVLW 0x0
1520C  200C     ADDWFC 0xC, W, ACCESS
1520E  6EDA     MOVWF __end_of_UART2_tx_vect_isr, ACCESS
15210  0E02     MOVLW 0x2
15212  6EDF     MOVWF 0xFDF, ACCESS
243:                       clear_2hz();
15214  EC64     CALL 0x26C8, 0
15216  F013     NOP
244:                       clear_10hz();
15218  EC6A     CALL 0x26D4, 0
1521A  F013     NOP
245:                       client->cstate = INIT;
1521C  0EFD     MOVLW 0xFD
1521E  0061     MOVFFL PLUSW1, wtemp5
15220  F38C     NOP
15222  F50B     NOP
15224  0EFE     MOVLW 0xFE
15226  0061     MOVFFL PLUSW1, 0x50C
15228  F38C     NOP
1522A  F50C     NOP
1522C  0E01     MOVLW 0x1
1522E  240B     ADDWF 0xB, W, ACCESS
15230  6ED9     MOVWF 0xFD9, ACCESS
15232  0E00     MOVLW 0x0
15234  200C     ADDWFC 0xC, W, ACCESS
15236  6EDA     MOVWF __end_of_UART2_tx_vect_isr, ACCESS
15238  0E01     MOVLW 0x1
1523A  6EDF     MOVWF 0xFDF, ACCESS
246:                       client->modbus_command = client->mcmd++; // sequence modbus commands to client
1523C  0EFD     MOVLW 0xFD
1523E  C4E3     MOVFF PLUSW1, FSR2
15240  F4D9     NOP
15242  0EFE     MOVLW 0xFE
15244  C4E3     MOVFF PLUSW1, FSR2H
15246  F4DA     NOP
15248  0EFD     MOVLW 0xFD
1524A  0061     MOVFFL PLUSW1, wtemp5
1524C  F38C     NOP
1524E  F50B     NOP
15250  0EFE     MOVLW 0xFE
15252  0061     MOVFFL PLUSW1, 0x50C
15254  F38C     NOP
15256  F50C     NOP
15258  0E02     MOVLW 0x2
1525A  240B     ADDWF 0xB, W, ACCESS
1525C  6EE9     MOVWF 0xFE9, ACCESS
1525E  0E00     MOVLW 0x0
15260  200C     ADDWFC 0xC, W, ACCESS
15262  6EEA     MOVWF 0xFEA, ACCESS
15264  C4DF     MOVFF INDF2, INDF0
15266  F4EF     NOP
15268  0EFD     MOVLW 0xFD
1526A  C4E3     MOVFF PLUSW1, FSR2
1526C  F4D9     NOP
1526E  0EFE     MOVLW 0xFE
15270  C4E3     MOVFF PLUSW1, FSR2H
15272  F4DA     NOP
15274  2ADF     INCF 0xFDF, F, ACCESS
247:                       if (client->modbus_command == G_CONFIG && client->config_ok) { // skip if we have valid data from client
15276  0EFD     MOVLW 0xFD
15278  0061     MOVFFL PLUSW1, wtemp5
1527A  F38C     NOP
1527C  F50B     NOP
1527E  0EFE     MOVLW 0xFE
15280  0061     MOVFFL PLUSW1, 0x50C
15282  F38C     NOP
15284  F50C     NOP
15286  0E02     MOVLW 0x2
15288  240B     ADDWF 0xB, W, ACCESS
1528A  6ED9     MOVWF 0xFD9, ACCESS
1528C  0E00     MOVLW 0x0
1528E  200C     ADDWFC 0xC, W, ACCESS
15290  6EDA     MOVWF __end_of_UART2_tx_vect_isr, ACCESS
15292  0E03     MOVLW 0x3
15294  18DE     XORWF 0xFDE, W, ACCESS
15296  A4D8     BTFSS 0xFD8, 2, ACCESS
15298  D02E     BRA 0x52F6
1529A  0EFD     MOVLW 0xFD
1529C  0061     MOVFFL PLUSW1, wtemp5
1529E  F38C     NOP
152A0  F50B     NOP
152A2  0EFE     MOVLW 0xFE
152A4  0061     MOVFFL PLUSW1, 0x50C
152A6  F38C     NOP
152A8  F50C     NOP
152AA  0E08     MOVLW 0x8
152AC  240B     ADDWF 0xB, W, ACCESS
152AE  6ED9     MOVWF 0xFD9, ACCESS
152B0  0E00     MOVLW 0x0
152B2  200C     ADDWFC 0xC, W, ACCESS
152B4  6EDA     MOVWF __end_of_UART2_tx_vect_isr, ACCESS
152B6  50DF     MOVF 0xFDF, W, ACCESS
152B8  B4D8     BTFSC 0xFD8, 2, ACCESS
152BA  D01D     BRA 0x52F6
248:                           client->modbus_command = client->mcmd++;
152BC  0EFD     MOVLW 0xFD
152BE  C4E3     MOVFF PLUSW1, FSR2
152C0  F4D9     NOP
152C2  0EFE     MOVLW 0xFE
152C4  C4E3     MOVFF PLUSW1, FSR2H
152C6  F4DA     NOP
152C8  0EFD     MOVLW 0xFD
152CA  0061     MOVFFL PLUSW1, wtemp5
152CC  F38C     NOP
152CE  F50B     NOP
152D0  0EFE     MOVLW 0xFE
152D2  0061     MOVFFL PLUSW1, 0x50C
152D4  F38C     NOP
152D6  F50C     NOP
152D8  0E02     MOVLW 0x2
152DA  240B     ADDWF 0xB, W, ACCESS
152DC  6EE9     MOVWF 0xFE9, ACCESS
152DE  0E00     MOVLW 0x0
152E0  200C     ADDWFC 0xC, W, ACCESS
152E2  6EEA     MOVWF 0xFEA, ACCESS
152E4  C4DF     MOVFF INDF2, INDF0
152E6  F4EF     NOP
152E8  0EFD     MOVLW 0xFD
152EA  C4E3     MOVFF PLUSW1, FSR2
152EC  F4D9     NOP
152EE  0EFE     MOVLW 0xFE
152F0  C4E3     MOVFF PLUSW1, FSR2H
152F2  F4DA     NOP
152F4  2ADF     INCF 0xFDF, F, ACCESS
249:                       }
250:                       if (client->modbus_command == G_PASSWD && client->passwd_ok) { // skip if we have valid data from client
152F6  0EFD     MOVLW 0xFD
152F8  0061     MOVFFL PLUSW1, wtemp5
152FA  F38C     NOP
152FC  F50B     NOP
152FE  0EFE     MOVLW 0xFE
15300  0061     MOVFFL PLUSW1, 0x50C
15302  F38C     NOP
15304  F50C     NOP
15306  0E02     MOVLW 0x2
15308  240B     ADDWF 0xB, W, ACCESS
1530A  6ED9     MOVWF 0xFD9, ACCESS
1530C  0E00     MOVLW 0x0
1530E  200C     ADDWFC 0xC, W, ACCESS
15310  6EDA     MOVWF __end_of_UART2_tx_vect_isr, ACCESS
15312  0E04     MOVLW 0x4
15314  18DE     XORWF 0xFDE, W, ACCESS
15316  A4D8     BTFSS 0xFD8, 2, ACCESS
15318  D02E     BRA 0x5376
1531A  0EFD     MOVLW 0xFD
1531C  0061     MOVFFL PLUSW1, wtemp5
1531E  F38C     NOP
15320  F50B     NOP
15322  0EFE     MOVLW 0xFE
15324  0061     MOVFFL PLUSW1, 0x50C
15326  F38C     NOP
15328  F50C     NOP
1532A  0E07     MOVLW 0x7
1532C  240B     ADDWF 0xB, W, ACCESS
1532E  6ED9     MOVWF 0xFD9, ACCESS
15330  0E00     MOVLW 0x0
15332  200C     ADDWFC 0xC, W, ACCESS
15334  6EDA     MOVWF __end_of_UART2_tx_vect_isr, ACCESS
15336  50DF     MOVF 0xFDF, W, ACCESS
15338  B4D8     BTFSC 0xFD8, 2, ACCESS
1533A  D01D     BRA 0x5376
251:                           client->modbus_command = client->mcmd++;
1533C  0EFD     MOVLW 0xFD
1533E  C4E3     MOVFF PLUSW1, FSR2
15340  F4D9     NOP
15342  0EFE     MOVLW 0xFE
15344  C4E3     MOVFF PLUSW1, FSR2H
15346  F4DA     NOP
15348  0EFD     MOVLW 0xFD
1534A  0061     MOVFFL PLUSW1, wtemp5
1534C  F38C     NOP
1534E  F50B     NOP
15350  0EFE     MOVLW 0xFE
15352  0061     MOVFFL PLUSW1, 0x50C
15354  F38C     NOP
15356  F50C     NOP
15358  0E02     MOVLW 0x2
1535A  240B     ADDWF 0xB, W, ACCESS
1535C  6EE9     MOVWF 0xFE9, ACCESS
1535E  0E00     MOVLW 0x0
15360  200C     ADDWFC 0xC, W, ACCESS
15362  6EEA     MOVWF 0xFEA, ACCESS
15364  C4DF     MOVFF INDF2, INDF0
15366  F4EF     NOP
15368  0EFD     MOVLW 0xFD
1536A  C4E3     MOVFF PLUSW1, FSR2
1536C  F4D9     NOP
1536E  0EFE     MOVLW 0xFE
15370  C4E3     MOVFF PLUSW1, FSR2H
15372  F4DA     NOP
15374  2ADF     INCF 0xFDF, F, ACCESS
252:                       }
253:                       if (client->modbus_command == G_LIGHT && client->light_ok) { // skip if we have valid data from client
15376  0EFD     MOVLW 0xFD
15378  0061     MOVFFL PLUSW1, wtemp5
1537A  F38C     NOP
1537C  F50B     NOP
1537E  0EFE     MOVLW 0xFE
15380  0061     MOVFFL PLUSW1, 0x50C
15382  F38C     NOP
15384  F50C     NOP
15386  0E02     MOVLW 0x2
15388  240B     ADDWF 0xB, W, ACCESS
1538A  6ED9     MOVWF 0xFD9, ACCESS
1538C  0E00     MOVLW 0x0
1538E  200C     ADDWFC 0xC, W, ACCESS
15390  6EDA     MOVWF __end_of_UART2_tx_vect_isr, ACCESS
15392  0E05     MOVLW 0x5
15394  18DE     XORWF 0xFDE, W, ACCESS
15396  A4D8     BTFSS 0xFD8, 2, ACCESS
15398  D02E     BRA 0x53F6
1539A  0EFD     MOVLW 0xFD
1539C  0061     MOVFFL PLUSW1, wtemp5
1539E  F38C     NOP
153A0  F50B     NOP
153A2  0EFE     MOVLW 0xFE
153A4  0061     MOVFFL PLUSW1, 0x50C
153A6  F38C     NOP
153A8  F50C     NOP
153AA  0E0A     MOVLW 0xA
153AC  240B     ADDWF 0xB, W, ACCESS
153AE  6ED9     MOVWF 0xFD9, ACCESS
153B0  0E00     MOVLW 0x0
153B2  200C     ADDWFC 0xC, W, ACCESS
153B4  6EDA     MOVWF __end_of_UART2_tx_vect_isr, ACCESS
153B6  50DF     MOVF 0xFDF, W, ACCESS
153B8  B4D8     BTFSC 0xFD8, 2, ACCESS
153BA  D01D     BRA 0x53F6
254:                           client->modbus_command = client->mcmd++;
153BC  0EFD     MOVLW 0xFD
153BE  C4E3     MOVFF PLUSW1, FSR2
153C0  F4D9     NOP
153C2  0EFE     MOVLW 0xFE
153C4  C4E3     MOVFF PLUSW1, FSR2H
153C6  F4DA     NOP
153C8  0EFD     MOVLW 0xFD
153CA  0061     MOVFFL PLUSW1, wtemp5
153CC  F38C     NOP
153CE  F50B     NOP
153D0  0EFE     MOVLW 0xFE
153D2  0061     MOVFFL PLUSW1, 0x50C
153D4  F38C     NOP
153D6  F50C     NOP
153D8  0E02     MOVLW 0x2
153DA  240B     ADDWF 0xB, W, ACCESS
153DC  6EE9     MOVWF 0xFE9, ACCESS
153DE  0E00     MOVLW 0x0
153E0  200C     ADDWFC 0xC, W, ACCESS
153E2  6EEA     MOVWF 0xFEA, ACCESS
153E4  C4DF     MOVFF INDF2, INDF0
153E6  F4EF     NOP
153E8  0EFD     MOVLW 0xFD
153EA  C4E3     MOVFF PLUSW1, FSR2
153EC  F4D9     NOP
153EE  0EFE     MOVLW 0xFE
153F0  C4E3     MOVFF PLUSW1, FSR2H
153F2  F4DA     NOP
153F4  2ADF     INCF 0xFDF, F, ACCESS
255:                       }
256:                       if (client->modbus_command == G_VERSION && client->version_ok) { // skip if we have valid data from client
153F6  0EFD     MOVLW 0xFD
153F8  0061     MOVFFL PLUSW1, wtemp5
153FA  F38C     NOP
153FC  F50B     NOP
153FE  0EFE     MOVLW 0xFE
15400  0061     MOVFFL PLUSW1, 0x50C
15402  F38C     NOP
15404  F50C     NOP
15406  0E02     MOVLW 0x2
15408  240B     ADDWF 0xB, W, ACCESS
1540A  6ED9     MOVWF 0xFD9, ACCESS
1540C  0E00     MOVLW 0x0
1540E  200C     ADDWFC 0xC, W, ACCESS
15410  6EDA     MOVWF __end_of_UART2_tx_vect_isr, ACCESS
15412  0E06     MOVLW 0x6
15414  18DE     XORWF 0xFDE, W, ACCESS
15416  A4D8     BTFSS 0xFD8, 2, ACCESS
15418  D02E     BRA 0x5476
1541A  0EFD     MOVLW 0xFD
1541C  0061     MOVFFL PLUSW1, wtemp5
1541E  F38C     NOP
15420  F50B     NOP
15422  0EFE     MOVLW 0xFE
15424  0061     MOVFFL PLUSW1, 0x50C
15426  F38C     NOP
15428  F50C     NOP
1542A  0E0C     MOVLW 0xC
1542C  240B     ADDWF 0xB, W, ACCESS
1542E  6ED9     MOVWF 0xFD9, ACCESS
15430  0E00     MOVLW 0x0
15432  200C     ADDWFC 0xC, W, ACCESS
15434  6EDA     MOVWF __end_of_UART2_tx_vect_isr, ACCESS
15436  50DF     MOVF 0xFDF, W, ACCESS
15438  B4D8     BTFSC 0xFD8, 2, ACCESS
1543A  D01D     BRA 0x5476
257:                           client->modbus_command = client->mcmd++;
1543C  0EFD     MOVLW 0xFD
1543E  C4E3     MOVFF PLUSW1, FSR2
15440  F4D9     NOP
15442  0EFE     MOVLW 0xFE
15444  C4E3     MOVFF PLUSW1, FSR2H
15446  F4DA     NOP
15448  0EFD     MOVLW 0xFD
1544A  0061     MOVFFL PLUSW1, wtemp5
1544C  F38C     NOP
1544E  F50B     NOP
15450  0EFE     MOVLW 0xFE
15452  0061     MOVFFL PLUSW1, 0x50C
15454  F38C     NOP
15456  F50C     NOP
15458  0E02     MOVLW 0x2
1545A  240B     ADDWF 0xB, W, ACCESS
1545C  6EE9     MOVWF 0xFE9, ACCESS
1545E  0E00     MOVLW 0x0
15460  200C     ADDWFC 0xC, W, ACCESS
15462  6EEA     MOVWF 0xFEA, ACCESS
15464  C4DF     MOVFF INDF2, INDF0
15466  F4EF     NOP
15468  0EFD     MOVLW 0xFD
1546A  C4E3     MOVFF PLUSW1, FSR2
1546C  F4D9     NOP
1546E  0EFE     MOVLW 0xFE
15470  C4E3     MOVFF PLUSW1, FSR2H
15472  F4DA     NOP
15474  2ADF     INCF 0xFDF, F, ACCESS
258:                       }
259:                       if (client->modbus_command == G_SERIAL && client->serial_ok) { // skip if we have valid data from client
15476  0EFD     MOVLW 0xFD
15478  0061     MOVFFL PLUSW1, wtemp5
1547A  F38C     NOP
1547C  F50B     NOP
1547E  0EFE     MOVLW 0xFE
15480  0061     MOVFFL PLUSW1, 0x50C
15482  F38C     NOP
15484  F50C     NOP
15486  0E02     MOVLW 0x2
15488  240B     ADDWF 0xB, W, ACCESS
1548A  6ED9     MOVWF 0xFD9, ACCESS
1548C  0E00     MOVLW 0x0
1548E  200C     ADDWFC 0xC, W, ACCESS
15490  6EDA     MOVWF __end_of_UART2_tx_vect_isr, ACCESS
15492  0E07     MOVLW 0x7
15494  18DE     XORWF 0xFDE, W, ACCESS
15496  A4D8     BTFSS 0xFD8, 2, ACCESS
15498  D02E     BRA 0x54F6
1549A  0EFD     MOVLW 0xFD
1549C  0061     MOVFFL PLUSW1, wtemp5
1549E  F38C     NOP
154A0  F50B     NOP
154A2  0EFE     MOVLW 0xFE
154A4  0061     MOVFFL PLUSW1, 0x50C
154A6  F38C     NOP
154A8  F50C     NOP
154AA  0E0B     MOVLW 0xB
154AC  240B     ADDWF 0xB, W, ACCESS
154AE  6ED9     MOVWF 0xFD9, ACCESS
154B0  0E00     MOVLW 0x0
154B2  200C     ADDWFC 0xC, W, ACCESS
154B4  6EDA     MOVWF __end_of_UART2_tx_vect_isr, ACCESS
154B6  50DF     MOVF 0xFDF, W, ACCESS
154B8  B4D8     BTFSC 0xFD8, 2, ACCESS
154BA  D01D     BRA 0x54F6
260:                           client->modbus_command = client->mcmd++;
154BC  0EFD     MOVLW 0xFD
154BE  C4E3     MOVFF PLUSW1, FSR2
154C0  F4D9     NOP
154C2  0EFE     MOVLW 0xFE
154C4  C4E3     MOVFF PLUSW1, FSR2H
154C6  F4DA     NOP
154C8  0EFD     MOVLW 0xFD
154CA  0061     MOVFFL PLUSW1, wtemp5
154CC  F38C     NOP
154CE  F50B     NOP
154D0  0EFE     MOVLW 0xFE
154D2  0061     MOVFFL PLUSW1, 0x50C
154D4  F38C     NOP
154D6  F50C     NOP
154D8  0E02     MOVLW 0x2
154DA  240B     ADDWF 0xB, W, ACCESS
154DC  6EE9     MOVWF 0xFE9, ACCESS
154DE  0E00     MOVLW 0x0
154E0  200C     ADDWFC 0xC, W, ACCESS
154E2  6EEA     MOVWF 0xFEA, ACCESS
154E4  C4DF     MOVFF INDF2, INDF0
154E6  F4EF     NOP
154E8  0EFD     MOVLW 0xFD
154EA  C4E3     MOVFF PLUSW1, FSR2
154EC  F4D9     NOP
154EE  0EFE     MOVLW 0xFE
154F0  C4E3     MOVFF PLUSW1, FSR2H
154F2  F4DA     NOP
154F4  2ADF     INCF 0xFDF, F, ACCESS
261:                       }
262:                       if (client->mcmd > G_LAST) {
154F6  0EFD     MOVLW 0xFD
154F8  C4E3     MOVFF PLUSW1, FSR2
154FA  F4D9     NOP
154FC  0EFE     MOVLW 0xFE
154FE  C4E3     MOVFF PLUSW1, FSR2H
15500  F4DA     NOP
15502  0E08     MOVLW 0x8
15504  64DF     CPFSGT 0xFDF, ACCESS
15506  D12B     BRA 0x575E
263:                           client->mcmd = G_ID;
15508  0EFD     MOVLW 0xFD
1550A  C4E3     MOVFF PLUSW1, FSR2
1550C  F4D9     NOP
1550E  0EFE     MOVLW 0xFE
15510  C4E3     MOVFF PLUSW1, FSR2H
15512  F4DA     NOP
15514  6ADF     CLRF 0xFDF, ACCESS
15516  D123     BRA 0x575E
264:                       }
265:                       /*
266:                        * command specific tx buffer setup
267:                        */
268:                       switch (client->modbus_command) {
269:                           case G_VERSION: // write code request
270:                               client->trace = T_version;
15518  0EFD     MOVLW 0xFD
1551A  0061     MOVFFL PLUSW1, wtemp5
1551C  F38C     NOP
1551E  F50B     NOP
15520  0EFE     MOVLW 0xFE
15522  0061     MOVFFL PLUSW1, 0x50C
15524  F38C     NOP
15526  F50C     NOP
15528  0E05     MOVLW 0x5
1552A  240B     ADDWF 0xB, W, ACCESS
1552C  6ED9     MOVWF 0xFD9, ACCESS
1552E  0E00     MOVLW 0x0
15530  200C     ADDWFC 0xC, W, ACCESS
15532  6EDA     MOVWF __end_of_UART2_tx_vect_isr, ACCESS
15534  0E08     MOVLW 0x8
15536  6EDF     MOVWF 0xFDF, ACCESS
271:                               client->req_length = modbus_rtu_send_msg((void*) cc_buffer_tx, (const void *) modbus_em_version, sizeof (modbus_em_version));
15538  0E06     MOVLW 0x6
1553A  6EE6     MOVWF 0xFE6, ACCESS
1553C  0E00     MOVLW 0x0
1553E  6EE6     MOVWF 0xFE6, ACCESS
15540  0E24     MOVLW 0x24
15542  6EE6     MOVWF 0xFE6, ACCESS
15544  0EFC     MOVLW 0xFC
15546  6EE6     MOVWF 0xFE6, ACCESS
15548  0E00     MOVLW 0x0
1554A  6EE6     MOVWF 0xFE6, ACCESS
1554C  0E0F     MOVLW 0xF
1554E  6EE6     MOVWF 0xFE6, ACCESS
15550  EC1F     CALL 0x163E, 0
15552  F00B     NOP
15554  D0EF     BRA 0x5734
272:                               break;
273:                           case G_SERIAL: // write code request
274:                               client->trace = T_serial;
15556  0EFD     MOVLW 0xFD
15558  0061     MOVFFL PLUSW1, wtemp5
1555A  F38C     NOP
1555C  F50B     NOP
1555E  0EFE     MOVLW 0xFE
15560  0061     MOVFFL PLUSW1, 0x50C
15562  F38C     NOP
15564  F50C     NOP
15566  0E05     MOVLW 0x5
15568  240B     ADDWF 0xB, W, ACCESS
1556A  6ED9     MOVWF 0xFD9, ACCESS
1556C  0E00     MOVLW 0x0
1556E  200C     ADDWFC 0xC, W, ACCESS
15570  6EDA     MOVWF __end_of_UART2_tx_vect_isr, ACCESS
15572  0E07     MOVLW 0x7
15574  6EDF     MOVWF 0xFDF, ACCESS
275:                               client->req_length = modbus_rtu_send_msg((void*) cc_buffer_tx, (const void *) modbus_em_serial, sizeof (modbus_em_serial));
15576  0E06     MOVLW 0x6
15578  6EE6     MOVWF 0xFE6, ACCESS
1557A  0E00     MOVLW 0x0
1557C  6EE6     MOVWF 0xFE6, ACCESS
1557E  0E12     MOVLW 0x12
15580  6EE6     MOVWF 0xFE6, ACCESS
15582  0EFC     MOVLW 0xFC
15584  6EE6     MOVWF 0xFE6, ACCESS
15586  0E00     MOVLW 0x0
15588  6EE6     MOVWF 0xFE6, ACCESS
1558A  0E0F     MOVLW 0xF
1558C  6EE6     MOVWF 0xFE6, ACCESS
1558E  EC1F     CALL 0x163E, 0
15590  F00B     NOP
15592  D0D0     BRA 0x5734
276:                               break;
277:                           case G_LIGHT: // write code request
278:                               client->trace = T_light;
15594  0EFD     MOVLW 0xFD
15596  0061     MOVFFL PLUSW1, wtemp5
15598  F38C     NOP
1559A  F50B     NOP
1559C  0EFE     MOVLW 0xFE
1559E  0061     MOVFFL PLUSW1, 0x50C
155A0  F38C     NOP
155A2  F50C     NOP
155A4  0E05     MOVLW 0x5
155A6  240B     ADDWF 0xB, W, ACCESS
155A8  6ED9     MOVWF 0xFD9, ACCESS
155AA  0E00     MOVLW 0x0
155AC  200C     ADDWFC 0xC, W, ACCESS
155AE  6EDA     MOVWF __end_of_UART2_tx_vect_isr, ACCESS
155B0  0E13     MOVLW 0x13
155B2  6EDF     MOVWF 0xFDF, ACCESS
279:                               client->req_length = modbus_rtu_send_msg((void*) cc_buffer_tx, (const void *) modbus_em_light, sizeof (modbus_em_light));
155B4  0E06     MOVLW 0x6
155B6  6EE6     MOVWF 0xFE6, ACCESS
155B8  0E00     MOVLW 0x0
155BA  6EE6     MOVWF 0xFE6, ACCESS
155BC  0E00     MOVLW 0x0
155BE  6EE6     MOVWF 0xFE6, ACCESS
155C0  0EFC     MOVLW 0xFC
155C2  6EE6     MOVWF 0xFE6, ACCESS
155C4  0E00     MOVLW 0x0
155C6  6EE6     MOVWF 0xFE6, ACCESS
155C8  0E0F     MOVLW 0xF
155CA  6EE6     MOVWF 0xFE6, ACCESS
155CC  EC1F     CALL 0x163E, 0
155CE  F00B     NOP
155D0  D0B1     BRA 0x5734
280:                               break;
281:                           case G_PASSWD: // write code request
282:                               client->trace = T_passwd;
155D2  0EFD     MOVLW 0xFD
155D4  0061     MOVFFL PLUSW1, wtemp5
155D6  F38C     NOP
155D8  F50B     NOP
155DA  0EFE     MOVLW 0xFE
155DC  0061     MOVFFL PLUSW1, 0x50C
155DE  F38C     NOP
155E0  F50C     NOP
155E2  0E05     MOVLW 0x5
155E4  240B     ADDWF 0xB, W, ACCESS
155E6  6ED9     MOVWF 0xFD9, ACCESS
155E8  0E00     MOVLW 0x0
155EA  200C     ADDWFC 0xC, W, ACCESS
155EC  6EDA     MOVWF __end_of_UART2_tx_vect_isr, ACCESS
155EE  0E03     MOVLW 0x3
155F0  6EDF     MOVWF 0xFDF, ACCESS
283:                               client->req_length = modbus_rtu_send_msg((void*) cc_buffer_tx, (const void *) modbus_em_passwd, sizeof (modbus_em_passwd));
155F2  0E06     MOVLW 0x6
155F4  6EE6     MOVWF 0xFE6, ACCESS
155F6  0E00     MOVLW 0x0
155F8  6EE6     MOVWF 0xFE6, ACCESS
155FA  0E06     MOVLW 0x6
155FC  6EE6     MOVWF 0xFE6, ACCESS
155FE  0EFC     MOVLW 0xFC
15600  6EE6     MOVWF 0xFE6, ACCESS
15602  0E00     MOVLW 0x0
15604  6EE6     MOVWF 0xFE6, ACCESS
15606  0E0F     MOVLW 0xF
15608  6EE6     MOVWF 0xFE6, ACCESS
1560A  EC1F     CALL 0x163E, 0
1560C  F00B     NOP
1560E  D092     BRA 0x5734
284:                               break;
285:                           case G_CONFIG: // write code request
286:                               client->trace = T_config;
15610  0EFD     MOVLW 0xFD
15612  0061     MOVFFL PLUSW1, wtemp5
15614  F38C     NOP
15616  F50B     NOP
15618  0EFE     MOVLW 0xFE
1561A  0061     MOVFFL PLUSW1, 0x50C
1561C  F38C     NOP
1561E  F50C     NOP
15620  0E05     MOVLW 0x5
15622  240B     ADDWF 0xB, W, ACCESS
15624  6ED9     MOVWF 0xFD9, ACCESS
15626  0E00     MOVLW 0x0
15628  200C     ADDWFC 0xC, W, ACCESS
1562A  6EDA     MOVWF __end_of_UART2_tx_vect_isr, ACCESS
1562C  0E04     MOVLW 0x4
1562E  6EDF     MOVWF 0xFDF, ACCESS
287:                               client->req_length = modbus_rtu_send_msg((void*) cc_buffer_tx, (const void *) modbus_em_config, sizeof (modbus_em_config));
15630  0E06     MOVLW 0x6
15632  6EE6     MOVWF 0xFE6, ACCESS
15634  0E00     MOVLW 0x0
15636  6EE6     MOVWF 0xFE6, ACCESS
15638  0E0C     MOVLW 0xC
1563A  6EE6     MOVWF 0xFE6, ACCESS
1563C  0EFC     MOVLW 0xFC
1563E  6EE6     MOVWF 0xFE6, ACCESS
15640  0E00     MOVLW 0x0
15642  6EE6     MOVWF 0xFE6, ACCESS
15644  0E0F     MOVLW 0xF
15646  6EE6     MOVWF 0xFE6, ACCESS
15648  EC1F     CALL 0x163E, 0
1564A  F00B     NOP
1564C  D073     BRA 0x5734
288:                               break;
289:                           case G_DATA1: // read code request
290:                               client->trace = T_data;
1564E  0EFD     MOVLW 0xFD
15650  0061     MOVFFL PLUSW1, wtemp5
15652  F38C     NOP
15654  F50B     NOP
15656  0EFE     MOVLW 0xFE
15658  0061     MOVFFL PLUSW1, 0x50C
1565A  F38C     NOP
1565C  F50C     NOP
1565E  0E05     MOVLW 0x5
15660  240B     ADDWF 0xB, W, ACCESS
15662  6ED9     MOVWF 0xFD9, ACCESS
15664  0E00     MOVLW 0x0
15666  200C     ADDWFC 0xC, W, ACCESS
15668  6EDA     MOVWF __end_of_UART2_tx_vect_isr, ACCESS
1566A  0E05     MOVLW 0x5
1566C  6EDF     MOVWF 0xFDF, ACCESS
291:                               client->req_length = modbus_rtu_send_msg((void*) cc_buffer_tx, (const void *) modbus_em_data1, sizeof (modbus_em_data1));
1566E  0E06     MOVLW 0x6
15670  6EE6     MOVWF 0xFE6, ACCESS
15672  0E00     MOVLW 0x0
15674  6EE6     MOVWF 0xFE6, ACCESS
15676  0E1E     MOVLW 0x1E
15678  6EE6     MOVWF 0xFE6, ACCESS
1567A  0EFC     MOVLW 0xFC
1567C  6EE6     MOVWF 0xFE6, ACCESS
1567E  0E00     MOVLW 0x0
15680  6EE6     MOVWF 0xFE6, ACCESS
15682  0E0F     MOVLW 0xF
15684  6EE6     MOVWF 0xFE6, ACCESS
15686  EC1F     CALL 0x163E, 0
15688  F00B     NOP
1568A  D054     BRA 0x5734
292:                               break;
293:                           case G_DATA2: // read code request
294:                               client->trace = T_data;
1568C  0EFD     MOVLW 0xFD
1568E  0061     MOVFFL PLUSW1, wtemp5
15690  F38C     NOP
15692  F50B     NOP
15694  0EFE     MOVLW 0xFE
15696  0061     MOVFFL PLUSW1, 0x50C
15698  F38C     NOP
1569A  F50C     NOP
1569C  0E05     MOVLW 0x5
1569E  240B     ADDWF 0xB, W, ACCESS
156A0  6ED9     MOVWF 0xFD9, ACCESS
156A2  0E00     MOVLW 0x0
156A4  200C     ADDWFC 0xC, W, ACCESS
156A6  6EDA     MOVWF __end_of_UART2_tx_vect_isr, ACCESS
156A8  0E05     MOVLW 0x5
156AA  6EDF     MOVWF 0xFDF, ACCESS
295:                               client->req_length = modbus_rtu_send_msg((void*) cc_buffer_tx, (const void *) modbus_em_data2, sizeof (modbus_em_data2));
156AC  0E06     MOVLW 0x6
156AE  6EE6     MOVWF 0xFE6, ACCESS
156B0  0E00     MOVLW 0x0
156B2  6EE6     MOVWF 0xFE6, ACCESS
156B4  0E18     MOVLW 0x18
156B6  6EE6     MOVWF 0xFE6, ACCESS
156B8  0EFC     MOVLW 0xFC
156BA  6EE6     MOVWF 0xFE6, ACCESS
156BC  0E00     MOVLW 0x0
156BE  6EE6     MOVWF 0xFE6, ACCESS
156C0  0E0F     MOVLW 0xF
156C2  6EE6     MOVWF 0xFE6, ACCESS
156C4  EC1F     CALL 0x163E, 0
156C6  F00B     NOP
156C8  D035     BRA 0x5734
296:                               break;
297:                           case G_LAST: // end of command sequences
298:                               client->cstate = CLEAR;
156CA  0EFD     MOVLW 0xFD
156CC  0061     MOVFFL PLUSW1, wtemp5
156CE  F38C     NOP
156D0  F50B     NOP
156D2  0EFE     MOVLW 0xFE
156D4  0061     MOVFFL PLUSW1, 0x50C
156D6  F38C     NOP
156D8  F50C     NOP
156DA  0E01     MOVLW 0x1
156DC  240B     ADDWF 0xB, W, ACCESS
156DE  6ED9     MOVWF 0xFD9, ACCESS
156E0  0E00     MOVLW 0x0
156E2  200C     ADDWFC 0xC, W, ACCESS
156E4  6EDA     MOVWF __end_of_UART2_tx_vect_isr, ACCESS
156E6  6ADF     CLRF 0xFDF, ACCESS
299:                               client->mcmd = G_ID; // what do we run next
156E8  0EFD     MOVLW 0xFD
156EA  C4E3     MOVFF PLUSW1, FSR2
156EC  F4D9     NOP
156EE  0EFE     MOVLW 0xFE
156F0  C4E3     MOVFF PLUSW1, FSR2H
156F2  F4DA     NOP
156F4  6ADF     CLRF 0xFDF, ACCESS
300:                               break;
156F6  D2D0     BRA 0x5C98
301:                           case G_ID: // operating mode request
302:                               client->trace = T_id;
156F8  0EFD     MOVLW 0xFD
156FA  0061     MOVFFL PLUSW1, wtemp5
156FC  F38C     NOP
156FE  F50B     NOP
15700  0EFE     MOVLW 0xFE
15702  0061     MOVFFL PLUSW1, 0x50C
15704  F38C     NOP
15706  F50C     NOP
15708  0E05     MOVLW 0x5
1570A  240B     ADDWF 0xB, W, ACCESS
1570C  6ED9     MOVWF 0xFD9, ACCESS
1570E  0E00     MOVLW 0x0
15710  200C     ADDWFC 0xC, W, ACCESS
15712  6EDA     MOVWF __end_of_UART2_tx_vect_isr, ACCESS
15714  0E06     MOVLW 0x6
15716  6EDF     MOVWF 0xFDF, ACCESS
303:                           default:
304:                               client->req_length = modbus_rtu_send_msg((void*) cc_buffer_tx, (const void *) modbus_em_id, sizeof (modbus_em_id));
15718  0E06     MOVLW 0x6
1571A  6EE6     MOVWF 0xFE6, ACCESS
1571C  0E00     MOVLW 0x0
1571E  6EE6     MOVWF 0xFE6, ACCESS
15720  0E2A     MOVLW 0x2A
15722  6EE6     MOVWF 0xFE6, ACCESS
15724  0EFC     MOVLW 0xFC
15726  6EE6     MOVWF 0xFE6, ACCESS
15728  0E00     MOVLW 0x0
1572A  6EE6     MOVWF 0xFE6, ACCESS
1572C  0E0F     MOVLW 0xF
1572E  6EE6     MOVWF 0xFE6, ACCESS
15730  EC1F     CALL 0x163E, 0
15732  F00B     NOP
15734  0EFD     MOVLW 0xFD
15736  0061     MOVFFL PLUSW1, wtemp5
15738  F38C     NOP
1573A  F50B     NOP
1573C  0EFE     MOVLW 0xFE
1573E  0061     MOVFFL PLUSW1, 0x50C
15740  F38C     NOP
15742  F50C     NOP
15744  0E03     MOVLW 0x3
15746  240B     ADDWF 0xB, W, ACCESS
15748  6ED9     MOVWF 0xFD9, ACCESS
1574A  0E00     MOVLW 0x0
1574C  200C     ADDWFC 0xC, W, ACCESS
1574E  6EDA     MOVWF __end_of_UART2_tx_vect_isr, ACCESS
15750  0061     MOVFFL ltemp0, POSTINC2
15752  F404     NOP
15754  F4DE     NOP
15756  0061     MOVFFL ttemp5, POSTDEC2
15758  F408     NOP
1575A  F4DD     NOP
305:                               break;
1575C  D29D     BRA 0x5C98
306:                       }
1575E  0EFD     MOVLW 0xFD
15760  0061     MOVFFL PLUSW1, wtemp5
15762  F38C     NOP
15764  F50B     NOP
15766  0EFE     MOVLW 0xFE
15768  0061     MOVFFL PLUSW1, 0x50C
1576A  F38C     NOP
1576C  F50C     NOP
1576E  0E02     MOVLW 0x2
15770  240B     ADDWF 0xB, W, ACCESS
15772  6ED9     MOVWF 0xFD9, ACCESS
15774  0E00     MOVLW 0x0
15776  200C     ADDWFC 0xC, W, ACCESS
15778  6EDA     MOVWF __end_of_UART2_tx_vect_isr, ACCESS
1577A  50DF     MOVF 0xFDF, W, ACCESS
1577C  6E0B     MOVWF 0xB, ACCESS
1577E  6A0C     CLRF 0xC, ACCESS
15780  500C     MOVF 0xC, W, ACCESS
15782  0A00     XORLW 0x0
15784  A4D8     BTFSS 0xFD8, 2, ACCESS
15786  D7C8     BRA 0x5718
15788  500B     MOVF 0xB, W, ACCESS
1578A  0A00     XORLW 0x0
1578C  B4D8     BTFSC 0xFD8, 2, ACCESS
1578E  D7B4     BRA 0x56F8
15790  0A01     XORLW 0x1
15792  B4D8     BTFSC 0xFD8, 2, ACCESS
15794  D75C     BRA 0x564E
15796  0A03     XORLW 0x3
15798  B4D8     BTFSC 0xFD8, 2, ACCESS
1579A  D778     BRA 0x568C
1579C  0A01     XORLW 0x1
1579E  B4D8     BTFSC 0xFD8, 2, ACCESS
157A0  D737     BRA 0x5610
157A2  0A07     XORLW 0x7
157A4  B4D8     BTFSC 0xFD8, 2, ACCESS
157A6  D715     BRA 0x55D2
157A8  0A01     XORLW 0x1
157AA  B4D8     BTFSC 0xFD8, 2, ACCESS
157AC  D6F3     BRA 0x5594
157AE  0A03     XORLW 0x3
157B0  B4D8     BTFSC 0xFD8, 2, ACCESS
157B2  D6B2     BRA 0x5518
157B4  0A01     XORLW 0x1
157B6  B4D8     BTFSC 0xFD8, 2, ACCESS
157B8  D6CE     BRA 0x5556
157BA  0A0F     XORLW 0xF
157BC  B4D8     BTFSC 0xFD8, 2, ACCESS
157BE  D785     BRA 0x56CA
157C0  D7AB     BRA 0x5718
307:                       break;
308:                   case INIT:
309:                       client->trace = T_init;
157C2  0EFD     MOVLW 0xFD
157C4  0061     MOVFFL PLUSW1, wtemp5
157C6  F38C     NOP
157C8  F50B     NOP
157CA  0EFE     MOVLW 0xFE
157CC  0061     MOVFFL PLUSW1, 0x50C
157CE  F38C     NOP
157D0  F50C     NOP
157D2  0E05     MOVLW 0x5
157D4  240B     ADDWF 0xB, W, ACCESS
157D6  6ED9     MOVWF 0xFD9, ACCESS
157D8  0E00     MOVLW 0x0
157DA  200C     ADDWFC 0xC, W, ACCESS
157DC  6EDA     MOVWF __end_of_UART2_tx_vect_isr, ACCESS
157DE  0E09     MOVLW 0x9
157E0  6EDF     MOVWF 0xFDF, ACCESS
310:                       /*
311:                        * MODBUS master query speed
312:                        */
313:           #ifdef	FASTQ
314:                       if (get_10hz(false) >= CDELAY) {
157E2  0E00     MOVLW 0x0
157E4  6EE6     MOVWF 0xFE6, ACCESS
157E6  EC6D     CALL 0x1ADA, 0
157E8  F00D     NOP
157EA  5004     MOVF __activetblptr, W, ACCESS
157EC  1003     IORWF __activetblptr, W, ACCESS
157EE  1002     IORWF ___rparam_used, W, ACCESS
157F0  E104     BNZ 0x57FA
157F2  0E28     MOVLW 0x28
157F4  5C01     SUBWF __ptext283, W, ACCESS
157F6  A0D8     BTFSS 0xFD8, 0, ACCESS
157F8  D24F     BRA 0x5C98
315:           #else
316:                       if (get_2hz(false) >= QDELAY) {
317:           #endif
318:                           half_dup_tx(false); // no delays here
157FA  0E00     MOVLW 0x0
157FC  6EE6     MOVWF 0xFE6, ACCESS
157FE  EC67     CALL 0x24CE, 0
15800  F012     NOP
319:                           M.recv_count = 0;
15802  0106     MOVLB 0x6
15804  6BE1     CLRF 0xE1, BANKED
320:                           client->cstate = SEND;
15806  0EFD     MOVLW 0xFD
15808  0061     MOVFFL PLUSW1, wtemp5
1580A  F38C     NOP
1580C  F50B     NOP
1580E  0EFE     MOVLW 0xFE
15810  0061     MOVFFL PLUSW1, 0x50C
15812  F38C     NOP
15814  F50C     NOP
15816  0E01     MOVLW 0x1
15818  240B     ADDWF 0xB, W, ACCESS
1581A  6ED9     MOVWF 0xFD9, ACCESS
1581C  0E00     MOVLW 0x0
1581E  200C     ADDWFC 0xC, W, ACCESS
15820  6EDA     MOVWF __end_of_UART2_tx_vect_isr, ACCESS
15822  0E02     MOVLW 0x2
15824  6EDF     MOVWF 0xFDF, ACCESS
321:                           clear_500hz();
15826  EC5E     CALL 0x26BC, 0
15828  F013     NOP
322:                           client->trace = T_init_d;
1582A  0EFD     MOVLW 0xFD
1582C  0061     MOVFFL PLUSW1, wtemp5
1582E  F38C     NOP
15830  F50B     NOP
15832  0EFE     MOVLW 0xFE
15834  0061     MOVFFL PLUSW1, 0x50C
15836  F38C     NOP
15838  F50C     NOP
1583A  0E05     MOVLW 0x5
1583C  240B     ADDWF 0xB, W, ACCESS
1583E  6ED9     MOVWF 0xFD9, ACCESS
15840  0E00     MOVLW 0x0
15842  200C     ADDWFC 0xC, W, ACCESS
15844  6EDA     MOVWF __end_of_UART2_tx_vect_isr, ACCESS
15846  0E0A     MOVLW 0xA
15848  6EDF     MOVWF 0xFDF, ACCESS
1584A  D226     BRA 0x5C98
323:                       }
324:                       break;
325:                   case SEND:
326:                       client->trace = T_send;
1584C  0EFD     MOVLW 0xFD
1584E  0061     MOVFFL PLUSW1, wtemp5
15850  F38C     NOP
15852  F50B     NOP
15854  0EFE     MOVLW 0xFE
15856  0061     MOVFFL PLUSW1, 0x50C
15858  F38C     NOP
1585A  F50C     NOP
1585C  0E05     MOVLW 0x5
1585E  240B     ADDWF 0xB, W, ACCESS
15860  6ED9     MOVWF 0xFD9, ACCESS
15862  0E00     MOVLW 0x0
15864  200C     ADDWFC 0xC, W, ACCESS
15866  6EDA     MOVWF __end_of_UART2_tx_vect_isr, ACCESS
15868  0E0B     MOVLW 0xB
1586A  6EDF     MOVWF 0xFDF, ACCESS
327:                       if (get_500hz(false) >= TEDELAY) {
1586C  0E00     MOVLW 0x0
1586E  6E09     MOVWF 0x9, ACCESS
15870  6A0A     CLRF 0xA, ACCESS
15872  6A0B     CLRF 0xB, ACCESS
15874  6A0C     CLRF 0xC, ACCESS
15876  0E00     MOVLW 0x0
15878  6EE6     MOVWF 0xFE6, ACCESS
1587A  EC51     CALL 0x1AA2, 0
1587C  F00D     NOP
1587E  0061     MOVFFL ltemp0, ltemp1
15880  F404     NOP
15882  F505     NOP
15884  0061     MOVFFL ttemp5, 0x506
15886  F408     NOP
15888  F506     NOP
1588A  0061     MOVFFL wtemp1, ttemp2
1588C  F40C     NOP
1588E  F507     NOP
15890  0061     MOVFFL ttemp1, 0x508
15892  F410     NOP
15894  F508     NOP
15896  500C     MOVF 0xC, W, ACCESS
15898  1808     XORWF 0x8, W, ACCESS
1589A  E108     BNZ 0x58AC
1589C  500B     MOVF 0xB, W, ACCESS
1589E  1807     XORWF 0x7, W, ACCESS
158A0  E105     BNZ 0x58AC
158A2  500A     MOVF 0xA, W, ACCESS
158A4  1806     XORWF 0x6, W, ACCESS
158A6  E102     BNZ 0x58AC
158A8  5009     MOVF 0x9, W, ACCESS
158AA  1805     XORWF 0x5, W, ACCESS
158AC  B4D8     BTFSC 0xFD8, 2, ACCESS
158AE  D1F4     BRA 0x5C98
328:                           for (uint8_t i = 0; i < client->req_length; i++) {
158B0  0EFF     MOVLW 0xFF
158B2  6AE3     CLRF 0xFE3, ACCESS
158B4  D010     BRA 0x58D6
329:                               Swrite(cc_buffer_tx[i]);
158B6  0EFF     MOVLW 0xFF
158B8  50E3     MOVF 0xFE3, W, ACCESS
158BA  6E0B     MOVWF 0xB, ACCESS
158BC  6A0C     CLRF 0xC, ACCESS
158BE  0E00     MOVLW 0x0
158C0  240B     ADDWF 0xB, W, ACCESS
158C2  6ED9     MOVWF 0xFD9, ACCESS
158C4  0E0F     MOVLW 0xF
158C6  200C     ADDWFC 0xC, W, ACCESS
158C8  6EDA     MOVWF __end_of_UART2_tx_vect_isr, ACCESS
158CA  50DF     MOVF 0xFDF, W, ACCESS
158CC  6EE6     MOVWF 0xFE6, ACCESS
158CE  EC89     CALL 0x1B12, 0
158D0  F00D     NOP
330:                           }
158D2  0EFF     MOVLW 0xFF
158D4  2AE3     INCF 0xFE3, F, ACCESS
158D6  0EFD     MOVLW 0xFD
158D8  0061     MOVFFL PLUSW1, wtemp5
158DA  F38C     NOP
158DC  F50B     NOP
158DE  0EFE     MOVLW 0xFE
158E0  0061     MOVFFL PLUSW1, 0x50C
158E2  F38C     NOP
158E4  F50C     NOP
158E6  0E03     MOVLW 0x3
158E8  240B     ADDWF 0xB, W, ACCESS
158EA  6ED9     MOVWF 0xFD9, ACCESS
158EC  0E00     MOVLW 0x0
158EE  200C     ADDWFC 0xC, W, ACCESS
158F0  6EDA     MOVWF __end_of_UART2_tx_vect_isr, ACCESS
158F2  0EFF     MOVLW 0xFF
158F4  50E3     MOVF 0xFE3, W, ACCESS
158F6  6E0B     MOVWF 0xB, ACCESS
158F8  6A0C     CLRF 0xC, ACCESS
158FA  50DE     MOVF 0xFDE, W, ACCESS
158FC  5C0B     SUBWF 0xB, W, ACCESS
158FE  50DE     MOVF 0xFDE, W, ACCESS
15900  580C     SUBWFB 0xC, W, ACCESS
15902  A0D8     BTFSS 0xFD8, 0, ACCESS
15904  D7D8     BRA 0x58B6
331:                           client->cstate = RECV;
15906  0EFD     MOVLW 0xFD
15908  0061     MOVFFL PLUSW1, wtemp5
1590A  F38C     NOP
1590C  F50B     NOP
1590E  0EFE     MOVLW 0xFE
15910  0061     MOVFFL PLUSW1, 0x50C
15912  F38C     NOP
15914  F50C     NOP
15916  0E01     MOVLW 0x1
15918  240B     ADDWF 0xB, W, ACCESS
1591A  6ED9     MOVWF 0xFD9, ACCESS
1591C  0E00     MOVLW 0x0
1591E  200C     ADDWFC 0xC, W, ACCESS
15920  6EDA     MOVWF __end_of_UART2_tx_vect_isr, ACCESS
15922  0E03     MOVLW 0x3
15924  6EDF     MOVWF 0xFDF, ACCESS
332:                           clear_500hz(); // state machine execute background timer clear
15926  EC5E     CALL 0x26BC, 0
15928  F013     NOP
333:                           client->trace = T_send_d;
1592A  0EFD     MOVLW 0xFD
1592C  0061     MOVFFL PLUSW1, wtemp5
1592E  F38C     NOP
15930  F50B     NOP
15932  0EFE     MOVLW 0xFE
15934  0061     MOVFFL PLUSW1, 0x50C
15936  F38C     NOP
15938  F50C     NOP
1593A  0E05     MOVLW 0x5
1593C  240B     ADDWF 0xB, W, ACCESS
1593E  6ED9     MOVWF 0xFD9, ACCESS
15940  0E00     MOVLW 0x0
15942  200C     ADDWFC 0xC, W, ACCESS
15944  6EDA     MOVWF __end_of_UART2_tx_vect_isr, ACCESS
15946  0E0C     MOVLW 0xC
15948  6EDF     MOVWF 0xFDF, ACCESS
334:                           M.sends++;
1594A  0E01     MOVLW 0x1
1594C  27F1     ADDWF DMAnDSAH, F, BANKED
1594E  0E00     MOVLW 0x0
15950  23F2     ADDWFC DMAnSCNT, F, BANKED
15952  23F3     ADDWFC DMAnSCNTH, F, BANKED
15954  23F4     ADDWFC DMAnSPTR, F, BANKED
335:                           M.rx = false;
15956  6BF5     CLRF DMAnSPTRH, BANKED
336:                           if (serial_trmt()) { // check for serial UART transmit shift register and buffer empty
15958  EC97     CALL 0x272E, 0
1595A  F013     NOP
1595C  5001     MOVF __ptext283, W, ACCESS
1595E  A4D8     BTFSS 0xFD8, 2, ACCESS
337:                               clear_500hz(); // clear timer until buffer empty
15960  EC5E     CALL 0x26BC, 0
15962  F013     NOP
338:                           }
339:                           delay_ms(TDELAY);
15964  0E02     MOVLW 0x2
15966  6EE6     MOVWF 0xFE6, ACCESS
15968  0E00     MOVLW 0x0
1596A  6EE6     MOVWF 0xFE6, ACCESS
1596C  EC13     CALL 0x2626, 0
1596E  F013     NOP
340:                           DERE_SetLow(); // enable modbus receiver
15970  94C0     BCF 0xFC0, 2, ACCESS
341:                           DB0_SetHigh();
15972  82C1     BSF 0xFC1, 1, ACCESS
15974  D191     BRA 0x5C98
342:                       }
343:                       break;
344:                   case RECV:
345:                       client->trace = T_recv;
15976  0EFD     MOVLW 0xFD
15978  0061     MOVFFL PLUSW1, wtemp5
1597A  F38C     NOP
1597C  F50B     NOP
1597E  0EFE     MOVLW 0xFE
15980  0061     MOVFFL PLUSW1, 0x50C
15982  F38C     NOP
15984  F50C     NOP
15986  0E05     MOVLW 0x5
15988  240B     ADDWF 0xB, W, ACCESS
1598A  6ED9     MOVWF 0xFD9, ACCESS
1598C  0E00     MOVLW 0x0
1598E  200C     ADDWFC 0xC, W, ACCESS
15990  6EDA     MOVWF __end_of_UART2_tx_vect_isr, ACCESS
15992  0E0D     MOVLW 0xD
15994  6EDF     MOVWF 0xFDF, ACCESS
346:                       if (get_500hz(false) >= TEDELAY) { // state machine execute timer test
15996  0E00     MOVLW 0x0
15998  6E09     MOVWF 0x9, ACCESS
1599A  6A0A     CLRF 0xA, ACCESS
1599C  6A0B     CLRF 0xB, ACCESS
1599E  6A0C     CLRF 0xC, ACCESS
159A0  0E00     MOVLW 0x0
159A2  6EE6     MOVWF 0xFE6, ACCESS
159A4  EC51     CALL 0x1AA2, 0
159A6  F00D     NOP
159A8  0061     MOVFFL ltemp0, ltemp1
159AA  F404     NOP
159AC  F505     NOP
159AE  0061     MOVFFL ttemp5, 0x506
159B0  F408     NOP
159B2  F506     NOP
159B4  0061     MOVFFL wtemp1, ttemp2
159B6  F40C     NOP
159B8  F507     NOP
159BA  0061     MOVFFL ttemp1, 0x508
159BC  F410     NOP
159BE  F508     NOP
159C0  500C     MOVF 0xC, W, ACCESS
159C2  1808     XORWF 0x8, W, ACCESS
159C4  E108     BNZ 0x59D6
159C6  500B     MOVF 0xB, W, ACCESS
159C8  1807     XORWF 0x7, W, ACCESS
159CA  E105     BNZ 0x59D6
159CC  500A     MOVF 0xA, W, ACCESS
159CE  1806     XORWF 0x6, W, ACCESS
159D0  E102     BNZ 0x59D6
159D2  5009     MOVF 0x9, W, ACCESS
159D4  1805     XORWF 0x5, W, ACCESS
159D6  B4D8     BTFSC 0xFD8, 2, ACCESS
159D8  D15F     BRA 0x5C98
347:           
348:                           client->trace = T_recv_r;
159DA  0EFD     MOVLW 0xFD
159DC  0061     MOVFFL PLUSW1, wtemp5
159DE  F38C     NOP
159E0  F50B     NOP
159E2  0EFE     MOVLW 0xFE
159E4  0061     MOVFFL PLUSW1, 0x50C
159E6  F38C     NOP
159E8  F50C     NOP
159EA  0E05     MOVLW 0x5
159EC  240B     ADDWF 0xB, W, ACCESS
159EE  6ED9     MOVWF 0xFD9, ACCESS
159F0  0E00     MOVLW 0x0
159F2  200C     ADDWFC 0xC, W, ACCESS
159F4  6EDA     MOVWF __end_of_UART2_tx_vect_isr, ACCESS
159F6  0E0E     MOVLW 0xE
159F8  6EDF     MOVWF 0xFDF, ACCESS
349:                           half_dup_rx(false); // no delays here
159FA  0E00     MOVLW 0x0
159FC  6EE6     MOVWF 0xFE6, ACCESS
159FE  EC76     CALL 0x24EC, 0
15A00  F012     NOP
350:           
351:                           /*
352:                            * check received response data for size and format for each command sent
353:                            */
354:                           switch (client->modbus_command) {
15A02  D0F8     BRA 0x5BF4
355:                               case G_LIGHT: // check for controller back-light codes
356:                                   modbus_write_check(client, &client->light_ok, sizeof (em_light));
15A04  0E08     MOVLW 0x8
15A06  6EE6     MOVWF 0xFE6, ACCESS
15A08  0E00     MOVLW 0x0
15A0A  6EE6     MOVWF 0xFE6, ACCESS
15A0C  0EFB     MOVLW 0xFB
15A0E  50E3     MOVF 0xFE3, W, ACCESS
15A10  0F0A     ADDLW 0xA
15A12  6E0B     MOVWF 0xB, ACCESS
15A14  0EFC     MOVLW 0xFC
15A16  0061     MOVFFL PLUSW1, 0x50C
15A18  F38C     NOP
15A1A  F50C     NOP
15A1C  0E00     MOVLW 0x0
15A1E  220C     ADDWFC 0xC, F, ACCESS
15A20  0061     MOVFFL wtemp5, POSTINC1
15A22  F42C     NOP
15A24  F4E6     NOP
15A26  0061     MOVFFL 0x50C, POSTINC1
15A28  F430     NOP
15A2A  F4E6     NOP
15A2C  0EF9     MOVLW 0xF9
15A2E  C4E3     MOVFF PLUSW1, POSTINC1
15A30  F4E6     NOP
15A32  C4E3     MOVFF PLUSW1, POSTINC1
15A34  F4E6     NOP
15A36  EC37     CALL 0x1BC6E, 0
15A38  F0DE     NOP
357:                                   break;
15A3A  D12E     BRA 0x5C98
358:                               case G_PASSWD: // check for controller password codes
359:                                   modbus_write_check(client, &client->passwd_ok, sizeof (em_passwd));
15A3C  0E08     MOVLW 0x8
15A3E  6EE6     MOVWF 0xFE6, ACCESS
15A40  0E00     MOVLW 0x0
15A42  6EE6     MOVWF 0xFE6, ACCESS
15A44  0EFB     MOVLW 0xFB
15A46  50E3     MOVF 0xFE3, W, ACCESS
15A48  0F07     ADDLW 0x7
15A4A  6E0B     MOVWF 0xB, ACCESS
15A4C  0EFC     MOVLW 0xFC
15A4E  0061     MOVFFL PLUSW1, 0x50C
15A50  F38C     NOP
15A52  F50C     NOP
15A54  0E00     MOVLW 0x0
15A56  220C     ADDWFC 0xC, F, ACCESS
15A58  0061     MOVFFL wtemp5, POSTINC1
15A5A  F42C     NOP
15A5C  F4E6     NOP
15A5E  0061     MOVFFL 0x50C, POSTINC1
15A60  F430     NOP
15A62  F4E6     NOP
15A64  0EF9     MOVLW 0xF9
15A66  C4E3     MOVFF PLUSW1, POSTINC1
15A68  F4E6     NOP
15A6A  C4E3     MOVFF PLUSW1, POSTINC1
15A6C  F4E6     NOP
15A6E  EC37     CALL 0x1BC6E, 0
15A70  F0DE     NOP
360:                                   break;
15A72  D112     BRA 0x5C98
361:                               case G_CONFIG: // check for controller configuration codes
362:                                   modbus_write_check(client, &client->config_ok, sizeof (em_config));
15A74  0E08     MOVLW 0x8
15A76  6EE6     MOVWF 0xFE6, ACCESS
15A78  0E00     MOVLW 0x0
15A7A  6EE6     MOVWF 0xFE6, ACCESS
15A7C  0EFB     MOVLW 0xFB
15A7E  50E3     MOVF 0xFE3, W, ACCESS
15A80  0F08     ADDLW 0x8
15A82  6E0B     MOVWF 0xB, ACCESS
15A84  0EFC     MOVLW 0xFC
15A86  0061     MOVFFL PLUSW1, 0x50C
15A88  F38C     NOP
15A8A  F50C     NOP
15A8C  0E00     MOVLW 0x0
15A8E  220C     ADDWFC 0xC, F, ACCESS
15A90  0061     MOVFFL wtemp5, POSTINC1
15A92  F42C     NOP
15A94  F4E6     NOP
15A96  0061     MOVFFL 0x50C, POSTINC1
15A98  F430     NOP
15A9A  F4E6     NOP
15A9C  0EF9     MOVLW 0xF9
15A9E  C4E3     MOVFF PLUSW1, POSTINC1
15AA0  F4E6     NOP
15AA2  C4E3     MOVFF PLUSW1, POSTINC1
15AA4  F4E6     NOP
15AA6  EC37     CALL 0x1BC6E, 0
15AA8  F0DE     NOP
363:                                   break;
15AAA  D0F6     BRA 0x5C98
364:                               case G_DATA1: // check for controller data1 codes
365:                                   modbus_read_check(client, &client->data_ok, sizeof (em_data1), em_data_handler);
15AAC  0EBA     MOVLW 0xBA
15AAE  6EE6     MOVWF 0xFE6, ACCESS
15AB0  0EA7     MOVLW 0xA7
15AB2  6EE6     MOVWF 0xFE6, ACCESS
15AB4  0E01     MOVLW 0x1
15AB6  6EE6     MOVWF 0xFE6, ACCESS
15AB8  0E6D     MOVLW 0x6D
15ABA  6EE6     MOVWF 0xFE6, ACCESS
15ABC  0E00     MOVLW 0x0
15ABE  6EE6     MOVWF 0xFE6, ACCESS
15AC0  0EF8     MOVLW 0xF8
15AC2  50E3     MOVF 0xFE3, W, ACCESS
15AC4  0F09     ADDLW 0x9
15AC6  6E0B     MOVWF 0xB, ACCESS
15AC8  0EF9     MOVLW 0xF9
15ACA  0061     MOVFFL PLUSW1, 0x50C
15ACC  F38C     NOP
15ACE  F50C     NOP
15AD0  0E00     MOVLW 0x0
15AD2  220C     ADDWFC 0xC, F, ACCESS
15AD4  0061     MOVFFL wtemp5, POSTINC1
15AD6  F42C     NOP
15AD8  F4E6     NOP
15ADA  0061     MOVFFL 0x50C, POSTINC1
15ADC  F430     NOP
15ADE  F4E6     NOP
15AE0  0EF6     MOVLW 0xF6
15AE2  C4E3     MOVFF PLUSW1, POSTINC1
15AE4  F4E6     NOP
15AE6  C4E3     MOVFF PLUSW1, POSTINC1
15AE8  F4E6     NOP
15AEA  EC4E     CALL 0x1AA9C, 0
15AEC  F0D5     NOP
366:                                   break;
15AEE  D0D4     BRA 0x5C98
367:                               case G_DATA2: // check for controller data2 codes
368:                                   modbus_read_check(client, &client->data_ok, sizeof (em_data2), emt_data_handler);
15AF0  0E00     MOVLW 0x0
15AF2  6EE6     MOVWF 0xFE6, ACCESS
15AF4  0E14     MOVLW 0x14
15AF6  6EE6     MOVWF 0xFE6, ACCESS
15AF8  0E00     MOVLW 0x0
15AFA  6EE6     MOVWF 0xFE6, ACCESS
15AFC  0E85     MOVLW 0x85
15AFE  6EE6     MOVWF 0xFE6, ACCESS
15B00  0E00     MOVLW 0x0
15B02  6EE6     MOVWF 0xFE6, ACCESS
15B04  0EF8     MOVLW 0xF8
15B06  50E3     MOVF 0xFE3, W, ACCESS
15B08  0F09     ADDLW 0x9
15B0A  6E0B     MOVWF 0xB, ACCESS
15B0C  0EF9     MOVLW 0xF9
15B0E  0061     MOVFFL PLUSW1, 0x50C
15B10  F38C     NOP
15B12  F50C     NOP
15B14  0E00     MOVLW 0x0
15B16  220C     ADDWFC 0xC, F, ACCESS
15B18  0061     MOVFFL wtemp5, POSTINC1
15B1A  F42C     NOP
15B1C  F4E6     NOP
15B1E  0061     MOVFFL 0x50C, POSTINC1
15B20  F430     NOP
15B22  F4E6     NOP
15B24  0EF6     MOVLW 0xF6
15B26  C4E3     MOVFF PLUSW1, POSTINC1
15B28  F4E6     NOP
15B2A  C4E3     MOVFF PLUSW1, POSTINC1
15B2C  F4E6     NOP
15B2E  EC4E     CALL 0x1AA9C, 0
15B30  F0D5     NOP
369:                                   break;
15B32  D0B2     BRA 0x5C98
370:                               case G_VERSION: // check for controller EM540 firmware codes
371:                                   modbus_read_check(client, &client->version_ok, sizeof (em_version), emv_data_handler);
15B34  0EB6     MOVLW 0xB6
15B36  6EE6     MOVWF 0xFE6, ACCESS
15B38  0E1B     MOVLW 0x1B
15B3A  6EE6     MOVWF 0xFE6, ACCESS
15B3C  0E00     MOVLW 0x0
15B3E  6EE6     MOVWF 0xFE6, ACCESS
15B40  0E07     MOVLW 0x7
15B42  6EE6     MOVWF 0xFE6, ACCESS
15B44  0E00     MOVLW 0x0
15B46  6EE6     MOVWF 0xFE6, ACCESS
15B48  0EF8     MOVLW 0xF8
15B4A  50E3     MOVF 0xFE3, W, ACCESS
15B4C  0F0C     ADDLW 0xC
15B4E  6E0B     MOVWF 0xB, ACCESS
15B50  0EF9     MOVLW 0xF9
15B52  0061     MOVFFL PLUSW1, 0x50C
15B54  F38C     NOP
15B56  F50C     NOP
15B58  0E00     MOVLW 0x0
15B5A  220C     ADDWFC 0xC, F, ACCESS
15B5C  0061     MOVFFL wtemp5, POSTINC1
15B5E  F42C     NOP
15B60  F4E6     NOP
15B62  0061     MOVFFL 0x50C, POSTINC1
15B64  F430     NOP
15B66  F4E6     NOP
15B68  0EF6     MOVLW 0xF6
15B6A  C4E3     MOVFF PLUSW1, POSTINC1
15B6C  F4E6     NOP
15B6E  C4E3     MOVFF PLUSW1, POSTINC1
15B70  F4E6     NOP
15B72  EC4E     CALL 0x1AA9C, 0
15B74  F0D5     NOP
372:                                   break;
15B76  D090     BRA 0x5C98
373:                               case G_SERIAL: // check for controller EM540 serial codes
374:                                   modbus_read_check(client, &client->serial_ok, sizeof (em_serial), ems_data_handler);
15B78  0EBC     MOVLW 0xBC
15B7A  6EE6     MOVWF 0xFE6, ACCESS
15B7C  0E19     MOVLW 0x19
15B7E  6EE6     MOVWF 0xFE6, ACCESS
15B80  0E00     MOVLW 0x0
15B82  6EE6     MOVWF 0xFE6, ACCESS
15B84  0E15     MOVLW 0x15
15B86  6EE6     MOVWF 0xFE6, ACCESS
15B88  0E00     MOVLW 0x0
15B8A  6EE6     MOVWF 0xFE6, ACCESS
15B8C  0EF8     MOVLW 0xF8
15B8E  50E3     MOVF 0xFE3, W, ACCESS
15B90  0F0B     ADDLW 0xB
15B92  6E0B     MOVWF 0xB, ACCESS
15B94  0EF9     MOVLW 0xF9
15B96  0061     MOVFFL PLUSW1, 0x50C
15B98  F38C     NOP
15B9A  F50C     NOP
15B9C  0E00     MOVLW 0x0
15B9E  220C     ADDWFC 0xC, F, ACCESS
15BA0  0061     MOVFFL wtemp5, POSTINC1
15BA2  F42C     NOP
15BA4  F4E6     NOP
15BA6  0061     MOVFFL 0x50C, POSTINC1
15BA8  F430     NOP
15BAA  F4E6     NOP
15BAC  0EF6     MOVLW 0xF6
15BAE  C4E3     MOVFF PLUSW1, POSTINC1
15BB0  F4E6     NOP
15BB2  C4E3     MOVFF PLUSW1, POSTINC1
15BB4  F4E6     NOP
15BB6  EC4E     CALL 0x1AA9C, 0
15BB8  F0D5     NOP
375:                                   break;
15BBA  D06E     BRA 0x5C98
376:                               case G_ID: // check for client module type
377:                               default:
378:                                   modbus_read_id_check(client, &client->id_ok, sizeof (em_id));
15BBC  0E07     MOVLW 0x7
15BBE  6EE6     MOVWF 0xFE6, ACCESS
15BC0  0E00     MOVLW 0x0
15BC2  6EE6     MOVWF 0xFE6, ACCESS
15BC4  0EFB     MOVLW 0xFB
15BC6  50E3     MOVF 0xFE3, W, ACCESS
15BC8  0F06     ADDLW 0x6
15BCA  6E0B     MOVWF 0xB, ACCESS
15BCC  0EFC     MOVLW 0xFC
15BCE  0061     MOVFFL PLUSW1, 0x50C
15BD0  F38C     NOP
15BD2  F50C     NOP
15BD4  0E00     MOVLW 0x0
15BD6  220C     ADDWFC 0xC, F, ACCESS
15BD8  0061     MOVFFL wtemp5, POSTINC1
15BDA  F42C     NOP
15BDC  F4E6     NOP
15BDE  0061     MOVFFL 0x50C, POSTINC1
15BE0  F430     NOP
15BE2  F4E6     NOP
15BE4  0EF9     MOVLW 0xF9
15BE6  C4E3     MOVFF PLUSW1, POSTINC1
15BE8  F4E6     NOP
15BEA  C4E3     MOVFF PLUSW1, POSTINC1
15BEC  F4E6     NOP
15BEE  EC16     CALL 0x19A2C, 0
15BF0  F0CD     NOP
379:                                   break;
15BF2  D052     BRA 0x5C98
380:                           }
15BF4  0EFD     MOVLW 0xFD
15BF6  0061     MOVFFL PLUSW1, wtemp5
15BF8  F38C     NOP
15BFA  F50B     NOP
15BFC  0EFE     MOVLW 0xFE
15BFE  0061     MOVFFL PLUSW1, 0x50C
15C00  F38C     NOP
15C02  F50C     NOP
15C04  0E02     MOVLW 0x2
15C06  240B     ADDWF 0xB, W, ACCESS
15C08  6ED9     MOVWF 0xFD9, ACCESS
15C0A  0E00     MOVLW 0x0
15C0C  200C     ADDWFC 0xC, W, ACCESS
15C0E  6EDA     MOVWF __end_of_UART2_tx_vect_isr, ACCESS
15C10  50DF     MOVF 0xFDF, W, ACCESS
15C12  6E0B     MOVWF 0xB, ACCESS
15C14  6A0C     CLRF 0xC, ACCESS
15C16  500C     MOVF 0xC, W, ACCESS
15C18  0A00     XORLW 0x0
15C1A  A4D8     BTFSS 0xFD8, 2, ACCESS
15C1C  D7CF     BRA 0x5BBC
15C1E  500B     MOVF 0xB, W, ACCESS
15C20  0A00     XORLW 0x0
15C22  B4D8     BTFSC 0xFD8, 2, ACCESS
15C24  D7CB     BRA 0x5BBC
15C26  0A01     XORLW 0x1
15C28  B4D8     BTFSC 0xFD8, 2, ACCESS
15C2A  D740     BRA 0x5AAC
15C2C  0A03     XORLW 0x3
15C2E  B4D8     BTFSC 0xFD8, 2, ACCESS
15C30  D75F     BRA 0x5AF0
15C32  0A01     XORLW 0x1
15C34  B4D8     BTFSC 0xFD8, 2, ACCESS
15C36  D71E     BRA 0x5A74
15C38  0A07     XORLW 0x7
15C3A  B4D8     BTFSC 0xFD8, 2, ACCESS
15C3C  D6FF     BRA 0x5A3C
15C3E  0A01     XORLW 0x1
15C40  B4D8     BTFSC 0xFD8, 2, ACCESS
15C42  D6E0     BRA 0x5A04
15C44  0A03     XORLW 0x3
15C46  B4D8     BTFSC 0xFD8, 2, ACCESS
15C48  D775     BRA 0x5B34
15C4A  0A01     XORLW 0x1
15C4C  B4D8     BTFSC 0xFD8, 2, ACCESS
15C4E  D794     BRA 0x5B78
15C50  D7B5     BRA 0x5BBC
381:                       }
382:                       break;
383:                   default:
384:                       break;
385:               }
15C52  0EFD     MOVLW 0xFD
15C54  0061     MOVFFL PLUSW1, wtemp5
15C56  F38C     NOP
15C58  F50B     NOP
15C5A  0EFE     MOVLW 0xFE
15C5C  0061     MOVFFL PLUSW1, 0x50C
15C5E  F38C     NOP
15C60  F50C     NOP
15C62  0E01     MOVLW 0x1
15C64  240B     ADDWF 0xB, W, ACCESS
15C66  6ED9     MOVWF 0xFD9, ACCESS
15C68  0E00     MOVLW 0x0
15C6A  200C     ADDWFC 0xC, W, ACCESS
15C6C  6EDA     MOVWF __end_of_UART2_tx_vect_isr, ACCESS
15C6E  50DF     MOVF 0xFDF, W, ACCESS
15C70  6E0B     MOVWF 0xB, ACCESS
15C72  6A0C     CLRF 0xC, ACCESS
15C74  500C     MOVF 0xC, W, ACCESS
15C76  0A00     XORLW 0x0
15C78  A4D8     BTFSS 0xFD8, 2, ACCESS
15C7A  D00E     BRA 0x5C98
15C7C  500B     MOVF 0xB, W, ACCESS
15C7E  0A00     XORLW 0x0
15C80  B4D8     BTFSC 0xFD8, 2, ACCESS
15C82  EFFA     GOTO 0x151F4
15C84  F0A8     NOP
15C86  0A01     XORLW 0x1
15C88  B4D8     BTFSC 0xFD8, 2, ACCESS
15C8A  D59B     BRA 0x57C2
15C8C  0A03     XORLW 0x3
15C8E  B4D8     BTFSC 0xFD8, 2, ACCESS
15C90  D5DD     BRA 0x584C
15C92  0A01     XORLW 0x1
15C94  B4D8     BTFSC 0xFD8, 2, ACCESS
15C96  D66F     BRA 0x5976
386:               IO_RD7_SetLow();
15C98  9EC1     BCF 0xFC1, 7, ACCESS
387:               return client->trace;
15C9A  0EFD     MOVLW 0xFD
15C9C  0061     MOVFFL PLUSW1, wtemp5
15C9E  F38C     NOP
15CA0  F50B     NOP
15CA2  0EFE     MOVLW 0xFE
15CA4  0061     MOVFFL PLUSW1, 0x50C
15CA6  F38C     NOP
15CA8  F50C     NOP
15CAA  0E05     MOVLW 0x5
15CAC  240B     ADDWF 0xB, W, ACCESS
15CAE  6ED9     MOVWF 0xFD9, ACCESS
15CB0  0E00     MOVLW 0x0
15CB2  200C     ADDWFC 0xC, W, ACCESS
15CB4  6EDA     MOVWF __end_of_UART2_tx_vect_isr, ACCESS
388:           }
15CB6  52E5     MOVF 0xFE5, F, ACCESS
15CB6  52E5     MOVF 0xFE5, F, ACCESS
15CB6  52E5     MOVF 0xFE5, F, ACCESS
15CB6  52E5     MOVF 0xFE5, F, ACCESS
389:           
390:           /*
391:            * state machine no busy wait timers
392:            */
393:           void clear_2hz(void) {
394:               MT.clock_2hz = 0;
26C8  0106     MOVLB 0x6
26CA  6B08     CLRF 0x8, BANKED
26CC  6B09     CLRF 0x9, BANKED
26CE  6B0A     CLRF 0xA, BANKED
26D0  6B0B     CLRF 0xB, BANKED
395:           }
26D2  0012     RETURN 0
396:           
397:           void clear_10hz(void) {
398:               MT.clock_10hz = 0;
26D4  0106     MOVLB 0x6
26D6  6B04     CLRF __activetblptr, BANKED
26D8  6B05     CLRF 0x5, BANKED
26DA  6B06     CLRF 0x6, BANKED
26DC  6B07     CLRF 0x7, BANKED
399:           }
26DE  0012     RETURN 0
400:           
401:           void clear_500hz(void) {
402:               MT.clock_500hz = 0;
26BC  0106     MOVLB 0x6
26BE  6B00     CLRF __smallconst, BANKED
26C0  6B01     CLRF __ptext283, BANKED
26C2  6B02     CLRF ___rparam_used, BANKED
26C4  6B03     CLRF __activetblptr, BANKED
403:           }
26C6  0012     RETURN 0
404:           
405:           uint32_t get_2hz(const uint8_t mode) {
406:               static uint32_t tmp = 0;
407:           
408:               if (mode) {
409:                   return tmp;
410:               }
411:           
412:               tmp = MT.clock_2hz;
413:               return tmp;
414:           }
415:           
416:           /*
417:            * fake timer, really 500Hz updates
418:            * used for fast updates timing
419:            */
420:           uint32_t get_10hz(const uint8_t mode) {
421:               static uint32_t tmp = 0;
422:           
423:               if (mode) {
1ADA  0EFF     MOVLW 0xFF
1ADC  50E3     MOVF 0xFE3, W, ACCESS
1ADE  B4D8     BTFSC 0xFD8, 2, ACCESS
1AE0  D00D     BRA 0x1AFC
424:                   return tmp;
1AE2  0061     MOVFFL tmp, ltemp0
1AE4  F874     NOP
1AE6  F501     NOP
1AE8  0061     MOVFFL 0x61E, ttemp5
1AEA  F878     NOP
1AEC  F502     NOP
1AEE  0061     MOVFFL 0x61F, wtemp1
1AF0  F87C     NOP
1AF2  F503     NOP
1AF4  0061     MOVFFL 0x620, ttemp1
1AF6  F880     NOP
1AF8  F504     NOP
1AFA  D009     BRA 0x1B0E
425:               }
426:           
427:               tmp = MT.clock_10hz;
1AFC  C604     MOVFF 0x604, tmp
1AFE  F61D     NOP
1B00  C605     MOVFF 0x605, 0x61E
1B02  F61E     NOP
1B04  C606     MOVFF 0x606, 0x61F
1B06  F61F     NOP
1B08  C607     MOVFF 0x607, 0x620
1B0A  F620     NOP
1B0C  D7EA     BRA 0x1AE2
428:               return tmp;
429:           }
1B0E  52E5     MOVF 0xFE5, F, ACCESS
1B0E  52E5     MOVF 0xFE5, F, ACCESS
430:           
431:           uint32_t get_500hz(const uint8_t mode) {
432:               static uint32_t tmp = 0;
433:           
434:               if (mode) {
1AA2  0EFF     MOVLW 0xFF
1AA4  50E3     MOVF 0xFE3, W, ACCESS
1AA6  B4D8     BTFSC 0xFD8, 2, ACCESS
1AA8  D00D     BRA 0x1AC4
435:                   return tmp;
1AAA  0061     MOVFFL tmp, ltemp0
1AAC  F864     NOP
1AAE  F501     NOP
1AB0  0061     MOVFFL 0x61A, ttemp5
1AB2  F868     NOP
1AB4  F502     NOP
1AB6  0061     MOVFFL 0x61B, wtemp1
1AB8  F86C     NOP
1ABA  F503     NOP
1ABC  0061     MOVFFL 0x61C, ttemp1
1ABE  F870     NOP
1AC0  F504     NOP
1AC2  D009     BRA 0x1AD6
436:               }
437:           
438:               tmp = MT.clock_500hz;
1AC4  C600     MOVFF MT, tmp
1AC6  F619     NOP
1AC8  C601     MOVFF 0x601, 0x61A
1ACA  F61A     NOP
1ACC  C602     MOVFF 0x602, 0x61B
1ACE  F61B     NOP
1AD0  C603     MOVFF 0x603, 0x61C
1AD2  F61C     NOP
1AD4  D7EA     BRA 0x1AAA
439:               return tmp;
440:           }
1AD6  52E5     MOVF 0xFE5, F, ACCESS
1AD6  52E5     MOVF 0xFE5, F, ACCESS
441:           
442:           // switch RS transceiver to transmit mode and wait if not tx
443:           
444:           static void half_dup_tx(const bool delay) {
445:               if (DERE_GetValue()) {
24CE  B4D0     BTFSC 0xFD0, 2, ACCESS
24D0  D00B     BRA 0x24E8
446:                   return;
447:               }
448:               DERE_SetHigh(); // enable modbus transmitter
24D2  84C0     BSF 0xFC0, 2, ACCESS
449:           
450:               if (delay) {
24D4  0EFF     MOVLW 0xFF
24D6  50E3     MOVF 0xFE3, W, ACCESS
24D8  B4D8     BTFSC 0xFD8, 2, ACCESS
24DA  D006     BRA 0x24E8
451:                   delay_ms(DUPL_DELAY); // busy waits
24DC  0E02     MOVLW 0x2
24DE  6EE6     MOVWF 0xFE6, ACCESS
24E0  0E00     MOVLW 0x0
24E2  6EE6     MOVWF 0xFE6, ACCESS
24E4  EC13     CALL 0x2626, 0
24E6  F013     NOP
452:               }
453:           }
24E8  52E5     MOVF 0xFE5, F, ACCESS
24E8  52E5     MOVF 0xFE5, F, ACCESS
454:           
455:           // switch RS transceiver to receive mode and wait if not rx
456:           
457:           static void half_dup_rx(const bool delay) {
458:               if (!DERE_GetValue()) {
24EC  A4D0     BTFSS 0xFD0, 2, ACCESS
24EE  D00B     BRA 0x2506
459:                   return;
460:               }
461:               if (delay) {
24F0  0EFF     MOVLW 0xFF
24F2  50E3     MOVF 0xFE3, W, ACCESS
24F4  B4D8     BTFSC 0xFD8, 2, ACCESS
24F6  D006     BRA 0x2504
462:                   delay_ms(DUPL_DELAY); // busy waits
24F8  0E02     MOVLW 0x2
24FA  6EE6     MOVWF 0xFE6, ACCESS
24FC  0E00     MOVLW 0x0
24FE  6EE6     MOVWF 0xFE6, ACCESS
2500  EC13     CALL 0x2626, 0
2502  F013     NOP
463:               }
464:               DERE_SetLow(); // enable modbus receiver
2504  94C0     BCF 0xFC0, 2, ACCESS
465:           }
2506  52E5     MOVF 0xFE5, F, ACCESS
2506  52E5     MOVF 0xFE5, F, ACCESS
466:           
467:           // ISR function for TMR5
468:           
469:           void timer_500ms_tick(void) {
470:               INT_TRACE;
1CB6  ACBF     BTFSS 0xFBF, 6, ACCESS
1CB8  D002     BRA 0x1CBE
1CBA  0E01     MOVLW 0x1
1CBC  D001     BRA 0x1CC0
1CBE  0E00     MOVLW 0x0
1CC0  0AFF     XORLW 0xFF
1CC2  6E0C     MOVWF 0xC, ACCESS
1CC4  3A0C     SWAPF 0xC, F, ACCESS
1CC6  460C     RLNCF 0xC, F, ACCESS
1CC8  460C     RLNCF 0xC, F, ACCESS
1CCA  50BF     MOVF 0xFBF, W, ACCESS
1CCC  180C     XORWF 0xC, W, ACCESS
1CCE  0BBF     ANDLW 0xBF
1CD0  180C     XORWF 0xC, W, ACCESS
1CD2  6EBF     MOVWF 0xFBF, ACCESS
471:               MT.clock_2hz++;
1CD4  0E01     MOVLW 0x1
1CD6  0106     MOVLB 0x6
1CD8  2708     ADDWF 0x8, F, BANKED
1CDA  0E00     MOVLW 0x0
1CDC  2309     ADDWFC 0x9, F, BANKED
1CDE  230A     ADDWFC 0xA, F, BANKED
1CE0  230B     ADDWFC 0xB, F, BANKED
472:               MT.clock_blinks++;
1CE2  2B0C     INCF 0xC, F, BANKED
473:           }
1CE4  0012     RETURN 0
474:           
475:           // ISR function for TMR6
476:           
477:           void timer_2ms_tick(void) {
478:               INT_TRACE;
19F6  ACBF     BTFSS 0xFBF, 6, ACCESS
19F8  D002     BRA 0x19FE
19FA  0E01     MOVLW 0x1
19FC  D001     BRA 0x1A00
19FE  0E00     MOVLW 0x0
1A00  0AFF     XORLW 0xFF
1A02  6E0C     MOVWF 0xC, ACCESS
1A04  3A0C     SWAPF 0xC, F, ACCESS
1A06  460C     RLNCF 0xC, F, ACCESS
1A08  460C     RLNCF 0xC, F, ACCESS
1A0A  50BF     MOVF 0xFBF, W, ACCESS
1A0C  180C     XORWF 0xC, W, ACCESS
1A0E  0BBF     ANDLW 0xBF
1A10  180C     XORWF 0xC, W, ACCESS
1A12  6EBF     MOVWF 0xFBF, ACCESS
479:               MT.clock_500hz++;
1A14  0E01     MOVLW 0x1
1A16  0106     MOVLB 0x6
1A18  2700     ADDWF __smallconst, F, BANKED
1A1A  0E00     MOVLW 0x0
1A1C  2301     ADDWFC __ptext283, F, BANKED
1A1E  2302     ADDWFC ___rparam_used, F, BANKED
1A20  2303     ADDWFC __activetblptr, F, BANKED
480:               MT.clock_10hz++;
1A22  0E01     MOVLW 0x1
1A24  2704     ADDWF __activetblptr, F, BANKED
1A26  0E00     MOVLW 0x0
1A28  2305     ADDWFC 0x5, F, BANKED
1A2A  2306     ADDWFC 0x6, F, BANKED
1A2C  2307     ADDWFC 0x7, F, BANKED
481:           }
0EC8  C4D8     MOVFF STATUS, 0xCF4
1A2E  0012     RETURN 0
482:           
483:           /*
484:            * check if we are done with interrupt background buffered transmission of serial data with FIFO
485:            *
486:            * TRMT: Transmit Shift Register is Empty bit (read-only)
487:            * 1 = Transmit shift register is empty and transmit buffer is empty (the last transmission has completed)
488:            * 0 = Transmit shift register is not empty, a transmission is in progress or queued in the transmit buffer
489:            *
490:            * ? 8-level deep First-In-First-Out (FIFO) transmit data buffer, ? 8-level deep FIFO receive data buffer
491:            * Interrupt is generated and asserted while the transmit buffer is empty
492:            *
493:            * so this will return 'true' after the buffer is empty 'interrupt' and after the last bit is on the wire
494:            */
495:           
496:           static bool serial_trmt(void) {
497:               return !(Strmt); // note, we invert the TRMT bit so it's true while transmitting
272E  0E00     MOVLW 0x0
2730  6E01     MOVWF __ptext283, ACCESS
498:           }
2732  0012     RETURN 0
499:           
500:           /*
501:            * serial port testing routine
502:            */
503:           void mb_tx_test(C_data * client) {
504:               if (TimerDone(TMR_MBTEST)) {
505:                   StartTimer(TMR_MBTEST, 500);
506:                   client->req_length = modbus_rtu_send_msg((void*) cc_buffer_tx, (const void *) modbus_em_passwd, sizeof (modbus_em_passwd));
507:                   for (int8_t i = 0; i < client->req_length; i++) {
508:                       if (UART5_is_tx_ready()) {
509:                           Swrite(cc_buffer_tx[i]);
510:                       }
511:                   }
512:               }
513:           }
514:           
515:           static void UART1_DefaultFramingErrorHandler_mb(void) {
516:               INT_TRACE; // GPIO interrupt scope trace
517:               MM_ERROR_S;
518:           }
519:           
520:           static void UART1_DefaultOverrunErrorHandler_mb(void) {
521:               INT_TRACE; // GPIO interrupt scope trace
522:               MM_ERROR_S;
523:           }
524:           
525:           static void UART1_DefaultErrorHandler_mb(void) {
526:               INT_TRACE; // GPIO interrupt scope trace
527:               MM_ERROR_S;
528:           }
529:           
530:           void mb_setup(void) {
531:               UART1_SetFramingErrorHandler(UART1_DefaultFramingErrorHandler_mb);
532:               UART1_SetOverrunErrorHandler(UART1_DefaultOverrunErrorHandler_mb);
533:               UART1_SetErrorHandler(UART1_DefaultErrorHandler_mb);
534:           }
535:           
536:           static bool modbus_write_check(C_data * client, bool* cstate, const uint16_t rec_length) {
1BC6E  52E6     MOVF 0xFE6, F, ACCESS
1BC70  52E6     MOVF 0xFE6, F, ACCESS
1BC72  52E6     MOVF 0xFE6, F, ACCESS
1BC74  52E6     MOVF 0xFE6, F, ACCESS
537:               uint16_t c_crc, c_crc_rec;
538:           
539:           #ifdef	MB_EM540
540:               client->req_length = rec_length;
1BC76  50E1     MOVF 0xFE1, W, ACCESS
1BC78  0FF6     ADDLW 0xF6
1BC7A  6ED9     MOVWF 0xFD9, ACCESS
1BC7C  50E2     MOVF 0xFE2, W, ACCESS
1BC7E  6EDA     MOVWF __end_of_UART2_tx_vect_isr, ACCESS
1BC80  0EFF     MOVLW 0xFF
1BC82  22DA     ADDWFC __end_of_UART2_tx_vect_isr, F, ACCESS
1BC84  0EFA     MOVLW 0xFA
1BC86  0061     MOVFFL PLUSW1, wtemp5
1BC88  F38C     NOP
1BC8A  F50B     NOP
1BC8C  0EFB     MOVLW 0xFB
1BC8E  0061     MOVFFL PLUSW1, 0x50C
1BC90  F38C     NOP
1BC92  F50C     NOP
1BC94  0E03     MOVLW 0x3
1BC96  240B     ADDWF 0xB, W, ACCESS
1BC98  6EE9     MOVWF 0xFE9, ACCESS
1BC9A  0E00     MOVLW 0x0
1BC9C  200C     ADDWFC 0xC, W, ACCESS
1BC9E  6EEA     MOVWF 0xFEA, ACCESS
1BCA0  C4DE     MOVFF POSTINC2, POSTINC0
1BCA2  F4EE     NOP
1BCA4  C4DD     MOVFF POSTDEC2, POSTDEC0
1BCA6  F4ED     NOP
541:               if (DBUG_R((M.recv_count >= client->req_length) && (cc_buffer[0] == MADDR) && (cc_buffer[1] == WRITE_SINGLE_REGISTER))) {
1BCA8  0EFA     MOVLW 0xFA
1BCAA  0061     MOVFFL PLUSW1, wtemp5
1BCAC  F38C     NOP
1BCAE  F50B     NOP
1BCB0  0EFB     MOVLW 0xFB
1BCB2  0061     MOVFFL PLUSW1, 0x50C
1BCB4  F38C     NOP
1BCB6  F50C     NOP
1BCB8  0E03     MOVLW 0x3
1BCBA  240B     ADDWF 0xB, W, ACCESS
1BCBC  6ED9     MOVWF 0xFD9, ACCESS
1BCBE  0E00     MOVLW 0x0
1BCC0  200C     ADDWFC 0xC, W, ACCESS
1BCC2  6EDA     MOVWF __end_of_UART2_tx_vect_isr, ACCESS
1BCC4  0106     MOVLB 0x6
1BCC6  51E1     MOVF 0xE1, W, BANKED
1BCC8  6E0B     MOVWF 0xB, ACCESS
1BCCA  6A0C     CLRF 0xC, ACCESS
1BCCC  50DE     MOVF 0xFDE, W, ACCESS
1BCCE  5C0B     SUBWF 0xB, W, ACCESS
1BCD0  50DE     MOVF 0xFDE, W, ACCESS
1BCD2  580C     SUBWFB 0xC, W, ACCESS
1BCD4  A0D8     BTFSS 0xFD8, 0, ACCESS
1BCD6  D08A     BRA 0xBDEC
1BCD8  010C     MOVLB 0xC
1BCDA  0500     DECF __smallconst, W, BANKED
1BCDC  A4D8     BTFSS 0xFD8, 2, ACCESS
1BCDE  D086     BRA 0xBDEC
1BCE0  0E06     MOVLW 0x6
1BCE2  1901     XORWF __ptext283, W, BANKED
1BCE4  A4D8     BTFSS 0xFD8, 2, ACCESS
1BCE6  D082     BRA 0xBDEC
542:                   c_crc = crc16(cc_buffer, client->req_length - 2);
1BCE8  0EFA     MOVLW 0xFA
1BCEA  0061     MOVFFL PLUSW1, wtemp5
1BCEC  F38C     NOP
1BCEE  F50B     NOP
1BCF0  0EFB     MOVLW 0xFB
1BCF2  0061     MOVFFL PLUSW1, 0x50C
1BCF4  F38C     NOP
1BCF6  F50C     NOP
1BCF8  0E03     MOVLW 0x3
1BCFA  240B     ADDWF 0xB, W, ACCESS
1BCFC  6ED9     MOVWF 0xFD9, ACCESS
1BCFE  0E00     MOVLW 0x0
1BD00  200C     ADDWFC 0xC, W, ACCESS
1BD02  6EDA     MOVWF __end_of_UART2_tx_vect_isr, ACCESS
1BD04  0061     MOVFFL POSTINC2, wtemp5
1BD06  F378     NOP
1BD08  F50B     NOP
1BD0A  0061     MOVFFL POSTDEC2, 0x50C
1BD0C  F374     NOP
1BD0E  F50C     NOP
1BD10  0EFE     MOVLW 0xFE
1BD12  240B     ADDWF 0xB, W, ACCESS
1BD14  6E09     MOVWF 0x9, ACCESS
1BD16  0EFF     MOVLW 0xFF
1BD18  200C     ADDWFC 0xC, W, ACCESS
1BD1A  6E0A     MOVWF 0xA, ACCESS
1BD1C  0061     MOVFFL ltemp2, POSTINC1
1BD1E  F424     NOP
1BD20  F4E6     NOP
1BD22  0061     MOVFFL ttemp3, POSTINC1
1BD24  F428     NOP
1BD26  F4E6     NOP
1BD28  0E00     MOVLW 0x0
1BD2A  6EE6     MOVWF 0xFE6, ACCESS
1BD2C  0E0C     MOVLW 0xC
1BD2E  6EE6     MOVWF 0xFE6, ACCESS
1BD30  EC35     CALL 0x1DE6A, 0
1BD32  F0EF     NOP
1BD34  0EFE     MOVLW 0xFE
1BD36  0061     MOVFFL ltemp0, PLUSW1
1BD38  F404     NOP
1BD3A  F4E3     NOP
1BD3C  0EFF     MOVLW 0xFF
1BD3E  0061     MOVFFL ttemp5, PLUSW1
1BD40  F408     NOP
1BD42  F4E3     NOP
543:                   c_crc_rec = crc16_receive(client);
1BD44  0EFA     MOVLW 0xFA
1BD46  C4E3     MOVFF PLUSW1, POSTINC1
1BD48  F4E6     NOP
1BD4A  C4E3     MOVFF PLUSW1, POSTINC1
1BD4C  F4E6     NOP
1BD4E  EC0F     CALL 0x1FE1E, 0
1BD50  F0FF     NOP
1BD52  0EFC     MOVLW 0xFC
1BD54  0061     MOVFFL ltemp0, PLUSW1
1BD56  F404     NOP
1BD58  F4E3     NOP
1BD5A  0EFD     MOVLW 0xFD
1BD5C  0061     MOVFFL ttemp5, PLUSW1
1BD5E  F408     NOP
1BD60  F4E3     NOP
544:                   if (DBUG_R c_crc == c_crc_rec) {
1BD62  50E1     MOVF 0xFE1, W, ACCESS
1BD64  0FFE     ADDLW 0xFE
1BD66  6ED9     MOVWF 0xFD9, ACCESS
1BD68  50E2     MOVF 0xFE2, W, ACCESS
1BD6A  6EDA     MOVWF __end_of_UART2_tx_vect_isr, ACCESS
1BD6C  0EFF     MOVLW 0xFF
1BD6E  22DA     ADDWFC __end_of_UART2_tx_vect_isr, F, ACCESS
1BD70  0EFC     MOVLW 0xFC
1BD72  50E3     MOVF 0xFE3, W, ACCESS
1BD74  18DE     XORWF 0xFDE, W, ACCESS
1BD76  E10F     BNZ 0xBD96
1BD78  0EFD     MOVLW 0xFD
1BD7A  50E3     MOVF 0xFE3, W, ACCESS
1BD7C  18DE     XORWF 0xFDE, W, ACCESS
1BD7E  A4D8     BTFSS 0xFD8, 2, ACCESS
1BD80  D00A     BRA 0xBD96
545:                       *cstate = true;
1BD82  0EF8     MOVLW 0xF8
1BD84  C4E3     MOVFF PLUSW1, FSR2
1BD86  F4D9     NOP
1BD88  0EF9     MOVLW 0xF9
1BD8A  C4E3     MOVFF PLUSW1, FSR2H
1BD8C  F4DA     NOP
1BD8E  0E01     MOVLW 0x1
1BD90  6EDF     MOVWF 0xFDF, ACCESS
546:                       MM_ERROR_C;
1BD92  92BF     BCF 0xFBF, 1, ACCESS
1BD94  D013     BRA 0xBDBC
547:                   } else {
548:                       *cstate = false;
1BD96  0EF8     MOVLW 0xF8
1BD98  C4E3     MOVFF PLUSW1, FSR2
1BD9A  F4D9     NOP
1BD9C  0EF9     MOVLW 0xF9
1BD9E  C4E3     MOVFF PLUSW1, FSR2H
1BDA0  F4DA     NOP
1BDA2  6ADF     CLRF 0xFDF, ACCESS
549:                       log_crc_error(c_crc, c_crc_rec);
1BDA4  0EFC     MOVLW 0xFC
1BDA6  C4E3     MOVFF PLUSW1, POSTINC1
1BDA8  F4E6     NOP
1BDAA  C4E3     MOVFF PLUSW1, POSTINC1
1BDAC  F4E6     NOP
1BDAE  0EFC     MOVLW 0xFC
1BDB0  C4E3     MOVFF PLUSW1, POSTINC1
1BDB2  F4E6     NOP
1BDB4  C4E3     MOVFF PLUSW1, POSTINC1
1BDB6  F4E6     NOP
1BDB8  EC11     CALL 0x1C22, 0
1BDBA  F00E     NOP
550:                   }
551:                   client->cstate = CLEAR; // where do we go next
1BDBC  0EFA     MOVLW 0xFA
1BDBE  0061     MOVFFL PLUSW1, wtemp5
1BDC0  F38C     NOP
1BDC2  F50B     NOP
1BDC4  0EFB     MOVLW 0xFB
1BDC6  0061     MOVFFL PLUSW1, 0x50C
1BDC8  F38C     NOP
1BDCA  F50C     NOP
1BDCC  0E01     MOVLW 0x1
1BDCE  240B     ADDWF 0xB, W, ACCESS
1BDD0  6ED9     MOVWF 0xFD9, ACCESS
1BDD2  0E00     MOVLW 0x0
1BDD4  200C     ADDWFC 0xC, W, ACCESS
1BDD6  6EDA     MOVWF __end_of_UART2_tx_vect_isr, ACCESS
1BDD8  6ADF     CLRF 0xFDF, ACCESS
552:                   client->mcmd = G_LAST; // what do we run next
1BDDA  0EFA     MOVLW 0xFA
1BDDC  C4E3     MOVFF PLUSW1, FSR2
1BDDE  F4D9     NOP
1BDE0  0EFB     MOVLW 0xFB
1BDE2  C4E3     MOVFF PLUSW1, FSR2H
1BDE4  F4DA     NOP
1BDE6  0E08     MOVLW 0x8
1BDE8  6EDF     MOVWF 0xFDF, ACCESS
553:               } else {
1BDEA  D03D     BRA 0xBE66
554:                   if (get_500hz(false) >= RDELAY) {
1BDEC  0E00     MOVLW 0x0
1BDEE  6EE6     MOVWF 0xFE6, ACCESS
1BDF0  EC51     CALL 0x1AA2, 0
1BDF2  F00D     NOP
1BDF4  5004     MOVF __activetblptr, W, ACCESS
1BDF6  1003     IORWF __activetblptr, W, ACCESS
1BDF8  1002     IORWF ___rparam_used, W, ACCESS
1BDFA  E104     BNZ 0xBE04
1BDFC  0EC8     MOVLW 0xC8
1BDFE  5C01     SUBWF __ptext283, W, ACCESS
1BE00  A0D8     BTFSS 0xFD8, 0, ACCESS
1BE02  D031     BRA 0xBE66
555:                       DB0_SetLow();
1BE04  92C1     BCF 0xFC1, 1, ACCESS
556:                       client->cstate = CLEAR; // where do we go next
1BE06  0EFA     MOVLW 0xFA
1BE08  0061     MOVFFL PLUSW1, wtemp5
1BE0A  F38C     NOP
1BE0C  F50B     NOP
1BE0E  0EFB     MOVLW 0xFB
1BE10  0061     MOVFFL PLUSW1, 0x50C
1BE12  F38C     NOP
1BE14  F50C     NOP
1BE16  0E01     MOVLW 0x1
1BE18  240B     ADDWF 0xB, W, ACCESS
1BE1A  6ED9     MOVWF 0xFD9, ACCESS
1BE1C  0E00     MOVLW 0x0
1BE1E  200C     ADDWFC 0xC, W, ACCESS
1BE20  6EDA     MOVWF __end_of_UART2_tx_vect_isr, ACCESS
1BE22  6ADF     CLRF 0xFDF, ACCESS
557:                       client->mcmd = G_ID; // what do we run next
1BE24  0EFA     MOVLW 0xFA
1BE26  C4E3     MOVFF PLUSW1, FSR2
1BE28  F4D9     NOP
1BE2A  0EFB     MOVLW 0xFB
1BE2C  C4E3     MOVFF PLUSW1, FSR2H
1BE2E  F4DA     NOP
1BE30  6ADF     CLRF 0xFDF, ACCESS
558:                       M.to_error++;
1BE32  0E01     MOVLW 0x1
1BE34  0106     MOVLB 0x6
1BE36  27ED     ADDWF DMAnDPTRH, F, BANKED
1BE38  0E00     MOVLW 0x0
1BE3A  23EE     ADDWFC DMAnDSZ, F, BANKED
1BE3C  23EF     ADDWFC DMAnDSZH, F, BANKED
1BE3E  23F0     ADDWFC DMAnDSA, F, BANKED
559:                       M.error++;
1BE40  4BE3     INFSNZ 0xE3, F, BANKED
1BE42  2BE4     INCF 0xE4, F, BANKED
560:                       if (client->data_ok) {
1BE44  0EFA     MOVLW 0xFA
1BE46  0061     MOVFFL PLUSW1, wtemp5
1BE48  F38C     NOP
1BE4A  F50B     NOP
1BE4C  0EFB     MOVLW 0xFB
1BE4E  0061     MOVFFL PLUSW1, 0x50C
1BE50  F38C     NOP
1BE52  F50C     NOP
1BE54  0E09     MOVLW 0x9
1BE56  240B     ADDWF 0xB, W, ACCESS
1BE58  6ED9     MOVWF 0xFD9, ACCESS
1BE5A  0E00     MOVLW 0x0
1BE5C  200C     ADDWFC 0xC, W, ACCESS
1BE5E  6EDA     MOVWF __end_of_UART2_tx_vect_isr, ACCESS
1BE60  50DF     MOVF 0xFDF, W, ACCESS
1BE62  A4D8     BTFSS 0xFD8, 2, ACCESS
561:                           MM_ERROR_C;
1BE64  92BF     BCF 0xFBF, 1, ACCESS
562:                       }
563:                   }
564:               }
565:           #endif
566:               return *cstate;
567:           }
1BE66  0EF6     MOVLW 0xF6
1BE66  0EF6     MOVLW 0xF6
1BE66  0EF6     MOVLW 0xF6
1BE66  0EF6     MOVLW 0xF6
1BE66  0EF6     MOVLW 0xF6
568:           
569:           static bool modbus_read_check(C_data * client, bool* cstate, const uint16_t rec_length, void (* DataHandler)(void)) {
1AA9C  52E6     MOVF 0xFE6, F, ACCESS
1AA9E  52E6     MOVF 0xFE6, F, ACCESS
1AAA0  52E6     MOVF 0xFE6, F, ACCESS
1AAA2  52E6     MOVF 0xFE6, F, ACCESS
570:               uint16_t c_crc, c_crc_rec;
571:           
572:           #ifdef	MB_EM540
573:               client->req_length = rec_length;
1AAA4  50E1     MOVF 0xFE1, W, ACCESS
1AAA6  0FF6     ADDLW 0xF6
1AAA8  6ED9     MOVWF 0xFD9, ACCESS
1AAAA  50E2     MOVF 0xFE2, W, ACCESS
1AAAC  6EDA     MOVWF __end_of_UART2_tx_vect_isr, ACCESS
1AAAE  0EFF     MOVLW 0xFF
1AAB0  22DA     ADDWFC __end_of_UART2_tx_vect_isr, F, ACCESS
1AAB2  0EFA     MOVLW 0xFA
1AAB4  0061     MOVFFL PLUSW1, wtemp5
1AAB6  F38C     NOP
1AAB8  F50B     NOP
1AABA  0EFB     MOVLW 0xFB
1AABC  0061     MOVFFL PLUSW1, 0x50C
1AABE  F38C     NOP
1AAC0  F50C     NOP
1AAC2  0E03     MOVLW 0x3
1AAC4  240B     ADDWF 0xB, W, ACCESS
1AAC6  6EE9     MOVWF 0xFE9, ACCESS
1AAC8  0E00     MOVLW 0x0
1AACA  200C     ADDWFC 0xC, W, ACCESS
1AACC  6EEA     MOVWF 0xFEA, ACCESS
1AACE  C4DE     MOVFF POSTINC2, POSTINC0
1AAD0  F4EE     NOP
1AAD2  C4DD     MOVFF POSTDEC2, POSTDEC0
1AAD4  F4ED     NOP
574:               if (DBUG_R((M.recv_count >= client->req_length) && (cc_buffer[0] == MADDR) && (cc_buffer[1] == READ_HOLDING_REGISTERS))) {
1AAD6  0EFA     MOVLW 0xFA
1AAD8  0061     MOVFFL PLUSW1, wtemp5
1AADA  F38C     NOP
1AADC  F50B     NOP
1AADE  0EFB     MOVLW 0xFB
1AAE0  0061     MOVFFL PLUSW1, 0x50C
1AAE2  F38C     NOP
1AAE4  F50C     NOP
1AAE6  0E03     MOVLW 0x3
1AAE8  240B     ADDWF 0xB, W, ACCESS
1AAEA  6ED9     MOVWF 0xFD9, ACCESS
1AAEC  0E00     MOVLW 0x0
1AAEE  200C     ADDWFC 0xC, W, ACCESS
1AAF0  6EDA     MOVWF __end_of_UART2_tx_vect_isr, ACCESS
1AAF2  0106     MOVLB 0x6
1AAF4  51E1     MOVF 0xE1, W, BANKED
1AAF6  6E0B     MOVWF 0xB, ACCESS
1AAF8  6A0C     CLRF 0xC, ACCESS
1AAFA  50DE     MOVF 0xFDE, W, ACCESS
1AAFC  5C0B     SUBWF 0xB, W, ACCESS
1AAFE  50DE     MOVF 0xFDE, W, ACCESS
1AB00  580C     SUBWFB 0xC, W, ACCESS
1AB02  A0D8     BTFSS 0xFD8, 0, ACCESS
1AB04  D0FA     BRA 0xACFA
1AB06  010C     MOVLB 0xC
1AB08  0500     DECF __smallconst, W, BANKED
1AB0A  A4D8     BTFSS 0xFD8, 2, ACCESS
1AB0C  D0F6     BRA 0xACFA
1AB0E  0E03     MOVLW 0x3
1AB10  1901     XORWF __ptext283, W, BANKED
1AB12  A4D8     BTFSS 0xFD8, 2, ACCESS
1AB14  D0F2     BRA 0xACFA
575:                   c_crc = crc16(cc_buffer, client->req_length - 2);
1AB16  0EFA     MOVLW 0xFA
1AB18  0061     MOVFFL PLUSW1, wtemp5
1AB1A  F38C     NOP
1AB1C  F50B     NOP
1AB1E  0EFB     MOVLW 0xFB
1AB20  0061     MOVFFL PLUSW1, 0x50C
1AB22  F38C     NOP
1AB24  F50C     NOP
1AB26  0E03     MOVLW 0x3
1AB28  240B     ADDWF 0xB, W, ACCESS
1AB2A  6ED9     MOVWF 0xFD9, ACCESS
1AB2C  0E00     MOVLW 0x0
1AB2E  200C     ADDWFC 0xC, W, ACCESS
1AB30  6EDA     MOVWF __end_of_UART2_tx_vect_isr, ACCESS
1AB32  0061     MOVFFL POSTINC2, wtemp5
1AB34  F378     NOP
1AB36  F50B     NOP
1AB38  0061     MOVFFL POSTDEC2, 0x50C
1AB3A  F374     NOP
1AB3C  F50C     NOP
1AB3E  0EFE     MOVLW 0xFE
1AB40  240B     ADDWF 0xB, W, ACCESS
1AB42  6E09     MOVWF 0x9, ACCESS
1AB44  0EFF     MOVLW 0xFF
1AB46  200C     ADDWFC 0xC, W, ACCESS
1AB48  6E0A     MOVWF 0xA, ACCESS
1AB4A  0061     MOVFFL ltemp2, POSTINC1
1AB4C  F424     NOP
1AB4E  F4E6     NOP
1AB50  0061     MOVFFL ttemp3, POSTINC1
1AB52  F428     NOP
1AB54  F4E6     NOP
1AB56  0E00     MOVLW 0x0
1AB58  6EE6     MOVWF 0xFE6, ACCESS
1AB5A  0E0C     MOVLW 0xC
1AB5C  6EE6     MOVWF 0xFE6, ACCESS
1AB5E  EC35     CALL 0x1DE6A, 0
1AB60  F0EF     NOP
1AB62  0EFE     MOVLW 0xFE
1AB64  0061     MOVFFL ltemp0, PLUSW1
1AB66  F404     NOP
1AB68  F4E3     NOP
1AB6A  0EFF     MOVLW 0xFF
1AB6C  0061     MOVFFL ttemp5, PLUSW1
1AB6E  F408     NOP
1AB70  F4E3     NOP
576:                   c_crc_rec = crc16_receive(client);
1AB72  0EFA     MOVLW 0xFA
1AB74  C4E3     MOVFF PLUSW1, POSTINC1
1AB76  F4E6     NOP
1AB78  C4E3     MOVFF PLUSW1, POSTINC1
1AB7A  F4E6     NOP
1AB7C  EC0F     CALL 0x1FE1E, 0
1AB7E  F0FF     NOP
1AB80  0EFC     MOVLW 0xFC
1AB82  0061     MOVFFL ltemp0, PLUSW1
1AB84  F404     NOP
1AB86  F4E3     NOP
1AB88  0EFD     MOVLW 0xFD
1AB8A  0061     MOVFFL ttemp5, PLUSW1
1AB8C  F408     NOP
1AB8E  F4E3     NOP
577:                   if (DBUG_R c_crc == c_crc_rec) {
1AB90  50E1     MOVF 0xFE1, W, ACCESS
1AB92  0FFE     ADDLW 0xFE
1AB94  6ED9     MOVWF 0xFD9, ACCESS
1AB96  50E2     MOVF 0xFE2, W, ACCESS
1AB98  6EDA     MOVWF __end_of_UART2_tx_vect_isr, ACCESS
1AB9A  0EFF     MOVLW 0xFF
1AB9C  22DA     ADDWFC __end_of_UART2_tx_vect_isr, F, ACCESS
1AB9E  0EFC     MOVLW 0xFC
1ABA0  50E3     MOVF 0xFE3, W, ACCESS
1ABA2  18DE     XORWF 0xFDE, W, ACCESS
1ABA4  E169     BNZ 0xAC78
1ABA6  0EFD     MOVLW 0xFD
1ABA8  50E3     MOVF 0xFE3, W, ACCESS
1ABAA  18DE     XORWF 0xFDE, W, ACCESS
1ABAC  A4D8     BTFSS 0xFD8, 2, ACCESS
1ABAE  D064     BRA 0xAC78
578:                       client->data_ok = true;
1ABB0  0EFA     MOVLW 0xFA
1ABB2  0061     MOVFFL PLUSW1, wtemp5
1ABB4  F38C     NOP
1ABB6  F50B     NOP
1ABB8  0EFB     MOVLW 0xFB
1ABBA  0061     MOVFFL PLUSW1, 0x50C
1ABBC  F38C     NOP
1ABBE  F50C     NOP
1ABC0  0E09     MOVLW 0x9
1ABC2  240B     ADDWF 0xB, W, ACCESS
1ABC4  6ED9     MOVWF 0xFD9, ACCESS
1ABC6  0E00     MOVLW 0x0
1ABC8  200C     ADDWFC 0xC, W, ACCESS
1ABCA  6EDA     MOVWF __end_of_UART2_tx_vect_isr, ACCESS
1ABCC  0E01     MOVLW 0x1
1ABCE  6EDF     MOVWF 0xFDF, ACCESS
579:                       *cstate = true;
1ABD0  0EF8     MOVLW 0xF8
1ABD2  C4E3     MOVFF PLUSW1, FSR2
1ABD4  F4D9     NOP
1ABD6  0EF9     MOVLW 0xF9
1ABD8  C4E3     MOVFF PLUSW1, FSR2H
1ABDA  F4DA     NOP
1ABDC  0E01     MOVLW 0x1
1ABDE  6EDF     MOVWF 0xFDF, ACCESS
580:                       /*
581:                        * move from receive buffer to data structure and munge the data into the correct local 32-bit format from MODBUS client
582:                        */
583:                       DataHandler();
1ABE0  50E1     MOVF 0xFE1, W, ACCESS
1ABE2  0FF3     ADDLW 0xF3
1ABE4  6ED9     MOVWF 0xFD9, ACCESS
1ABE6  50E2     MOVF 0xFE2, W, ACCESS
1ABE8  6EDA     MOVWF __end_of_UART2_tx_vect_isr, ACCESS
1ABEA  0EFF     MOVLW 0xFF
1ABEC  22DA     ADDWFC __end_of_UART2_tx_vect_isr, F, ACCESS
1ABEE  D801     RCALL 0xABF2
1ABF0  D00A     BRA 0xAC06
1ABF2  0005     PUSH
1ABF4  6EFA     MOVWF 0xFFA, ACCESS
1ABF6  50DE     MOVF 0xFDE, W, ACCESS
1ABF8  6EFD     MOVWF 0xFFD, ACCESS
1ABFA  50DE     MOVF 0xFDE, W, ACCESS
1ABFC  6EFE     MOVWF 0xFFE, ACCESS
1ABFE  50DE     MOVF 0xFDE, W, ACCESS
1AC00  6EFF     MOVWF 0xFFF, ACCESS
1AC02  50FA     MOVF 0xFFA, W, ACCESS
1AC04  0012     RETURN 0
584:                       client->data_prev = client->data_count;
1AC06  0EFA     MOVLW 0xFA
1AC08  0061     MOVFFL PLUSW1, wtemp5
1AC0A  F38C     NOP
1AC0C  F50B     NOP
1AC0E  0EFB     MOVLW 0xFB
1AC10  0061     MOVFFL PLUSW1, 0x50C
1AC12  F38C     NOP
1AC14  F50C     NOP
1AC16  0E0E     MOVLW 0xE
1AC18  240B     ADDWF 0xB, W, ACCESS
1AC1A  6ED9     MOVWF 0xFD9, ACCESS
1AC1C  0E00     MOVLW 0x0
1AC1E  200C     ADDWFC 0xC, W, ACCESS
1AC20  6EDA     MOVWF __end_of_UART2_tx_vect_isr, ACCESS
1AC22  0EFA     MOVLW 0xFA
1AC24  0061     MOVFFL PLUSW1, wtemp5
1AC26  F38C     NOP
1AC28  F50B     NOP
1AC2A  0EFB     MOVLW 0xFB
1AC2C  0061     MOVFFL PLUSW1, 0x50C
1AC2E  F38C     NOP
1AC30  F50C     NOP
1AC32  0E12     MOVLW 0x12
1AC34  240B     ADDWF 0xB, W, ACCESS
1AC36  6EE9     MOVWF 0xFE9, ACCESS
1AC38  0E00     MOVLW 0x0
1AC3A  200C     ADDWFC 0xC, W, ACCESS
1AC3C  6EEA     MOVWF 0xFEA, ACCESS
1AC3E  C4DE     MOVFF POSTINC2, POSTINC0
1AC40  F4EE     NOP
1AC42  C4DE     MOVFF POSTINC2, POSTINC0
1AC44  F4EE     NOP
1AC46  C4DE     MOVFF POSTINC2, POSTINC0
1AC48  F4EE     NOP
1AC4A  C4DE     MOVFF POSTINC2, POSTINC0
1AC4C  F4EE     NOP
585:                       client->data_count++;
1AC4E  0EFA     MOVLW 0xFA
1AC50  0061     MOVFFL PLUSW1, wtemp5
1AC52  F38C     NOP
1AC54  F50B     NOP
1AC56  0EFB     MOVLW 0xFB
1AC58  0061     MOVFFL PLUSW1, 0x50C
1AC5A  F38C     NOP
1AC5C  F50C     NOP
1AC5E  0E0E     MOVLW 0xE
1AC60  240B     ADDWF 0xB, W, ACCESS
1AC62  6ED9     MOVWF 0xFD9, ACCESS
1AC64  0E00     MOVLW 0x0
1AC66  200C     ADDWFC 0xC, W, ACCESS
1AC68  6EDA     MOVWF __end_of_UART2_tx_vect_isr, ACCESS
1AC6A  2ADE     INCF 0xFDE, F, ACCESS
1AC6C  0E00     MOVLW 0x0
1AC6E  22DE     ADDWFC 0xFDE, F, ACCESS
1AC70  22DE     ADDWFC 0xFDE, F, ACCESS
1AC72  22DE     ADDWFC 0xFDE, F, ACCESS
586:                       MM_ERROR_C;
1AC74  92BF     BCF 0xFBF, 1, ACCESS
1AC76  D031     BRA 0xACDA
587:                   } else {
588:                       MM_ERROR_C;
1AC78  92BF     BCF 0xFBF, 1, ACCESS
589:                       *cstate = false;
1AC7A  0EF8     MOVLW 0xF8
1AC7C  C4E3     MOVFF PLUSW1, FSR2
1AC7E  F4D9     NOP
1AC80  0EF9     MOVLW 0xF9
1AC82  C4E3     MOVFF PLUSW1, FSR2H
1AC84  F4DA     NOP
1AC86  6ADF     CLRF 0xFDF, ACCESS
590:                       client->data_ok = false;
1AC88  0EFA     MOVLW 0xFA
1AC8A  0061     MOVFFL PLUSW1, wtemp5
1AC8C  F38C     NOP
1AC8E  F50B     NOP
1AC90  0EFB     MOVLW 0xFB
1AC92  0061     MOVFFL PLUSW1, 0x50C
1AC94  F38C     NOP
1AC96  F50C     NOP
1AC98  0E09     MOVLW 0x9
1AC9A  240B     ADDWF 0xB, W, ACCESS
1AC9C  6ED9     MOVWF 0xFD9, ACCESS
1AC9E  0E00     MOVLW 0x0
1ACA0  200C     ADDWFC 0xC, W, ACCESS
1ACA2  6EDA     MOVWF __end_of_UART2_tx_vect_isr, ACCESS
1ACA4  6ADF     CLRF 0xFDF, ACCESS
591:                       log_crc_error(c_crc, c_crc_rec);
1ACA6  0EFC     MOVLW 0xFC
1ACA8  C4E3     MOVFF PLUSW1, POSTINC1
1ACAA  F4E6     NOP
1ACAC  C4E3     MOVFF PLUSW1, POSTINC1
1ACAE  F4E6     NOP
1ACB0  0EFC     MOVLW 0xFC
1ACB2  C4E3     MOVFF PLUSW1, POSTINC1
1ACB4  F4E6     NOP
1ACB6  C4E3     MOVFF PLUSW1, POSTINC1
1ACB8  F4E6     NOP
1ACBA  EC11     CALL 0x1C22, 0
1ACBC  F00E     NOP
592:                       if (client->data_ok) {
1ACBE  0EFA     MOVLW 0xFA
1ACC0  0061     MOVFFL PLUSW1, wtemp5
1ACC2  F38C     NOP
1ACC4  F50B     NOP
1ACC6  0EFB     MOVLW 0xFB
1ACC8  0061     MOVFFL PLUSW1, 0x50C
1ACCA  F38C     NOP
1ACCC  F50C     NOP
1ACCE  0E09     MOVLW 0x9
1ACD0  240B     ADDWF 0xB, W, ACCESS
1ACD2  6ED9     MOVWF 0xFD9, ACCESS
1ACD4  0E00     MOVLW 0x0
1ACD6  200C     ADDWFC 0xC, W, ACCESS
1ACD8  6EDA     MOVWF __end_of_UART2_tx_vect_isr, ACCESS
593:                       }
594:                   }
595:                   client->cstate = CLEAR;
1ACDA  0EFA     MOVLW 0xFA
1ACDC  0061     MOVFFL PLUSW1, wtemp5
1ACDE  F38C     NOP
1ACE0  F50B     NOP
1ACE2  0EFB     MOVLW 0xFB
1ACE4  0061     MOVFFL PLUSW1, 0x50C
1ACE6  F38C     NOP
1ACE8  F50C     NOP
1ACEA  0E01     MOVLW 0x1
1ACEC  240B     ADDWF 0xB, W, ACCESS
1ACEE  6ED9     MOVWF 0xFD9, ACCESS
1ACF0  0E00     MOVLW 0x0
1ACF2  200C     ADDWFC 0xC, W, ACCESS
1ACF4  6EDA     MOVWF __end_of_UART2_tx_vect_isr, ACCESS
1ACF6  6ADF     CLRF 0xFDF, ACCESS
596:               } else {
1ACF8  D03B     BRA 0xAD70
597:                   if (get_500hz(false) >= RDELAY) {
1ACFA  0E00     MOVLW 0x0
1ACFC  6EE6     MOVWF 0xFE6, ACCESS
1ACFE  EC51     CALL 0x1AA2, 0
1AD00  F00D     NOP
1AD02  5004     MOVF __activetblptr, W, ACCESS
1AD04  1003     IORWF __activetblptr, W, ACCESS
1AD06  1002     IORWF ___rparam_used, W, ACCESS
1AD08  E104     BNZ 0xAD12
1AD0A  0EC8     MOVLW 0xC8
1AD0C  5C01     SUBWF __ptext283, W, ACCESS
1AD0E  A0D8     BTFSS 0xFD8, 0, ACCESS
1AD10  D02F     BRA 0xAD70
598:                       DB0_SetLow();
1AD12  92C1     BCF 0xFC1, 1, ACCESS
599:                       client->cstate = CLEAR;
1AD14  0EFA     MOVLW 0xFA
1AD16  0061     MOVFFL PLUSW1, wtemp5
1AD18  F38C     NOP
1AD1A  F50B     NOP
1AD1C  0EFB     MOVLW 0xFB
1AD1E  0061     MOVFFL PLUSW1, 0x50C
1AD20  F38C     NOP
1AD22  F50C     NOP
1AD24  0E01     MOVLW 0x1
1AD26  240B     ADDWF 0xB, W, ACCESS
1AD28  6ED9     MOVWF 0xFD9, ACCESS
1AD2A  0E00     MOVLW 0x0
1AD2C  200C     ADDWFC 0xC, W, ACCESS
1AD2E  6EDA     MOVWF __end_of_UART2_tx_vect_isr, ACCESS
1AD30  6ADF     CLRF 0xFDF, ACCESS
600:                       MM_ERROR_C;
1AD32  92BF     BCF 0xFBF, 1, ACCESS
601:                       client->mcmd = G_ID;
1AD34  0EFA     MOVLW 0xFA
1AD36  C4E3     MOVFF PLUSW1, FSR2
1AD38  F4D9     NOP
1AD3A  0EFB     MOVLW 0xFB
1AD3C  C4E3     MOVFF PLUSW1, FSR2H
1AD3E  F4DA     NOP
1AD40  6ADF     CLRF 0xFDF, ACCESS
602:                       M.to_error++;
1AD42  0E01     MOVLW 0x1
1AD44  0106     MOVLB 0x6
1AD46  27ED     ADDWF DMAnDPTRH, F, BANKED
1AD48  0E00     MOVLW 0x0
1AD4A  23EE     ADDWFC DMAnDSZ, F, BANKED
1AD4C  23EF     ADDWFC DMAnDSZH, F, BANKED
1AD4E  23F0     ADDWFC DMAnDSA, F, BANKED
603:                       M.error++;
1AD50  4BE3     INFSNZ 0xE3, F, BANKED
1AD52  2BE4     INCF 0xE4, F, BANKED
604:                       if (client->data_ok) {
1AD54  0EFA     MOVLW 0xFA
1AD56  0061     MOVFFL PLUSW1, wtemp5
1AD58  F38C     NOP
1AD5A  F50B     NOP
1AD5C  0EFB     MOVLW 0xFB
1AD5E  0061     MOVFFL PLUSW1, 0x50C
1AD60  F38C     NOP
1AD62  F50C     NOP
1AD64  0E09     MOVLW 0x9
1AD66  240B     ADDWF 0xB, W, ACCESS
1AD68  6ED9     MOVWF 0xFD9, ACCESS
1AD6A  0E00     MOVLW 0x0
1AD6C  200C     ADDWFC 0xC, W, ACCESS
1AD6E  6EDA     MOVWF __end_of_UART2_tx_vect_isr, ACCESS
605:                       }
606:                   }
607:               }
608:           #endif
609:               return *cstate;
610:           }
1AD70  0EF3     MOVLW 0xF3
1AD70  0EF3     MOVLW 0xF3
1AD70  0EF3     MOVLW 0xF3
1AD70  0EF3     MOVLW 0xF3
1AD70  0EF3     MOVLW 0xF3
611:           
612:           static bool modbus_read_id_check(C_data * client, bool* cstate, const uint16_t rec_length) {
19A2C  52E6     MOVF 0xFE6, F, ACCESS
19A2E  52E6     MOVF 0xFE6, F, ACCESS
19A30  52E6     MOVF 0xFE6, F, ACCESS
19A32  52E6     MOVF 0xFE6, F, ACCESS
613:               uint16_t c_crc, c_crc_rec;
614:           
615:           #ifdef	MB_EM540
616:               client->req_length = rec_length;
19A34  50E1     MOVF 0xFE1, W, ACCESS
19A36  0FF6     ADDLW 0xF6
19A38  6ED9     MOVWF 0xFD9, ACCESS
19A3A  50E2     MOVF 0xFE2, W, ACCESS
19A3C  6EDA     MOVWF __end_of_UART2_tx_vect_isr, ACCESS
19A3E  0EFF     MOVLW 0xFF
19A40  22DA     ADDWFC __end_of_UART2_tx_vect_isr, F, ACCESS
19A42  0EFA     MOVLW 0xFA
19A44  0061     MOVFFL PLUSW1, wtemp5
19A46  F38C     NOP
19A48  F50B     NOP
19A4A  0EFB     MOVLW 0xFB
19A4C  0061     MOVFFL PLUSW1, 0x50C
19A4E  F38C     NOP
19A50  F50C     NOP
19A52  0E03     MOVLW 0x3
19A54  240B     ADDWF 0xB, W, ACCESS
19A56  6EE9     MOVWF 0xFE9, ACCESS
19A58  0E00     MOVLW 0x0
19A5A  200C     ADDWFC 0xC, W, ACCESS
19A5C  6EEA     MOVWF 0xFEA, ACCESS
19A5E  C4DE     MOVFF POSTINC2, POSTINC0
19A60  F4EE     NOP
19A62  C4DD     MOVFF POSTDEC2, POSTDEC0
19A64  F4ED     NOP
617:               if (DBUG_R((M.recv_count >= client->req_length) && (cc_buffer[0] == MADDR) && (cc_buffer[1] == READ_HOLDING_REGISTERS))) {
19A66  0EFA     MOVLW 0xFA
19A68  0061     MOVFFL PLUSW1, wtemp5
19A6A  F38C     NOP
19A6C  F50B     NOP
19A6E  0EFB     MOVLW 0xFB
19A70  0061     MOVFFL PLUSW1, 0x50C
19A72  F38C     NOP
19A74  F50C     NOP
19A76  0E03     MOVLW 0x3
19A78  240B     ADDWF 0xB, W, ACCESS
19A7A  6ED9     MOVWF 0xFD9, ACCESS
19A7C  0E00     MOVLW 0x0
19A7E  200C     ADDWFC 0xC, W, ACCESS
19A80  6EDA     MOVWF __end_of_UART2_tx_vect_isr, ACCESS
19A82  0106     MOVLB 0x6
19A84  51E1     MOVF 0xE1, W, BANKED
19A86  6E0B     MOVWF 0xB, ACCESS
19A88  6A0C     CLRF 0xC, ACCESS
19A8A  50DE     MOVF 0xFDE, W, ACCESS
19A8C  5C0B     SUBWF 0xB, W, ACCESS
19A8E  50DE     MOVF 0xFDE, W, ACCESS
19A90  580C     SUBWFB 0xC, W, ACCESS
19A92  A0D8     BTFSS 0xFD8, 0, ACCESS
19A94  D0FF     BRA 0x9C94
19A96  010C     MOVLB 0xC
19A98  0500     DECF __smallconst, W, BANKED
19A9A  A4D8     BTFSS 0xFD8, 2, ACCESS
19A9C  D0FB     BRA 0x9C94
19A9E  0E03     MOVLW 0x3
19AA0  1901     XORWF __ptext283, W, BANKED
19AA2  A4D8     BTFSS 0xFD8, 2, ACCESS
19AA4  D0F7     BRA 0x9C94
618:                   c_crc = crc16(cc_buffer, client->req_length - 2);
19AA6  0EFA     MOVLW 0xFA
19AA8  0061     MOVFFL PLUSW1, wtemp5
19AAA  F38C     NOP
19AAC  F50B     NOP
19AAE  0EFB     MOVLW 0xFB
19AB0  0061     MOVFFL PLUSW1, 0x50C
19AB2  F38C     NOP
19AB4  F50C     NOP
19AB6  0E03     MOVLW 0x3
19AB8  240B     ADDWF 0xB, W, ACCESS
19ABA  6ED9     MOVWF 0xFD9, ACCESS
19ABC  0E00     MOVLW 0x0
19ABE  200C     ADDWFC 0xC, W, ACCESS
19AC0  6EDA     MOVWF __end_of_UART2_tx_vect_isr, ACCESS
19AC2  0061     MOVFFL POSTINC2, wtemp5
19AC4  F378     NOP
19AC6  F50B     NOP
19AC8  0061     MOVFFL POSTDEC2, 0x50C
19ACA  F374     NOP
19ACC  F50C     NOP
19ACE  0EFE     MOVLW 0xFE
19AD0  240B     ADDWF 0xB, W, ACCESS
19AD2  6E09     MOVWF 0x9, ACCESS
19AD4  0EFF     MOVLW 0xFF
19AD6  200C     ADDWFC 0xC, W, ACCESS
19AD8  6E0A     MOVWF 0xA, ACCESS
19ADA  0061     MOVFFL ltemp2, POSTINC1
19ADC  F424     NOP
19ADE  F4E6     NOP
19AE0  0061     MOVFFL ttemp3, POSTINC1
19AE2  F428     NOP
19AE4  F4E6     NOP
19AE6  0E00     MOVLW 0x0
19AE8  6EE6     MOVWF 0xFE6, ACCESS
19AEA  0E0C     MOVLW 0xC
19AEC  6EE6     MOVWF 0xFE6, ACCESS
19AEE  EC35     CALL 0x1DE6A, 0
19AF0  F0EF     NOP
19AF2  0EFE     MOVLW 0xFE
19AF4  0061     MOVFFL ltemp0, PLUSW1
19AF6  F404     NOP
19AF8  F4E3     NOP
19AFA  0EFF     MOVLW 0xFF
19AFC  0061     MOVFFL ttemp5, PLUSW1
19AFE  F408     NOP
19B00  F4E3     NOP
619:                   c_crc_rec = crc16_receive(client);
19B02  0EFA     MOVLW 0xFA
19B04  C4E3     MOVFF PLUSW1, POSTINC1
19B06  F4E6     NOP
19B08  C4E3     MOVFF PLUSW1, POSTINC1
19B0A  F4E6     NOP
19B0C  EC0F     CALL 0x1FE1E, 0
19B0E  F0FF     NOP
19B10  0EFC     MOVLW 0xFC
19B12  0061     MOVFFL ltemp0, PLUSW1
19B14  F404     NOP
19B16  F4E3     NOP
19B18  0EFD     MOVLW 0xFD
19B1A  0061     MOVFFL ttemp5, PLUSW1
19B1C  F408     NOP
19B1E  F4E3     NOP
620:                   if ((DBUG_R c_crc == c_crc_rec) && (cc_buffer[3] == MB_EM540_ID_H) && (cc_buffer[4] == MB_EM540_ID_L)) {
19B20  50E1     MOVF 0xFE1, W, ACCESS
19B22  0FFE     ADDLW 0xFE
19B24  6ED9     MOVWF 0xFD9, ACCESS
19B26  50E2     MOVF 0xFE2, W, ACCESS
19B28  6EDA     MOVWF __end_of_UART2_tx_vect_isr, ACCESS
19B2A  0EFF     MOVLW 0xFF
19B2C  22DA     ADDWFC __end_of_UART2_tx_vect_isr, F, ACCESS
19B2E  0EFC     MOVLW 0xFC
19B30  50E3     MOVF 0xFE3, W, ACCESS
19B32  18DE     XORWF 0xFDE, W, ACCESS
19B34  E128     BNZ 0x9B86
19B36  0EFD     MOVLW 0xFD
19B38  50E3     MOVF 0xFE3, W, ACCESS
19B3A  18DE     XORWF 0xFDE, W, ACCESS
19B3C  A4D8     BTFSS 0xFD8, 2, ACCESS
19B3E  D023     BRA 0x9B86
19B40  0E06     MOVLW 0x6
19B42  010C     MOVLB 0xC
19B44  1903     XORWF __activetblptr, W, BANKED
19B46  A4D8     BTFSS 0xFD8, 2, ACCESS
19B48  D01E     BRA 0x9B86
19B4A  0EE0     MOVLW 0xE0
19B4C  1904     XORWF __activetblptr, W, BANKED
19B4E  A4D8     BTFSS 0xFD8, 2, ACCESS
19B50  D01A     BRA 0x9B86
621:                       MM_ERROR_C;
19B52  92BF     BCF 0xFBF, 1, ACCESS
622:                       client->id_ok = true;
19B54  0EFA     MOVLW 0xFA
19B56  0061     MOVFFL PLUSW1, wtemp5
19B58  F38C     NOP
19B5A  F50B     NOP
19B5C  0EFB     MOVLW 0xFB
19B5E  0061     MOVFFL PLUSW1, 0x50C
19B60  F38C     NOP
19B62  F50C     NOP
19B64  0E06     MOVLW 0x6
19B66  240B     ADDWF 0xB, W, ACCESS
19B68  6ED9     MOVWF 0xFD9, ACCESS
19B6A  0E00     MOVLW 0x0
19B6C  200C     ADDWFC 0xC, W, ACCESS
19B6E  6EDA     MOVWF __end_of_UART2_tx_vect_isr, ACCESS
19B70  0E01     MOVLW 0x1
19B72  6EDF     MOVWF 0xFDF, ACCESS
623:                       *cstate = true;
19B74  0EF8     MOVLW 0xF8
19B76  C4E3     MOVFF PLUSW1, FSR2
19B78  F4D9     NOP
19B7A  0EF9     MOVLW 0xF9
19B7C  C4E3     MOVFF PLUSW1, FSR2H
19B7E  F4DA     NOP
19B80  0E01     MOVLW 0x1
19B82  6EDF     MOVWF 0xFDF, ACCESS
624:                   } else {
19B84  D07D     BRA 0x9C80
625:                       MM_ERROR_S;
19B86  82BF     BSF 0xFBF, 1, ACCESS
626:                       *cstate = false;
19B88  0EF8     MOVLW 0xF8
19B8A  C4E3     MOVFF PLUSW1, FSR2
19B8C  F4D9     NOP
19B8E  0EF9     MOVLW 0xF9
19B90  C4E3     MOVFF PLUSW1, FSR2H
19B92  F4DA     NOP
19B94  6ADF     CLRF 0xFDF, ACCESS
627:                       client->id_ok = false;
19B96  0EFA     MOVLW 0xFA
19B98  0061     MOVFFL PLUSW1, wtemp5
19B9A  F38C     NOP
19B9C  F50B     NOP
19B9E  0EFB     MOVLW 0xFB
19BA0  0061     MOVFFL PLUSW1, 0x50C
19BA2  F38C     NOP
19BA4  F50C     NOP
19BA6  0E06     MOVLW 0x6
19BA8  240B     ADDWF 0xB, W, ACCESS
19BAA  6ED9     MOVWF 0xFD9, ACCESS
19BAC  0E00     MOVLW 0x0
19BAE  200C     ADDWFC 0xC, W, ACCESS
19BB0  6EDA     MOVWF __end_of_UART2_tx_vect_isr, ACCESS
19BB2  6ADF     CLRF 0xFDF, ACCESS
628:                       client->config_ok = false;
19BB4  0EFA     MOVLW 0xFA
19BB6  0061     MOVFFL PLUSW1, wtemp5
19BB8  F38C     NOP
19BBA  F50B     NOP
19BBC  0EFB     MOVLW 0xFB
19BBE  0061     MOVFFL PLUSW1, 0x50C
19BC0  F38C     NOP
19BC2  F50C     NOP
19BC4  0E08     MOVLW 0x8
19BC6  240B     ADDWF 0xB, W, ACCESS
19BC8  6ED9     MOVWF 0xFD9, ACCESS
19BCA  0E00     MOVLW 0x0
19BCC  200C     ADDWFC 0xC, W, ACCESS
19BCE  6EDA     MOVWF __end_of_UART2_tx_vect_isr, ACCESS
19BD0  6ADF     CLRF 0xFDF, ACCESS
629:                       client->passwd_ok = false;
19BD2  0EFA     MOVLW 0xFA
19BD4  0061     MOVFFL PLUSW1, wtemp5
19BD6  F38C     NOP
19BD8  F50B     NOP
19BDA  0EFB     MOVLW 0xFB
19BDC  0061     MOVFFL PLUSW1, 0x50C
19BDE  F38C     NOP
19BE0  F50C     NOP
19BE2  0E07     MOVLW 0x7
19BE4  240B     ADDWF 0xB, W, ACCESS
19BE6  6ED9     MOVWF 0xFD9, ACCESS
19BE8  0E00     MOVLW 0x0
19BEA  200C     ADDWFC 0xC, W, ACCESS
19BEC  6EDA     MOVWF __end_of_UART2_tx_vect_isr, ACCESS
19BEE  6ADF     CLRF 0xFDF, ACCESS
630:                       client->data_ok = false;
19BF0  0EFA     MOVLW 0xFA
19BF2  0061     MOVFFL PLUSW1, wtemp5
19BF4  F38C     NOP
19BF6  F50B     NOP
19BF8  0EFB     MOVLW 0xFB
19BFA  0061     MOVFFL PLUSW1, 0x50C
19BFC  F38C     NOP
19BFE  F50C     NOP
19C00  0E09     MOVLW 0x9
19C02  240B     ADDWF 0xB, W, ACCESS
19C04  6ED9     MOVWF 0xFD9, ACCESS
19C06  0E00     MOVLW 0x0
19C08  200C     ADDWFC 0xC, W, ACCESS
19C0A  6EDA     MOVWF __end_of_UART2_tx_vect_isr, ACCESS
19C0C  6ADF     CLRF 0xFDF, ACCESS
631:                       client->light_ok = false;
19C0E  0EFA     MOVLW 0xFA
19C10  0061     MOVFFL PLUSW1, wtemp5
19C12  F38C     NOP
19C14  F50B     NOP
19C16  0EFB     MOVLW 0xFB
19C18  0061     MOVFFL PLUSW1, 0x50C
19C1A  F38C     NOP
19C1C  F50C     NOP
19C1E  0E0A     MOVLW 0xA
19C20  240B     ADDWF 0xB, W, ACCESS
19C22  6ED9     MOVWF 0xFD9, ACCESS
19C24  0E00     MOVLW 0x0
19C26  200C     ADDWFC 0xC, W, ACCESS
19C28  6EDA     MOVWF __end_of_UART2_tx_vect_isr, ACCESS
19C2A  6ADF     CLRF 0xFDF, ACCESS
632:                       client->version_ok = false;
19C2C  0EFA     MOVLW 0xFA
19C2E  0061     MOVFFL PLUSW1, wtemp5
19C30  F38C     NOP
19C32  F50B     NOP
19C34  0EFB     MOVLW 0xFB
19C36  0061     MOVFFL PLUSW1, 0x50C
19C38  F38C     NOP
19C3A  F50C     NOP
19C3C  0E0C     MOVLW 0xC
19C3E  240B     ADDWF 0xB, W, ACCESS
19C40  6ED9     MOVWF 0xFD9, ACCESS
19C42  0E00     MOVLW 0x0
19C44  200C     ADDWFC 0xC, W, ACCESS
19C46  6EDA     MOVWF __end_of_UART2_tx_vect_isr, ACCESS
19C48  6ADF     CLRF 0xFDF, ACCESS
633:                       client->serial_ok = false;
19C4A  0EFA     MOVLW 0xFA
19C4C  0061     MOVFFL PLUSW1, wtemp5
19C4E  F38C     NOP
19C50  F50B     NOP
19C52  0EFB     MOVLW 0xFB
19C54  0061     MOVFFL PLUSW1, 0x50C
19C56  F38C     NOP
19C58  F50C     NOP
19C5A  0E0B     MOVLW 0xB
19C5C  240B     ADDWF 0xB, W, ACCESS
19C5E  6ED9     MOVWF 0xFD9, ACCESS
19C60  0E00     MOVLW 0x0
19C62  200C     ADDWFC 0xC, W, ACCESS
19C64  6EDA     MOVWF __end_of_UART2_tx_vect_isr, ACCESS
19C66  6ADF     CLRF 0xFDF, ACCESS
634:                       log_crc_error(c_crc, c_crc_rec);
19C68  0EFC     MOVLW 0xFC
19C6A  C4E3     MOVFF PLUSW1, POSTINC1
19C6C  F4E6     NOP
19C6E  C4E3     MOVFF PLUSW1, POSTINC1
19C70  F4E6     NOP
19C72  0EFC     MOVLW 0xFC
19C74  C4E3     MOVFF PLUSW1, POSTINC1
19C76  F4E6     NOP
19C78  C4E3     MOVFF PLUSW1, POSTINC1
19C7A  F4E6     NOP
19C7C  EC11     CALL 0x1C22, 0
19C7E  F00E     NOP
635:                   }
636:                   client->cstate = CLEAR;
19C80  0EFA     MOVLW 0xFA
19C82  0061     MOVFFL PLUSW1, wtemp5
19C84  F38C     NOP
19C86  F50B     NOP
19C88  0EFB     MOVLW 0xFB
19C8A  0061     MOVFFL PLUSW1, 0x50C
19C8C  F38C     NOP
19C8E  F50C     NOP
19C90  0E01     MOVLW 0x1
19C92  D096     BRA 0x9DC0
637:               } else {
638:                   if (get_500hz(false) >= RDELAY) {
19C94  0E00     MOVLW 0x0
19C96  6EE6     MOVWF 0xFE6, ACCESS
19C98  EC51     CALL 0x1AA2, 0
19C9A  F00D     NOP
19C9C  5004     MOVF __activetblptr, W, ACCESS
19C9E  1003     IORWF __activetblptr, W, ACCESS
19CA0  1002     IORWF ___rparam_used, W, ACCESS
19CA2  E104     BNZ 0x9CAC
19CA4  0EC8     MOVLW 0xC8
19CA6  5C01     SUBWF __ptext283, W, ACCESS
19CA8  A0D8     BTFSS 0xFD8, 0, ACCESS
19CAA  D090     BRA 0x9DCC
639:                       DB0_SetLow();
19CAC  92C1     BCF 0xFC1, 1, ACCESS
640:                       client->cstate = CLEAR;
19CAE  0EFA     MOVLW 0xFA
19CB0  0061     MOVFFL PLUSW1, wtemp5
19CB2  F38C     NOP
19CB4  F50B     NOP
19CB6  0EFB     MOVLW 0xFB
19CB8  0061     MOVFFL PLUSW1, 0x50C
19CBA  F38C     NOP
19CBC  F50C     NOP
19CBE  0E01     MOVLW 0x1
19CC0  240B     ADDWF 0xB, W, ACCESS
19CC2  6ED9     MOVWF 0xFD9, ACCESS
19CC4  0E00     MOVLW 0x0
19CC6  200C     ADDWFC 0xC, W, ACCESS
19CC8  6EDA     MOVWF __end_of_UART2_tx_vect_isr, ACCESS
19CCA  6ADF     CLRF 0xFDF, ACCESS
641:                       client->mcmd = G_ID;
19CCC  0EFA     MOVLW 0xFA
19CCE  C4E3     MOVFF PLUSW1, FSR2
19CD0  F4D9     NOP
19CD2  0EFB     MOVLW 0xFB
19CD4  C4E3     MOVFF PLUSW1, FSR2H
19CD6  F4DA     NOP
19CD8  6ADF     CLRF 0xFDF, ACCESS
642:                       M.to_error++;
19CDA  0E01     MOVLW 0x1
19CDC  0106     MOVLB 0x6
19CDE  27ED     ADDWF DMAnDPTRH, F, BANKED
19CE0  0E00     MOVLW 0x0
19CE2  23EE     ADDWFC DMAnDSZ, F, BANKED
19CE4  23EF     ADDWFC DMAnDSZH, F, BANKED
19CE6  23F0     ADDWFC DMAnDSA, F, BANKED
643:                       M.error++;
19CE8  4BE3     INFSNZ 0xE3, F, BANKED
19CEA  2BE4     INCF 0xE4, F, BANKED
644:                       client->id_ok = false;
19CEC  0EFA     MOVLW 0xFA
19CEE  0061     MOVFFL PLUSW1, wtemp5
19CF0  F38C     NOP
19CF2  F50B     NOP
19CF4  0EFB     MOVLW 0xFB
19CF6  0061     MOVFFL PLUSW1, 0x50C
19CF8  F38C     NOP
19CFA  F50C     NOP
19CFC  0E06     MOVLW 0x6
19CFE  240B     ADDWF 0xB, W, ACCESS
19D00  6ED9     MOVWF 0xFD9, ACCESS
19D02  0E00     MOVLW 0x0
19D04  200C     ADDWFC 0xC, W, ACCESS
19D06  6EDA     MOVWF __end_of_UART2_tx_vect_isr, ACCESS
19D08  6ADF     CLRF 0xFDF, ACCESS
645:                       *cstate = false;
19D0A  0EF8     MOVLW 0xF8
19D0C  C4E3     MOVFF PLUSW1, FSR2
19D0E  F4D9     NOP
19D10  0EF9     MOVLW 0xF9
19D12  C4E3     MOVFF PLUSW1, FSR2H
19D14  F4DA     NOP
19D16  6ADF     CLRF 0xFDF, ACCESS
646:                       client->config_ok = false;
19D18  0EFA     MOVLW 0xFA
19D1A  0061     MOVFFL PLUSW1, wtemp5
19D1C  F38C     NOP
19D1E  F50B     NOP
19D20  0EFB     MOVLW 0xFB
19D22  0061     MOVFFL PLUSW1, 0x50C
19D24  F38C     NOP
19D26  F50C     NOP
19D28  0E08     MOVLW 0x8
19D2A  240B     ADDWF 0xB, W, ACCESS
19D2C  6ED9     MOVWF 0xFD9, ACCESS
19D2E  0E00     MOVLW 0x0
19D30  200C     ADDWFC 0xC, W, ACCESS
19D32  6EDA     MOVWF __end_of_UART2_tx_vect_isr, ACCESS
19D34  6ADF     CLRF 0xFDF, ACCESS
647:                       client->passwd_ok = false;
19D36  0EFA     MOVLW 0xFA
19D38  0061     MOVFFL PLUSW1, wtemp5
19D3A  F38C     NOP
19D3C  F50B     NOP
19D3E  0EFB     MOVLW 0xFB
19D40  0061     MOVFFL PLUSW1, 0x50C
19D42  F38C     NOP
19D44  F50C     NOP
19D46  0E07     MOVLW 0x7
19D48  240B     ADDWF 0xB, W, ACCESS
19D4A  6ED9     MOVWF 0xFD9, ACCESS
19D4C  0E00     MOVLW 0x0
19D4E  200C     ADDWFC 0xC, W, ACCESS
19D50  6EDA     MOVWF __end_of_UART2_tx_vect_isr, ACCESS
19D52  6ADF     CLRF 0xFDF, ACCESS
648:                       client->data_ok = false;
19D54  0EFA     MOVLW 0xFA
19D56  0061     MOVFFL PLUSW1, wtemp5
19D58  F38C     NOP
19D5A  F50B     NOP
19D5C  0EFB     MOVLW 0xFB
19D5E  0061     MOVFFL PLUSW1, 0x50C
19D60  F38C     NOP
19D62  F50C     NOP
19D64  0E09     MOVLW 0x9
19D66  240B     ADDWF 0xB, W, ACCESS
19D68  6ED9     MOVWF 0xFD9, ACCESS
19D6A  0E00     MOVLW 0x0
19D6C  200C     ADDWFC 0xC, W, ACCESS
19D6E  6EDA     MOVWF __end_of_UART2_tx_vect_isr, ACCESS
19D70  6ADF     CLRF 0xFDF, ACCESS
649:                       client->light_ok = false;
19D72  0EFA     MOVLW 0xFA
19D74  0061     MOVFFL PLUSW1, wtemp5
19D76  F38C     NOP
19D78  F50B     NOP
19D7A  0EFB     MOVLW 0xFB
19D7C  0061     MOVFFL PLUSW1, 0x50C
19D7E  F38C     NOP
19D80  F50C     NOP
19D82  0E0A     MOVLW 0xA
19D84  240B     ADDWF 0xB, W, ACCESS
19D86  6ED9     MOVWF 0xFD9, ACCESS
19D88  0E00     MOVLW 0x0
19D8A  200C     ADDWFC 0xC, W, ACCESS
19D8C  6EDA     MOVWF __end_of_UART2_tx_vect_isr, ACCESS
19D8E  6ADF     CLRF 0xFDF, ACCESS
650:                       client->version_ok = false;
19D90  0EFA     MOVLW 0xFA
19D92  0061     MOVFFL PLUSW1, wtemp5
19D94  F38C     NOP
19D96  F50B     NOP
19D98  0EFB     MOVLW 0xFB
19D9A  0061     MOVFFL PLUSW1, 0x50C
19D9C  F38C     NOP
19D9E  F50C     NOP
19DA0  0E0C     MOVLW 0xC
19DA2  240B     ADDWF 0xB, W, ACCESS
19DA4  6ED9     MOVWF 0xFD9, ACCESS
19DA6  0E00     MOVLW 0x0
19DA8  200C     ADDWFC 0xC, W, ACCESS
19DAA  6EDA     MOVWF __end_of_UART2_tx_vect_isr, ACCESS
19DAC  6ADF     CLRF 0xFDF, ACCESS
651:                       client->serial_ok = false;
19DAE  0EFA     MOVLW 0xFA
19DB0  0061     MOVFFL PLUSW1, wtemp5
19DB2  F38C     NOP
19DB4  F50B     NOP
19DB6  0EFB     MOVLW 0xFB
19DB8  0061     MOVFFL PLUSW1, 0x50C
19DBA  F38C     NOP
19DBC  F50C     NOP
19DBE  0E0B     MOVLW 0xB
19DC0  240B     ADDWF 0xB, W, ACCESS
19DC2  6ED9     MOVWF 0xFD9, ACCESS
19DC4  0E00     MOVLW 0x0
19DC6  200C     ADDWFC 0xC, W, ACCESS
19DC8  6EDA     MOVWF __end_of_UART2_tx_vect_isr, ACCESS
19DCA  6ADF     CLRF 0xFDF, ACCESS
652:                   }
653:               }
654:           #endif
655:               return *cstate;
656:           }
19DCC  0EF6     MOVLW 0xF6
19DCC  0EF6     MOVLW 0xF6
19DCC  0EF6     MOVLW 0xF6
19DCC  0EF6     MOVLW 0xF6
19DCC  0EF6     MOVLW 0xF6
657:           
658:           static void em_data_handler(void) {
1A7BA  0E68     MOVLW 0x68
659:               /*
660:                * move from receive buffer to data structure and munge the data into the correct local formats from MODBUS client
661:                */
662:               memcpy((void*) &em, (void*) &cc_buffer[3], sizeof (em));
1A7BC  6EE6     MOVWF 0xFE6, ACCESS
1A7BE  0E00     MOVLW 0x0
1A7C0  6EE6     MOVWF 0xFE6, ACCESS
1A7C2  0E03     MOVLW 0x3
1A7C4  6EE6     MOVWF 0xFE6, ACCESS
1A7C6  0E0C     MOVLW 0xC
1A7C8  6EE6     MOVWF 0xFE6, ACCESS
1A7CA  0E67     MOVLW 0x67
1A7CC  6EE6     MOVWF 0xFE6, ACCESS
1A7CE  0E06     MOVLW 0x6
1A7D0  6EE6     MOVWF 0xFE6, ACCESS
1A7D2  EC81     CALL 0x1E502, 0
1A7D4  F0F2     NOP
663:               em.vl1l2 = mb32_swap(em.vl1l2);
1A7D6  C673     MOVFF 0x673, POSTINC1
1A7D8  F4E6     NOP
1A7DA  C674     MOVFF 0x674, POSTINC1
1A7DC  F4E6     NOP
1A7DE  C675     MOVFF 0x675, POSTINC1
1A7E0  F4E6     NOP
1A7E2  C676     MOVFF 0x676, POSTINC1
1A7E4  F4E6     NOP
1A7E6  EC9D     CALL 0x1F13A, 0
1A7E8  F0F8     NOP
1A7EA  0061     MOVFFL ltemp0, 0x673
1A7EC  F404     NOP
1A7EE  F673     NOP
1A7F0  0061     MOVFFL ttemp5, 0x674
1A7F2  F408     NOP
1A7F4  F674     NOP
1A7F6  0061     MOVFFL wtemp1, 0x675
1A7F8  F40C     NOP
1A7FA  F675     NOP
1A7FC  0061     MOVFFL ttemp1, 0x676
1A7FE  F410     NOP
1A800  F676     NOP
664:               em.vl2l3 = mb32_swap(em.vl2l3);
1A802  C677     MOVFF 0x677, POSTINC1
1A804  F4E6     NOP
1A806  C678     MOVFF 0x678, POSTINC1
1A808  F4E6     NOP
1A80A  C679     MOVFF 0x679, POSTINC1
1A80C  F4E6     NOP
1A80E  C67A     MOVFF 0x67A, POSTINC1
1A810  F4E6     NOP
1A812  EC9D     CALL 0x1F13A, 0
1A814  F0F8     NOP
1A816  0061     MOVFFL ltemp0, 0x677
1A818  F404     NOP
1A81A  F677     NOP
1A81C  0061     MOVFFL ttemp5, 0x678
1A81E  F408     NOP
1A820  F678     NOP
1A822  0061     MOVFFL wtemp1, 0x679
1A824  F40C     NOP
1A826  F679     NOP
1A828  0061     MOVFFL ttemp1, 0x67A
1A82A  F410     NOP
1A82C  F67A     NOP
665:               em.vl3l1 = mb32_swap(em.vl3l1);
1A82E  C67B     MOVFF 0x67B, POSTINC1
1A830  F4E6     NOP
1A832  C67C     MOVFF 0x67C, POSTINC1
1A834  F4E6     NOP
1A836  C67D     MOVFF 0x67D, POSTINC1
1A838  F4E6     NOP
1A83A  C67E     MOVFF 0x67E, POSTINC1
1A83C  F4E6     NOP
1A83E  EC9D     CALL 0x1F13A, 0
1A840  F0F8     NOP
1A842  0061     MOVFFL ltemp0, 0x67B
1A844  F404     NOP
1A846  F67B     NOP
1A848  0061     MOVFFL ttemp5, 0x67C
1A84A  F408     NOP
1A84C  F67C     NOP
1A84E  0061     MOVFFL wtemp1, 0x67D
1A850  F40C     NOP
1A852  F67D     NOP
1A854  0061     MOVFFL ttemp1, 0x67E
1A856  F410     NOP
1A858  F67E     NOP
666:               em.al1 = mb32_swap(em.al1);
1A85A  C67F     MOVFF 0x67F, POSTINC1
1A85C  F4E6     NOP
1A85E  C680     MOVFF 0x680, POSTINC1
1A860  F4E6     NOP
1A862  C681     MOVFF 0x681, POSTINC1
1A864  F4E6     NOP
1A866  C682     MOVFF 0x682, POSTINC1
1A868  F4E6     NOP
1A86A  EC9D     CALL 0x1F13A, 0
1A86C  F0F8     NOP
1A86E  0061     MOVFFL ltemp0, 0x67F
1A870  F404     NOP
1A872  F67F     NOP
1A874  0061     MOVFFL ttemp5, 0x680
1A876  F408     NOP
1A878  F680     NOP
1A87A  0061     MOVFFL wtemp1, 0x681
1A87C  F40C     NOP
1A87E  F681     NOP
1A880  0061     MOVFFL ttemp1, 0x682
1A882  F410     NOP
1A884  F682     NOP
667:               em.al2 = mb32_swap(em.al2);
1A886  C683     MOVFF 0x683, POSTINC1
1A888  F4E6     NOP
1A88A  C684     MOVFF 0x684, POSTINC1
1A88C  F4E6     NOP
1A88E  C685     MOVFF 0x685, POSTINC1
1A890  F4E6     NOP
1A892  C686     MOVFF 0x686, POSTINC1
1A894  F4E6     NOP
1A896  EC9D     CALL 0x1F13A, 0
1A898  F0F8     NOP
1A89A  0061     MOVFFL ltemp0, 0x683
1A89C  F404     NOP
1A89E  F683     NOP
1A8A0  0061     MOVFFL ttemp5, 0x684
1A8A2  F408     NOP
1A8A4  F684     NOP
1A8A6  0061     MOVFFL wtemp1, 0x685
1A8A8  F40C     NOP
1A8AA  F685     NOP
1A8AC  0061     MOVFFL ttemp1, 0x686
1A8AE  F410     NOP
1A8B0  F686     NOP
668:               em.al3 = mb32_swap(em.al3);
1A8B2  C687     MOVFF 0x687, POSTINC1
1A8B4  F4E6     NOP
1A8B6  C688     MOVFF 0x688, POSTINC1
1A8B8  F4E6     NOP
1A8BA  C689     MOVFF 0x689, POSTINC1
1A8BC  F4E6     NOP
1A8BE  C68A     MOVFF 0x68A, POSTINC1
1A8C0  F4E6     NOP
1A8C2  EC9D     CALL 0x1F13A, 0
1A8C4  F0F8     NOP
1A8C6  0061     MOVFFL ltemp0, 0x687
1A8C8  F404     NOP
1A8CA  F687     NOP
1A8CC  0061     MOVFFL ttemp5, 0x688
1A8CE  F408     NOP
1A8D0  F688     NOP
1A8D2  0061     MOVFFL wtemp1, 0x689
1A8D4  F40C     NOP
1A8D6  F689     NOP
1A8D8  0061     MOVFFL ttemp1, 0x68A
1A8DA  F410     NOP
1A8DC  F68A     NOP
669:               em.wl1 = mb32_swap(em.wl1);
1A8DE  C68B     MOVFF 0x68B, POSTINC1
1A8E0  F4E6     NOP
1A8E2  C68C     MOVFF 0x68C, POSTINC1
1A8E4  F4E6     NOP
1A8E6  C68D     MOVFF 0x68D, POSTINC1
1A8E8  F4E6     NOP
1A8EA  C68E     MOVFF 0x68E, POSTINC1
1A8EC  F4E6     NOP
1A8EE  EC9D     CALL 0x1F13A, 0
1A8F0  F0F8     NOP
1A8F2  0061     MOVFFL ltemp0, 0x68B
1A8F4  F404     NOP
1A8F6  F68B     NOP
1A8F8  0061     MOVFFL ttemp5, 0x68C
1A8FA  F408     NOP
1A8FC  F68C     NOP
1A8FE  0061     MOVFFL wtemp1, 0x68D
1A900  F40C     NOP
1A902  F68D     NOP
1A904  0061     MOVFFL ttemp1, 0x68E
1A906  F410     NOP
1A908  F68E     NOP
670:               em.wl2 = mb32_swap(em.wl2);
1A90A  C68F     MOVFF 0x68F, POSTINC1
1A90C  F4E6     NOP
1A90E  C690     MOVFF 0x690, POSTINC1
1A910  F4E6     NOP
1A912  C691     MOVFF 0x691, POSTINC1
1A914  F4E6     NOP
1A916  C692     MOVFF 0x692, POSTINC1
1A918  F4E6     NOP
1A91A  EC9D     CALL 0x1F13A, 0
1A91C  F0F8     NOP
1A91E  0061     MOVFFL ltemp0, 0x68F
1A920  F404     NOP
1A922  F68F     NOP
1A924  0061     MOVFFL ttemp5, 0x690
1A926  F408     NOP
1A928  F690     NOP
1A92A  0061     MOVFFL wtemp1, 0x691
1A92C  F40C     NOP
1A92E  F691     NOP
1A930  0061     MOVFFL ttemp1, 0x692
1A932  F410     NOP
1A934  F692     NOP
671:               em.wl3 = mb32_swap(em.wl3);
1A936  C693     MOVFF 0x693, POSTINC1
1A938  F4E6     NOP
1A93A  C694     MOVFF 0x694, POSTINC1
1A93C  F4E6     NOP
1A93E  C695     MOVFF 0x695, POSTINC1
1A940  F4E6     NOP
1A942  C696     MOVFF 0x696, POSTINC1
1A944  F4E6     NOP
1A946  EC9D     CALL 0x1F13A, 0
1A948  F0F8     NOP
1A94A  0061     MOVFFL ltemp0, 0x693
1A94C  F404     NOP
1A94E  F693     NOP
1A950  0061     MOVFFL ttemp5, 0x694
1A952  F408     NOP
1A954  F694     NOP
1A956  0061     MOVFFL wtemp1, 0x695
1A958  F40C     NOP
1A95A  F695     NOP
1A95C  0061     MOVFFL ttemp1, 0x696
1A95E  F410     NOP
1A960  F696     NOP
672:               em.val1 = mb32_swap(em.val1);
1A962  C697     MOVFF 0x697, POSTINC1
1A964  F4E6     NOP
1A966  C698     MOVFF 0x698, POSTINC1
1A968  F4E6     NOP
1A96A  C699     MOVFF 0x699, POSTINC1
1A96C  F4E6     NOP
1A96E  C69A     MOVFF 0x69A, POSTINC1
1A970  F4E6     NOP
1A972  EC9D     CALL 0x1F13A, 0
1A974  F0F8     NOP
1A976  0061     MOVFFL ltemp0, 0x697
1A978  F404     NOP
1A97A  F697     NOP
1A97C  0061     MOVFFL ttemp5, 0x698
1A97E  F408     NOP
1A980  F698     NOP
1A982  0061     MOVFFL wtemp1, 0x699
1A984  F40C     NOP
1A986  F699     NOP
1A988  0061     MOVFFL ttemp1, 0x69A
1A98A  F410     NOP
1A98C  F69A     NOP
673:               em.val2 = mb32_swap(em.val2);
1A98E  C69B     MOVFF 0x69B, POSTINC1
1A990  F4E6     NOP
1A992  C69C     MOVFF 0x69C, POSTINC1
1A994  F4E6     NOP
1A996  C69D     MOVFF 0x69D, POSTINC1
1A998  F4E6     NOP
1A99A  C69E     MOVFF 0x69E, POSTINC1
1A99C  F4E6     NOP
1A99E  EC9D     CALL 0x1F13A, 0
1A9A0  F0F8     NOP
1A9A2  0061     MOVFFL ltemp0, 0x69B
1A9A4  F404     NOP
1A9A6  F69B     NOP
1A9A8  0061     MOVFFL ttemp5, 0x69C
1A9AA  F408     NOP
1A9AC  F69C     NOP
1A9AE  0061     MOVFFL wtemp1, 0x69D
1A9B0  F40C     NOP
1A9B2  F69D     NOP
1A9B4  0061     MOVFFL ttemp1, 0x69E
1A9B6  F410     NOP
1A9B8  F69E     NOP
674:               em.val3 = mb32_swap(em.val3);
1A9BA  C69F     MOVFF 0x69F, POSTINC1
1A9BC  F4E6     NOP
1A9BE  C6A0     MOVFF 0x6A0, POSTINC1
1A9C0  F4E6     NOP
1A9C2  C6A1     MOVFF 0x6A1, POSTINC1
1A9C4  F4E6     NOP
1A9C6  C6A2     MOVFF 0x6A2, POSTINC1
1A9C8  F4E6     NOP
1A9CA  EC9D     CALL 0x1F13A, 0
1A9CC  F0F8     NOP
1A9CE  0061     MOVFFL ltemp0, 0x69F
1A9D0  F404     NOP
1A9D2  F69F     NOP
1A9D4  0061     MOVFFL ttemp5, 0x6A0
1A9D6  F408     NOP
1A9D8  F6A0     NOP
1A9DA  0061     MOVFFL wtemp1, 0x6A1
1A9DC  F40C     NOP
1A9DE  F6A1     NOP
1A9E0  0061     MOVFFL ttemp1, 0x6A2
1A9E2  F410     NOP
1A9E4  F6A2     NOP
675:               em.varl1 = mb32_swap(em.varl1);
1A9E6  C6A3     MOVFF 0x6A3, POSTINC1
1A9E8  F4E6     NOP
1A9EA  C6A4     MOVFF 0x6A4, POSTINC1
1A9EC  F4E6     NOP
1A9EE  C6A5     MOVFF 0x6A5, POSTINC1
1A9F0  F4E6     NOP
1A9F2  C6A6     MOVFF 0x6A6, POSTINC1
1A9F4  F4E6     NOP
1A9F6  EC9D     CALL 0x1F13A, 0
1A9F8  F0F8     NOP
1A9FA  0061     MOVFFL ltemp0, 0x6A3
1A9FC  F404     NOP
1A9FE  F6A3     NOP
1AA00  0061     MOVFFL ttemp5, 0x6A4
1AA02  F408     NOP
1AA04  F6A4     NOP
1AA06  0061     MOVFFL wtemp1, 0x6A5
1AA08  F40C     NOP
1AA0A  F6A5     NOP
1AA0C  0061     MOVFFL ttemp1, 0x6A6
1AA0E  F410     NOP
1AA10  F6A6     NOP
676:               em.varl2 = mb32_swap(em.varl2);
1AA12  C6A7     MOVFF 0x6A7, POSTINC1
1AA14  F4E6     NOP
1AA16  C6A8     MOVFF 0x6A8, POSTINC1
1AA18  F4E6     NOP
1AA1A  C6A9     MOVFF 0x6A9, POSTINC1
1AA1C  F4E6     NOP
1AA1E  C6AA     MOVFF 0x6AA, POSTINC1
1AA20  F4E6     NOP
1AA22  EC9D     CALL 0x1F13A, 0
1AA24  F0F8     NOP
1AA26  0061     MOVFFL ltemp0, 0x6A7
1AA28  F404     NOP
1AA2A  F6A7     NOP
1AA2C  0061     MOVFFL ttemp5, 0x6A8
1AA2E  F408     NOP
1AA30  F6A8     NOP
1AA32  0061     MOVFFL wtemp1, 0x6A9
1AA34  F40C     NOP
1AA36  F6A9     NOP
1AA38  0061     MOVFFL ttemp1, 0x6AA
1AA3A  F410     NOP
1AA3C  F6AA     NOP
677:               em.varl3 = mb32_swap(em.varl3);
1AA3E  C6AB     MOVFF 0x6AB, POSTINC1
1AA40  F4E6     NOP
1AA42  C6AC     MOVFF 0x6AC, POSTINC1
1AA44  F4E6     NOP
1AA46  C6AD     MOVFF 0x6AD, POSTINC1
1AA48  F4E6     NOP
1AA4A  C6AE     MOVFF 0x6AE, POSTINC1
1AA4C  F4E6     NOP
1AA4E  EC9D     CALL 0x1F13A, 0
1AA50  F0F8     NOP
1AA52  0061     MOVFFL ltemp0, 0x6AB
1AA54  F404     NOP
1AA56  F6AB     NOP
1AA58  0061     MOVFFL ttemp5, 0x6AC
1AA5A  F408     NOP
1AA5C  F6AC     NOP
1AA5E  0061     MOVFFL wtemp1, 0x6AD
1AA60  F40C     NOP
1AA62  F6AD     NOP
1AA64  0061     MOVFFL ttemp1, 0x6AE
1AA66  F410     NOP
1AA68  F6AE     NOP
678:               em.pfl1 = mb16_swap(em.pfl1);
1AA6A  C6C3     MOVFF 0x6C3, POSTINC1
1AA6C  F4E6     NOP
1AA6E  C6C4     MOVFF 0x6C4, POSTINC1
1AA70  F4E6     NOP
1AA72  ECB9     CALL 0x972, 0
1AA74  F004     NOP
1AA76  0061     MOVFFL ltemp0, 0x6C3
1AA78  F404     NOP
1AA7A  F6C3     NOP
1AA7C  0061     MOVFFL ttemp5, 0x6C4
1AA7E  F408     NOP
1AA80  F6C4     NOP
679:               em.hz = mb16_swap(em.hz);
1AA82  C6CD     MOVFF 0x6CD, POSTINC1
1AA84  F4E6     NOP
1AA86  C6CE     MOVFF 0x6CE, POSTINC1
1AA88  F4E6     NOP
1AA8A  ECB9     CALL 0x972, 0
1AA8C  F004     NOP
1AA8E  0061     MOVFFL ltemp0, 0x6CD
1AA90  F404     NOP
1AA92  F6CD     NOP
1AA94  0061     MOVFFL ttemp5, 0x6CE
1AA96  F408     NOP
1AA98  F6CE     NOP
680:           }
1AA9A  0012     RETURN 0
681:           
682:           static void emt_data_handler(void) {
1400  0E80     MOVLW 0x80
683:               /*
684:                * move from receive buffer to data structure and munge the data into the correct local formats from MODBUS client
685:                */
686:               memcpy((void*) &emt, (void*) &cc_buffer[3], sizeof (emt));
1402  6EE6     MOVWF 0xFE6, ACCESS
1404  0E00     MOVLW 0x0
1406  6EE6     MOVWF 0xFE6, ACCESS
1408  0E03     MOVLW 0x3
140A  6EE6     MOVWF 0xFE6, ACCESS
140C  0E0C     MOVLW 0xC
140E  6EE6     MOVWF 0xFE6, ACCESS
1410  0E00     MOVLW 0x0
1412  6EE6     MOVWF 0xFE6, ACCESS
1414  0E09     MOVLW 0x9
1416  6EE6     MOVWF 0xFE6, ACCESS
1418  EC81     CALL 0x1E502, 0
141A  F0F2     NOP
687:               emt.hz = mb32_swap(emt.hz);
141C  C978     MOVFF 0x978, POSTINC1
141E  F4E6     NOP
1420  C979     MOVFF 0x979, POSTINC1
1422  F4E6     NOP
1424  C97A     MOVFF 0x97A, POSTINC1
1426  F4E6     NOP
1428  C97B     MOVFF 0x97B, POSTINC1
142A  F4E6     NOP
142C  EC9D     CALL 0x1F13A, 0
142E  F0F8     NOP
1430  0061     MOVFFL ltemp0, 0x978
1432  F404     NOP
1434  F978     NOP
1436  0061     MOVFFL ttemp5, 0x979
1438  F408     NOP
143A  F979     NOP
143C  0061     MOVFFL wtemp1, 0x97A
143E  F40C     NOP
1440  F97A     NOP
1442  0061     MOVFFL ttemp1, 0x97B
1444  F410     NOP
1446  F97B     NOP
688:           }
1448  0012     RETURN 0
689:           
690:           static void ems_data_handler(void) {
19BC  0E10     MOVLW 0x10
691:               /*
692:                * move from receive buffer to data structure and munge the data into the correct local formats from MODBUS client
693:                */
694:               memcpy((void*) &ems, (void*) &cc_buffer[3], sizeof (ems));
19BE  6EE6     MOVWF 0xFE6, ACCESS
19C0  0E00     MOVLW 0x0
19C2  6EE6     MOVWF 0xFE6, ACCESS
19C4  0E03     MOVLW 0x3
19C6  6EE6     MOVWF 0xFE6, ACCESS
19C8  0E0C     MOVLW 0xC
19CA  6EE6     MOVWF 0xFE6, ACCESS
19CC  0ECF     MOVLW 0xCF
19CE  6EE6     MOVWF 0xFE6, ACCESS
19D0  0E06     MOVLW 0x6
19D2  6EE6     MOVWF 0xFE6, ACCESS
19D4  EC81     CALL 0x1E502, 0
19D6  F0F2     NOP
695:               ems.serial[13] = 0; // terminate serial string data
19D8  0106     MOVLB 0x6
19DA  6BDC     CLRF CLCnGLS0, BANKED
696:               ems.year = mb16_swap(ems.year);
19DC  C6DD     MOVFF 0x6DD, POSTINC1
19DE  F4E6     NOP
19E0  C6DE     MOVFF 0x6DE, POSTINC1
19E2  F4E6     NOP
19E4  ECB9     CALL 0x972, 0
19E6  F004     NOP
19E8  0061     MOVFFL ltemp0, 0x6DD
19EA  F404     NOP
19EC  F6DD     NOP
19EE  0061     MOVFFL ttemp5, 0x6DE
19F0  F408     NOP
19F2  F6DE     NOP
697:           }
19F4  0012     RETURN 0
698:           
699:           static void emv_data_handler(void) {
1BB6  0E02     MOVLW 0x2
700:               /*
701:                * move from receive buffer to data structure and munge the data into the correct local formats from MODBUS client
702:                */
703:               memcpy((void*) &emv, (void*) &cc_buffer[3], sizeof (emv));
1BB8  6EE6     MOVWF 0xFE6, ACCESS
1BBA  0E00     MOVLW 0x0
1BBC  6EE6     MOVWF 0xFE6, ACCESS
1BBE  0E03     MOVLW 0x3
1BC0  6EE6     MOVWF 0xFE6, ACCESS
1BC2  0E0C     MOVLW 0xC
1BC4  6EE6     MOVWF 0xFE6, ACCESS
1BC6  0E37     MOVLW 0x37
1BC8  6EE6     MOVWF 0xFE6, ACCESS
1BCA  0E05     MOVLW 0x5
1BCC  6EE6     MOVWF 0xFE6, ACCESS
1BCE  EC81     CALL 0x1E502, 0
1BD0  F0F2     NOP
704:               emv.firmware = mb16_swap(emv.firmware);
1BD2  C537     MOVFF emv, POSTINC1
1BD4  F4E6     NOP
1BD6  C538     MOVFF 0x538, POSTINC1
1BD8  F4E6     NOP
1BDA  ECB9     CALL 0x972, 0
1BDC  F004     NOP
1BDE  0061     MOVFFL ltemp0, emv
1BE0  F404     NOP
1BE2  F537     NOP
1BE4  0061     MOVFFL ttemp5, 0x538
1BE6  F408     NOP
1BE8  F538     NOP
705:           }
1BEA  0012     RETURN 0
---  /public/Q84vtouch/mateQ84.X/mxcmd.c  ---------------------------------------------------------------
1:             #include "mxcmd.h"
2:             
3:             static volatile uint8_t data = 0x00, dcount = 0, dstart = 0, rdstart = 0;
4:             static volatile uint16_t tbuf[FM_BUFFER + 1], rbuf[FM_BUFFER + 1];
5:             static uint16_t *p_tbuf = (uint16_t*) tbuf, *p_rbuf = (uint16_t*) rbuf;
6:             static volatile uint8_t pace = 0; // the charge controller doesn't like back to back bytes
7:             
8:             void FM_restart(void) {
9:                 data = U1RXB;
10:                dcount = 0;
11:                dstart = 0;
12:                rdstart = 0;
13:                B.ten_sec_flag = false;
14:            }
15:            
16:            /*
17:             * Check for TX transmission
18:             */
19:            bool FM_tx_empty(void) {
20:                if (dcount == 0) {
264E  502C     MOVF 0x2C, W, ACCESS
2650  A4D8     BTFSS 0xFD8, 2, ACCESS
2652  D003     BRA 0x265A
21:                    return true;
2654  0E01     MOVLW 0x1
2656  6E01     MOVWF __ptext283, ACCESS
2658  0012     RETURN 0
22:                } else {
23:                    return false;
265A  0E00     MOVLW 0x0
265C  6E01     MOVWF __ptext283, ACCESS
24:                }
25:            }
265E  0012     RETURN 0
26:            
27:            /*
28:             * after the tbuf has been loaded start the TX transfer
29:             */
30:            uint8_t FM_tx(const uint16_t * data, const uint8_t count) {
31:                RELAY_SetHigh();
1092  80C2     BSF 0xFC2, 0, ACCESS
32:                RELAY_SetLow(); // tx trace signature
1094  90C2     BCF 0xFC2, 0, ACCESS
33:                RELAY_SetHigh();
1096  80C2     BSF 0xFC2, 0, ACCESS
34:                if (dcount == 0) {
1098  502C     MOVF 0x2C, W, ACCESS
109A  A4D8     BTFSS 0xFD8, 2, ACCESS
109C  D021     BRA 0x10E0
35:                    memcpy((void *) tbuf, (const void *) data, (size_t) (count << 1)); // copy 16-bit values
109E  0EFD     MOVLW 0xFD
10A0  0061     MOVFFL PLUSW1, 0x50C
10A2  F38C     NOP
10A4  F50C     NOP
10A6  90D8     BCF 0xFD8, 0, ACCESS
10A8  340C     RLCF 0xC, W, ACCESS
10AA  6E0B     MOVWF 0xB, ACCESS
10AC  6A0C     CLRF 0xC, ACCESS
10AE  360C     RLCF 0xC, F, ACCESS
10B0  0061     MOVFFL wtemp5, POSTINC1
10B2  F42C     NOP
10B4  F4E6     NOP
10B6  0061     MOVFFL 0x50C, POSTINC1
10B8  F430     NOP
10BA  F4E6     NOP
10BC  0EFC     MOVLW 0xFC
10BE  C4E3     MOVFF PLUSW1, POSTINC1
10C0  F4E6     NOP
10C2  C4E3     MOVFF PLUSW1, POSTINC1
10C4  F4E6     NOP
10C6  0E82     MOVLW 0x82
10C8  6EE6     MOVWF 0xFE6, ACCESS
10CA  0E0A     MOVLW 0xA
10CC  6EE6     MOVWF 0xFE6, ACCESS
10CE  EC81     CALL 0x1E502, 0
10D0  F0F2     NOP
36:                    dstart = 0;
10D2  6A2B     CLRF 0x2B, ACCESS
37:                    dcount = count;
10D4  0EFD     MOVLW 0xFD
10D6  C4E3     MOVFF PLUSW1, dcount
10D8  F52C     NOP
38:                    B.FM80_io = true; // start the CANBUS lockup until the RX transaction is complete
10DA  0E01     MOVLW 0x1
10DC  0105     MOVLB 0x5
10DE  6F70     MOVWF CM1CON0, BANKED
39:                }
40:                RELAY_SetLow();
10E0  90C2     BCF 0xFC2, 0, ACCESS
41:                return dstart;
42:            }
10E2  52E5     MOVF 0xFE5, F, ACCESS
10E2  52E5     MOVF 0xFE5, F, ACCESS
10E2  52E5     MOVF 0xFE5, F, ACCESS
10E2  52E5     MOVF 0xFE5, F, ACCESS
43:            
44:            /*
45:             * serial I/O ISR, TMR4 500us I/O sample rate
46:             * polls the required UART registers for 9-bit send and receive into 16-bit arrays
47:             */
48:            void FM_io(void) {
49:                INT_TRACE; // GPIO interrupt scope trace
1DAC0  ACBF     BTFSS 0xFBF, 6, ACCESS
1DAC2  D002     BRA 0xDAC8
1DAC4  0E01     MOVLW 0x1
1DAC6  D001     BRA 0xDACA
1DAC8  0E00     MOVLW 0x0
1DACA  0AFF     XORLW 0xFF
1DACC  6E0C     MOVWF 0xC, ACCESS
1DACE  3A0C     SWAPF 0xC, F, ACCESS
1DAD0  460C     RLNCF 0xC, F, ACCESS
1DAD2  460C     RLNCF 0xC, F, ACCESS
1DAD4  50BF     MOVF 0xFBF, W, ACCESS
1DAD6  180C     XORWF 0xC, W, ACCESS
1DAD8  0BBF     ANDLW 0xBF
1DADA  180C     XORWF 0xC, W, ACCESS
1DADC  6EBF     MOVWF 0xFBF, ACCESS
50:                MISC_SetHigh(); // serial CPU usage signal for I/O polling
1DADE  82C2     BSF 0xFC2, 1, ACCESS
51:            
52:                if (pace++ > BUFFER_SPACING) {
1DAE0  0105     MOVLB 0x5
1DAE2  2BDE     INCF CLCnGLS2, F, BANKED
1DAE4  05DE     DECF CLCnGLS2, W, BANKED
1DAE6  6E0C     MOVWF 0xC, ACCESS
1DAE8  0E04     MOVLW 0x4
1DAEA  640C     CPFSGT 0xC, ACCESS
1DAEC  D030     BRA 0xDB4E
53:                    if (dcount-- > 0) {
1DAEE  062C     DECF 0x2C, F, ACCESS
1DAF0  282C     INCF 0x2C, W, ACCESS
1DAF2  B4D8     BTFSC 0xFD8, 2, ACCESS
1DAF4  D028     BRA 0xDB46
54:                        if (tbuf[dstart] > 0xff) { // Check for bit-9
1DAF6  502B     MOVF 0x2B, W, ACCESS
1DAF8  0D02     MULLW 0x2
1DAFA  0E82     MOVLW 0x82
1DAFC  24F3     ADDWF 0xFF3, W, ACCESS
1DAFE  6ED9     MOVWF 0xFD9, ACCESS
1DB00  0E0A     MOVLW 0xA
1DB02  20F4     ADDWFC 0xFF4, W, ACCESS
1DB04  6EDA     MOVWF __end_of_UART2_tx_vect_isr, ACCESS
1DB06  0E00     MOVLW 0x0
1DB08  5CDE     SUBWF 0xFDE, W, ACCESS
1DB0A  0E01     MOVLW 0x1
1DB0C  58DE     SUBWFB 0xFDE, W, ACCESS
1DB0E  A0D8     BTFSS 0xFD8, 0, ACCESS
1DB10  D00C     BRA 0xDB2A
55:                            U1P1L = (uint8_t) tbuf[dstart]; // send with bit-9 high, start of packet
1DB12  502B     MOVF 0x2B, W, ACCESS
1DB14  0D02     MULLW 0x2
1DB16  0E82     MOVLW 0x82
1DB18  24F3     ADDWF 0xFF3, W, ACCESS
1DB1A  6ED9     MOVWF 0xFD9, ACCESS
1DB1C  0E0A     MOVLW 0xA
1DB1E  20F4     ADDWFC 0xFF4, W, ACCESS
1DB20  6EDA     MOVWF __end_of_UART2_tx_vect_isr, ACCESS
1DB22  50DF     MOVF 0xFDF, W, ACCESS
1DB24  0102     MOVLB 0x2
1DB26  6FA5     MOVWF 0xA5, BANKED
56:                        } else {
1DB28  D00C     BRA 0xDB42
57:                            UART1_Write((uint8_t) tbuf[dstart]); // send with bit-9 low
1DB2A  502B     MOVF 0x2B, W, ACCESS
1DB2C  0D02     MULLW 0x2
1DB2E  0E82     MOVLW 0x82
1DB30  24F3     ADDWF 0xFF3, W, ACCESS
1DB32  6ED9     MOVWF 0xFD9, ACCESS
1DB34  0E0A     MOVLW 0xA
1DB36  20F4     ADDWFC 0xFF4, W, ACCESS
1DB38  6EDA     MOVWF __end_of_UART2_tx_vect_isr, ACCESS
1DB3A  50DF     MOVF 0xFDF, W, ACCESS
1DB3C  6EE6     MOVWF 0xFE6, ACCESS
1DB3E  EC57     CALL 0x26AE, 0
1DB40  F013     NOP
58:                        }
59:                        dstart++;
1DB42  2A2B     INCF 0x2B, F, ACCESS
60:                    } else {
1DB44  D002     BRA 0xDB4A
61:                        dstart = 0;
1DB46  6A2B     CLRF 0x2B, ACCESS
62:                        dcount = 0;
1DB48  6A2C     CLRF 0x2C, ACCESS
63:                    }
64:                    pace = 0;
1DB4A  0105     MOVLB 0x5
1DB4C  6BDE     CLRF CLCnGLS2, BANKED
65:                }
66:            
67:                /*
68:                 * handle framing errors
69:                 */
70:                if (U1ERRIRbits.RXFOIF) {
1DB4E  0102     MOVLB 0x2
1DB50  A3B2     BTFSS OSCSTAT, 1, BANKED
1DB52  D007     BRA 0xDB62
71:                    rbuf[0] = U1RXB; // read bad data to clear error
1DB54  C2A1     MOVFF U1RXB, rbuf
1DB56  FA40     NOP
1DB58  010A     MOVLB 0xA
1DB5A  6B41     CLRF NVMCON1, BANKED
72:                    U1ERRIRbits.RXFOIF = 0;
1DB5C  0102     MOVLB 0x2
1DB5E  93B2     BCF OSCSTAT, 1, BANKED
73:                    rdstart = 0; // reset buffer to start
1DB60  6A2A     CLRF 0x2A, ACCESS
74:                }
75:            
76:                /*
77:                 * read serial data if polled interrupt flag is set
78:                 */
79:                if (PIR4bits.U1RXIF) {
1DB62  A0B2     BTFSS 0xFB2, 0, ACCESS
1DB64  D03B     BRA 0xDBDC
80:                    IO_RB7_Toggle(); // GPIO scope trace
1DB66  AEBF     BTFSS 0xFBF, 7, ACCESS
1DB68  D002     BRA 0xDB6E
1DB6A  0E01     MOVLW 0x1
1DB6C  D001     BRA 0xDB70
1DB6E  0E00     MOVLW 0x0
1DB70  0AFF     XORLW 0xFF
1DB72  6E0C     MOVWF 0xC, ACCESS
1DB74  320C     RRCF 0xC, F, ACCESS
1DB76  320C     RRCF 0xC, F, ACCESS
1DB78  50BF     MOVF 0xFBF, W, ACCESS
1DB7A  180C     XORWF 0xC, W, ACCESS
1DB7C  0B7F     ANDLW 0x7F
1DB7E  180C     XORWF 0xC, W, ACCESS
1DB80  6EBF     MOVWF 0xFBF, ACCESS
81:                    if (U1ERRIRbits.FERIF) {
1DB82  51B2     MOVF OSCSTAT, W, BANKED
82:                        // do nothing, will clear auto
83:                    }
84:            
85:                    if (rdstart > FM_BUFFER - 1) { // overload buffer index
1DB84  0E1F     MOVLW 0x1F
1DB86  642A     CPFSGT 0x2A, ACCESS
1DB88  D002     BRA 0xDB8E
86:                        rdstart = 0; // reset buffer to start
1DB8A  6A2A     CLRF 0x2A, ACCESS
87:                        MLED_SetHigh();
1DB8C  82BF     BSF 0xFBF, 1, ACCESS
88:                    }
89:                    if (U1ERRIRbits.PERIF) {
1DB8E  ADB2     BTFSS OSCSTAT, 6, BANKED
1DB90  D00E     BRA 0xDBAE
90:                        rdstart = 0; // restart receive buffer when we see a 9-th bit high
1DB92  6A2A     CLRF 0x2A, ACCESS
91:                        rbuf[rdstart] = 0x0100; // start of packet, bit 9 set
1DB94  502A     MOVF 0x2A, W, ACCESS
1DB96  0D02     MULLW 0x2
1DB98  0E40     MOVLW 0x40
1DB9A  24F3     ADDWF 0xFF3, W, ACCESS
1DB9C  6ED9     MOVWF 0xFD9, ACCESS
1DB9E  0E0A     MOVLW 0xA
1DBA0  20F4     ADDWFC 0xFF4, W, ACCESS
1DBA2  6EDA     MOVWF __end_of_UART2_tx_vect_isr, ACCESS
1DBA4  0E00     MOVLW 0x0
1DBA6  6EDE     MOVWF 0xFDE, ACCESS
1DBA8  0E01     MOVLW 0x1
1DBAA  6EDD     MOVWF 0xFDD, ACCESS
92:                    } else {
1DBAC  D00A     BRA 0xDBC2
93:                        rbuf[rdstart] = 0x00;
1DBAE  502A     MOVF 0x2A, W, ACCESS
1DBB0  0D02     MULLW 0x2
1DBB2  0E40     MOVLW 0x40
1DBB4  24F3     ADDWF 0xFF3, W, ACCESS
1DBB6  6ED9     MOVWF 0xFD9, ACCESS
1DBB8  0E0A     MOVLW 0xA
1DBBA  20F4     ADDWFC 0xFF4, W, ACCESS
1DBBC  6EDA     MOVWF __end_of_UART2_tx_vect_isr, ACCESS
1DBBE  6ADE     CLRF 0xFDE, ACCESS
1DBC0  6ADD     CLRF 0xFDD, ACCESS
94:                    }
95:                    rbuf[rdstart] += U1RXB;
1DBC2  502A     MOVF 0x2A, W, ACCESS
1DBC4  0D02     MULLW 0x2
1DBC6  0E40     MOVLW 0x40
1DBC8  24F3     ADDWF 0xFF3, W, ACCESS
1DBCA  6ED9     MOVWF 0xFD9, ACCESS
1DBCC  0E0A     MOVLW 0xA
1DBCE  20F4     ADDWFC 0xFF4, W, ACCESS
1DBD0  6EDA     MOVWF __end_of_UART2_tx_vect_isr, ACCESS
1DBD2  51A1     MOVF 0xA1, W, BANKED
1DBD4  26DE     ADDWF 0xFDE, F, ACCESS
1DBD6  0E00     MOVLW 0x0
1DBD8  22DD     ADDWFC 0xFDD, F, ACCESS
96:                    rdstart++;
1DBDA  2A2A     INCF 0x2A, F, ACCESS
97:                }
98:            
99:                MISC_SetLow();
1DBDC  92C2     BCF 0xFC2, 1, ACCESS
100:               timer_ms_tick(0, 0); // software timers update
1DBDE  0E00     MOVLW 0x0
1DBE0  6EE6     MOVWF 0xFE6, ACCESS
1DBE2  0E00     MOVLW 0x0
1DBE4  6EE6     MOVWF 0xFE6, ACCESS
1DBE6  0E00     MOVLW 0x0
1DBE8  6EE6     MOVWF 0xFE6, ACCESS
1DBEA  0E00     MOVLW 0x0
1DBEC  6EE6     MOVWF 0xFE6, ACCESS
1DBEE  0E00     MOVLW 0x0
1DBF0  6EE6     MOVWF 0xFE6, ACCESS
1DBF2  0E00     MOVLW 0x0
1DBF4  6EE6     MOVWF 0xFE6, ACCESS
1DBF6  0E00     MOVLW 0x0
1DBF8  6EE6     MOVWF 0xFE6, ACCESS
1DBFA  0E00     MOVLW 0x0
1DBFC  6EE6     MOVWF 0xFE6, ACCESS
1DBFE  ECB9     CALL 0x1FD72, 0
1DC00  F0FE     NOP
101:           
102:           }
1DC02  0012     RETURN 0
103:           
104:           /*
105:            * disabled using critical section interrupts here and it was too long 500us
106:            * and causing data errors
107:            */
108:           uint8_t FM_rx(uint16_t * data) {
13B6  52E6     MOVF 0xFE6, F, ACCESS
109:               uint8_t count;
110:           
111:               RELAY_SetHigh();
13B8  80C2     BSF 0xFC2, 0, ACCESS
112:               count = rdstart;
13BA  0EFF     MOVLW 0xFF
13BC  C52A     MOVFF rdstart, PLUSW1
13BE  F4E3     NOP
113:               memcpy(data, (const void *) rbuf, (size_t) (count << 1)); // copy 16-bit values
13C0  0EFF     MOVLW 0xFF
13C2  0061     MOVFFL PLUSW1, 0x50C
13C4  F38C     NOP
13C6  F50C     NOP
13C8  90D8     BCF 0xFD8, 0, ACCESS
13CA  340C     RLCF 0xC, W, ACCESS
13CC  6E0B     MOVWF 0xB, ACCESS
13CE  6A0C     CLRF 0xC, ACCESS
13D0  360C     RLCF 0xC, F, ACCESS
13D2  0061     MOVFFL wtemp5, POSTINC1
13D4  F42C     NOP
13D6  F4E6     NOP
13D8  0061     MOVFFL 0x50C, POSTINC1
13DA  F430     NOP
13DC  F4E6     NOP
13DE  0E40     MOVLW 0x40
13E0  6EE6     MOVWF 0xFE6, ACCESS
13E2  0E0A     MOVLW 0xA
13E4  6EE6     MOVWF 0xFE6, ACCESS
13E6  0EF9     MOVLW 0xF9
13E8  C4E3     MOVFF PLUSW1, POSTINC1
13EA  F4E6     NOP
13EC  C4E3     MOVFF PLUSW1, POSTINC1
13EE  F4E6     NOP
13F0  EC81     CALL 0x1E502, 0
13F2  F0F2     NOP
114:               rdstart = 0;
13F4  6A2A     CLRF 0x2A, ACCESS
115:               RELAY_SetLow();
13F6  90C2     BCF 0xFC2, 0, ACCESS
116:               return count;
117:           }
13F8  52E5     MOVF 0xFE5, F, ACCESS
13F8  52E5     MOVF 0xFE5, F, ACCESS
13F8  52E5     MOVF 0xFE5, F, ACCESS
13F8  52E5     MOVF 0xFE5, F, ACCESS
118:           
119:           bool FM_rx_ready(void) {
120:               if (rdstart == 0) {
2660  502A     MOVF 0x2A, W, ACCESS
2662  A4D8     BTFSS 0xFD8, 2, ACCESS
2664  D003     BRA 0x266C
121:                   return false;
2666  0E00     MOVLW 0x0
2668  6E01     MOVWF __ptext283, ACCESS
266A  0012     RETURN 0
122:               } else {
123:                   return true;
266C  0E01     MOVLW 0x1
266E  6E01     MOVWF __ptext283, ACCESS
124:               }
125:           }
2670  0012     RETURN 0
126:           
127:           uint8_t FM_rx_count(void) {
2612  52E6     MOVF 0xFE6, F, ACCESS
128:               uint8_t count;
129:           
130:               count = rdstart;
2614  0EFF     MOVLW 0xFF
2616  C52A     MOVFF rdstart, PLUSW1
2618  F4E3     NOP
131:               return count;
261A  0EFF     MOVLW 0xFF
261C  0061     MOVFFL PLUSW1, ltemp0
261E  F38C     NOP
2620  F501     NOP
132:           }
2622  52E5     MOVF 0xFE5, F, ACCESS
2622  52E5     MOVF 0xFE5, F, ACCESS
133:           
134:           void onesec_io(void) {
135:               INT_TRACE; // GPIO interrupt scope trace
1682  ACBF     BTFSS 0xFBF, 6, ACCESS
1684  D002     BRA 0x168A
1686  0E01     MOVLW 0x1
1688  D001     BRA 0x168C
168A  0E00     MOVLW 0x0
168C  0AFF     XORLW 0xFF
168E  6E0C     MOVWF 0xC, ACCESS
1690  3A0C     SWAPF 0xC, F, ACCESS
1692  460C     RLNCF 0xC, F, ACCESS
1694  460C     RLNCF 0xC, F, ACCESS
1696  50BF     MOVF 0xFBF, W, ACCESS
1698  180C     XORWF 0xC, W, ACCESS
169A  0BBF     ANDLW 0xBF
169C  180C     XORWF 0xC, W, ACCESS
169E  6EBF     MOVWF 0xFBF, ACCESS
136:               RLED_Toggle();
16A0  A4BF     BTFSS 0xFBF, 2, ACCESS
16A2  D002     BRA 0x16A8
16A4  0E01     MOVLW 0x1
16A6  D001     BRA 0x16AA
16A8  0E00     MOVLW 0x0
16AA  0AFF     XORLW 0xFF
16AC  6E0C     MOVWF 0xC, ACCESS
16AE  460C     RLNCF 0xC, F, ACCESS
16B0  460C     RLNCF 0xC, F, ACCESS
16B2  50BF     MOVF 0xFBF, W, ACCESS
16B4  180C     XORWF 0xC, W, ACCESS
16B6  0BFB     ANDLW 0xFB
16B8  180C     XORWF 0xC, W, ACCESS
16BA  6EBF     MOVWF 0xFBF, ACCESS
137:               MLED_SetLow();
16BC  92BF     BCF 0xFBF, 1, ACCESS
138:               B.one_sec_flag = true;
16BE  0E01     MOVLW 0x1
16C0  0105     MOVLB 0x5
16C2  6F61     MOVWF PMD1, BANKED
139:           }
127C  C4D8     MOVFF STATUS, 0xAEF
16C4  0012     RETURN 0
140:           
141:           void tensec_io(void) {
142:               INT_TRACE; // GPIO interrupt scope trace
0D4E  ACBF     BTFSS 0xFBF, 6, ACCESS
0D50  D002     BRA 0xD56
0D52  0E01     MOVLW 0x1
0D54  D001     BRA 0xD58
0D56  0E00     MOVLW 0x0
0D58  0AFF     XORLW 0xFF
0D5A  6E0C     MOVWF 0xC, ACCESS
0D5C  3A0C     SWAPF 0xC, F, ACCESS
0D5E  460C     RLNCF 0xC, F, ACCESS
0D60  460C     RLNCF 0xC, F, ACCESS
0D62  50BF     MOVF 0xFBF, W, ACCESS
0D64  180C     XORWF 0xC, W, ACCESS
0D66  0BBF     ANDLW 0xBF
0D68  180C     XORWF 0xC, W, ACCESS
0D6A  6EBF     MOVWF 0xFBF, ACCESS
143:               DLED1_Toggle();
0D6C  A6BF     BTFSS 0xFBF, 3, ACCESS
0D6E  D002     BRA 0xD74
0D70  0E01     MOVLW 0x1
0D72  D001     BRA 0xD76
0D74  0E00     MOVLW 0x0
0D76  0AFF     XORLW 0xFF
0D78  6E0C     MOVWF 0xC, ACCESS
0D7A  460C     RLNCF 0xC, F, ACCESS
0D7C  460C     RLNCF 0xC, F, ACCESS
0D7E  460C     RLNCF 0xC, F, ACCESS
0D80  50BF     MOVF 0xFBF, W, ACCESS
0D82  180C     XORWF 0xC, W, ACCESS
0D84  0BF7     ANDLW 0xF7
0D86  180C     XORWF 0xC, W, ACCESS
0D88  6EBF     MOVWF 0xFBF, ACCESS
144:               DLED_Toggle();
0D8A  A8C1     BTFSS 0xFC1, 4, ACCESS
0D8C  D002     BRA 0xD92
0D8E  0E01     MOVLW 0x1
0D90  D001     BRA 0xD94
0D92  0E00     MOVLW 0x0
0D94  0AFF     XORLW 0xFF
0D96  6E0C     MOVWF 0xC, ACCESS
0D98  3A0C     SWAPF 0xC, F, ACCESS
0D9A  50C1     MOVF 0xFC1, W, ACCESS
0D9C  180C     XORWF 0xC, W, ACCESS
0D9E  0BEF     ANDLW 0xEF
0DA0  180C     XORWF 0xC, W, ACCESS
0DA2  6EC1     MOVWF 0xFC1, ACCESS
145:               MLED_SetLow();
0DA4  92BF     BCF 0xFBF, 1, ACCESS
146:               B.ten_sec_flag = true;
0DA6  0E01     MOVLW 0x1
0DA8  0105     MOVLB 0x5
0DAA  6F60     MOVWF PMD0, BANKED
147:           }
0DAC  0012     RETURN 0
12CC  C4D8     MOVFF STATUS, __pcstackBANK12
12CE  FCF0     NOP
12D0  C4FA     MOVFF PCLATH, 0xCF1
12D2  FCF1     NOP
12D4  C4FB     MOVFF PCLATU, 0xCF2
12D6  FCF2     NOP
12D8  0061     MOVFFL 0x50C, 0xCF3
12DA  F430     NOP
12DC  FCF3     NOP
12DE  EE1A     LFSR 1, 0x2B55
12E0  F355     NOP
148:           
149:           /*
150:            * floating point low pass filter,
151:            * slow/fast select, use (-1) to zero buffer channel and return new
152:            */
153:           float lp_filter(const float new, const uint8_t bn, const int8_t slow) {
1CF22  52E6     MOVF 0xFE6, F, ACCESS
1CF24  52E6     MOVF 0xFE6, F, ACCESS
1CF26  52E6     MOVF 0xFE6, F, ACCESS
1CF28  52E6     MOVF 0xFE6, F, ACCESS
154:               static float smooth[LP_BUFFER_SIZE];
155:               float lp_speed;
156:           
157:               if (bn >= LP_BUFFER_SIZE) // buffer index check
1CF2A  0EF7     MOVLW 0xF7
1CF2C  0061     MOVFFL PLUSW1, ltemp0
1CF2E  F38C     NOP
1CF30  F501     NOP
1CF32  0E08     MOVLW 0x8
1CF34  6401     CPFSGT __ptext283, ACCESS
1CF36  D011     BRA 0xCF5A
158:                   return new;
1CF38  0EF8     MOVLW 0xF8
1CF3A  0061     MOVFFL PLUSW1, ltemp0
1CF3C  F38C     NOP
1CF3E  F501     NOP
1CF40  0EF9     MOVLW 0xF9
1CF42  0061     MOVFFL PLUSW1, ttemp5
1CF44  F38C     NOP
1CF46  F502     NOP
1CF48  0EFA     MOVLW 0xFA
1CF4A  0061     MOVFFL PLUSW1, wtemp1
1CF4C  F38C     NOP
1CF4E  F503     NOP
1CF50  0EFB     MOVLW 0xFB
1CF52  0061     MOVFFL PLUSW1, ttemp1
1CF54  F38C     NOP
1CF56  F504     NOP
1CF58  D0AD     BRA 0xD0B4
159:           
160:               if (slow == (-1)) { // reset smooth buffer and return original value
1CF5A  0EF6     MOVLW 0xF6
1CF5C  28E3     INCF 0xFE3, W, ACCESS
1CF5E  A4D8     BTFSS 0xFD8, 2, ACCESS
1CF60  D012     BRA 0xCF86
161:                   smooth[bn] = 0.0f;
1CF62  0EF7     MOVLW 0xF7
1CF64  50E3     MOVF 0xFE3, W, ACCESS
1CF66  0D04     MULLW 0x4
1CF68  0E81     MOVLW 0x81
1CF6A  24F3     ADDWF 0xFF3, W, ACCESS
1CF6C  6ED9     MOVWF 0xFD9, ACCESS
1CF6E  0E08     MOVLW 0x8
1CF70  20F4     ADDWFC 0xFF4, W, ACCESS
1CF72  6EDA     MOVWF __end_of_UART2_tx_vect_isr, ACCESS
1CF74  0E00     MOVLW 0x0
1CF76  6EDE     MOVWF 0xFDE, ACCESS
1CF78  0E00     MOVLW 0x0
1CF7A  6EDE     MOVWF 0xFDE, ACCESS
1CF7C  0E00     MOVLW 0x0
1CF7E  6EDE     MOVWF 0xFDE, ACCESS
1CF80  0E00     MOVLW 0x0
1CF82  6EDD     MOVWF 0xFDD, ACCESS
1CF84  D7D9     BRA 0xCF38
162:                   return new;
163:               }
164:           
165:               if (slow) { // some random filter cutoffs beta values
1CF86  0EF6     MOVLW 0xF6
1CF88  50E3     MOVF 0xFE3, W, ACCESS
1CF8A  B4D8     BTFSC 0xFD8, 2, ACCESS
1CF8C  D006     BRA 0xCF9A
166:                   lp_speed = 0.0333f;
1CF8E  0E95     MOVLW 0x95
1CF90  6E09     MOVWF 0x9, ACCESS
1CF92  0E65     MOVLW 0x65
1CF94  6E0A     MOVWF 0xA, ACCESS
1CF96  0E08     MOVLW 0x8
1CF98  D005     BRA 0xCFA4
167:               } else {
168:                   lp_speed = 0.1f;
1CF9A  0ECD     MOVLW 0xCD
1CF9C  6E09     MOVWF 0x9, ACCESS
1CF9E  0ECC     MOVLW 0xCC
1CFA0  6E0A     MOVWF 0xA, ACCESS
1CFA2  0ECC     MOVLW 0xCC
1CFA4  6E0B     MOVWF 0xB, ACCESS
1CFA6  0E3D     MOVLW 0x3D
1CFA8  6E0C     MOVWF 0xC, ACCESS
1CFAA  0EFC     MOVLW 0xFC
1CFAC  0061     MOVFFL ltemp2, PLUSW1
1CFAE  F424     NOP
1CFB0  F4E3     NOP
1CFB2  0EFD     MOVLW 0xFD
1CFB4  0061     MOVFFL ttemp3, PLUSW1
1CFB6  F428     NOP
1CFB8  F4E3     NOP
1CFBA  0EFE     MOVLW 0xFE
1CFBC  0061     MOVFFL wtemp5, PLUSW1
1CFBE  F42C     NOP
1CFC0  F4E3     NOP
1CFC2  0EFF     MOVLW 0xFF
1CFC4  0061     MOVFFL 0x50C, PLUSW1
1CFC6  F430     NOP
1CFC8  F4E3     NOP
169:               }
170:               // exponentially weighted moving average
171:               return smooth[bn] = smooth[bn] + ((new - smooth[bn]) * lp_speed);
1CFCA  0EF7     MOVLW 0xF7
1CFCC  50E3     MOVF 0xFE3, W, ACCESS
1CFCE  0D04     MULLW 0x4
1CFD0  0E81     MOVLW 0x81
1CFD2  24F3     ADDWF 0xFF3, W, ACCESS
1CFD4  6ED9     MOVWF 0xFD9, ACCESS
1CFD6  0E08     MOVLW 0x8
1CFD8  20F4     ADDWFC 0xFF4, W, ACCESS
1CFDA  6EDA     MOVWF __end_of_UART2_tx_vect_isr, ACCESS
1CFDC  C4DE     MOVFF POSTINC2, POSTINC1
1CFDE  F4E6     NOP
1CFE0  C4DE     MOVFF POSTINC2, POSTINC1
1CFE2  F4E6     NOP
1CFE4  C4DE     MOVFF POSTINC2, POSTINC1
1CFE6  F4E6     NOP
1CFE8  C4DE     MOVFF POSTINC2, POSTINC1
1CFEA  F4E6     NOP
1CFEC  0EF8     MOVLW 0xF8
1CFEE  C4E3     MOVFF PLUSW1, POSTINC1
1CFF0  F4E6     NOP
1CFF2  C4E3     MOVFF PLUSW1, POSTINC1
1CFF4  F4E6     NOP
1CFF6  C4E3     MOVFF PLUSW1, POSTINC1
1CFF8  F4E6     NOP
1CFFA  C4E3     MOVFF PLUSW1, POSTINC1
1CFFC  F4E6     NOP
1CFFE  0EEF     MOVLW 0xEF
1D000  50E3     MOVF 0xFE3, W, ACCESS
1D002  0D04     MULLW 0x4
1D004  0E81     MOVLW 0x81
1D006  24F3     ADDWF 0xFF3, W, ACCESS
1D008  6ED9     MOVWF 0xFD9, ACCESS
1D00A  0E08     MOVLW 0x8
1D00C  20F4     ADDWFC 0xFF4, W, ACCESS
1D00E  6EDA     MOVWF __end_of_UART2_tx_vect_isr, ACCESS
1D010  C4DE     MOVFF POSTINC2, POSTINC1
1D012  F4E6     NOP
1D014  C4DE     MOVFF POSTINC2, POSTINC1
1D016  F4E6     NOP
1D018  C4DE     MOVFF POSTINC2, POSTINC1
1D01A  F4E6     NOP
1D01C  C4DE     MOVFF POSTINC2, POSTINC1
1D01E  F4E6     NOP
1D020  0EEC     MOVLW 0xEC
1D022  C4E3     MOVFF PLUSW1, POSTINC1
1D024  F4E6     NOP
1D026  C4E3     MOVFF PLUSW1, POSTINC1
1D028  F4E6     NOP
1D02A  C4E3     MOVFF PLUSW1, POSTINC1
1D02C  F4E6     NOP
1D02E  C4E3     MOVFF PLUSW1, POSTINC1
1D030  F4E6     NOP
1D032  ECC0     CALL 0x1B80, 0
1D034  F00D     NOP
1D036  0061     MOVFFL ltemp0, POSTINC1
1D038  F404     NOP
1D03A  F4E6     NOP
1D03C  0061     MOVFFL ttemp5, POSTINC1
1D03E  F408     NOP
1D040  F4E6     NOP
1D042  0061     MOVFFL wtemp1, POSTINC1
1D044  F40C     NOP
1D046  F4E6     NOP
1D048  0061     MOVFFL ttemp1, POSTINC1
1D04A  F410     NOP
1D04C  F4E6     NOP
1D04E  EC2F     CALL 0x1705E, 0
1D050  F0B8     NOP
1D052  0061     MOVFFL ltemp0, POSTINC1
1D054  F404     NOP
1D056  F4E6     NOP
1D058  0061     MOVFFL ttemp5, POSTINC1
1D05A  F408     NOP
1D05C  F4E6     NOP
1D05E  0061     MOVFFL wtemp1, POSTINC1
1D060  F40C     NOP
1D062  F4E6     NOP
1D064  0061     MOVFFL ttemp1, POSTINC1
1D066  F410     NOP
1D068  F4E6     NOP
1D06A  EC30     CALL 0x17860, 0
1D06C  F0BC     NOP
1D06E  0EF7     MOVLW 0xF7
1D070  50E3     MOVF 0xFE3, W, ACCESS
1D072  0D04     MULLW 0x4
1D074  0E81     MOVLW 0x81
1D076  24F3     ADDWF 0xFF3, W, ACCESS
1D078  6ED9     MOVWF 0xFD9, ACCESS
1D07A  0E08     MOVLW 0x8
1D07C  20F4     ADDWFC 0xFF4, W, ACCESS
1D07E  6EDA     MOVWF __end_of_UART2_tx_vect_isr, ACCESS
1D080  0061     MOVFFL ltemp0, POSTINC2
1D082  F404     NOP
1D084  F4DE     NOP
1D086  0061     MOVFFL ttemp5, POSTINC2
1D088  F408     NOP
1D08A  F4DE     NOP
1D08C  0061     MOVFFL wtemp1, POSTINC2
1D08E  F40C     NOP
1D090  F4DE     NOP
1D092  0061     MOVFFL ttemp1, POSTDEC2
1D094  F410     NOP
1D096  F4DD     NOP
1D098  52DD     MOVF 0xFDD, F, ACCESS
1D09A  52DD     MOVF 0xFDD, F, ACCESS
1D09C  0061     MOVFFL POSTINC2, ltemp0
1D09E  F378     NOP
1D0A0  F501     NOP
1D0A2  0061     MOVFFL POSTINC2, ttemp5
1D0A4  F378     NOP
1D0A6  F502     NOP
1D0A8  0061     MOVFFL POSTINC2, wtemp1
1D0AA  F378     NOP
1D0AC  F503     NOP
1D0AE  0061     MOVFFL POSTINC2, ttemp1
1D0B0  F378     NOP
1D0B2  F504     NOP
172:           }
1D0B4  0EF6     MOVLW 0xF6
1D0B4  0EF6     MOVLW 0xF6
1D0B4  0EF6     MOVLW 0xF6
1D0B4  0EF6     MOVLW 0xF6
1D0B4  0EF6     MOVLW 0xF6
173:           
174:           uint16_t calc_checksum(uint8_t* data, const uint8_t len) {
1F858  52E6     MOVF 0xFE6, F, ACCESS
1F85A  52E6     MOVF 0xFE6, F, ACCESS
1F85C  52E6     MOVF 0xFE6, F, ACCESS
1F85E  52E6     MOVF 0xFE6, F, ACCESS
175:               uint16_t sum = 0;
1F860  0EFE     MOVLW 0xFE
1F862  6AE3     CLRF 0xFE3, ACCESS
1F864  0EFF     MOVLW 0xFF
1F866  6AE3     CLRF 0xFE3, ACCESS
176:               for (int i = 0; i < len; i++) {
1F868  0EFC     MOVLW 0xFC
1F86A  6AE3     CLRF 0xFE3, ACCESS
1F86C  0EFD     MOVLW 0xFD
1F86E  6AE3     CLRF 0xFE3, ACCESS
1F870  0EF9     MOVLW 0xF9
1F872  50E3     MOVF 0xFE3, W, ACCESS
1F874  B4D8     BTFSC 0xFD8, 2, ACCESS
1F876  D04C     BRA 0xF910
177:                   sum += data[i];
1F878  0EFC     MOVLW 0xFC
1F87A  0061     MOVFFL PLUSW1, wtemp5
1F87C  F38C     NOP
1F87E  F50B     NOP
1F880  0EFD     MOVLW 0xFD
1F882  0061     MOVFFL PLUSW1, 0x50C
1F884  F38C     NOP
1F886  F50C     NOP
1F888  0EFA     MOVLW 0xFA
1F88A  0061     MOVFFL PLUSW1, ltemp2
1F88C  F38C     NOP
1F88E  F509     NOP
1F890  0EFB     MOVLW 0xFB
1F892  0061     MOVFFL PLUSW1, ttemp3
1F894  F38C     NOP
1F896  F50A     NOP
1F898  500B     MOVF 0xB, W, ACCESS
1F89A  2409     ADDWF 0x9, W, ACCESS
1F89C  6ED9     MOVWF 0xFD9, ACCESS
1F89E  500C     MOVF 0xC, W, ACCESS
1F8A0  200A     ADDWFC 0xA, W, ACCESS
1F8A2  6EDA     MOVWF __end_of_UART2_tx_vect_isr, ACCESS
1F8A4  50DF     MOVF 0xFDF, W, ACCESS
1F8A6  6E0C     MOVWF 0xC, ACCESS
1F8A8  0EFE     MOVLW 0xFE
1F8AA  50E3     MOVF 0xFE3, W, ACCESS
1F8AC  240C     ADDWF 0xC, W, ACCESS
1F8AE  6E01     MOVWF __ptext283, ACCESS
1F8B0  0EFE     MOVLW 0xFE
1F8B2  0061     MOVFFL ltemp0, PLUSW1
1F8B4  F404     NOP
1F8B6  F4E3     NOP
1F8B8  6A01     CLRF __ptext283, ACCESS
1F8BA  0EFF     MOVLW 0xFF
1F8BC  50E3     MOVF 0xFE3, W, ACCESS
1F8BE  2201     ADDWFC __ptext283, F, ACCESS
1F8C0  0EFF     MOVLW 0xFF
1F8C2  0061     MOVFFL ltemp0, PLUSW1
1F8C4  F404     NOP
1F8C6  F4E3     NOP
178:               }
1F8C8  0EFC     MOVLW 0xFC
1F8CA  50E3     MOVF 0xFE3, W, ACCESS
1F8CC  0F01     ADDLW 0x1
1F8CE  6E01     MOVWF __ptext283, ACCESS
1F8D0  0EFC     MOVLW 0xFC
1F8D2  0061     MOVFFL ltemp0, PLUSW1
1F8D4  F404     NOP
1F8D6  F4E3     NOP
1F8D8  6A01     CLRF __ptext283, ACCESS
1F8DA  0EFD     MOVLW 0xFD
1F8DC  50E3     MOVF 0xFE3, W, ACCESS
1F8DE  2001     ADDWFC __ptext283, W, ACCESS
1F8E0  6E01     MOVWF __ptext283, ACCESS
1F8E2  0EFD     MOVLW 0xFD
1F8E4  0061     MOVFFL ltemp0, PLUSW1
1F8E6  F404     NOP
1F8E8  F4E3     NOP
1F8EA  0EF9     MOVLW 0xF9
1F8EC  50E3     MOVF 0xFE3, W, ACCESS
1F8EE  6E0B     MOVWF 0xB, ACCESS
1F8F0  6A0C     CLRF 0xC, ACCESS
1F8F2  0EFC     MOVLW 0xFC
1F8F4  0061     MOVFFL PLUSW1, ltemp0
1F8F6  F38C     NOP
1F8F8  F501     NOP
1F8FA  500B     MOVF 0xB, W, ACCESS
1F8FC  5C01     SUBWF __ptext283, W, ACCESS
1F8FE  0EFD     MOVLW 0xFD
1F900  50E3     MOVF 0xFE3, W, ACCESS
1F902  0A80     XORLW 0x80
1F904  6E01     MOVWF __ptext283, ACCESS
1F906  500C     MOVF 0xC, W, ACCESS
1F908  0A80     XORLW 0x80
1F90A  5801     SUBWFB __ptext283, W, ACCESS
1F90C  A0D8     BTFSS 0xFD8, 0, ACCESS
1F90E  D7B4     BRA 0xF878
179:               return sum;
1F910  0EFE     MOVLW 0xFE
1F912  0061     MOVFFL PLUSW1, ltemp0
1F914  F38C     NOP
1F916  F501     NOP
1F918  0EFF     MOVLW 0xFF
1F91A  0061     MOVFFL PLUSW1, ttemp5
1F91C  F38C     NOP
1F91E  F502     NOP
180:           }
1F920  0EF9     MOVLW 0xF9
1F922  26E1     ADDWF 0xFE1, F, ACCESS
1F924  0EFF     MOVLW 0xFF
1F926  22E2     ADDWFC 0xFE2, F, ACCESS
1F926  22E2     ADDWFC 0xFE2, F, ACCESS
---  /public/Q84vtouch/mateQ84.X/mcc_generated_files/uart5.c  -------------------------------------------
1:             /**
2:               UART5 Generated Driver File
3:             
4:               @Company
5:                 Microchip Technology Inc.
6:             
7:               @File Name
8:                 uart5.c
9:             
10:              @Summary
11:                This is the generated driver implementation file for the UART5 driver using PIC10 / PIC12 / PIC16 / PIC18 MCUs
12:            
13:              @Description
14:                This source file provides APIs for UART5.
15:                Generation Information :
16:            	Product Revision  :  PIC10 / PIC12 / PIC16 / PIC18 MCUs - 1.81.8
17:            	Device            :  PIC18F47Q84
18:            	Driver Version    :  2.4.1
19:                The generated drivers are tested against the following:
20:            	Compiler          :  XC8 2.36 and above
21:            	MPLAB             :  MPLAB X 6.00
22:             */
23:            
24:            /*
25:                (c) 2018 Microchip Technology Inc. and its subsidiaries. 
26:                
27:                Subject to your compliance with these terms, you may use Microchip software and any 
28:                derivatives exclusively with Microchip products. It is your responsibility to comply with third party 
29:                license terms applicable to your use of third party software (including open source software) that 
30:                may accompany Microchip software.
31:                
32:                THIS SOFTWARE IS SUPPLIED BY MICROCHIP "AS IS". NO WARRANTIES, WHETHER 
33:                EXPRESS, IMPLIED OR STATUTORY, APPLY TO THIS SOFTWARE, INCLUDING ANY 
34:                IMPLIED WARRANTIES OF NON-INFRINGEMENT, MERCHANTABILITY, AND FITNESS 
35:                FOR A PARTICULAR PURPOSE.
36:                
37:                IN NO EVENT WILL MICROCHIP BE LIABLE FOR ANY INDIRECT, SPECIAL, PUNITIVE, 
38:                INCIDENTAL OR CONSEQUENTIAL LOSS, DAMAGE, COST OR EXPENSE OF ANY KIND 
39:                WHATSOEVER RELATED TO THE SOFTWARE, HOWEVER CAUSED, EVEN IF MICROCHIP 
40:                HAS BEEN ADVISED OF THE POSSIBILITY OR THE DAMAGES ARE FORESEEABLE. TO 
41:                THE FULLEST EXTENT ALLOWED BY LAW, MICROCHIP'S TOTAL LIABILITY ON ALL 
42:                CLAIMS IN ANY WAY RELATED TO THIS SOFTWARE WILL NOT EXCEED THE AMOUNT 
43:                OF FEES, IF ANY, THAT YOU HAVE PAID DIRECTLY TO MICROCHIP FOR THIS 
44:                SOFTWARE.
45:             */
46:            
47:            /**
48:              Section: Included Files
49:             */
50:            #include <xc.h>
51:            #include "uart5.h"
52:            #include "interrupt_manager.h"
53:            
54:            #define IO_RB6_Toggle()             do { LATBbits.LATB6 = ~LATBbits.LATB6; } while(0)
55:            #define TRACE
56:            
57:            #ifdef TRACE
58:            #define INT_TRACE	IO_RB6_Toggle()
59:            #else
60:            #define INT_TRACE	""
61:            #endif
62:            
63:            /**
64:              Section: Macro Declarations
65:             */
66:            #define UART5_TX_BUFFER_SIZE 64
67:            #define UART5_RX_BUFFER_SIZE 8
68:            
69:            /**
70:              Section: Global Variables
71:             */
72:            
73:            static volatile uint8_t uart5TxHead = 0;
74:            static volatile uint8_t uart5TxTail = 0;
75:            static volatile uint8_t uart5TxBuffer[UART5_TX_BUFFER_SIZE];
76:            volatile uint8_t uart5TxBufferRemaining;
77:            
78:            static volatile uint8_t uart5RxHead = 0;
79:            static volatile uint8_t uart5RxTail = 0;
80:            static volatile uint8_t uart5RxBuffer[UART5_RX_BUFFER_SIZE];
81:            static volatile uart5_status_t uart5RxStatusBuffer[UART5_RX_BUFFER_SIZE];
82:            volatile uint8_t uart5RxCount;
83:            static volatile uart5_status_t uart5RxLastError;
84:            
85:            /**
86:              Section: UART5 APIs
87:             */
88:            void (*UART5_FramingErrorHandler)(void);
89:            void (*UART5_OverrunErrorHandler)(void);
90:            void (*UART5_ErrorHandler)(void);
91:            
92:            void UART5_DefaultFramingErrorHandler(void);
93:            void UART5_DefaultOverrunErrorHandler(void);
94:            void UART5_DefaultErrorHandler(void);
95:            
96:            void UART5_Initialize(void)
97:            {
98:            	// Disable interrupts before changing states
99:            	PIE13bits.U5RXIE = 0;
05D6  90AB     BCF 0xFAB, 0, ACCESS
100:           	UART5_SetRxInterruptHandler(UART5_Receive_ISR);
05D8  0E4E     MOVLW 0x4E
05DA  6EE6     MOVWF 0xFE6, ACCESS
05DC  0E02     MOVLW 0x2
05DE  6EE6     MOVWF 0xFE6, ACCESS
05E0  0E00     MOVLW 0x0
05E2  6EE6     MOVWF 0xFE6, ACCESS
05E4  EC39     CALL 0x2072, 0
05E6  F010     NOP
101:           	PIE13bits.U5TXIE = 0;
05E8  92AB     BCF 0xFAB, 1, ACCESS
102:           	UART5_SetTxInterruptHandler(UART5_Transmit_ISR);
05EA  0EF2     MOVLW 0xF2
05EC  6EE6     MOVWF 0xFE6, ACCESS
05EE  0E1E     MOVLW 0x1E
05F0  6EE6     MOVWF 0xFE6, ACCESS
05F2  0E00     MOVLW 0x0
05F4  6EE6     MOVWF 0xFE6, ACCESS
05F6  EC28     CALL 0x2050, 0
05F8  F010     NOP
103:           
104:           	// Set the UART5 module to the options selected in the user interface.
105:           
106:           	// P1L 0; 
107:           	U5P1L = 0x00;
05FA  0102     MOVLB 0x2
05FC  6BF1     CLRF DMAnDSAH, BANKED
108:           
109:           	// P2L 0; 
110:           	U5P2L = 0x00;
05FE  6BF3     CLRF DMAnSCNTH, BANKED
111:           
112:           	// P3L 0; 
113:           	U5P3L = 0x00;
0600  6BF5     CLRF DMAnSPTRH, BANKED
114:           
115:           	// BRGS high speed; MODE Asynchronous 8-bit mode; RXEN enabled; TXEN enabled; ABDEN disabled; 
116:           	U5CON0 = 0xB0;
0602  0EB0     MOVLW 0xB0
0604  6FF7     MOVWF DMAnSSZ, BANKED
117:           
118:           	// RXBIMD Set RXBKIF on rising RX input; BRKOVR disabled; WUE disabled; SENDB disabled; ON enabled; 
119:           	U5CON1 = 0x80;
0606  0E80     MOVLW 0x80
0608  6FF8     MOVWF DMAnSSZH, BANKED
120:           
121:           	// TXPOL not inverted; FLO off; RXPOL not inverted; RUNOVF RX input shifter stops all activity; STP Transmit 1Stop bit, receiver verifies first Stop bit; 
122:           	U5CON2 = 0x00;
060A  6BF9     CLRF DMAnSSA, BANKED
123:           
124:           	// BRGL 86; 
125:           	U5BRGL = 0x56;
060C  0E56     MOVLW 0x56
060E  6FFA     MOVWF DMAnSSAH, BANKED
126:           
127:           	// BRGH 0; 
128:           	U5BRGH = 0x00;
0610  6BFB     CLRF DMAnSSAU, BANKED
129:           
130:           	// STPMD in middle of first Stop bit; TXWRE No error; 
131:           	U5FIFO = 0x00;
0612  6BFC     CLRF DMAnCON0, BANKED
132:           
133:           	// ABDIF Auto-baud not enabled or not complete; WUIF WUE not enabled by software; ABDIE disabled; 
134:           	U5UIR = 0x00;
0614  6BFD     CLRF DMAnCON1, BANKED
135:           
136:           	// ABDOVF Not overflowed; TXCIF 0; RXBKIF No Break detected; RXFOIF not overflowed; CERIF No Checksum error; 
137:           	U5ERRIR = 0x00;
0616  6BFE     CLRF DMAnAIRQ, BANKED
138:           
139:           	// TXCIE disabled; FERIE disabled; TXMTIE disabled; ABDOVE disabled; CERIE disabled; RXFOIE disabled; PERIE disabled; RXBKIE disabled; 
140:           	U5ERRIE = 0x00;
0618  6BFF     CLRF DMAnSIRQ, BANKED
141:           
142:           
143:           	UART5_SetFramingErrorHandler(UART5_DefaultFramingErrorHandler);
061A  0EAC     MOVLW 0xAC
061C  6EE6     MOVWF 0xFE6, ACCESS
061E  0E27     MOVLW 0x27
0620  6EE6     MOVWF 0xFE6, ACCESS
0622  0E00     MOVLW 0x0
0624  6EE6     MOVWF 0xFE6, ACCESS
0626  EC5B     CALL 0x20B6, 0
0628  F010     NOP
144:           	UART5_SetOverrunErrorHandler(UART5_DefaultOverrunErrorHandler);
062A  0EAA     MOVLW 0xAA
062C  6EE6     MOVWF 0xFE6, ACCESS
062E  0E27     MOVLW 0x27
0630  6EE6     MOVWF 0xFE6, ACCESS
0632  0E00     MOVLW 0x0
0634  6EE6     MOVWF 0xFE6, ACCESS
0636  EC4A     CALL 0x2094, 0
0638  F010     NOP
145:           	UART5_SetErrorHandler(UART5_DefaultErrorHandler);
063A  0E7C     MOVLW 0x7C
063C  6EE6     MOVWF 0xFE6, ACCESS
063E  0E27     MOVLW 0x27
0640  6EE6     MOVWF 0xFE6, ACCESS
0642  0E00     MOVLW 0x0
0644  6EE6     MOVWF 0xFE6, ACCESS
0646  EC6C     CALL 0x20D8, 0
0648  F010     NOP
146:           
147:           	uart5RxLastError.status = 0;
064A  0106     MOVLB 0x6
064C  6B62     CLRF PMD2, BANKED
148:           
149:           	// initializing the driver state
150:           	uart5TxHead = 0;
064E  6A30     CLRF 0x30, ACCESS
151:           	uart5TxTail = 0;
0650  6A2F     CLRF 0x2F, ACCESS
152:           	uart5TxBufferRemaining = sizeof(uart5TxBuffer);
0652  0E40     MOVLW 0x40
0654  6E2E     MOVWF 0x2E, ACCESS
153:           	uart5RxHead = 0;
0656  6A2D     CLRF 0x2D, ACCESS
154:           	uart5RxTail = 0;
0658  6B64     CLRF PMD4, BANKED
155:           	uart5RxCount = 0;
065A  6B63     CLRF PMD3, BANKED
156:           
157:           	// enable receive interrupt
158:           	PIE13bits.U5RXIE = 1;
065C  80AB     BSF 0xFAB, 0, ACCESS
159:           }
065E  0012     RETURN 0
160:           
161:           bool UART5_is_rx_ready(void)
162:           {
163:           	return(uart5RxCount ? true : false);
164:           }
165:           
166:           bool UART5_is_tx_ready(void)
167:           {
168:           	return(uart5TxBufferRemaining ? true : false);
169:           }
170:           
171:           bool UART5_is_tx_done(void)
172:           {
173:           	return U5ERRIRbits.TXMTIF;
174:           }
175:           
176:           uart5_status_t UART5_get_last_status(void)
177:           {
178:           	return uart5RxLastError;
179:           }
180:           
181:           uint8_t UART5_Read(void)
182:           {
183:           	uint8_t readValue = 0;
184:           
185:           	while (0 == uart5RxCount) {
186:           	}
187:           
188:           	uart5RxLastError = uart5RxStatusBuffer[uart5RxTail];
189:           
190:           	readValue = uart5RxBuffer[uart5RxTail++];
191:           	if (sizeof(uart5RxBuffer) <= uart5RxTail) {
192:           		uart5RxTail = 0;
193:           	}
194:           	PIE13bits.U5RXIE = 0;
195:           	uart5RxCount--;
196:           	PIE13bits.U5RXIE = 1;
197:           
198:           	return readValue;
199:           }
200:           
201:           void UART5_Write(uint8_t txData)
202:           {
203:           	while (0 == uart5TxBufferRemaining) {
1B12  502E     MOVF 0x2E, W, ACCESS
1B14  B4D8     BTFSC 0xFD8, 2, ACCESS
1B16  D7FD     BRA UART5_Write
204:           	}
205:           
206:           	if (0 == PIE13bits.U5TXIE) {
1B18  B2AB     BTFSC 0xFAB, 1, ACCESS
1B1A  D004     BRA 0x1B24
207:           		U5TXB = txData;
1B1C  0EFF     MOVLW 0xFF
1B1E  C4E3     MOVFF PLUSW1, U5TXB
1B20  F2EF     NOP
208:           	} else {
1B22  D010     BRA 0x1B44
209:           		PIE13bits.U5TXIE = 0;
1B24  92AB     BCF 0xFAB, 1, ACCESS
210:           		uart5TxBuffer[uart5TxHead++] = txData;
1B26  0E00     MOVLW 0x0
1B28  2430     ADDWF 0x30, W, ACCESS
1B2A  6ED9     MOVWF 0xFD9, ACCESS
1B2C  6ADA     CLRF __end_of_UART2_tx_vect_isr, ACCESS
1B2E  0E0E     MOVLW 0xE
1B30  22DA     ADDWFC __end_of_UART2_tx_vect_isr, F, ACCESS
1B32  0EFF     MOVLW 0xFF
1B34  C4E3     MOVFF PLUSW1, INDF2
1B36  F4DF     NOP
1B38  2A30     INCF 0x30, F, ACCESS
211:           		if (sizeof(uart5TxBuffer) <= uart5TxHead) {
1B3A  0E3F     MOVLW 0x3F
1B3C  6430     CPFSGT 0x30, ACCESS
1B3E  D001     BRA 0x1B42
212:           			uart5TxHead = 0;
1B40  6A30     CLRF 0x30, ACCESS
213:           		}
214:           		uart5TxBufferRemaining--;
1B42  062E     DECF 0x2E, F, ACCESS
215:           	}
216:           	PIE13bits.U5TXIE = 1;
1B44  82AB     BSF 0xFAB, 1, ACCESS
217:           }
1B46  52E5     MOVF 0xFE5, F, ACCESS
1B46  52E5     MOVF 0xFE5, F, ACCESS
218:           
219:           void __interrupt(irq(U5TX), base(8)) UART5_tx_vect_isr()
1038  C4FA     MOVFF PCLATH, 0xAE5
220:           {
221:           	INT_TRACE; // GPIO interrupt scope trace
1044  ACBF     BTFSS 0xFBF, 6, ACCESS
1046  D002     BRA 0x104C
1048  0E01     MOVLW 0x1
104A  D001     BRA 0x104E
104C  0E00     MOVLW 0x0
104E  0AFF     XORLW 0xFF
1050  010A     MOVLB 0xA
1052  6FE4     MOVWF 0xE4, BANKED
1054  3BE4     SWAPF 0xE4, F, BANKED
1056  47E4     RLNCF 0xE4, F, BANKED
1058  47E4     RLNCF 0xE4, F, BANKED
105A  50BF     MOVF 0xFBF, W, ACCESS
105C  19E4     XORWF 0xE4, W, BANKED
105E  0BBF     ANDLW 0xBF
1060  19E4     XORWF 0xE4, W, BANKED
1062  6EBF     MOVWF 0xFBF, ACCESS
222:           	if (UART5_TxInterruptHandler) {
1064  0107     MOVLB 0x7
1066  51BD     MOVF DMA8PR, W, BANKED
1068  11BE     IORWF MAINPR, W, BANKED
106A  11BF     IORWF ISRPR, W, BANKED
106C  B4D8     BTFSC 0xFD8, 2, ACCESS
106E  D00C     BRA 0x1088
223:           		UART5_TxInterruptHandler();
1070  D801     RCALL 0x1074
1072  D00A     BRA 0x1088
1074  0005     PUSH
1076  6EFA     MOVWF 0xFFA, ACCESS
1078  51BD     MOVF DMA8PR, W, BANKED
107A  6EFD     MOVWF 0xFFD, ACCESS
107C  51BE     MOVF MAINPR, W, BANKED
107E  6EFE     MOVWF 0xFFE, ACCESS
1080  51BF     MOVF ISRPR, W, BANKED
1082  6EFF     MOVWF 0xFFF, ACCESS
1084  50FA     MOVF 0xFFA, W, ACCESS
1086  0012     RETURN 0
224:           	}
225:           }
1088  CAE6     MOVFF 0xAE6, PCLATU
1088  CAE6     MOVFF 0xAE6, PCLATU
1088  CAE6     MOVFF 0xAE6, PCLATU
1088  CAE6     MOVFF 0xAE6, PCLATU
1088  CAE6     MOVFF 0xAE6, PCLATU
226:           
227:           void __interrupt(irq(U5RX), base(8)) UART5_rx_vect_isr()
228:           {
229:           	INT_TRACE; // GPIO interrupt scope trace
0C96  ACBF     BTFSS 0xFBF, 6, ACCESS
0C98  D002     BRA 0xC9E
0C9A  0E01     MOVLW 0x1
0C9C  D001     BRA 0xCA0
0C9E  0E00     MOVLW 0x0
0CA0  0AFF     XORLW 0xFF
0CA2  010A     MOVLB 0xA
0CA4  6FE7     MOVWF 0xE7, BANKED
0CA6  3BE7     SWAPF 0xE7, F, BANKED
0CA8  47E7     RLNCF 0xE7, F, BANKED
0CAA  47E7     RLNCF 0xE7, F, BANKED
0CAC  50BF     MOVF 0xFBF, W, ACCESS
0CAE  19E7     XORWF 0xE7, W, BANKED
0CB0  0BBF     ANDLW 0xBF
0CB2  19E7     XORWF 0xE7, W, BANKED
0CB4  6EBF     MOVWF 0xFBF, ACCESS
230:           	if (UART5_RxInterruptHandler) {
0CB6  0107     MOVLB 0x7
0CB8  51C0     MOVF 0xC0, W, BANKED
0CBA  11C1     IORWF 0xC1, W, BANKED
0CBC  11C2     IORWF 0xC2, W, BANKED
0CBE  B4D8     BTFSC 0xFD8, 2, ACCESS
0CC0  D00C     BRA 0xCDA
231:           		UART5_RxInterruptHandler();
0CC2  D801     RCALL 0xCC6
0CC4  D00A     BRA 0xCDA
0CC6  0005     PUSH
0CC8  6EFA     MOVWF 0xFFA, ACCESS
0CCA  51C0     MOVF 0xC0, W, BANKED
0CCC  6EFD     MOVWF 0xFFD, ACCESS
0CCE  51C1     MOVF 0xC1, W, BANKED
0CD0  6EFE     MOVWF 0xFFE, ACCESS
0CD2  51C2     MOVF 0xC2, W, BANKED
0CD4  6EFF     MOVWF 0xFFF, ACCESS
0CD6  50FA     MOVF 0xFFA, W, ACCESS
0CD8  0012     RETURN 0
232:           	}
233:           }
0CDA  0062     MOVFFL 0xAEA, 0x50C
234:           
235:           void UART5_Transmit_ISR(void)
236:           {
237:           	// use this default transmit interrupt handler code
238:           	if (sizeof(uart5TxBuffer) > uart5TxBufferRemaining) {
1EF2  0E40     MOVLW 0x40
1EF4  602E     CPFSLT 0x2E, ACCESS
1EF6  D010     BRA 0x1F18
239:           		U5TXB = uart5TxBuffer[uart5TxTail++];
1EF8  0E00     MOVLW 0x0
1EFA  242F     ADDWF 0x2F, W, ACCESS
1EFC  6ED9     MOVWF 0xFD9, ACCESS
1EFE  6ADA     CLRF __end_of_UART2_tx_vect_isr, ACCESS
1F00  0E0E     MOVLW 0xE
1F02  22DA     ADDWFC __end_of_UART2_tx_vect_isr, F, ACCESS
1F04  50DF     MOVF 0xFDF, W, ACCESS
1F06  0102     MOVLB 0x2
1F08  6FEF     MOVWF DMAnDSZH, BANKED
1F0A  2A2F     INCF 0x2F, F, ACCESS
240:           		if (sizeof(uart5TxBuffer) <= uart5TxTail) {
1F0C  0E3F     MOVLW 0x3F
1F0E  642F     CPFSGT 0x2F, ACCESS
1F10  D001     BRA 0x1F14
241:           			uart5TxTail = 0;
1F12  6A2F     CLRF 0x2F, ACCESS
242:           		}
243:           		uart5TxBufferRemaining++;
1F14  2A2E     INCF 0x2E, F, ACCESS
244:           	} else {
1F16  0012     RETURN 0
245:           		PIE13bits.U5TXIE = 0;
1F18  92AB     BCF 0xFAB, 1, ACCESS
246:           	}
247:           
248:           	// or set custom function using UART5_SetTxInterruptHandler()
249:           }
0C84  C4FA     MOVFF PCLATH, 0xAE8
0C86  FAE8     NOP
0C88  C4FB     MOVFF PCLATU, 0xAE9
0C8A  FAE9     NOP
0C8C  0061     MOVFFL 0x50C, 0xAEA
0C8E  F430     NOP
0C90  FAEA     NOP
0C92  EE17     LFSR 1, 0x1FAA
0C94  F3AA     NOP
1F1A  0012     RETURN 0
250:           
251:           void UART5_Receive_ISR(void)
252:           {
253:           	// use this default receive interrupt handler code
254:           	uart5RxStatusBuffer[uart5RxHead].status = 0;
024E  0E0A     MOVLW 0xA
0250  242D     ADDWF 0x2D, W, ACCESS
0252  6ED9     MOVWF 0xFD9, ACCESS
0254  6ADA     CLRF __end_of_UART2_tx_vect_isr, ACCESS
0256  0E07     MOVLW 0x7
0258  22DA     ADDWFC __end_of_UART2_tx_vect_isr, F, ACCESS
025A  6ADF     CLRF 0xFDF, ACCESS
255:           
256:           	if (U5ERRIRbits.FERIF) {
025C  0102     MOVLB 0x2
025E  A7FE     BTFSS DMAnAIRQ, 3, BANKED
0260  D014     BRA 0x28A
257:           		uart5RxStatusBuffer[uart5RxHead].ferr = 1;
0262  0E0A     MOVLW 0xA
0264  242D     ADDWF 0x2D, W, ACCESS
0266  6ED9     MOVWF 0xFD9, ACCESS
0268  6ADA     CLRF __end_of_UART2_tx_vect_isr, ACCESS
026A  0E07     MOVLW 0x7
026C  22DA     ADDWFC __end_of_UART2_tx_vect_isr, F, ACCESS
026E  0107     MOVLB 0x7
0270  82DF     BSF 0xFDF, 1, ACCESS
258:           		UART5_FramingErrorHandler();
0272  D801     RCALL 0x276
0274  D00A     BRA 0x28A
0276  0005     PUSH
0278  6EFA     MOVWF 0xFFA, ACCESS
027A  5196     MOVF SPI2BAUD, W, BANKED
027C  6EFD     MOVWF 0xFFD, ACCESS
027E  5197     MOVF SPI2INTF, W, BANKED
0280  6EFE     MOVWF 0xFFE, ACCESS
0282  5198     MOVF SPI2INTE, W, BANKED
0284  6EFF     MOVWF 0xFFF, ACCESS
0286  50FA     MOVF 0xFFA, W, ACCESS
0288  0012     RETURN 0
259:           	}
260:           
261:           	if (U5ERRIRbits.RXFOIF) {
028A  0102     MOVLB 0x2
028C  A3FE     BTFSS DMAnAIRQ, 1, BANKED
028E  D014     BRA 0x2B8
262:           		uart5RxStatusBuffer[uart5RxHead].oerr = 1;
0290  0E0A     MOVLW 0xA
0292  242D     ADDWF 0x2D, W, ACCESS
0294  6ED9     MOVWF 0xFD9, ACCESS
0296  6ADA     CLRF __end_of_UART2_tx_vect_isr, ACCESS
0298  0E07     MOVLW 0x7
029A  22DA     ADDWFC __end_of_UART2_tx_vect_isr, F, ACCESS
029C  0107     MOVLB 0x7
029E  84DF     BSF 0xFDF, 2, ACCESS
263:           		UART5_OverrunErrorHandler();
02A0  D801     RCALL 0x2A4
02A2  D00A     BRA 0x2B8
02A4  0005     PUSH
02A6  6EFA     MOVWF 0xFFA, ACCESS
02A8  5193     MOVF SPI2CON2, W, BANKED
02AA  6EFD     MOVWF 0xFFD, ACCESS
02AC  5194     MOVF SPI2STATUS, W, BANKED
02AE  6EFE     MOVWF 0xFFE, ACCESS
02B0  5195     MOVF SPI2TWIDTH, W, BANKED
02B2  6EFF     MOVWF 0xFFF, ACCESS
02B4  50FA     MOVF 0xFFA, W, ACCESS
02B6  0012     RETURN 0
264:           	}
265:           
266:           	if (uart5RxStatusBuffer[uart5RxHead].status) {
02B8  0E0A     MOVLW 0xA
02BA  242D     ADDWF 0x2D, W, ACCESS
02BC  6ED9     MOVWF 0xFD9, ACCESS
02BE  6ADA     CLRF __end_of_UART2_tx_vect_isr, ACCESS
02C0  0E07     MOVLW 0x7
02C2  22DA     ADDWFC __end_of_UART2_tx_vect_isr, F, ACCESS
02C4  50DF     MOVF 0xFDF, W, ACCESS
02C6  B4D8     BTFSC 0xFD8, 2, ACCESS
02C8  D00D     BRA 0x2E4
267:           		UART5_ErrorHandler();
02CA  D801     RCALL 0x2CE
02CC  0012     RETURN 0
02CE  0005     PUSH
02D0  6EFA     MOVWF 0xFFA, ACCESS
02D2  0107     MOVLB 0x7
02D4  5190     MOVF SPI2TCNTH, W, BANKED
02D6  6EFD     MOVWF 0xFFD, ACCESS
02D8  5191     MOVF SPI2CON0, W, BANKED
02DA  6EFE     MOVWF 0xFFE, ACCESS
02DC  5192     MOVF SPI2CON1, W, BANKED
02DE  6EFF     MOVWF 0xFFF, ACCESS
02E0  50FA     MOVF 0xFFA, W, ACCESS
02E2  0012     RETURN 0
268:           	} else {
269:           		UART5_RxDataHandler();
02E4  EC47     CALL 0x248E, 0
02E6  F012     NOP
270:           	}
271:           
272:           	// or set custom function using UART5_SetRxInterruptHandler()
273:           }
02E8  0012     RETURN 0
274:           
275:           void UART5_RxDataHandler(void)
276:           {
277:           	// use this default receive interrupt handler code
278:           	uart5RxBuffer[uart5RxHead++] = U5RXB;
248E  0E12     MOVLW 0x12
2490  242D     ADDWF 0x2D, W, ACCESS
2492  6ED9     MOVWF 0xFD9, ACCESS
2494  6ADA     CLRF __end_of_UART2_tx_vect_isr, ACCESS
2496  0E07     MOVLW 0x7
2498  22DA     ADDWFC __end_of_UART2_tx_vect_isr, F, ACCESS
249A  C2ED     MOVFF U5RXB, INDF2
249C  F4DF     NOP
249E  2A2D     INCF 0x2D, F, ACCESS
279:           	if (sizeof(uart5RxBuffer) <= uart5RxHead) {
24A0  0E07     MOVLW 0x7
24A2  642D     CPFSGT 0x2D, ACCESS
24A4  D001     BRA 0x24A8
280:           		uart5RxHead = 0;
24A6  6A2D     CLRF 0x2D, ACCESS
281:           	}
282:           	uart5RxCount++;
24A8  0106     MOVLB 0x6
24AA  2B63     INCF PMD3, F, BANKED
283:           }
24AC  0012     RETURN 0
284:           
285:           void UART5_DefaultFramingErrorHandler(void)
286:           {
287:           }
27AC  0012     RETURN 0
288:           
289:           void UART5_DefaultOverrunErrorHandler(void)
290:           {
291:           }
27AA  0012     RETURN 0
292:           
293:           void UART5_DefaultErrorHandler(void)
294:           {
295:           	UART5_RxDataHandler();
277C  EC47     CALL 0x248E, 0
277E  F012     NOP
296:           }
2780  0012     RETURN 0
297:           
298:           void UART5_SetFramingErrorHandler(void (* interruptHandler)(void))
299:           {
300:           	UART5_FramingErrorHandler = interruptHandler;
20B6  50E1     MOVF 0xFE1, W, ACCESS
20B8  0FFD     ADDLW 0xFD
20BA  6ED9     MOVWF 0xFD9, ACCESS
20BC  50E2     MOVF 0xFE2, W, ACCESS
20BE  6EDA     MOVWF __end_of_UART2_tx_vect_isr, ACCESS
20C0  0EFF     MOVLW 0xFF
20C2  22DA     ADDWFC __end_of_UART2_tx_vect_isr, F, ACCESS
20C4  C4DE     MOVFF POSTINC2, UART5_FramingErrorHandler
20C6  F796     NOP
20C8  C4DE     MOVFF POSTINC2, 0x797
20CA  F797     NOP
20CC  C4DD     MOVFF POSTDEC2, 0x798
20CE  F798     NOP
301:           }
20D0  52E5     MOVF 0xFE5, F, ACCESS
20D0  52E5     MOVF 0xFE5, F, ACCESS
20D0  52E5     MOVF 0xFE5, F, ACCESS
20D0  52E5     MOVF 0xFE5, F, ACCESS
302:           
303:           void UART5_SetOverrunErrorHandler(void (* interruptHandler)(void))
304:           {
305:           	UART5_OverrunErrorHandler = interruptHandler;
2094  50E1     MOVF 0xFE1, W, ACCESS
2096  0FFD     ADDLW 0xFD
2098  6ED9     MOVWF 0xFD9, ACCESS
209A  50E2     MOVF 0xFE2, W, ACCESS
209C  6EDA     MOVWF __end_of_UART2_tx_vect_isr, ACCESS
209E  0EFF     MOVLW 0xFF
20A0  22DA     ADDWFC __end_of_UART2_tx_vect_isr, F, ACCESS
20A2  C4DE     MOVFF POSTINC2, UART5_OverrunErrorHandler
20A4  F793     NOP
20A6  C4DE     MOVFF POSTINC2, 0x794
20A8  F794     NOP
20AA  C4DD     MOVFF POSTDEC2, 0x795
20AC  F795     NOP
306:           }
20AE  52E5     MOVF 0xFE5, F, ACCESS
20AE  52E5     MOVF 0xFE5, F, ACCESS
20AE  52E5     MOVF 0xFE5, F, ACCESS
20AE  52E5     MOVF 0xFE5, F, ACCESS
307:           
308:           void UART5_SetErrorHandler(void (* interruptHandler)(void))
309:           {
310:           	UART5_ErrorHandler = interruptHandler;
20D8  50E1     MOVF 0xFE1, W, ACCESS
20DA  0FFD     ADDLW 0xFD
20DC  6ED9     MOVWF 0xFD9, ACCESS
20DE  50E2     MOVF 0xFE2, W, ACCESS
20E0  6EDA     MOVWF __end_of_UART2_tx_vect_isr, ACCESS
20E2  0EFF     MOVLW 0xFF
20E4  22DA     ADDWFC __end_of_UART2_tx_vect_isr, F, ACCESS
20E6  C4DE     MOVFF POSTINC2, UART5_ErrorHandler
20E8  F790     NOP
20EA  C4DE     MOVFF POSTINC2, 0x791
20EC  F791     NOP
20EE  C4DD     MOVFF POSTDEC2, 0x792
20F0  F792     NOP
311:           }
20F2  52E5     MOVF 0xFE5, F, ACCESS
20F2  52E5     MOVF 0xFE5, F, ACCESS
20F2  52E5     MOVF 0xFE5, F, ACCESS
20F2  52E5     MOVF 0xFE5, F, ACCESS
312:           
313:           void UART5_SetRxInterruptHandler(void (* InterruptHandler)(void))
314:           {
315:           	UART5_RxInterruptHandler = InterruptHandler;
2072  50E1     MOVF 0xFE1, W, ACCESS
2074  0FFD     ADDLW 0xFD
2076  6ED9     MOVWF 0xFD9, ACCESS
2078  50E2     MOVF 0xFE2, W, ACCESS
207A  6EDA     MOVWF __end_of_UART2_tx_vect_isr, ACCESS
207C  0EFF     MOVLW 0xFF
207E  22DA     ADDWFC __end_of_UART2_tx_vect_isr, F, ACCESS
2080  C4DE     MOVFF POSTINC2, UART5_RxInterruptHandler
2082  F7C0     NOP
2084  C4DE     MOVFF POSTINC2, 0x7C1
2086  F7C1     NOP
2088  C4DD     MOVFF POSTDEC2, 0x7C2
208A  F7C2     NOP
316:           }
208C  52E5     MOVF 0xFE5, F, ACCESS
208C  52E5     MOVF 0xFE5, F, ACCESS
208C  52E5     MOVF 0xFE5, F, ACCESS
208C  52E5     MOVF 0xFE5, F, ACCESS
317:           
318:           void UART5_SetTxInterruptHandler(void (* InterruptHandler)(void))
319:           {
320:           	UART5_TxInterruptHandler = InterruptHandler;
2050  50E1     MOVF 0xFE1, W, ACCESS
2052  0FFD     ADDLW 0xFD
2054  6ED9     MOVWF 0xFD9, ACCESS
2056  50E2     MOVF 0xFE2, W, ACCESS
2058  6EDA     MOVWF __end_of_UART2_tx_vect_isr, ACCESS
205A  0EFF     MOVLW 0xFF
205C  22DA     ADDWFC __end_of_UART2_tx_vect_isr, F, ACCESS
205E  C4DE     MOVFF POSTINC2, UART5_TxInterruptHandler
2060  F7BD     NOP
2062  C4DE     MOVFF POSTINC2, 0x7BE
2064  F7BE     NOP
2066  C4DD     MOVFF POSTDEC2, 0x7BF
2068  F7BF     NOP
321:           }
206A  52E5     MOVF 0xFE5, F, ACCESS
206A  52E5     MOVF 0xFE5, F, ACCESS
206A  52E5     MOVF 0xFE5, F, ACCESS
206A  52E5     MOVF 0xFE5, F, ACCESS
322:           
323:           
324:           /**
325:             End of File
326:            */
---  /public/Q84vtouch/mateQ84.X/mcc_generated_files/uart2.c  -------------------------------------------
1:             /**
2:               UART2 Generated Driver File
3:             
4:               @Company
5:                 Microchip Technology Inc.
6:             
7:               @File Name
8:                 uart2.c
9:             
10:              @Summary
11:                This is the generated driver implementation file for the UART2 driver using PIC10 / PIC12 / PIC16 / PIC18 MCUs
12:            
13:              @Description
14:                This source file provides APIs for UART2.
15:                Generation Information :
16:            	Product Revision  :  PIC10 / PIC12 / PIC16 / PIC18 MCUs - 1.81.8
17:            	Device            :  PIC18F47Q84
18:            	Driver Version    :  2.4.1
19:                The generated drivers are tested against the following:
20:            	Compiler          :  XC8 2.36 and above
21:            	MPLAB             :  MPLAB X 6.00
22:             */
23:            
24:            /*
25:                (c) 2018 Microchip Technology Inc. and its subsidiaries. 
26:                
27:                Subject to your compliance with these terms, you may use Microchip software and any 
28:                derivatives exclusively with Microchip products. It is your responsibility to comply with third party 
29:                license terms applicable to your use of third party software (including open source software) that 
30:                may accompany Microchip software.
31:                
32:                THIS SOFTWARE IS SUPPLIED BY MICROCHIP "AS IS". NO WARRANTIES, WHETHER 
33:                EXPRESS, IMPLIED OR STATUTORY, APPLY TO THIS SOFTWARE, INCLUDING ANY 
34:                IMPLIED WARRANTIES OF NON-INFRINGEMENT, MERCHANTABILITY, AND FITNESS 
35:                FOR A PARTICULAR PURPOSE.
36:                
37:                IN NO EVENT WILL MICROCHIP BE LIABLE FOR ANY INDIRECT, SPECIAL, PUNITIVE, 
38:                INCIDENTAL OR CONSEQUENTIAL LOSS, DAMAGE, COST OR EXPENSE OF ANY KIND 
39:                WHATSOEVER RELATED TO THE SOFTWARE, HOWEVER CAUSED, EVEN IF MICROCHIP 
40:                HAS BEEN ADVISED OF THE POSSIBILITY OR THE DAMAGES ARE FORESEEABLE. TO 
41:                THE FULLEST EXTENT ALLOWED BY LAW, MICROCHIP'S TOTAL LIABILITY ON ALL 
42:                CLAIMS IN ANY WAY RELATED TO THIS SOFTWARE WILL NOT EXCEED THE AMOUNT 
43:                OF FEES, IF ANY, THAT YOU HAVE PAID DIRECTLY TO MICROCHIP FOR THIS 
44:                SOFTWARE.
45:             */
46:            
47:            /**
48:              Section: Included Files
49:             */
50:            #include <xc.h>
51:            #include "uart2.h"
52:            #include "interrupt_manager.h"
53:            
54:            #define IO_RB6_Toggle()             do { LATBbits.LATB6 = ~LATBbits.LATB6; } while(0)
55:            #define TRACE
56:            
57:            #ifdef TRACE
58:            #define INT_TRACE	IO_RB6_Toggle()
59:            #else
60:            #define INT_TRACE	""
61:            #endif
62:            
63:            /**
64:              Section: Macro Declarations
65:             */
66:            #define UART2_TX_BUFFER_SIZE 64
67:            #define UART2_RX_BUFFER_SIZE 64
68:            
69:            /**
70:              Section: Global Variables
71:             */
72:            
73:            static volatile uint8_t uart2TxHead = 0;
74:            static volatile uint8_t uart2TxTail = 0;
75:            static volatile uint8_t uart2TxBuffer[UART2_TX_BUFFER_SIZE];
76:            volatile uint8_t uart2TxBufferRemaining;
77:            
78:            static volatile uint8_t uart2RxHead = 0;
79:            static volatile uint8_t uart2RxTail = 0;
80:            static volatile uint8_t uart2RxBuffer[UART2_RX_BUFFER_SIZE];
81:            static volatile uart2_status_t uart2RxStatusBuffer[UART2_RX_BUFFER_SIZE];
82:            volatile uint8_t uart2RxCount;
83:            static volatile uart2_status_t uart2RxLastError;
84:            
85:            /**
86:              Section: UART2 APIs
87:             */
88:            void (*UART2_FramingErrorHandler)(void);
89:            void (*UART2_OverrunErrorHandler)(void);
90:            void (*UART2_ErrorHandler)(void);
91:            
92:            void UART2_DefaultFramingErrorHandler(void);
93:            void UART2_DefaultOverrunErrorHandler(void);
94:            void UART2_DefaultErrorHandler(void);
95:            
96:            void UART2_Initialize(void)
97:            {
98:            	// Disable interrupts before changing states
99:            	PIE8bits.U2RXIE = 0;
0546  90A6     BCF 0xFA6, 0, ACCESS
100:           	UART2_SetRxInterruptHandler(UART2_Receive_ISR);
0548  0E12     MOVLW 0x12
054A  6EE6     MOVWF 0xFE6, ACCESS
054C  0E01     MOVLW 0x1
054E  6EE6     MOVWF 0xFE6, ACCESS
0550  0E00     MOVLW 0x0
0552  6EE6     MOVWF 0xFE6, ACCESS
0554  EC8E     CALL 0x211C, 0
0556  F010     NOP
101:           	PIE8bits.U2TXIE = 0;
0558  92A6     BCF 0xFA6, 1, ACCESS
102:           	UART2_SetTxInterruptHandler(UART2_Transmit_ISR);
055A  0EC8     MOVLW 0xC8
055C  6EE6     MOVWF 0xFE6, ACCESS
055E  0E1E     MOVLW 0x1E
0560  6EE6     MOVWF 0xFE6, ACCESS
0562  0E00     MOVLW 0x0
0564  6EE6     MOVWF 0xFE6, ACCESS
0566  EC7D     CALL 0x20FA, 0
0568  F010     NOP
103:           
104:           	// Set the UART2 module to the options selected in the user interface.
105:           
106:           	// P1L 0; 
107:           	U2P1L = 0x00;
056A  0102     MOVLB 0x2
056C  6BB8     CLRF DMA3PR, BANKED
108:           
109:           	// P1H 0; 
110:           	U2P1H = 0x00;
056E  6BB9     CLRF DMA4PR, BANKED
111:           
112:           	// P2L 0; 
113:           	U2P2L = 0x00;
0570  6BBA     CLRF DMA5PR, BANKED
114:           
115:           	// P2H 0; 
116:           	U2P2H = 0x00;
0572  6BBB     CLRF DMA6PR, BANKED
117:           
118:           	// P3L 0; 
119:           	U2P3L = 0x00;
0574  6BBC     CLRF DMA7PR, BANKED
120:           
121:           	// P3H 0; 
122:           	U2P3H = 0x00;
0576  6BBD     CLRF DMA8PR, BANKED
123:           
124:           	// BRGS high speed; MODE Asynchronous 8-bit mode; RXEN enabled; TXEN enabled; ABDEN disabled; 
125:           	U2CON0 = 0xB0;
0578  0EB0     MOVLW 0xB0
057A  6FBE     MOVWF MAINPR, BANKED
126:           
127:           	// RXBIMD Set RXBKIF on rising RX input; BRKOVR disabled; WUE disabled; SENDB disabled; ON enabled; 
128:           	U2CON1 = 0x80;
057C  0E80     MOVLW 0x80
057E  6FBF     MOVWF ISRPR, BANKED
129:           
130:           	// TXPOL not inverted; FLO off; C0EN Checksum Mode 0; RXPOL not inverted; RUNOVF RX input shifter stops all activity; STP Transmit 1Stop bit, receiver verifies first Stop bit; 
131:           	U2CON2 = 0x00;
0580  6BC0     CLRF 0xC0, BANKED
132:           
133:           	// BRGL 86; 
134:           	U2BRGL = 0x56;
0582  0E56     MOVLW 0x56
0584  6FC1     MOVWF 0xC1, BANKED
135:           
136:           	// BRGH 0; 
137:           	U2BRGH = 0x00;
0586  6BC2     CLRF 0xC2, BANKED
138:           
139:           	// STPMD in middle of first Stop bit; TXWRE No error; 
140:           	U2FIFO = 0x00;
0588  6BC3     CLRF 0xC3, BANKED
141:           
142:           	// ABDIF Auto-baud not enabled or not complete; WUIF WUE not enabled by software; ABDIE disabled; 
143:           	U2UIR = 0x00;
058A  6BC4     CLRF 0xC4, BANKED
144:           
145:           	// ABDOVF Not overflowed; TXCIF 0; RXBKIF No Break detected; RXFOIF not overflowed; CERIF No Checksum error; 
146:           	U2ERRIR = 0x00;
058C  6BC5     CLRF 0xC5, BANKED
147:           
148:           	// TXCIE disabled; FERIE disabled; TXMTIE disabled; ABDOVE disabled; CERIE disabled; RXFOIE disabled; PERIE disabled; RXBKIE disabled; 
149:           	U2ERRIE = 0x00;
058E  6BC6     CLRF 0xC6, BANKED
150:           
151:           
152:           	UART2_SetFramingErrorHandler(UART2_DefaultFramingErrorHandler);
0590  0E9E     MOVLW 0x9E
0592  6EE6     MOVWF 0xFE6, ACCESS
0594  0E27     MOVLW 0x27
0596  6EE6     MOVWF 0xFE6, ACCESS
0598  0E00     MOVLW 0x0
059A  6EE6     MOVWF 0xFE6, ACCESS
059C  ECB0     CALL 0x2160, 0
059E  F010     NOP
153:           	UART2_SetOverrunErrorHandler(UART2_DefaultOverrunErrorHandler);
05A0  0E9C     MOVLW 0x9C
05A2  6EE6     MOVWF 0xFE6, ACCESS
05A4  0E27     MOVLW 0x27
05A6  6EE6     MOVWF 0xFE6, ACCESS
05A8  0E00     MOVLW 0x0
05AA  6EE6     MOVWF 0xFE6, ACCESS
05AC  EC9F     CALL 0x213E, 0
05AE  F010     NOP
154:           	UART2_SetErrorHandler(UART2_DefaultErrorHandler);
05B0  0E76     MOVLW 0x76
05B2  6EE6     MOVWF 0xFE6, ACCESS
05B4  0E27     MOVLW 0x27
05B6  6EE6     MOVWF 0xFE6, ACCESS
05B8  0E00     MOVLW 0x0
05BA  6EE6     MOVWF 0xFE6, ACCESS
05BC  ECC1     CALL 0x2182, 0
05BE  F010     NOP
155:           
156:           	uart2RxLastError.status = 0;
05C0  0106     MOVLB 0x6
05C2  6B66     CLRF PMD6, BANKED
157:           
158:           	// initializing the driver state
159:           	uart2TxHead = 0;
05C4  6A36     CLRF 0x36, ACCESS
160:           	uart2TxTail = 0;
05C6  6A35     CLRF 0x35, ACCESS
161:           	uart2TxBufferRemaining = sizeof(uart2TxBuffer);
05C8  0E40     MOVLW 0x40
05CA  6E34     MOVWF 0x34, ACCESS
162:           	uart2RxHead = 0;
05CC  6A33     CLRF 0x33, ACCESS
163:           	uart2RxTail = 0;
05CE  6A32     CLRF 0x32, ACCESS
164:           	uart2RxCount = 0;
05D0  6A31     CLRF 0x31, ACCESS
165:           
166:           	// enable receive interrupt
167:           	PIE8bits.U2RXIE = 1;
05D2  80A6     BSF 0xFA6, 0, ACCESS
168:           }
05D4  0012     RETURN 0
169:           
170:           bool UART2_is_rx_ready(void)
171:           {
172:           	return(uart2RxCount ? true : false);
2672  5031     MOVF 0x31, W, ACCESS
2674  B4D8     BTFSC 0xFD8, 2, ACCESS
2676  D003     BRA 0x267E
2678  6A01     CLRF __ptext283, ACCESS
267A  2A01     INCF __ptext283, F, ACCESS
267C  0012     RETURN 0
267E  6A01     CLRF __ptext283, ACCESS
173:           }
2680  0012     RETURN 0
174:           
175:           bool UART2_is_tx_ready(void)
176:           {
177:           	return(uart2TxBufferRemaining ? true : false);
178:           }
179:           
180:           bool UART2_is_tx_done(void)
181:           {
182:           	return U2ERRIRbits.TXMTIF;
183:           }
184:           
185:           uart2_status_t UART2_get_last_status(void)
186:           {
187:           	return uart2RxLastError;
188:           }
189:           
190:           uint8_t UART2_Read(void)
131C  52E6     MOVF 0xFE6, F, ACCESS
191:           {
192:           	uint8_t readValue = 0;
193:           
194:           	while (0 == uart2RxCount) {
131E  5031     MOVF 0x31, W, ACCESS
1320  B4D8     BTFSC 0xFD8, 2, ACCESS
1322  D7FD     BRA 0x131E
195:           	}
196:           
197:           	uart2RxLastError = uart2RxStatusBuffer[uart2RxTail];
1324  0E00     MOVLW 0x0
1326  2432     ADDWF 0x32, W, ACCESS
1328  6ED9     MOVWF 0xFD9, ACCESS
132A  6ADA     CLRF __end_of_UART2_tx_vect_isr, ACCESS
132C  0E0A     MOVLW 0xA
132E  22DA     ADDWFC __end_of_UART2_tx_vect_isr, F, ACCESS
1330  50DF     MOVF 0xFDF, W, ACCESS
1332  0106     MOVLB 0x6
1334  6F66     MOVWF PMD6, BANKED
198:           
199:           	readValue = uart2RxBuffer[uart2RxTail++];
1336  0E40     MOVLW 0x40
1338  2432     ADDWF 0x32, W, ACCESS
133A  6ED9     MOVWF 0xFD9, ACCESS
133C  6ADA     CLRF __end_of_UART2_tx_vect_isr, ACCESS
133E  0E0E     MOVLW 0xE
1340  22DA     ADDWFC __end_of_UART2_tx_vect_isr, F, ACCESS
1342  50DF     MOVF 0xFDF, W, ACCESS
1344  6E0C     MOVWF 0xC, ACCESS
1346  0EFF     MOVLW 0xFF
1348  0061     MOVFFL 0x50C, PLUSW1
134A  F430     NOP
134C  F4E3     NOP
134E  2A32     INCF 0x32, F, ACCESS
200:           	if (sizeof(uart2RxBuffer) <= uart2RxTail) {
1350  0E3F     MOVLW 0x3F
1352  6432     CPFSGT 0x32, ACCESS
1354  D001     BRA 0x1358
201:           		uart2RxTail = 0;
1356  6A32     CLRF 0x32, ACCESS
202:           	}
203:           	PIE8bits.U2RXIE = 0;
1358  90A6     BCF 0xFA6, 0, ACCESS
204:           	uart2RxCount--;
135A  0631     DECF 0x31, F, ACCESS
205:           	PIE8bits.U2RXIE = 1;
135C  80A6     BSF 0xFA6, 0, ACCESS
206:           
207:           	return readValue;
135E  0EFF     MOVLW 0xFF
1360  0061     MOVFFL PLUSW1, ltemp0
1362  F38C     NOP
1364  F501     NOP
208:           }
1366  52E5     MOVF 0xFE5, F, ACCESS
1366  52E5     MOVF 0xFE5, F, ACCESS
209:           
210:           void UART2_Write(uint8_t txData)
211:           {
212:           	while (0 == uart2TxBufferRemaining) {
1A6A  5034     MOVF 0x34, W, ACCESS
1A6C  B4D8     BTFSC 0xFD8, 2, ACCESS
1A6E  D7FD     BRA UART2_Write
213:           	}
214:           
215:           	if (0 == PIE8bits.U2TXIE) {
1A70  B2A6     BTFSC 0xFA6, 1, ACCESS
1A72  D004     BRA 0x1A7C
216:           		U2TXB = txData;
1A74  0EFF     MOVLW 0xFF
1A76  C4E3     MOVFF PLUSW1, U2TXB
1A78  F2B6     NOP
217:           	} else {
1A7A  D010     BRA 0x1A9C
218:           		PIE8bits.U2TXIE = 0;
1A7C  92A6     BCF 0xFA6, 1, ACCESS
219:           		uart2TxBuffer[uart2TxHead++] = txData;
1A7E  0E00     MOVLW 0x0
1A80  2436     ADDWF 0x36, W, ACCESS
1A82  6ED9     MOVWF 0xFD9, ACCESS
1A84  6ADA     CLRF __end_of_UART2_tx_vect_isr, ACCESS
1A86  0E0D     MOVLW 0xD
1A88  22DA     ADDWFC __end_of_UART2_tx_vect_isr, F, ACCESS
1A8A  0EFF     MOVLW 0xFF
1A8C  C4E3     MOVFF PLUSW1, INDF2
1A8E  F4DF     NOP
1A90  2A36     INCF 0x36, F, ACCESS
220:           		if (sizeof(uart2TxBuffer) <= uart2TxHead) {
1A92  0E3F     MOVLW 0x3F
1A94  6436     CPFSGT 0x36, ACCESS
1A96  D001     BRA 0x1A9A
221:           			uart2TxHead = 0;
1A98  6A36     CLRF 0x36, ACCESS
222:           		}
223:           		uart2TxBufferRemaining--;
1A9A  0634     DECF 0x34, F, ACCESS
224:           	}
225:           	PIE8bits.U2TXIE = 1;
1A9C  82A6     BSF 0xFA6, 1, ACCESS
226:           }
1A9E  52E5     MOVF 0xFE5, F, ACCESS
1A9E  52E5     MOVF 0xFE5, F, ACCESS
227:           
228:           int getch(void)
229:           {
230:           	return UART2_Read();
231:           }
232:           
233:           void putch(char txData)
234:           {
235:           	UART2_Write(txData);
2692  0EFF     MOVLW 0xFF
2694  50E3     MOVF 0xFE3, W, ACCESS
2696  6EE6     MOVWF 0xFE6, ACCESS
2698  EC35     CALL 0x1A6A, 0
269A  F00D     NOP
236:           }
269C  52E5     MOVF 0xFE5, F, ACCESS
269C  52E5     MOVF 0xFE5, F, ACCESS
237:           
238:           void __interrupt(irq(U2TX), base(8)) UART2_tx_vect_isr()
0F80  C4FA     MOVFF PCLATH, 0x5C6
0F82  F5C6     NOP
0F84  C4FB     MOVFF PCLATU, 0x5C7
0F86  F5C7     NOP
0F88  EE17     LFSR 1, 0x1FAA
0F8A  F3AA     NOP
239:           {
240:           	INT_TRACE; // GPIO interrupt scope trace
0F8C  ACBF     BTFSS 0xFBF, 6, ACCESS
0F8E  D002     BRA 0xF94
0F90  0E01     MOVLW 0x1
0F92  D001     BRA 0xF96
0F94  0E00     MOVLW 0x0
0F96  0AFF     XORLW 0xFF
0F98  0105     MOVLB 0x5
0F9A  6FC5     MOVWF 0xC5, BANKED
0F9C  3BC5     SWAPF 0xC5, F, BANKED
0F9E  47C5     RLNCF 0xC5, F, BANKED
0FA0  47C5     RLNCF 0xC5, F, BANKED
0FA2  50BF     MOVF 0xFBF, W, ACCESS
0FA4  19C5     XORWF 0xC5, W, BANKED
0FA6  0BBF     ANDLW 0xBF
0FA8  19C5     XORWF 0xC5, W, BANKED
0FAA  6EBF     MOVWF 0xFBF, ACCESS
241:           	if (UART2_TxInterruptHandler) {
0FAC  0107     MOVLB 0x7
0FAE  51C3     MOVF 0xC3, W, BANKED
0FB0  11C4     IORWF 0xC4, W, BANKED
0FB2  11C5     IORWF 0xC5, W, BANKED
0FB4  B4D8     BTFSC 0xFD8, 2, ACCESS
0FB6  D00C     BRA 0xFD0
242:           		UART2_TxInterruptHandler();
0FB8  D801     RCALL 0xFBC
0FBA  D00A     BRA 0xFD0
0FBC  0005     PUSH
0FBE  6EFA     MOVWF 0xFFA, ACCESS
0FC0  51C3     MOVF 0xC3, W, BANKED
0FC2  6EFD     MOVWF 0xFFD, ACCESS
0FC4  51C4     MOVF 0xC4, W, BANKED
0FC6  6EFE     MOVWF 0xFFE, ACCESS
0FC8  51C5     MOVF 0xC5, W, BANKED
0FCA  6EFF     MOVWF 0xFFF, ACCESS
0FCC  50FA     MOVF 0xFFA, W, ACCESS
0FCE  0012     RETURN 0
243:           	}
244:           }
0FD0  C5C7     MOVFF 0x5C7, PCLATU
0FD0  C5C7     MOVFF 0x5C7, PCLATU
0FD0  C5C7     MOVFF 0x5C7, PCLATU
0FD0  C5C7     MOVFF 0x5C7, PCLATU
0FD0  C5C7     MOVFF 0x5C7, PCLATU
245:           
246:           void __interrupt(irq(U2RX), base(8)) UART2_rx_vect_isr()
247:           {
248:           	INT_TRACE; // GPIO interrupt scope trace
0FE8  ACBF     BTFSS 0xFBF, 6, ACCESS
0FEA  D002     BRA 0xFF0
0FEC  0E01     MOVLW 0x1
0FEE  D001     BRA 0xFF2
0FF0  0E00     MOVLW 0x0
0FF2  0AFF     XORLW 0xFF
0FF4  0105     MOVLB 0x5
0FF6  6FC8     MOVWF 0xC8, BANKED
0FF8  3BC8     SWAPF 0xC8, F, BANKED
0FFA  47C8     RLNCF 0xC8, F, BANKED
0FFC  47C8     RLNCF 0xC8, F, BANKED
0FFE  50BF     MOVF 0xFBF, W, ACCESS
1000  19C8     XORWF 0xC8, W, BANKED
1002  0BBF     ANDLW 0xBF
1004  19C8     XORWF 0xC8, W, BANKED
1006  6EBF     MOVWF 0xFBF, ACCESS
249:           	if (UART2_RxInterruptHandler) {
1008  0107     MOVLB 0x7
100A  51C6     MOVF 0xC6, W, BANKED
100C  11C7     IORWF 0xC7, W, BANKED
100E  11C8     IORWF 0xC8, W, BANKED
1010  B4D8     BTFSC 0xFD8, 2, ACCESS
1012  D00C     BRA 0x102C
250:           		UART2_RxInterruptHandler();
1014  D801     RCALL 0x1018
1016  D00A     BRA 0x102C
1018  0005     PUSH
101A  6EFA     MOVWF 0xFFA, ACCESS
101C  51C6     MOVF 0xC6, W, BANKED
101E  6EFD     MOVWF 0xFFD, ACCESS
1020  51C7     MOVF 0xC7, W, BANKED
1022  6EFE     MOVWF 0xFFE, ACCESS
1024  51C8     MOVF 0xC8, W, BANKED
1026  6EFF     MOVWF 0xFFF, ACCESS
1028  50FA     MOVF 0xFFA, W, ACCESS
102A  0012     RETURN 0
251:           	}
252:           }
102C  C5CA     MOVFF 0x5CA, PCLATU
253:           
254:           void UART2_Transmit_ISR(void)
255:           {
256:           	// use this default transmit interrupt handler code
257:           	if (sizeof(uart2TxBuffer) > uart2TxBufferRemaining) {
1EC8  0E40     MOVLW 0x40
1ECA  6034     CPFSLT 0x34, ACCESS
1ECC  D010     BRA 0x1EEE
258:           		U2TXB = uart2TxBuffer[uart2TxTail++];
1ECE  0E00     MOVLW 0x0
1ED0  2435     ADDWF 0x35, W, ACCESS
1ED2  6ED9     MOVWF 0xFD9, ACCESS
1ED4  6ADA     CLRF __end_of_UART2_tx_vect_isr, ACCESS
1ED6  0E0D     MOVLW 0xD
1ED8  22DA     ADDWFC __end_of_UART2_tx_vect_isr, F, ACCESS
1EDA  50DF     MOVF 0xFDF, W, ACCESS
1EDC  0102     MOVLB 0x2
1EDE  6FB6     MOVWF DMA1PR, BANKED
1EE0  2A35     INCF 0x35, F, ACCESS
259:           		if (sizeof(uart2TxBuffer) <= uart2TxTail) {
1EE2  0E3F     MOVLW 0x3F
1EE4  6435     CPFSGT 0x35, ACCESS
1EE6  D001     BRA 0x1EEA
260:           			uart2TxTail = 0;
1EE8  6A35     CLRF 0x35, ACCESS
261:           		}
262:           		uart2TxBufferRemaining++;
1EEA  2A34     INCF 0x34, F, ACCESS
263:           	} else {
1EEC  0012     RETURN 0
264:           		PIE8bits.U2TXIE = 0;
1EEE  92A6     BCF 0xFA6, 1, ACCESS
265:           	}
266:           
267:           	// or set custom function using UART2_SetTxInterruptHandler()
268:           }
0FDC  C4FA     MOVFF PCLATH, 0x5C9
0FDE  F5C9     NOP
0FE0  C4FB     MOVFF PCLATU, 0x5CA
0FE2  F5CA     NOP
0FE4  EE17     LFSR 1, 0x1FAA
0FE6  F3AA     NOP
1EF0  0012     RETURN 0
269:           
270:           void UART2_Receive_ISR(void)
271:           {
272:           	// use this default receive interrupt handler code
273:           	uart2RxStatusBuffer[uart2RxHead].status = 0;
0112  0E00     MOVLW 0x0
0114  2433     ADDWF 0x33, W, ACCESS
0116  6ED9     MOVWF 0xFD9, ACCESS
0118  6ADA     CLRF __end_of_UART2_tx_vect_isr, ACCESS
011A  0E0A     MOVLW 0xA
011C  22DA     ADDWFC __end_of_UART2_tx_vect_isr, F, ACCESS
011E  6ADF     CLRF 0xFDF, ACCESS
274:           
275:           	if (U2ERRIRbits.FERIF) {
0120  0102     MOVLB 0x2
0122  A7C5     BTFSS 0xC5, 3, BANKED
0124  D015     BRA 0x150
276:           		uart2RxStatusBuffer[uart2RxHead].ferr = 1;
0126  0E00     MOVLW 0x0
0128  2433     ADDWF 0x33, W, ACCESS
012A  6ED9     MOVWF 0xFD9, ACCESS
012C  6ADA     CLRF __end_of_UART2_tx_vect_isr, ACCESS
012E  0E0A     MOVLW 0xA
0130  22DA     ADDWFC __end_of_UART2_tx_vect_isr, F, ACCESS
0132  010A     MOVLB 0xA
0134  82DF     BSF 0xFDF, 1, ACCESS
277:           		UART2_FramingErrorHandler();
0136  D801     RCALL 0x13A
0138  D00B     BRA 0x150
013A  0005     PUSH
013C  6EFA     MOVWF 0xFFA, ACCESS
013E  0107     MOVLB 0x7
0140  51B7     MOVF DMA2PR, W, BANKED
0142  6EFD     MOVWF 0xFFD, ACCESS
0144  51B8     MOVF DMA3PR, W, BANKED
0146  6EFE     MOVWF 0xFFE, ACCESS
0148  51B9     MOVF DMA4PR, W, BANKED
014A  6EFF     MOVWF 0xFFF, ACCESS
014C  50FA     MOVF 0xFFA, W, ACCESS
014E  0012     RETURN 0
278:           	}
279:           
280:           	if (U2ERRIRbits.RXFOIF) {
0150  0102     MOVLB 0x2
0152  A3C5     BTFSS 0xC5, 1, BANKED
0154  D015     BRA 0x180
281:           		uart2RxStatusBuffer[uart2RxHead].oerr = 1;
0156  0E00     MOVLW 0x0
0158  2433     ADDWF 0x33, W, ACCESS
015A  6ED9     MOVWF 0xFD9, ACCESS
015C  6ADA     CLRF __end_of_UART2_tx_vect_isr, ACCESS
015E  0E0A     MOVLW 0xA
0160  22DA     ADDWFC __end_of_UART2_tx_vect_isr, F, ACCESS
0162  010A     MOVLB 0xA
0164  84DF     BSF 0xFDF, 2, ACCESS
282:           		UART2_OverrunErrorHandler();
0166  D801     RCALL 0x16A
0168  D00B     BRA 0x180
016A  0005     PUSH
016C  6EFA     MOVWF 0xFFA, ACCESS
016E  0107     MOVLB 0x7
0170  51B4     MOVF PRLOCK, W, BANKED
0172  6EFD     MOVWF 0xFFD, ACCESS
0174  51B5     MOVF SCANPR, W, BANKED
0176  6EFE     MOVWF 0xFFE, ACCESS
0178  51B6     MOVF DMA1PR, W, BANKED
017A  6EFF     MOVWF 0xFFF, ACCESS
017C  50FA     MOVF 0xFFA, W, ACCESS
017E  0012     RETURN 0
283:           	}
284:           
285:           	if (uart2RxStatusBuffer[uart2RxHead].status) {
0180  0E00     MOVLW 0x0
0182  2433     ADDWF 0x33, W, ACCESS
0184  6ED9     MOVWF 0xFD9, ACCESS
0186  6ADA     CLRF __end_of_UART2_tx_vect_isr, ACCESS
0188  0E0A     MOVLW 0xA
018A  22DA     ADDWFC __end_of_UART2_tx_vect_isr, F, ACCESS
018C  50DF     MOVF 0xFDF, W, ACCESS
018E  B4D8     BTFSC 0xFD8, 2, ACCESS
0190  D00D     BRA 0x1AC
286:           		UART2_ErrorHandler();
0192  D801     RCALL 0x196
0194  0012     RETURN 0
0196  0005     PUSH
0198  6EFA     MOVWF 0xFFA, ACCESS
019A  0107     MOVLB 0x7
019C  51B1     MOVF OSCFRQ, W, BANKED
019E  6EFD     MOVWF 0xFFD, ACCESS
01A0  51B2     MOVF OSCSTAT, W, BANKED
01A2  6EFE     MOVWF 0xFFE, ACCESS
01A4  51B3     MOVF OSCEN, W, BANKED
01A6  6EFF     MOVWF 0xFFF, ACCESS
01A8  50FA     MOVF 0xFFA, W, ACCESS
01AA  0012     RETURN 0
287:           	} else {
288:           		UART2_RxDataHandler();
01AC  ECB2     CALL 0x2564, 0
01AE  F012     NOP
289:           	}
290:           
291:           	// or set custom function using UART2_SetRxInterruptHandler()
292:           }
01B0  0012     RETURN 0
293:           
294:           void UART2_RxDataHandler(void)
295:           {
296:           	// use this default receive interrupt handler code
297:           	uart2RxBuffer[uart2RxHead++] = U2RXB;
2564  0E40     MOVLW 0x40
2566  2433     ADDWF 0x33, W, ACCESS
2568  6ED9     MOVWF 0xFD9, ACCESS
256A  6ADA     CLRF __end_of_UART2_tx_vect_isr, ACCESS
256C  0E0E     MOVLW 0xE
256E  22DA     ADDWFC __end_of_UART2_tx_vect_isr, F, ACCESS
2570  C2B4     MOVFF U2RXB, INDF2
2572  F4DF     NOP
2574  2A33     INCF 0x33, F, ACCESS
298:           	if (sizeof(uart2RxBuffer) <= uart2RxHead) {
2576  0E3F     MOVLW 0x3F
2578  6433     CPFSGT 0x33, ACCESS
257A  D001     BRA 0x257E
299:           		uart2RxHead = 0;
257C  6A33     CLRF 0x33, ACCESS
300:           	}
301:           	uart2RxCount++;
257E  2A31     INCF 0x31, F, ACCESS
302:           }
18CC  C4FA     MOVFF PCLATH, __pcstackBANK6
18CE  F6FE     NOP
18D0  C4FB     MOVFF PCLATU, 0x6FF
18D2  F6FF     NOP
18D4  EE17     LFSR 1, 0x1FAA
18D6  F3AA     NOP
2580  0012     RETURN 0
303:           
304:           void UART2_DefaultFramingErrorHandler(void)
305:           {
306:           }
279E  0012     RETURN 0
307:           
308:           void UART2_DefaultOverrunErrorHandler(void)
309:           {
310:           }
279C  0012     RETURN 0
311:           
312:           void UART2_DefaultErrorHandler(void)
313:           {
314:           	UART2_RxDataHandler();
2776  ECB2     CALL 0x2564, 0
2778  F012     NOP
315:           }
277A  0012     RETURN 0
316:           
317:           void UART2_SetFramingErrorHandler(void (* interruptHandler)(void))
318:           {
319:           	UART2_FramingErrorHandler = interruptHandler;
2160  50E1     MOVF 0xFE1, W, ACCESS
2162  0FFD     ADDLW 0xFD
2164  6ED9     MOVWF 0xFD9, ACCESS
2166  50E2     MOVF 0xFE2, W, ACCESS
2168  6EDA     MOVWF __end_of_UART2_tx_vect_isr, ACCESS
216A  0EFF     MOVLW 0xFF
216C  22DA     ADDWFC __end_of_UART2_tx_vect_isr, F, ACCESS
216E  C4DE     MOVFF POSTINC2, UART2_FramingErrorHandler
2170  F7B7     NOP
2172  C4DE     MOVFF POSTINC2, 0x7B8
2174  F7B8     NOP
2176  C4DD     MOVFF POSTDEC2, 0x7B9
2178  F7B9     NOP
320:           }
217A  52E5     MOVF 0xFE5, F, ACCESS
217A  52E5     MOVF 0xFE5, F, ACCESS
217A  52E5     MOVF 0xFE5, F, ACCESS
217A  52E5     MOVF 0xFE5, F, ACCESS
321:           
322:           void UART2_SetOverrunErrorHandler(void (* interruptHandler)(void))
323:           {
324:           	UART2_OverrunErrorHandler = interruptHandler;
213E  50E1     MOVF 0xFE1, W, ACCESS
2140  0FFD     ADDLW 0xFD
2142  6ED9     MOVWF 0xFD9, ACCESS
2144  50E2     MOVF 0xFE2, W, ACCESS
2146  6EDA     MOVWF __end_of_UART2_tx_vect_isr, ACCESS
2148  0EFF     MOVLW 0xFF
214A  22DA     ADDWFC __end_of_UART2_tx_vect_isr, F, ACCESS
214C  C4DE     MOVFF POSTINC2, UART2_OverrunErrorHandler
214E  F7B4     NOP
2150  C4DE     MOVFF POSTINC2, 0x7B5
2152  F7B5     NOP
2154  C4DD     MOVFF POSTDEC2, 0x7B6
2156  F7B6     NOP
325:           }
2158  52E5     MOVF 0xFE5, F, ACCESS
2158  52E5     MOVF 0xFE5, F, ACCESS
2158  52E5     MOVF 0xFE5, F, ACCESS
2158  52E5     MOVF 0xFE5, F, ACCESS
326:           
327:           void UART2_SetErrorHandler(void (* interruptHandler)(void))
328:           {
329:           	UART2_ErrorHandler = interruptHandler;
2182  50E1     MOVF 0xFE1, W, ACCESS
2184  0FFD     ADDLW 0xFD
2186  6ED9     MOVWF 0xFD9, ACCESS
2188  50E2     MOVF 0xFE2, W, ACCESS
218A  6EDA     MOVWF __end_of_UART2_tx_vect_isr, ACCESS
218C  0EFF     MOVLW 0xFF
218E  22DA     ADDWFC __end_of_UART2_tx_vect_isr, F, ACCESS
2190  C4DE     MOVFF POSTINC2, UART2_ErrorHandler
2192  F7B1     NOP
2194  C4DE     MOVFF POSTINC2, 0x7B2
2196  F7B2     NOP
2198  C4DD     MOVFF POSTDEC2, 0x7B3
219A  F7B3     NOP
330:           }
219C  52E5     MOVF 0xFE5, F, ACCESS
219C  52E5     MOVF 0xFE5, F, ACCESS
219C  52E5     MOVF 0xFE5, F, ACCESS
219C  52E5     MOVF 0xFE5, F, ACCESS
331:           
332:           void UART2_SetRxInterruptHandler(void (* InterruptHandler)(void))
333:           {
334:           	UART2_RxInterruptHandler = InterruptHandler;
211C  50E1     MOVF 0xFE1, W, ACCESS
211E  0FFD     ADDLW 0xFD
2120  6ED9     MOVWF 0xFD9, ACCESS
2122  50E2     MOVF 0xFE2, W, ACCESS
2124  6EDA     MOVWF __end_of_UART2_tx_vect_isr, ACCESS
2126  0EFF     MOVLW 0xFF
2128  22DA     ADDWFC __end_of_UART2_tx_vect_isr, F, ACCESS
212A  C4DE     MOVFF POSTINC2, UART2_RxInterruptHandler
212C  F7C6     NOP
212E  C4DE     MOVFF POSTINC2, 0x7C7
2130  F7C7     NOP
2132  C4DD     MOVFF POSTDEC2, 0x7C8
2134  F7C8     NOP
335:           }
2136  52E5     MOVF 0xFE5, F, ACCESS
2136  52E5     MOVF 0xFE5, F, ACCESS
2136  52E5     MOVF 0xFE5, F, ACCESS
2136  52E5     MOVF 0xFE5, F, ACCESS
336:           
337:           void UART2_SetTxInterruptHandler(void (* InterruptHandler)(void))
338:           {
339:           	UART2_TxInterruptHandler = InterruptHandler;
20FA  50E1     MOVF 0xFE1, W, ACCESS
20FC  0FFD     ADDLW 0xFD
20FE  6ED9     MOVWF 0xFD9, ACCESS
2100  50E2     MOVF 0xFE2, W, ACCESS
2102  6EDA     MOVWF __end_of_UART2_tx_vect_isr, ACCESS
2104  0EFF     MOVLW 0xFF
2106  22DA     ADDWFC __end_of_UART2_tx_vect_isr, F, ACCESS
2108  C4DE     MOVFF POSTINC2, UART2_TxInterruptHandler
210A  F7C3     NOP
210C  C4DE     MOVFF POSTINC2, 0x7C4
210E  F7C4     NOP
2110  C4DD     MOVFF POSTDEC2, 0x7C5
2112  F7C5     NOP
340:           }
2114  52E5     MOVF 0xFE5, F, ACCESS
2114  52E5     MOVF 0xFE5, F, ACCESS
2114  52E5     MOVF 0xFE5, F, ACCESS
2114  52E5     MOVF 0xFE5, F, ACCESS
341:           
342:           
343:           /**
344:             End of File
345:            */
---  /public/Q84vtouch/mateQ84.X/mcc_generated_files/uart1.c  -------------------------------------------
1:             /**
2:               UART1 Generated Driver File
3:             
4:               @Company
5:                 Microchip Technology Inc.
6:             
7:               @File Name
8:                 uart1.c
9:             
10:              @Summary
11:                This is the generated driver implementation file for the UART1 driver using PIC10 / PIC12 / PIC16 / PIC18 MCUs
12:            
13:              @Description
14:                This source file provides APIs for UART1.
15:                Generation Information :
16:                    Product Revision  :  PIC10 / PIC12 / PIC16 / PIC18 MCUs - 1.81.8
17:                    Device            :  PIC18F47Q84
18:                    Driver Version    :  2.4.1
19:                The generated drivers are tested against the following:
20:                    Compiler          :  XC8 2.36 and above
21:                    MPLAB             :  MPLAB X 6.00
22:            */
23:            
24:            /*
25:                (c) 2018 Microchip Technology Inc. and its subsidiaries. 
26:                
27:                Subject to your compliance with these terms, you may use Microchip software and any 
28:                derivatives exclusively with Microchip products. It is your responsibility to comply with third party 
29:                license terms applicable to your use of third party software (including open source software) that 
30:                may accompany Microchip software.
31:                
32:                THIS SOFTWARE IS SUPPLIED BY MICROCHIP "AS IS". NO WARRANTIES, WHETHER 
33:                EXPRESS, IMPLIED OR STATUTORY, APPLY TO THIS SOFTWARE, INCLUDING ANY 
34:                IMPLIED WARRANTIES OF NON-INFRINGEMENT, MERCHANTABILITY, AND FITNESS 
35:                FOR A PARTICULAR PURPOSE.
36:                
37:                IN NO EVENT WILL MICROCHIP BE LIABLE FOR ANY INDIRECT, SPECIAL, PUNITIVE, 
38:                INCIDENTAL OR CONSEQUENTIAL LOSS, DAMAGE, COST OR EXPENSE OF ANY KIND 
39:                WHATSOEVER RELATED TO THE SOFTWARE, HOWEVER CAUSED, EVEN IF MICROCHIP 
40:                HAS BEEN ADVISED OF THE POSSIBILITY OR THE DAMAGES ARE FORESEEABLE. TO 
41:                THE FULLEST EXTENT ALLOWED BY LAW, MICROCHIP'S TOTAL LIABILITY ON ALL 
42:                CLAIMS IN ANY WAY RELATED TO THIS SOFTWARE WILL NOT EXCEED THE AMOUNT 
43:                OF FEES, IF ANY, THAT YOU HAVE PAID DIRECTLY TO MICROCHIP FOR THIS 
44:                SOFTWARE.
45:            */
46:            
47:            /**
48:              Section: Included Files
49:            */
50:            #include <xc.h>
51:            #include "uart1.h"
52:            
53:            static volatile uart1_status_t uart1RxLastError;
54:            
55:            /**
56:              Section: UART1 APIs
57:            */
58:            void (*UART1_FramingErrorHandler)(void);
59:            void (*UART1_OverrunErrorHandler)(void);
60:            void (*UART1_ErrorHandler)(void);
61:            
62:            void UART1_DefaultFramingErrorHandler(void);
63:            void UART1_DefaultOverrunErrorHandler(void);
64:            void UART1_DefaultErrorHandler(void);
65:            
66:            void UART1_Initialize(void)
67:            {
68:                // Disable interrupts before changing states
69:            
70:                // Set the UART1 module to the options selected in the user interface.
71:            
72:                // P1L 0; 
73:                U1P1L = 0x00;
0E6A  0102     MOVLB 0x2
0E6C  6BA5     CLRF 0xA5, BANKED
74:            
75:                // P1H 0; 
76:                U1P1H = 0x00;
0E6E  6BA6     CLRF 0xA6, BANKED
77:            
78:                // P2L 0; 
79:                U1P2L = 0x00;
0E70  6BA7     CLRF 0xA7, BANKED
80:            
81:                // P2H 0; 
82:                U1P2H = 0x00;
0E72  6BA8     CLRF 0xA8, BANKED
83:            
84:                // P3L 0; 
85:                U1P3L = 0x00;
0E74  6BA9     CLRF 0xA9, BANKED
86:            
87:                // P3H 0; 
88:                U1P3H = 0x00;
0E76  6BAA     CLRF 0xAA, BANKED
89:            
90:                // BRGS high speed; MODE Asynchronous 9-bit mode; RXEN enabled; TXEN enabled; ABDEN disabled; 
91:                U1CON0 = 0xB4;
0E78  0EB4     MOVLW 0xB4
0E7A  6FAB     MOVWF 0xAB, BANKED
92:            
93:                // RXBIMD Set RXBKIF on rising RX input; BRKOVR disabled; WUE disabled; SENDB disabled; ON enabled; 
94:                U1CON1 = 0x80;
0E7C  0E80     MOVLW 0x80
0E7E  6FAC     MOVWF ACTCON, BANKED
95:            
96:                // TXPOL not inverted; FLO off; C0EN Checksum Mode 0; RXPOL not inverted; RUNOVF RX input shifter stops all activity; STP Transmit 1Stop bit, receiver verifies first Stop bit; 
97:                U1CON2 = 0x00;
0E80  6BAD     CLRF OSCCON1, BANKED
98:            
99:                // BRGL 17; 
100:               U1BRGL = 0x11;
0E82  0E11     MOVLW 0x11
0E84  6FAE     MOVWF OSCCON2, BANKED
101:           
102:               // BRGH 4; 
103:               U1BRGH = 0x04;
0E86  0E04     MOVLW 0x4
0E88  6FAF     MOVWF OSCCON3, BANKED
104:           
105:               // STPMD in middle of first Stop bit; TXWRE No error; 
106:               U1FIFO = 0x00;
0E8A  6BB0     CLRF OSCTUNE, BANKED
107:           
108:               // ABDIF Auto-baud not enabled or not complete; WUIF WUE not enabled by software; ABDIE disabled; 
109:               U1UIR = 0x00;
0E8C  6BB1     CLRF OSCFRQ, BANKED
110:           
111:               // ABDOVF Not overflowed; TXCIF 0; RXBKIF No Break detected; RXFOIF not overflowed; CERIF No Checksum error; 
112:               U1ERRIR = 0x00;
0E8E  6BB2     CLRF OSCSTAT, BANKED
113:           
114:               // TXCIE disabled; FERIE disabled; TXMTIE disabled; ABDOVE disabled; CERIE disabled; RXFOIE disabled; PERIE disabled; RXBKIE disabled; 
115:               U1ERRIE = 0x00;
0E90  6BB3     CLRF OSCEN, BANKED
116:           
117:           
118:               UART1_SetFramingErrorHandler(UART1_DefaultFramingErrorHandler);
0E92  0E00     MOVLW 0x0
0E94  6EE6     MOVWF 0xFE6, ACCESS
0E96  0E00     MOVLW 0x0
0E98  6EE6     MOVWF 0xFE6, ACCESS
0E9A  0E00     MOVLW 0x0
0E9C  6EE6     MOVWF 0xFE6, ACCESS
0E9E  EC8F     CALL 0x271E, 0
0EA0  F013     NOP
119:               UART1_SetOverrunErrorHandler(UART1_DefaultOverrunErrorHandler);
0EA2  0E00     MOVLW 0x0
0EA4  6EE6     MOVWF 0xFE6, ACCESS
0EA6  0E00     MOVLW 0x0
0EA8  6EE6     MOVWF 0xFE6, ACCESS
0EAA  0E00     MOVLW 0x0
0EAC  6EE6     MOVWF 0xFE6, ACCESS
0EAE  EC8B     CALL 0x2716, 0
0EB0  F013     NOP
120:               UART1_SetErrorHandler(UART1_DefaultErrorHandler);
0EB2  0E00     MOVLW 0x0
0EB4  6EE6     MOVWF 0xFE6, ACCESS
0EB6  0E00     MOVLW 0x0
0EB8  6EE6     MOVWF 0xFE6, ACCESS
0EBA  0E00     MOVLW 0x0
0EBC  6EE6     MOVWF 0xFE6, ACCESS
0EBE  EC93     CALL 0x2726, 0
0EC0  F013     NOP
121:           
122:               uart1RxLastError.status = 0;
0EC2  0106     MOVLB 0x6
0EC4  6B65     CLRF PMD5, BANKED
123:           
124:           }
0EC6  0012     RETURN 0
125:           
126:           bool UART1_is_rx_ready(void)
127:           {
128:               return (bool)(PIR4bits.U1RXIF);
129:           }
130:           
131:           bool UART1_is_tx_ready(void)
132:           {
133:               return (bool)(PIR4bits.U1TXIF && U1CON0bits.TXEN);
134:           }
135:           
136:           bool UART1_is_tx_done(void)
137:           {
138:               return U1ERRIRbits.TXMTIF;
139:           }
140:           
141:           uart1_status_t UART1_get_last_status(void){
142:               return uart1RxLastError;
143:           }
144:           
145:           uint8_t UART1_Read(void)
146:           {
147:               while(!PIR4bits.U1RXIF)
148:               {
149:               }
150:           
151:               uart1RxLastError.status = 0;
152:           
153:               if(U1ERRIRbits.FERIF){
154:                   uart1RxLastError.ferr = 1;
155:                   UART1_FramingErrorHandler();
156:               }
157:           
158:               if(U1ERRIRbits.RXFOIF){
159:                   uart1RxLastError.oerr = 1;
160:                   UART1_OverrunErrorHandler();
161:               }
162:           
163:               if(uart1RxLastError.status){
164:                   UART1_ErrorHandler();
165:               }
166:           
167:               return U1RXB;
168:           }
169:           
170:           void UART1_Write(uint8_t txData)
171:           {
172:               while(0 == PIR4bits.U1TXIF)
26AE  A2B2     BTFSS 0xFB2, 1, ACCESS
26B0  D7FE     BRA UART1_Write
173:               {
174:               }
175:           
176:               U1TXB = txData;    // Write the data byte to the USART.
26B2  0EFF     MOVLW 0xFF
26B4  C4E3     MOVFF PLUSW1, U1TXB
26B6  F2A3     NOP
177:           }
14DC  C4FA     MOVFF PCLATH, 0x7F8
14DE  F7F8     NOP
14E0  C4FB     MOVFF PCLATU, 0x7F9
14E2  F7F9     NOP
14E4  0061     MOVFFL 0x50C, 0x7FA
14E6  F430     NOP
14E8  F7FA     NOP
14EA  EE17     LFSR 1, 0x1FAA
14EC  F3AA     NOP
26B8  52E5     MOVF 0xFE5, F, ACCESS
26B8  52E5     MOVF 0xFE5, F, ACCESS
178:           
179:           void UART1_SetAddresstoTransmit(uint8_t txAddress)
180:           {
181:               U1P1L = txAddress;
182:           }
183:           
184:           
185:           
186:           
187:           
188:           void UART1_DefaultFramingErrorHandler(void){}
189:           
190:           void UART1_DefaultOverrunErrorHandler(void){}
191:           
192:           void UART1_DefaultErrorHandler(void){
193:           }
194:           
195:           void UART1_SetFramingErrorHandler(void (* interruptHandler)(void)){
196:               UART1_FramingErrorHandler = interruptHandler;
197:           }
271E  52E5     MOVF 0xFE5, F, ACCESS
271E  52E5     MOVF 0xFE5, F, ACCESS
271E  52E5     MOVF 0xFE5, F, ACCESS
271E  52E5     MOVF 0xFE5, F, ACCESS
198:           
199:           void UART1_SetOverrunErrorHandler(void (* interruptHandler)(void)){
200:               UART1_OverrunErrorHandler = interruptHandler;
201:           }
2716  52E5     MOVF 0xFE5, F, ACCESS
2716  52E5     MOVF 0xFE5, F, ACCESS
2716  52E5     MOVF 0xFE5, F, ACCESS
2716  52E5     MOVF 0xFE5, F, ACCESS
202:           
203:           void UART1_SetErrorHandler(void (* interruptHandler)(void)){
204:               UART1_ErrorHandler = interruptHandler;
205:           }
2726  52E5     MOVF 0xFE5, F, ACCESS
2728  52E5     MOVF 0xFE5, F, ACCESS
272A  52E5     MOVF 0xFE5, F, ACCESS
272A  52E5     MOVF 0xFE5, F, ACCESS
206:           
207:           
208:           
209:           
210:           
211:           
212:           /**
213:             End of File
214:           */
---  /public/Q84vtouch/mateQ84.X/mcc_generated_files/tmr6.c  --------------------------------------------
1:             /**
2:               TMR6 Generated Driver File
3:             
4:               @Company
5:                 Microchip Technology Inc.
6:             
7:               @File Name
8:                 tmr6.c
9:             
10:              @Summary
11:                This is the generated driver implementation file for the TMR6 driver using PIC10 / PIC12 / PIC16 / PIC18 MCUs
12:            
13:              @Description
14:                This source file provides APIs for TMR6.
15:                Generation Information :
16:                    Product Revision  :  PIC10 / PIC12 / PIC16 / PIC18 MCUs - 1.81.8
17:                    Device            :  PIC18F47Q84
18:                    Driver Version    :  2.11
19:                The generated drivers are tested against the following:
20:                    Compiler          :  XC8 2.36 and above 
21:                    MPLAB 	          :  MPLAB X 6.00
22:            */
23:            
24:            /*
25:                (c) 2018 Microchip Technology Inc. and its subsidiaries. 
26:                
27:                Subject to your compliance with these terms, you may use Microchip software and any 
28:                derivatives exclusively with Microchip products. It is your responsibility to comply with third party 
29:                license terms applicable to your use of third party software (including open source software) that 
30:                may accompany Microchip software.
31:                
32:                THIS SOFTWARE IS SUPPLIED BY MICROCHIP "AS IS". NO WARRANTIES, WHETHER 
33:                EXPRESS, IMPLIED OR STATUTORY, APPLY TO THIS SOFTWARE, INCLUDING ANY 
34:                IMPLIED WARRANTIES OF NON-INFRINGEMENT, MERCHANTABILITY, AND FITNESS 
35:                FOR A PARTICULAR PURPOSE.
36:                
37:                IN NO EVENT WILL MICROCHIP BE LIABLE FOR ANY INDIRECT, SPECIAL, PUNITIVE, 
38:                INCIDENTAL OR CONSEQUENTIAL LOSS, DAMAGE, COST OR EXPENSE OF ANY KIND 
39:                WHATSOEVER RELATED TO THE SOFTWARE, HOWEVER CAUSED, EVEN IF MICROCHIP 
40:                HAS BEEN ADVISED OF THE POSSIBILITY OR THE DAMAGES ARE FORESEEABLE. TO 
41:                THE FULLEST EXTENT ALLOWED BY LAW, MICROCHIP'S TOTAL LIABILITY ON ALL 
42:                CLAIMS IN ANY WAY RELATED TO THIS SOFTWARE WILL NOT EXCEED THE AMOUNT 
43:                OF FEES, IF ANY, THAT YOU HAVE PAID DIRECTLY TO MICROCHIP FOR THIS 
44:                SOFTWARE.
45:            */
46:            
47:            /**
48:              Section: Included Files
49:            */
50:            
51:            #include <xc.h>
52:            #include "tmr6.h"
53:            #include "interrupt_manager.h"
54:            
55:            /**
56:              Section: Global Variables Definitions
57:            */
58:            
59:            void (*TMR6_InterruptHandler)(void);
60:            
61:            /**
62:              Section: TMR6 APIs
63:            */
64:            
65:            void TMR6_Initialize(void)
66:            {
67:                // Set TMR6 to the options selected in the User Interface
68:            
69:                // T6CS LFINTOSC; 
70:                T6CLKCON = 0x04;
1D9A  0E04     MOVLW 0x4
1D9C  0103     MOVLB 0x3
1D9E  6F3E     MOVWF 0x3E, BANKED
71:            
72:                // T6PSYNC Not Synchronized; T6MODE Software control; T6CKPOL Rising Edge; T6CKSYNC Not Synchronized; 
73:                T6HLT = 0x00;
1DA0  6B3D     CLRF 0x3D, BANKED
74:            
75:                // T6RSEL T6CKIPPS pin; 
76:                T6RST = 0x00;
1DA2  6B3F     CLRF 0x3F, BANKED
77:            
78:                // PR6 61; 
79:                T6PR = 0x3D;
1DA4  0E3D     MOVLW 0x3D
1DA6  6F3B     MOVWF 0x3B, BANKED
80:            
81:                // TMR6 0; 
82:                T6TMR = 0x00;
1DA8  6B3A     CLRF CLKRCLK, BANKED
83:            
84:                // Clearing IF flag before enabling the interrupt.
85:                PIR15bits.TMR6IF = 0;
1DAA  96BD     BCF 0xFBD, 3, ACCESS
86:            
87:                // Enabling TMR6 interrupt.
88:                PIE15bits.TMR6IE = 1;
1DAC  86AD     BSF 0xFAD, 3, ACCESS
89:            
90:                // Set Default Interrupt Handler
91:                TMR6_SetInterruptHandler(TMR6_DefaultInterruptHandler);
1DAE  0E86     MOVLW 0x86
1DB0  6EE6     MOVWF 0xFE6, ACCESS
1DB2  0E27     MOVLW 0x27
1DB4  6EE6     MOVWF 0xFE6, ACCESS
1DB6  0E00     MOVLW 0x0
1DB8  6EE6     MOVWF 0xFE6, ACCESS
1DBA  ECD2     CALL 0x21A4, 0
1DBC  F010     NOP
92:            
93:                // T6CKPS 1:1; T6OUTPS 1:1; TMR6ON on; 
94:                T6CON = 0x80;
1DBE  0E80     MOVLW 0x80
1DC0  0103     MOVLB 0x3
1DC2  6F3C     MOVWF 0x3C, BANKED
95:            }
1DC4  0012     RETURN 0
96:            
97:            void TMR6_ModeSet(TMR6_HLT_MODE mode)
98:            {
99:               // Configure different types HLT mode
100:               T6HLTbits.MODE = mode;
101:           }
102:           
103:           void TMR6_ExtResetSourceSet(TMR6_HLT_EXT_RESET_SOURCE reset)
104:           {
105:               //Configure different types of HLT external reset source
106:               T6RSTbits.RSEL = reset;
107:           }
108:           
109:           void TMR6_Start(void)
110:           {
111:               // Start the Timer by writing to TMRxON bit
112:               T6CONbits.TMR6ON = 1;
273A  0103     MOVLB 0x3
273C  8F3C     BSF 0x3C, 7, BANKED
113:           }
273E  0012     RETURN 0
114:           
115:           void TMR6_StartTimer(void)
116:           {
117:               TMR6_Start();
2734  EC9D     CALL 0x273A, 0
2736  F013     NOP
118:           }
2738  0012     RETURN 0
119:           
120:           void TMR6_Stop(void)
121:           {
122:               // Stop the Timer by writing to TMRxON bit
123:               T6CONbits.TMR6ON = 0;
124:           }
125:           
126:           void TMR6_StopTimer(void)
127:           {
128:               TMR6_Stop();
129:           }
130:           
131:           uint8_t TMR6_Counter8BitGet(void)
132:           {
133:               uint8_t readVal;
134:           
135:               readVal = TMR6;
136:           
137:               return readVal;
138:           }
139:           
140:           uint8_t TMR6_ReadTimer(void)
141:           {
142:               return TMR6_Counter8BitGet();
143:           }
144:           
145:           void TMR6_Counter8BitSet(uint8_t timerVal)
146:           {
147:               // Write to the Timer6 register
148:               TMR6 = timerVal;
149:           }
150:           
151:           void TMR6_WriteTimer(uint8_t timerVal)
152:           {
153:               TMR6_Counter8BitSet(timerVal);
154:           }
155:           
156:           void TMR6_Period8BitSet(uint8_t periodVal)
157:           {
158:              PR6 = periodVal;
159:           }
160:           
161:           void TMR6_LoadPeriodRegister(uint8_t periodVal)
162:           {
163:              TMR6_Period8BitSet(periodVal);
164:           }
165:           
166:           void __interrupt(irq(TMR6),base(8),low_priority) TMR6_ISR()
12CC  C4D8     MOVFF STATUS, __pcstackBANK12
167:           {
168:           
169:               // clear the TMR6 interrupt flag
170:               PIR15bits.TMR6IF = 0;
12E2  96BD     BCF 0xFBD, 3, ACCESS
171:           
172:               if(TMR6_InterruptHandler)
12E4  0107     MOVLB 0x7
12E6  518D     MOVF SPI2RXB, W, BANKED
12E8  118E     IORWF SPI2TXB, W, BANKED
12EA  118F     IORWF SPI2TCNT, W, BANKED
12EC  B4D8     BTFSC 0xFD8, 2, ACCESS
12EE  D00C     BRA 0x1308
173:               {
174:                   TMR6_InterruptHandler();
12F0  D801     RCALL 0x12F4
12F2  D00A     BRA 0x1308
12F4  0005     PUSH
12F6  6EFA     MOVWF 0xFFA, ACCESS
12F8  518D     MOVF SPI2RXB, W, BANKED
12FA  6EFD     MOVWF 0xFFD, ACCESS
12FC  518E     MOVF SPI2TXB, W, BANKED
12FE  6EFE     MOVWF 0xFFE, ACCESS
1300  518F     MOVF SPI2TCNT, W, BANKED
1302  6EFF     MOVWF 0xFFF, ACCESS
1304  50FA     MOVF 0xFFA, W, ACCESS
1306  0012     RETURN 0
175:               }
176:           }
1308  0063     MOVFFL 0xCF3, 0x50C
1308  0063     MOVFFL 0xCF3, 0x50C
1308  0063     MOVFFL 0xCF3, 0x50C
1308  0063     MOVFFL 0xCF3, 0x50C
1308  0063     MOVFFL 0xCF3, 0x50C
1308  0063     MOVFFL 0xCF3, 0x50C
1308  0063     MOVFFL 0xCF3, 0x50C
1308  0063     MOVFFL 0xCF3, 0x50C
1308  0063     MOVFFL 0xCF3, 0x50C
1308  0063     MOVFFL 0xCF3, 0x50C
177:           
178:           
179:           void TMR6_SetInterruptHandler(void (* InterruptHandler)(void)){
180:               TMR6_InterruptHandler = InterruptHandler;
21A4  50E1     MOVF 0xFE1, W, ACCESS
21A6  0FFD     ADDLW 0xFD
21A8  6ED9     MOVWF 0xFD9, ACCESS
21AA  50E2     MOVF 0xFE2, W, ACCESS
21AC  6EDA     MOVWF __end_of_UART2_tx_vect_isr, ACCESS
21AE  0EFF     MOVLW 0xFF
21B0  22DA     ADDWFC __end_of_UART2_tx_vect_isr, F, ACCESS
21B2  C4DE     MOVFF POSTINC2, TMR6_InterruptHandler
21B4  F78D     NOP
21B6  C4DE     MOVFF POSTINC2, 0x78E
21B8  F78E     NOP
21BA  C4DD     MOVFF POSTDEC2, 0x78F
21BC  F78F     NOP
181:           }
21BE  52E5     MOVF 0xFE5, F, ACCESS
21BE  52E5     MOVF 0xFE5, F, ACCESS
21BE  52E5     MOVF 0xFE5, F, ACCESS
21BE  52E5     MOVF 0xFE5, F, ACCESS
182:           
183:           void TMR6_DefaultInterruptHandler(void){
184:               // add your TMR6 interrupt custom code
185:               // or set custom function using TMR6_SetInterruptHandler()
186:           }
2786  0012     RETURN 0
187:           
188:           /**
189:             End of File
190:           */
---  /public/Q84vtouch/mateQ84.X/mcc_generated_files/tmr5.c  --------------------------------------------
1:             /**
2:               TMR5 Generated Driver File
3:             
4:               @Company
5:                 Microchip Technology Inc.
6:             
7:               @File Name
8:                 tmr5.c
9:             
10:              @Summary
11:                This is the generated driver implementation file for the TMR5 driver using PIC10 / PIC12 / PIC16 / PIC18 MCUs
12:            
13:              @Description
14:                This source file provides APIs for TMR5.
15:                Generation Information :
16:                    Product Revision  :  PIC10 / PIC12 / PIC16 / PIC18 MCUs - 1.81.8
17:                    Device            :  PIC18F47Q84
18:                    Driver Version    :  2.11
19:                The generated drivers are tested against the following:
20:                    Compiler          :  XC8 2.36 and above
21:                    MPLAB 	          :  MPLAB X 6.00
22:            */
23:            
24:            /*
25:                (c) 2018 Microchip Technology Inc. and its subsidiaries. 
26:                
27:                Subject to your compliance with these terms, you may use Microchip software and any 
28:                derivatives exclusively with Microchip products. It is your responsibility to comply with third party 
29:                license terms applicable to your use of third party software (including open source software) that 
30:                may accompany Microchip software.
31:                
32:                THIS SOFTWARE IS SUPPLIED BY MICROCHIP "AS IS". NO WARRANTIES, WHETHER 
33:                EXPRESS, IMPLIED OR STATUTORY, APPLY TO THIS SOFTWARE, INCLUDING ANY 
34:                IMPLIED WARRANTIES OF NON-INFRINGEMENT, MERCHANTABILITY, AND FITNESS 
35:                FOR A PARTICULAR PURPOSE.
36:                
37:                IN NO EVENT WILL MICROCHIP BE LIABLE FOR ANY INDIRECT, SPECIAL, PUNITIVE, 
38:                INCIDENTAL OR CONSEQUENTIAL LOSS, DAMAGE, COST OR EXPENSE OF ANY KIND 
39:                WHATSOEVER RELATED TO THE SOFTWARE, HOWEVER CAUSED, EVEN IF MICROCHIP 
40:                HAS BEEN ADVISED OF THE POSSIBILITY OR THE DAMAGES ARE FORESEEABLE. TO 
41:                THE FULLEST EXTENT ALLOWED BY LAW, MICROCHIP'S TOTAL LIABILITY ON ALL 
42:                CLAIMS IN ANY WAY RELATED TO THIS SOFTWARE WILL NOT EXCEED THE AMOUNT 
43:                OF FEES, IF ANY, THAT YOU HAVE PAID DIRECTLY TO MICROCHIP FOR THIS 
44:                SOFTWARE.
45:            */
46:            
47:            /**
48:              Section: Included Files
49:            */
50:            
51:            #include <xc.h>
52:            #include "tmr5.h"
53:            #include "interrupt_manager.h"
54:            
55:            /**
56:              Section: Global Variables Definitions
57:            */
58:            volatile uint16_t timer5ReloadVal;
59:            void (*TMR5_InterruptHandler)(void);
60:            
61:            /**
62:              Section: TMR5 APIs
63:            */
64:            
65:            void TMR5_Initialize(void)
66:            {
67:                //Set the Timer to the options selected in the GUI
68:            
69:                //T5GE disabled; T5GTM disabled; T5GPOL low; T5GGO done; T5GSPM disabled; 
70:                T5GCON = 0x00;
1492  0103     MOVLB 0x3
1494  6B37     CLRF 0x37, BANKED
71:            
72:                //GSS T5G_pin; 
73:                T5GATE = 0x00;
1496  6B38     CLRF BOOTREG, BANKED
74:            
75:                //CS LFINTOSC; 
76:                T5CLK = 0x04;
1498  0E04     MOVLW 0x4
149A  6F39     MOVWF CLKRCON, BANKED
77:            
78:                //TMR5H 192; 
79:                TMR5H = 0xC0;
149C  0EC0     MOVLW 0xC0
149E  6F35     MOVWF 0x35, BANKED
80:            
81:                //TMR5L 0; 
82:                TMR5L = 0x00;
14A0  6B34     CLRF 0x34, BANKED
83:            
84:                // Clearing IF flag before enabling the interrupt.
85:                PIR8bits.TMR5IF = 0;
14A2  98B6     BCF 0xFB6, 4, ACCESS
86:            
87:                // Load the TMR value to reload variable
88:                timer5ReloadVal=(uint16_t)((TMR5H << 8) | TMR5L);
14A4  5134     MOVF 0x34, W, BANKED
14A6  0060     MOVFFL TMR5H, ltemp0
14A8  FCD4     NOP
14AA  F501     NOP
14AC  6A02     CLRF ___rparam_used, ACCESS
14AE  0061     MOVFFL ltemp0, ttemp5
14B0  F404     NOP
14B2  F502     NOP
14B4  6A01     CLRF __ptext283, ACCESS
14B6  1001     IORWF __ptext283, W, ACCESS
14B8  0106     MOVLB 0x6
14BA  6F5E     MOVWF 0x5E, BANKED
14BC  5002     MOVF ___rparam_used, W, ACCESS
14BE  6F5F     MOVWF 0x5F, BANKED
89:            
90:                // Enabling TMR5 interrupt.
91:                PIE8bits.TMR5IE = 1;
14C0  88A6     BSF 0xFA6, 4, ACCESS
92:            
93:                // Set Default Interrupt Handler
94:                TMR5_SetInterruptHandler(TMR5_DefaultInterruptHandler);
14C2  0E88     MOVLW 0x88
14C4  6EE6     MOVWF 0xFE6, ACCESS
14C6  0E27     MOVLW 0x27
14C8  6EE6     MOVWF 0xFE6, ACCESS
14CA  0E00     MOVLW 0x0
14CC  6EE6     MOVWF 0xFE6, ACCESS
14CE  ECE3     CALL 0x21C6, 0
14D0  F010     NOP
95:            
96:                // CKPS 1:1; NOT_SYNC synchronize; TMR5ON enabled; T5RD16 disabled; 
97:                T5CON = 0x01;
14D2  0E01     MOVLW 0x1
14D4  0103     MOVLB 0x3
14D6  6F36     MOVWF 0x36, BANKED
98:            }
14D8  0012     RETURN 0
99:            
100:           void TMR5_StartTimer(void)
101:           {
102:               // Start the Timer by writing to TMRxON bit
103:               T5CONbits.TMR5ON = 1;
2740  0103     MOVLB 0x3
2742  8136     BSF 0x36, 0, BANKED
104:           }
2744  0012     RETURN 0
105:           
106:           void TMR5_StopTimer(void)
107:           {
108:               // Stop the Timer by writing to TMRxON bit
109:               T5CONbits.TMR5ON = 0;
110:           }
111:           
112:           uint16_t TMR5_ReadTimer(void)
113:           {
114:               uint16_t readVal;
115:               uint8_t readValHigh;
116:               uint8_t readValLow;
117:               
118:               T5CONbits.T5RD16 = 1;
119:           	
120:               readValLow = TMR5L;
121:               readValHigh = TMR5H;
122:               
123:               readVal = ((uint16_t)readValHigh << 8) | readValLow;
124:           
125:               return readVal;
126:           }
127:           
128:           void TMR5_WriteTimer(uint16_t timerVal)
129:           {
130:               if (T5CONbits.NOT_SYNC == 1)
188C  0103     MOVLB 0x3
188E  A536     BTFSS 0x36, 2, BANKED
1890  D00E     BRA 0x18AE
131:               {
132:                   // Stop the Timer by writing to TMRxON bit
133:                   T5CONbits.TMR5ON = 0;
1892  9136     BCF 0x36, 0, BANKED
134:           
135:                   // Write to the Timer5 register
136:                   TMR5H = (uint8_t)(timerVal >> 8);
1894  0EFF     MOVLW 0xFF
1896  24E1     ADDWF 0xFE1, W, ACCESS
1898  6ED9     MOVWF 0xFD9, ACCESS
189A  0EFF     MOVLW 0xFF
189C  20E2     ADDWFC 0xFE2, W, ACCESS
189E  6EDA     MOVWF __end_of_UART2_tx_vect_isr, ACCESS
18A0  50DF     MOVF 0xFDF, W, ACCESS
18A2  6F35     MOVWF 0x35, BANKED
137:                   TMR5L = (uint8_t)timerVal;
18A4  0EFE     MOVLW 0xFE
18A6  C4E3     MOVFF PLUSW1, TMR5
18A8  F334     NOP
138:           
139:                   // Start the Timer after writing to the register
140:                   T5CONbits.TMR5ON =1;
18AA  8136     BSF 0x36, 0, BANKED
141:               }
18AC  D00B     BRA 0x18C4
142:               else
143:               {
144:                   // Write to the Timer5 register
145:                   TMR5H = (uint8_t)(timerVal >> 8);
18AE  0EFF     MOVLW 0xFF
18B0  24E1     ADDWF 0xFE1, W, ACCESS
18B2  6ED9     MOVWF 0xFD9, ACCESS
18B4  0EFF     MOVLW 0xFF
18B6  20E2     ADDWFC 0xFE2, W, ACCESS
18B8  6EDA     MOVWF __end_of_UART2_tx_vect_isr, ACCESS
18BA  50DF     MOVF 0xFDF, W, ACCESS
18BC  6F35     MOVWF 0x35, BANKED
146:                   TMR5L = (uint8_t)timerVal;
18BE  0EFE     MOVLW 0xFE
18C0  C4E3     MOVFF PLUSW1, TMR5
18C2  F334     NOP
147:               }
148:           }
18C4  52E5     MOVF 0xFE5, F, ACCESS
1CBA0  C4FA     MOVFF PCLATH, __pcstackCOMRAM
1CBA2  F539     NOP
149:           
150:           void TMR5_Reload(void)
151:           {
152:               TMR5_WriteTimer(timer5ReloadVal);
153:           }
154:           
155:           void TMR5_StartSinglePulseAcquisition(void)
156:           {
157:               T5GCONbits.T5GGO = 1;
158:           }
159:           
160:           uint8_t TMR5_CheckGateValueStatus(void)
161:           {
162:               return (T5GCONbits.T5GVAL);
163:           }
164:           
165:           void __interrupt(irq(TMR5),base(8),low_priority) TMR5_ISR()
0EC8  C4D8     MOVFF STATUS, 0xCF4
0ECA  FCF4     NOP
0ECC  C4FA     MOVFF PCLATH, 0xCF5
0ECE  FCF5     NOP
0ED0  C4FB     MOVFF PCLATU, 0xCF6
0ED2  FCF6     NOP
0ED4  0061     MOVFFL 0x50C, 0xCF7
0ED6  F430     NOP
0ED8  FCF7     NOP
0EDA  EE1A     LFSR 1, 0x2B55
0EDC  F355     NOP
166:           {
167:           
168:               // Clear the TMR5 interrupt flag
169:               PIR8bits.TMR5IF = 0;
0EDE  98B6     BCF 0xFB6, 4, ACCESS
170:               TMR5_WriteTimer(timer5ReloadVal);
0EE0  C65E     MOVFF timer5ReloadVal, POSTINC1
0EE2  F4E6     NOP
0EE4  C65F     MOVFF 0x65F, POSTINC1
0EE6  F4E6     NOP
0EE8  EC46     CALL 0x188C, 0
0EEA  F00C     NOP
171:           
172:               if(TMR5_InterruptHandler)
0EEC  0107     MOVLB 0x7
0EEE  518A     MOVF SPI1INTF, W, BANKED
0EF0  118B     IORWF SPI1INTE, W, BANKED
0EF2  118C     IORWF SPI1CLK, W, BANKED
0EF4  B4D8     BTFSC 0xFD8, 2, ACCESS
0EF6  D00C     BRA 0xF10
173:               {
174:                   TMR5_InterruptHandler();
0EF8  D801     RCALL 0xEFC
0EFA  D00A     BRA 0xF10
0EFC  0005     PUSH
0EFE  6EFA     MOVWF 0xFFA, ACCESS
0F00  518A     MOVF SPI1INTF, W, BANKED
0F02  6EFD     MOVWF 0xFFD, ACCESS
0F04  518B     MOVF SPI1INTE, W, BANKED
0F06  6EFE     MOVWF 0xFFE, ACCESS
0F08  518C     MOVF SPI1CLK, W, BANKED
0F0A  6EFF     MOVWF 0xFFF, ACCESS
0F0C  50FA     MOVF 0xFFA, W, ACCESS
0F0E  0012     RETURN 0
175:               }
176:           }
0F10  0063     MOVFFL 0xCF7, 0x50C
0F10  0063     MOVFFL 0xCF7, 0x50C
0F10  0063     MOVFFL 0xCF7, 0x50C
0F10  0063     MOVFFL 0xCF7, 0x50C
0F10  0063     MOVFFL 0xCF7, 0x50C
0F10  0063     MOVFFL 0xCF7, 0x50C
0F10  0063     MOVFFL 0xCF7, 0x50C
0F10  0063     MOVFFL 0xCF7, 0x50C
0F10  0063     MOVFFL 0xCF7, 0x50C
0F10  0063     MOVFFL 0xCF7, 0x50C
177:           
178:           
179:           void TMR5_SetInterruptHandler(void (* InterruptHandler)(void)){
180:               TMR5_InterruptHandler = InterruptHandler;
21C6  50E1     MOVF 0xFE1, W, ACCESS
21C8  0FFD     ADDLW 0xFD
21CA  6ED9     MOVWF 0xFD9, ACCESS
21CC  50E2     MOVF 0xFE2, W, ACCESS
21CE  6EDA     MOVWF __end_of_UART2_tx_vect_isr, ACCESS
21D0  0EFF     MOVLW 0xFF
21D2  22DA     ADDWFC __end_of_UART2_tx_vect_isr, F, ACCESS
21D4  C4DE     MOVFF POSTINC2, TMR5_InterruptHandler
21D6  F78A     NOP
21D8  C4DE     MOVFF POSTINC2, 0x78B
21DA  F78B     NOP
21DC  C4DD     MOVFF POSTDEC2, 0x78C
21DE  F78C     NOP
181:           }
21E0  52E5     MOVF 0xFE5, F, ACCESS
21E0  52E5     MOVF 0xFE5, F, ACCESS
21E0  52E5     MOVF 0xFE5, F, ACCESS
21E0  52E5     MOVF 0xFE5, F, ACCESS
182:           
183:           void TMR5_DefaultInterruptHandler(void){
184:               // add your TMR5 interrupt custom code
185:               // or set custom function using TMR5_SetInterruptHandler()
186:           }
2788  0012     RETURN 0
187:           
188:           /**
189:             End of File
190:           */
---  /public/Q84vtouch/mateQ84.X/mcc_generated_files/tmr4.c  --------------------------------------------
1:             /**
2:               TMR4 Generated Driver File
3:             
4:               @Company
5:                 Microchip Technology Inc.
6:             
7:               @File Name
8:                 tmr4.c
9:             
10:              @Summary
11:                This is the generated driver implementation file for the TMR4 driver using PIC10 / PIC12 / PIC16 / PIC18 MCUs
12:            
13:              @Description
14:                This source file provides APIs for TMR4.
15:                Generation Information :
16:                    Product Revision  :  PIC10 / PIC12 / PIC16 / PIC18 MCUs - 1.81.8
17:                    Device            :  PIC18F47Q84
18:                    Driver Version    :  2.11
19:                The generated drivers are tested against the following:
20:                    Compiler          :  XC8 2.36 and above 
21:                    MPLAB 	          :  MPLAB X 6.00
22:            */
23:            
24:            /*
25:                (c) 2018 Microchip Technology Inc. and its subsidiaries. 
26:                
27:                Subject to your compliance with these terms, you may use Microchip software and any 
28:                derivatives exclusively with Microchip products. It is your responsibility to comply with third party 
29:                license terms applicable to your use of third party software (including open source software) that 
30:                may accompany Microchip software.
31:                
32:                THIS SOFTWARE IS SUPPLIED BY MICROCHIP "AS IS". NO WARRANTIES, WHETHER 
33:                EXPRESS, IMPLIED OR STATUTORY, APPLY TO THIS SOFTWARE, INCLUDING ANY 
34:                IMPLIED WARRANTIES OF NON-INFRINGEMENT, MERCHANTABILITY, AND FITNESS 
35:                FOR A PARTICULAR PURPOSE.
36:                
37:                IN NO EVENT WILL MICROCHIP BE LIABLE FOR ANY INDIRECT, SPECIAL, PUNITIVE, 
38:                INCIDENTAL OR CONSEQUENTIAL LOSS, DAMAGE, COST OR EXPENSE OF ANY KIND 
39:                WHATSOEVER RELATED TO THE SOFTWARE, HOWEVER CAUSED, EVEN IF MICROCHIP 
40:                HAS BEEN ADVISED OF THE POSSIBILITY OR THE DAMAGES ARE FORESEEABLE. TO 
41:                THE FULLEST EXTENT ALLOWED BY LAW, MICROCHIP'S TOTAL LIABILITY ON ALL 
42:                CLAIMS IN ANY WAY RELATED TO THIS SOFTWARE WILL NOT EXCEED THE AMOUNT 
43:                OF FEES, IF ANY, THAT YOU HAVE PAID DIRECTLY TO MICROCHIP FOR THIS 
44:                SOFTWARE.
45:            */
46:            
47:            /**
48:              Section: Included Files
49:            */
50:            
51:            #include <xc.h>
52:            #include "tmr4.h"
53:            #include "interrupt_manager.h"
54:            
55:            /**
56:              Section: Global Variables Definitions
57:            */
58:            
59:            void (*TMR4_InterruptHandler)(void);
60:            
61:            /**
62:              Section: TMR4 APIs
63:            */
64:            
65:            void TMR4_Initialize(void)
66:            {
67:                // Set TMR4 to the options selected in the User Interface
68:            
69:                // T4CS FOSC; 
70:                T4CLKCON = 0x02;
1DC6  0E02     MOVLW 0x2
1DC8  0103     MOVLB 0x3
1DCA  6F32     MOVWF 0x32, BANKED
71:            
72:                // T4PSYNC Not Synchronized; T4MODE Software control; T4CKPOL Rising Edge; T4CKSYNC Not Synchronized; 
73:                T4HLT = 0x00;
1DCC  6B31     CLRF 0x31, BANKED
74:            
75:                // T4RSEL T4CKIPPS pin; 
76:                T4RST = 0x00;
1DCE  6B33     CLRF 0x33, BANKED
77:            
78:                // PR4 124; 
79:                T4PR = 0x7C;
1DD0  0E7C     MOVLW 0x7C
1DD2  6F2F     MOVWF 0x2F, BANKED
80:            
81:                // TMR4 0; 
82:                T4TMR = 0x00;
1DD4  6B2E     CLRF 0x2E, BANKED
83:            
84:                // Clearing IF flag before enabling the interrupt.
85:                PIR11bits.TMR4IF = 0;
1DD6  96B9     BCF 0xFB9, 3, ACCESS
86:            
87:                // Enabling TMR4 interrupt.
88:                PIE11bits.TMR4IE = 1;
1DD8  86A9     BSF 0xFA9, 3, ACCESS
89:            
90:                // Set Default Interrupt Handler
91:                TMR4_SetInterruptHandler(TMR4_DefaultInterruptHandler);
1DDA  0EA6     MOVLW 0xA6
1DDC  6EE6     MOVWF 0xFE6, ACCESS
1DDE  0E27     MOVLW 0x27
1DE0  6EE6     MOVWF 0xFE6, ACCESS
1DE2  0E00     MOVLW 0x0
1DE4  6EE6     MOVWF 0xFE6, ACCESS
1DE6  ECF4     CALL 0x21E8, 0
1DE8  F010     NOP
92:            
93:                // T4CKPS 1:16; T4OUTPS 1:10; TMR4ON on; 
94:                T4CON = 0xC9;
1DEA  0EC9     MOVLW 0xC9
1DEC  0103     MOVLB 0x3
1DEE  6F30     MOVWF 0x30, BANKED
95:            }
1DF0  0012     RETURN 0
96:            
97:            void TMR4_ModeSet(TMR4_HLT_MODE mode)
98:            {
99:               // Configure different types HLT mode
100:               T4HLTbits.MODE = mode;
101:           }
102:           
103:           void TMR4_ExtResetSourceSet(TMR4_HLT_EXT_RESET_SOURCE reset)
104:           {
105:               //Configure different types of HLT external reset source
106:               T4RSTbits.RSEL = reset;
107:           }
108:           
109:           void TMR4_Start(void)
110:           {
111:               // Start the Timer by writing to TMRxON bit
112:               T4CONbits.TMR4ON = 1;
2758  0103     MOVLB 0x3
275A  8F30     BSF 0x30, 7, BANKED
113:           }
275C  0012     RETURN 0
114:           
115:           void TMR4_StartTimer(void)
116:           {
117:               TMR4_Start();
2752  ECAC     CALL 0x2758, 0
2754  F013     NOP
118:           }
2756  0012     RETURN 0
119:           
120:           void TMR4_Stop(void)
121:           {
122:               // Stop the Timer by writing to TMRxON bit
123:               T4CONbits.TMR4ON = 0;
124:           }
125:           
126:           void TMR4_StopTimer(void)
127:           {
128:               TMR4_Stop();
129:           }
130:           
131:           uint8_t TMR4_Counter8BitGet(void)
132:           {
133:               uint8_t readVal;
134:           
135:               readVal = TMR4;
136:           
137:               return readVal;
138:           }
139:           
140:           uint8_t TMR4_ReadTimer(void)
141:           {
142:               return TMR4_Counter8BitGet();
143:           }
144:           
145:           void TMR4_Counter8BitSet(uint8_t timerVal)
146:           {
147:               // Write to the Timer4 register
148:               TMR4 = timerVal;
149:           }
150:           
151:           void TMR4_WriteTimer(uint8_t timerVal)
152:           {
153:               TMR4_Counter8BitSet(timerVal);
154:           }
155:           
156:           void TMR4_Period8BitSet(uint8_t periodVal)
157:           {
158:              PR4 = periodVal;
159:           }
160:           
161:           void TMR4_LoadPeriodRegister(uint8_t periodVal)
162:           {
163:              TMR4_Period8BitSet(periodVal);
164:           }
165:           
166:           void __interrupt(irq(TMR4),base(8)) TMR4_ISR()
0A68  C4FA     MOVFF PCLATH, __pcstackBANK8
0A6A  F8F5     NOP
0A6C  C4FB     MOVFF PCLATU, 0x8F6
0A6E  F8F6     NOP
0A70  0061     MOVFFL ltemp0, 0x8F7
0A72  F404     NOP
0A74  F8F7     NOP
0A76  0061     MOVFFL ltemp2, 0x8F8
0A78  F424     NOP
0A7A  F8F8     NOP
0A7C  0061     MOVFFL ttemp3, 0x8F9
0A7E  F428     NOP
0A80  F8F9     NOP
0A82  0061     MOVFFL wtemp5, 0x8FA
0A84  F42C     NOP
0A86  F8FA     NOP
0A88  0061     MOVFFL 0x50C, 0x8FB
0A8A  F430     NOP
0A8C  F8FB     NOP
0A8E  EE17     LFSR 1, 0x1FAA
0A90  F3AA     NOP
167:           {
168:           
169:               // clear the TMR4 interrupt flag
170:               PIR11bits.TMR4IF = 0;
0A92  96B9     BCF 0xFB9, 3, ACCESS
171:           
172:               if(TMR4_InterruptHandler)
0A94  0107     MOVLB 0x7
0A96  51A2     MOVF 0xA2, W, BANKED
0A98  11A3     IORWF 0xA3, W, BANKED
0A9A  11A4     IORWF 0xA4, W, BANKED
0A9C  B4D8     BTFSC 0xFD8, 2, ACCESS
0A9E  D00C     BRA 0xAB8
173:               {
174:                   TMR4_InterruptHandler();
0AA0  D801     RCALL 0xAA4
0AA2  D00A     BRA 0xAB8
0AA4  0005     PUSH
0AA6  6EFA     MOVWF 0xFFA, ACCESS
0AA8  51A2     MOVF 0xA2, W, BANKED
0AAA  6EFD     MOVWF 0xFFD, ACCESS
0AAC  51A3     MOVF 0xA3, W, BANKED
0AAE  6EFE     MOVWF 0xFFE, ACCESS
0AB0  51A4     MOVF 0xA4, W, BANKED
0AB2  6EFF     MOVWF 0xFFF, ACCESS
0AB4  50FA     MOVF 0xFFA, W, ACCESS
0AB6  0012     RETURN 0
175:               }
176:           }
0AB8  0062     MOVFFL 0x8FB, 0x50C
0AB8  0062     MOVFFL 0x8FB, 0x50C
0AB8  0062     MOVFFL 0x8FB, 0x50C
0AB8  0062     MOVFFL 0x8FB, 0x50C
0AB8  0062     MOVFFL 0x8FB, 0x50C
0AB8  0062     MOVFFL 0x8FB, 0x50C
0AB8  0062     MOVFFL 0x8FB, 0x50C
0AB8  0062     MOVFFL 0x8FB, 0x50C
0AB8  0062     MOVFFL 0x8FB, 0x50C
0AB8  0062     MOVFFL 0x8FB, 0x50C
0AB8  0062     MOVFFL 0x8FB, 0x50C
0AB8  0062     MOVFFL 0x8FB, 0x50C
0AB8  0062     MOVFFL 0x8FB, 0x50C
0AB8  0062     MOVFFL 0x8FB, 0x50C
0AB8  0062     MOVFFL 0x8FB, 0x50C
0AB8  0062     MOVFFL 0x8FB, 0x50C
0AB8  0062     MOVFFL 0x8FB, 0x50C
0AB8  0062     MOVFFL 0x8FB, 0x50C
0AB8  0062     MOVFFL 0x8FB, 0x50C
0AB8  0062     MOVFFL 0x8FB, 0x50C
177:           
178:           
179:           void TMR4_SetInterruptHandler(void (* InterruptHandler)(void)){
180:               TMR4_InterruptHandler = InterruptHandler;
21E8  50E1     MOVF 0xFE1, W, ACCESS
21EA  0FFD     ADDLW 0xFD
21EC  6ED9     MOVWF 0xFD9, ACCESS
21EE  50E2     MOVF 0xFE2, W, ACCESS
21F0  6EDA     MOVWF __end_of_UART2_tx_vect_isr, ACCESS
21F2  0EFF     MOVLW 0xFF
21F4  22DA     ADDWFC __end_of_UART2_tx_vect_isr, F, ACCESS
21F6  C4DE     MOVFF POSTINC2, TMR4_InterruptHandler
21F8  F7A2     NOP
21FA  C4DE     MOVFF POSTINC2, 0x7A3
21FC  F7A3     NOP
21FE  C4DD     MOVFF POSTDEC2, 0x7A4
2200  F7A4     NOP
181:           }
2202  52E5     MOVF 0xFE5, F, ACCESS
2202  52E5     MOVF 0xFE5, F, ACCESS
2202  52E5     MOVF 0xFE5, F, ACCESS
2202  52E5     MOVF 0xFE5, F, ACCESS
182:           
183:           void TMR4_DefaultInterruptHandler(void){
184:               // add your TMR4 interrupt custom code
185:               // or set custom function using TMR4_SetInterruptHandler()
186:           }
27A6  0012     RETURN 0
187:           
188:           /**
189:             End of File
190:           */
---  /public/Q84vtouch/mateQ84.X/mcc_generated_files/tmr2.c  --------------------------------------------
1:             /**
2:               TMR2 Generated Driver File
3:             
4:               @Company
5:                 Microchip Technology Inc.
6:             
7:               @File Name
8:                 tmr2.c
9:             
10:              @Summary
11:                This is the generated driver implementation file for the TMR2 driver using PIC10 / PIC12 / PIC16 / PIC18 MCUs
12:            
13:              @Description
14:                This source file provides APIs for TMR2.
15:                Generation Information :
16:                    Product Revision  :  PIC10 / PIC12 / PIC16 / PIC18 MCUs - 1.81.8
17:                    Device            :  PIC18F47Q84
18:                    Driver Version    :  2.11
19:                The generated drivers are tested against the following:
20:                    Compiler          :  XC8 2.36 and above 
21:                    MPLAB 	          :  MPLAB X 6.00
22:            */
23:            
24:            /*
25:                (c) 2018 Microchip Technology Inc. and its subsidiaries. 
26:                
27:                Subject to your compliance with these terms, you may use Microchip software and any 
28:                derivatives exclusively with Microchip products. It is your responsibility to comply with third party 
29:                license terms applicable to your use of third party software (including open source software) that 
30:                may accompany Microchip software.
31:                
32:                THIS SOFTWARE IS SUPPLIED BY MICROCHIP "AS IS". NO WARRANTIES, WHETHER 
33:                EXPRESS, IMPLIED OR STATUTORY, APPLY TO THIS SOFTWARE, INCLUDING ANY 
34:                IMPLIED WARRANTIES OF NON-INFRINGEMENT, MERCHANTABILITY, AND FITNESS 
35:                FOR A PARTICULAR PURPOSE.
36:                
37:                IN NO EVENT WILL MICROCHIP BE LIABLE FOR ANY INDIRECT, SPECIAL, PUNITIVE, 
38:                INCIDENTAL OR CONSEQUENTIAL LOSS, DAMAGE, COST OR EXPENSE OF ANY KIND 
39:                WHATSOEVER RELATED TO THE SOFTWARE, HOWEVER CAUSED, EVEN IF MICROCHIP 
40:                HAS BEEN ADVISED OF THE POSSIBILITY OR THE DAMAGES ARE FORESEEABLE. TO 
41:                THE FULLEST EXTENT ALLOWED BY LAW, MICROCHIP'S TOTAL LIABILITY ON ALL 
42:                CLAIMS IN ANY WAY RELATED TO THIS SOFTWARE WILL NOT EXCEED THE AMOUNT 
43:                OF FEES, IF ANY, THAT YOU HAVE PAID DIRECTLY TO MICROCHIP FOR THIS 
44:                SOFTWARE.
45:            */
46:            
47:            /**
48:              Section: Included Files
49:            */
50:            
51:            #include <xc.h>
52:            #include "tmr2.h"
53:            #include "interrupt_manager.h"
54:            
55:            /**
56:              Section: Global Variables Definitions
57:            */
58:            
59:            void (*TMR2_InterruptHandler)(void);
60:            
61:            /**
62:              Section: TMR2 APIs
63:            */
64:            
65:            void TMR2_Initialize(void)
66:            {
67:                // Set TMR2 to the options selected in the User Interface
68:            
69:                // T2CS LFINTOSC; 
70:                T2CLKCON = 0x04;
1E74  0E04     MOVLW 0x4
1E76  0103     MOVLB 0x3
1E78  6F26     MOVWF 0x26, BANKED
71:            
72:                // T2PSYNC Not Synchronized; T2MODE Software control; T2CKPOL Rising Edge; T2CKSYNC Not Synchronized; 
73:                T2HLT = 0x00;
1E7A  6B25     CLRF 0x25, BANKED
74:            
75:                // T2RSEL T2CKIPPS pin; 
76:                T2RST = 0x00;
1E7C  6B27     CLRF 0x27, BANKED
77:            
78:                // PR2 150; 
79:                T2PR = 0x96;
1E7E  0E96     MOVLW 0x96
1E80  6F23     MOVWF 0x23, BANKED
80:            
81:                // TMR2 0; 
82:                T2TMR = 0x00;
1E82  6B22     CLRF 0x22, BANKED
83:            
84:                // Clearing IF flag before enabling the interrupt.
85:                PIR3bits.TMR2IF = 0;
1E84  96B1     BCF 0xFB1, 3, ACCESS
86:            
87:                // Enabling TMR2 interrupt.
88:                PIE3bits.TMR2IE = 1;
1E86  86A1     BSF 0xFA1, 3, ACCESS
89:            
90:                // Set Default Interrupt Handler
91:                TMR2_SetInterruptHandler(TMR2_DefaultInterruptHandler);
1E88  0E9E     MOVLW 0x9E
1E8A  6EE6     MOVWF 0xFE6, ACCESS
1E8C  0ECB     MOVLW 0xCB
1E8E  6EE6     MOVWF 0xFE6, ACCESS
1E90  0E01     MOVLW 0x1
1E92  6EE6     MOVWF 0xFE6, ACCESS
1E94  EC05     CALL 0x220A, 0
1E96  F011     NOP
92:            
93:                // T2CKPS 1:128; T2OUTPS 1:16; TMR2ON on; 
94:                T2CON = 0xFF;
1E98  0103     MOVLB 0x3
1E9A  6924     SETF 0x24, BANKED
95:            }
1E9C  0012     RETURN 0
96:            
97:            void TMR2_ModeSet(TMR2_HLT_MODE mode)
98:            {
99:               // Configure different types HLT mode
100:               T2HLTbits.MODE = mode;
101:           }
102:           
103:           void TMR2_ExtResetSourceSet(TMR2_HLT_EXT_RESET_SOURCE reset)
104:           {
105:               //Configure different types of HLT external reset source
106:               T2RSTbits.RSEL = reset;
107:           }
108:           
109:           void TMR2_Start(void)
110:           {
111:               // Start the Timer by writing to TMRxON bit
112:               T2CONbits.TMR2ON = 1;
2764  0103     MOVLB 0x3
2766  8F24     BSF 0x24, 7, BANKED
113:           }
2768  0012     RETURN 0
114:           
115:           void TMR2_StartTimer(void)
116:           {
117:               TMR2_Start();
275E  ECB2     CALL 0x2764, 0
2760  F013     NOP
118:           }
2762  0012     RETURN 0
119:           
120:           void TMR2_Stop(void)
121:           {
122:               // Stop the Timer by writing to TMRxON bit
123:               T2CONbits.TMR2ON = 0;
124:           }
125:           
126:           void TMR2_StopTimer(void)
127:           {
128:               TMR2_Stop();
129:           }
130:           
131:           uint8_t TMR2_Counter8BitGet(void)
132:           {
133:               uint8_t readVal;
134:           
135:               readVal = TMR2;
136:           
137:               return readVal;
138:           }
139:           
140:           uint8_t TMR2_ReadTimer(void)
141:           {
142:               return TMR2_Counter8BitGet();
143:           }
144:           
145:           void TMR2_Counter8BitSet(uint8_t timerVal)
146:           {
147:               // Write to the Timer2 register
148:               TMR2 = timerVal;
149:           }
150:           
151:           void TMR2_WriteTimer(uint8_t timerVal)
152:           {
153:               TMR2_Counter8BitSet(timerVal);
154:           }
155:           
156:           void TMR2_Period8BitSet(uint8_t periodVal)
157:           {
158:              PR2 = periodVal;
159:           }
160:           
161:           void TMR2_LoadPeriodRegister(uint8_t periodVal)
162:           {
163:              TMR2_Period8BitSet(periodVal);
164:           }
165:           
166:           void __interrupt(irq(TMR2),base(8),low_priority) TMR2_ISR()
127C  C4D8     MOVFF STATUS, 0xAEF
127E  FAEF     NOP
1280  C4FA     MOVFF PCLATH, 0xAF0
1282  FAF0     NOP
1284  C4FB     MOVFF PCLATU, 0xAF1
1286  FAF1     NOP
1288  0061     MOVFFL 0x50C, 0xAF2
128A  F430     NOP
128C  FAF2     NOP
128E  EE1A     LFSR 1, 0x2B55
1290  F355     NOP
167:           {
168:           
169:               // clear the TMR2 interrupt flag
170:               PIR3bits.TMR2IF = 0;
1292  96B1     BCF 0xFB1, 3, ACCESS
171:           
172:               if(TMR2_InterruptHandler)
1294  0107     MOVLB 0x7
1296  51A5     MOVF 0xA5, W, BANKED
1298  11A6     IORWF 0xA6, W, BANKED
129A  11A7     IORWF 0xA7, W, BANKED
129C  B4D8     BTFSC 0xFD8, 2, ACCESS
129E  D00C     BRA 0x12B8
173:               {
174:                   TMR2_InterruptHandler();
12A0  D801     RCALL 0x12A4
12A2  D00A     BRA 0x12B8
12A4  0005     PUSH
12A6  6EFA     MOVWF 0xFFA, ACCESS
12A8  51A5     MOVF 0xA5, W, BANKED
12AA  6EFD     MOVWF 0xFFD, ACCESS
12AC  51A6     MOVF 0xA6, W, BANKED
12AE  6EFE     MOVWF 0xFFE, ACCESS
12B0  51A7     MOVF 0xA7, W, BANKED
12B2  6EFF     MOVWF 0xFFF, ACCESS
12B4  50FA     MOVF 0xFFA, W, ACCESS
12B6  0012     RETURN 0
175:               }
176:           }
12B8  0062     MOVFFL 0xAF2, 0x50C
12B8  0062     MOVFFL 0xAF2, 0x50C
12B8  0062     MOVFFL 0xAF2, 0x50C
12B8  0062     MOVFFL 0xAF2, 0x50C
12B8  0062     MOVFFL 0xAF2, 0x50C
12B8  0062     MOVFFL 0xAF2, 0x50C
12B8  0062     MOVFFL 0xAF2, 0x50C
12B8  0062     MOVFFL 0xAF2, 0x50C
12B8  0062     MOVFFL 0xAF2, 0x50C
12B8  0062     MOVFFL 0xAF2, 0x50C
177:           
178:           
179:           void TMR2_SetInterruptHandler(void (* InterruptHandler)(void)){
180:               TMR2_InterruptHandler = InterruptHandler;
220A  50E1     MOVF 0xFE1, W, ACCESS
220C  0FFD     ADDLW 0xFD
220E  6ED9     MOVWF 0xFD9, ACCESS
2210  50E2     MOVF 0xFE2, W, ACCESS
2212  6EDA     MOVWF __end_of_UART2_tx_vect_isr, ACCESS
2214  0EFF     MOVLW 0xFF
2216  22DA     ADDWFC __end_of_UART2_tx_vect_isr, F, ACCESS
2218  C4DE     MOVFF POSTINC2, TMR2_InterruptHandler
221A  F7A5     NOP
221C  C4DE     MOVFF POSTINC2, 0x7A6
221E  F7A6     NOP
2220  C4DD     MOVFF POSTDEC2, 0x7A7
2222  F7A7     NOP
181:           }
2224  52E5     MOVF 0xFE5, F, ACCESS
2224  52E5     MOVF 0xFE5, F, ACCESS
2224  52E5     MOVF 0xFE5, F, ACCESS
2224  52E5     MOVF 0xFE5, F, ACCESS
182:           
183:           void TMR2_DefaultInterruptHandler(void){
184:               // add your TMR2 interrupt custom code
185:               // or set custom function using TMR2_SetInterruptHandler()
186:           }
1CB9E  0012     RETURN 0
187:           
188:           /**
189:             End of File
190:           */
---  /public/Q84vtouch/mateQ84.X/mcc_generated_files/tmr0.c  --------------------------------------------
1:             /**
2:               TMR0 Generated Driver File
3:             
4:               @Company
5:                 Microchip Technology Inc.
6:             
7:               @File Name
8:                 tmr0.c
9:             
10:              @Summary
11:                This is the generated driver implementation file for the TMR0 driver using PIC10 / PIC12 / PIC16 / PIC18 MCUs
12:            
13:              @Description
14:                This source file provides APIs for TMR0.
15:                Generation Information :
16:                    Product Revision  :  PIC10 / PIC12 / PIC16 / PIC18 MCUs - 1.81.8
17:                    Device            :  PIC18F47Q84
18:                    Driver Version    :  3.10
19:                The generated drivers are tested against the following:
20:                    Compiler          :  XC8 2.36 and above
21:                    MPLAB 	          :  MPLAB X 6.00
22:            */
23:            
24:            /*
25:                (c) 2018 Microchip Technology Inc. and its subsidiaries. 
26:                
27:                Subject to your compliance with these terms, you may use Microchip software and any 
28:                derivatives exclusively with Microchip products. It is your responsibility to comply with third party 
29:                license terms applicable to your use of third party software (including open source software) that 
30:                may accompany Microchip software.
31:                
32:                THIS SOFTWARE IS SUPPLIED BY MICROCHIP "AS IS". NO WARRANTIES, WHETHER 
33:                EXPRESS, IMPLIED OR STATUTORY, APPLY TO THIS SOFTWARE, INCLUDING ANY 
34:                IMPLIED WARRANTIES OF NON-INFRINGEMENT, MERCHANTABILITY, AND FITNESS 
35:                FOR A PARTICULAR PURPOSE.
36:                
37:                IN NO EVENT WILL MICROCHIP BE LIABLE FOR ANY INDIRECT, SPECIAL, PUNITIVE, 
38:                INCIDENTAL OR CONSEQUENTIAL LOSS, DAMAGE, COST OR EXPENSE OF ANY KIND 
39:                WHATSOEVER RELATED TO THE SOFTWARE, HOWEVER CAUSED, EVEN IF MICROCHIP 
40:                HAS BEEN ADVISED OF THE POSSIBILITY OR THE DAMAGES ARE FORESEEABLE. TO 
41:                THE FULLEST EXTENT ALLOWED BY LAW, MICROCHIP'S TOTAL LIABILITY ON ALL 
42:                CLAIMS IN ANY WAY RELATED TO THIS SOFTWARE WILL NOT EXCEED THE AMOUNT 
43:                OF FEES, IF ANY, THAT YOU HAVE PAID DIRECTLY TO MICROCHIP FOR THIS 
44:                SOFTWARE.
45:            */
46:            
47:            /**
48:              Section: Included Files
49:            */
50:            
51:            #include <xc.h>
52:            #include "tmr0.h"
53:            #include "interrupt_manager.h"
54:            
55:            
56:            /**
57:              Section: TMR0 APIs
58:            */
59:            
60:            void (*TMR0_InterruptHandler)(void);
61:            
62:            void TMR0_Initialize(void)
63:            {
64:                // Set TMR0 to the options selected in the User Interface
65:            
66:                // T0CS FOSC/4; T0CKPS 1:32768; T0ASYNC synchronised; 
67:                T0CON1 = 0x4F;
1F6C  0E4F     MOVLW 0x4F
1F6E  0103     MOVLB 0x3
1F70  6F1B     MOVWF 0x1B, BANKED
68:            
69:                // TMR0H 152; 
70:                TMR0H = 0x98;
1F72  0E98     MOVLW 0x98
1F74  6F19     MOVWF 0x19, BANKED
71:            
72:                // TMR0L 0; 
73:                TMR0L = 0x00;
1F76  6B18     CLRF 0x18, BANKED
74:            
75:                // Clear Interrupt flag before enabling the interrupt
76:                PIR3bits.TMR0IF = 0;
1F78  9EB1     BCF 0xFB1, 7, ACCESS
77:            
78:                // Enabling TMR0 interrupt.
79:                PIE3bits.TMR0IE = 1;
1F7A  8EA1     BSF 0xFA1, 7, ACCESS
80:            
81:                // Set Default Interrupt Handler
82:                TMR0_SetInterruptHandler(TMR0_DefaultInterruptHandler);
1F7C  0EFE     MOVLW 0xFE
1F7E  6EE6     MOVWF 0xFE6, ACCESS
1F80  0EFF     MOVLW 0xFF
1F82  6EE6     MOVWF 0xFE6, ACCESS
1F84  0E01     MOVLW 0x1
1F86  6EE6     MOVWF 0xFE6, ACCESS
1F88  EC16     CALL 0x222C, 0
1F8A  F011     NOP
83:            
84:                // T0OUTPS 1:2; T0EN enabled; T016BIT 8-bit; 
85:                T0CON0 = 0x81;
1F8C  0E81     MOVLW 0x81
1F8E  0103     MOVLB 0x3
1F90  6F1A     MOVWF 0x1A, BANKED
86:            }
1F92  0012     RETURN 0
87:            
88:            void TMR0_StartTimer(void)
89:            {
90:                // Start the Timer by writing to TMR0ON bit
91:                T0CON0bits.T0EN = 1;
276A  0103     MOVLB 0x3
276C  8F1A     BSF 0x1A, 7, BANKED
92:            }
276E  0012     RETURN 0
93:            
94:            void TMR0_StopTimer(void)
95:            {
96:                // Stop the Timer by writing to TMR0ON bit
97:                T0CON0bits.T0EN = 0;
98:            }
99:            
100:           uint8_t TMR0_ReadTimer(void)
101:           {
102:               uint8_t readVal;
103:           
104:               // read Timer0, low register only
105:               readVal = TMR0L;
106:           
107:               return readVal;
108:           }
109:           
110:           void TMR0_WriteTimer(uint8_t timerVal)
111:           {
112:               // Write to Timer0 registers, low register only
113:               TMR0L = timerVal;
114:            }
115:           
116:           void TMR0_Reload(uint8_t periodVal)
117:           {
118:              // Write to Timer0 registers, high register only
119:              TMR0H = periodVal;
120:           }
121:           
122:           void __interrupt(irq(TMR0),base(8),low_priority) TMR0_ISR()
122C  C4D8     MOVFF STATUS, 0xAEB
122E  FAEB     NOP
1230  C4FA     MOVFF PCLATH, 0xAEC
1232  FAEC     NOP
1234  C4FB     MOVFF PCLATU, 0xAED
1236  FAED     NOP
1238  0061     MOVFFL 0x50C, 0xAEE
123A  F430     NOP
123C  FAEE     NOP
123E  EE1A     LFSR 1, 0x2B55
1240  F355     NOP
123:           {
124:               // clear the TMR0 interrupt flag
125:               PIR3bits.TMR0IF = 0;
1242  9EB1     BCF 0xFB1, 7, ACCESS
126:               if(TMR0_InterruptHandler)
1244  0107     MOVLB 0x7
1246  51BA     MOVF DMA5PR, W, BANKED
1248  11BB     IORWF DMA6PR, W, BANKED
124A  11BC     IORWF DMA7PR, W, BANKED
124C  B4D8     BTFSC 0xFD8, 2, ACCESS
124E  D00C     BRA 0x1268
127:               {
128:                   TMR0_InterruptHandler();
1250  D801     RCALL 0x1254
1252  D00A     BRA 0x1268
1254  0005     PUSH
1256  6EFA     MOVWF 0xFFA, ACCESS
1258  51BA     MOVF DMA5PR, W, BANKED
125A  6EFD     MOVWF 0xFFD, ACCESS
125C  51BB     MOVF DMA6PR, W, BANKED
125E  6EFE     MOVWF 0xFFE, ACCESS
1260  51BC     MOVF DMA7PR, W, BANKED
1262  6EFF     MOVWF 0xFFF, ACCESS
1264  50FA     MOVF 0xFFA, W, ACCESS
1266  0012     RETURN 0
129:               }
130:           
131:               // add your TMR0 interrupt custom code
132:           }
1268  0062     MOVFFL 0xAEE, 0x50C
1268  0062     MOVFFL 0xAEE, 0x50C
1268  0062     MOVFFL 0xAEE, 0x50C
1268  0062     MOVFFL 0xAEE, 0x50C
1268  0062     MOVFFL 0xAEE, 0x50C
1268  0062     MOVFFL 0xAEE, 0x50C
1268  0062     MOVFFL 0xAEE, 0x50C
1268  0062     MOVFFL 0xAEE, 0x50C
1268  0062     MOVFFL 0xAEE, 0x50C
1268  0062     MOVFFL 0xAEE, 0x50C
133:           
134:           
135:           void TMR0_SetInterruptHandler(void (* InterruptHandler)(void)){
136:               TMR0_InterruptHandler = InterruptHandler;
222C  50E1     MOVF 0xFE1, W, ACCESS
222E  0FFD     ADDLW 0xFD
2230  6ED9     MOVWF 0xFD9, ACCESS
2232  50E2     MOVF 0xFE2, W, ACCESS
2234  6EDA     MOVWF __end_of_UART2_tx_vect_isr, ACCESS
2236  0EFF     MOVLW 0xFF
2238  22DA     ADDWFC __end_of_UART2_tx_vect_isr, F, ACCESS
223A  C4DE     MOVFF POSTINC2, TMR0_InterruptHandler
223C  F7BA     NOP
223E  C4DE     MOVFF POSTINC2, 0x7BB
2240  F7BB     NOP
2242  C4DD     MOVFF POSTDEC2, 0x7BC
2244  F7BC     NOP
137:           }
2246  52E5     MOVF 0xFE5, F, ACCESS
2246  52E5     MOVF 0xFE5, F, ACCESS
2246  52E5     MOVF 0xFE5, F, ACCESS
2246  52E5     MOVF 0xFE5, F, ACCESS
138:           
139:           void TMR0_DefaultInterruptHandler(void){
140:               // add your TMR0 interrupt custom code
141:               // or set custom function using TMR0_SetInterruptHandler()
142:           }
1FFFE  0012     RETURN 0
143:           
144:           /**
145:             End of File
146:           */
---  /public/Q84vtouch/mateQ84.X/mcc_generated_files/spi1.c  --------------------------------------------
1:             /**
2:               SPI1 Generated Driver File
3:             
4:               @Company
5:                 Microchip Technology Inc.
6:             
7:               @File Name
8:                 spi1.c
9:             
10:              @Summary
11:                This is the generated driver implementation file for the SPI1 driver using PIC10 / PIC12 / PIC16 / PIC18 MCUs
12:            
13:              @Description
14:                This header file provides implementations for driver APIs for SPI1.
15:                Generation Information :
16:                    Product Revision  :  PIC10 / PIC12 / PIC16 / PIC18 MCUs - 1.81.8
17:                    Device            :  PIC18F47Q84
18:                    Driver Version    :  1.0.0
19:                The generated drivers are tested against the following:
20:                    Compiler          :  XC8 2.36 and above or later
21:                    MPLAB             :  MPLAB X 6.00
22:            */
23:            
24:            /*
25:                (c) 2018 Microchip Technology Inc. and its subsidiaries. 
26:                
27:                Subject to your compliance with these terms, you may use Microchip software and any 
28:                derivatives exclusively with Microchip products. It is your responsibility to comply with third party 
29:                license terms applicable to your use of third party software (including open source software) that 
30:                may accompany Microchip software.
31:                
32:                THIS SOFTWARE IS SUPPLIED BY MICROCHIP "AS IS". NO WARRANTIES, WHETHER 
33:                EXPRESS, IMPLIED OR STATUTORY, APPLY TO THIS SOFTWARE, INCLUDING ANY 
34:                IMPLIED WARRANTIES OF NON-INFRINGEMENT, MERCHANTABILITY, AND FITNESS 
35:                FOR A PARTICULAR PURPOSE.
36:                
37:                IN NO EVENT WILL MICROCHIP BE LIABLE FOR ANY INDIRECT, SPECIAL, PUNITIVE, 
38:                INCIDENTAL OR CONSEQUENTIAL LOSS, DAMAGE, COST OR EXPENSE OF ANY KIND 
39:                WHATSOEVER RELATED TO THE SOFTWARE, HOWEVER CAUSED, EVEN IF MICROCHIP 
40:                HAS BEEN ADVISED OF THE POSSIBILITY OR THE DAMAGES ARE FORESEEABLE. TO 
41:                THE FULLEST EXTENT ALLOWED BY LAW, MICROCHIP'S TOTAL LIABILITY ON ALL 
42:                CLAIMS IN ANY WAY RELATED TO THIS SOFTWARE WILL NOT EXCEED THE AMOUNT 
43:                OF FEES, IF ANY, THAT YOU HAVE PAID DIRECTLY TO MICROCHIP FOR THIS 
44:                SOFTWARE.
45:            */
46:            
47:            #include "spi1.h"
48:            #include <xc.h>
49:            
50:            typedef struct { 
51:                uint8_t con0; 
52:                uint8_t con1; 
53:                uint8_t con2; 
54:                uint8_t baud; 
55:                uint8_t operation;
56:            } spi1_configuration_t;
57:            
58:            
59:            //con0 == SPIxCON0, con1 == SPIxCON1, con2 == SPIxCON2, baud == SPIxBAUD, operation == Master/Slave
60:            static const spi1_configuration_t spi1_configuration[] = {   
61:                { 0x83, 0x20, 0x3, 0x96, 0 }
62:            };
63:            
64:            void SPI1_Initialize(void)
65:            {
66:                //EN enabled; LSBF MSb first; MST bus master; BMODE every byte; 
67:                SPI1CON0 = 0x83;
259E  0E83     MOVLW 0x83
25A0  0100     MOVLB 0x0
25A2  6F84     MOVWF SPI1CON0, BANKED
68:                //SMP Middle; CKE Idle to active; CKP Idle:High, Active:Low; FST disabled; SSP active high; SDIP active high; SDOP active high; 
69:                SPI1CON1 = 0x20;
25A4  0E20     MOVLW 0x20
25A6  6F85     MOVWF SPI1CON1, BANKED
70:                //SSET disabled; TXR required for a transfer; RXR suspended if the RxFIFO is full; 
71:                SPI1CON2 = 0x03;
25A8  0E03     MOVLW 0x3
25AA  6F86     MOVWF SPI1CON2, BANKED
72:                //CLKSEL HFINTOSC; 
73:                SPI1CLK = 0x01;
25AC  0E01     MOVLW 0x1
25AE  6F8C     MOVWF SPI1CLK, BANKED
74:                //BAUD 150; 
75:                SPI1BAUD = 0x96;
25B0  0E96     MOVLW 0x96
25B2  6F89     MOVWF SPI1BAUD, BANKED
76:                TRISCbits.TRISC3 = 0;
25B4  96C8     BCF 0xFC8, 3, ACCESS
77:            }
25B6  0012     RETURN 0
78:            
79:            bool SPI1_Open(spi1_modes_t spi1UniqueConfiguration)
80:            {
81:                if(!SPI1CON0bits.EN)
82:                {
83:                    SPI1CON0 = spi1_configuration[spi1UniqueConfiguration].con0;
84:                    SPI1CON1 = spi1_configuration[spi1UniqueConfiguration].con1;
85:                    SPI1CON2 = spi1_configuration[spi1UniqueConfiguration].con2 | (_SPI1CON2_SPI1RXR_MASK | _SPI1CON2_SPI1TXR_MASK);
86:                    SPI1BAUD = spi1_configuration[spi1UniqueConfiguration].baud;        
87:                    TRISCbits.TRISC3 = spi1_configuration[spi1UniqueConfiguration].operation;
88:                    SPI1CON0bits.EN = 1;
89:                    return true;
90:                }
91:                return false;
92:            }
93:            
94:            void SPI1_Close(void)
95:            {
96:                SPI1CON0bits.EN = 0;
97:            }
98:            
99:            uint8_t SPI1_ExchangeByte(uint8_t data)
100:           {
101:               SPI1TCNTL = 1;
102:               SPI1TXB = data;
103:               while(!PIR3bits.SPI1RXIF);
104:               return SPI1RXB;
105:           }
106:           
107:           void SPI1_ExchangeBlock(void *block, size_t blockSize)
108:           {
109:               uint8_t *data = block;
110:               while(blockSize--)
111:               {
112:                   SPI1TCNTL = 1;
113:                   SPI1TXB = *data;
114:                   while(!PIR3bits.SPI1RXIF);
115:                   *data++ = SPI1RXB;
116:               }
117:           }
118:           
119:           // Half Duplex SPI Functions
120:           void SPI1_WriteBlock(void *block, size_t blockSize)
121:           {
122:               uint8_t *data = block;
123:               while(blockSize--)
124:               {
125:                   SPI1_ExchangeByte(*data++);
126:               }
127:           }
128:           
129:           void SPI1_ReadBlock(void *block, size_t blockSize)
130:           {
131:               uint8_t *data = block;
132:               while(blockSize--)
133:               {
134:                   *data++ = SPI1_ExchangeByte(0);
135:               }
136:           }
137:           
138:           void SPI1_WriteByte(uint8_t byte)
139:           {
140:               SPI1TXB = byte;
141:           }
142:           
143:           uint8_t SPI1_ReadByte(void)
144:           {
145:               return SPI1RXB;
146:           }
---  /public/Q84vtouch/mateQ84.X/mcc_generated_files/pin_manager.c  -------------------------------------
1:             /**
2:               Generated Pin Manager File
3:             
4:               Company:
5:                 Microchip Technology Inc.
6:             
7:               File Name:
8:                 pin_manager.c
9:             
10:              Summary:
11:                This is the Pin Manager file generated using PIC10 / PIC12 / PIC16 / PIC18 MCUs
12:            
13:              Description:
14:                This header file provides implementations for pin APIs for all pins selected in the GUI.
15:                Generation Information :
16:                    Product Revision  :  PIC10 / PIC12 / PIC16 / PIC18 MCUs - 1.81.8
17:                    Device            :  PIC18F47Q84
18:                    Driver Version    :  2.11
19:                The generated drivers are tested against the following:
20:                    Compiler          :  XC8 2.36 and above
21:                    MPLAB             :  MPLAB X 6.00
22:            
23:                Copyright (c) 2013 - 2015 released Microchip Technology Inc.  All rights reserved.
24:            */
25:            
26:            /*
27:                (c) 2018 Microchip Technology Inc. and its subsidiaries. 
28:                
29:                Subject to your compliance with these terms, you may use Microchip software and any 
30:                derivatives exclusively with Microchip products. It is your responsibility to comply with third party 
31:                license terms applicable to your use of third party software (including open source software) that 
32:                may accompany Microchip software.
33:                
34:                THIS SOFTWARE IS SUPPLIED BY MICROCHIP "AS IS". NO WARRANTIES, WHETHER 
35:                EXPRESS, IMPLIED OR STATUTORY, APPLY TO THIS SOFTWARE, INCLUDING ANY 
36:                IMPLIED WARRANTIES OF NON-INFRINGEMENT, MERCHANTABILITY, AND FITNESS 
37:                FOR A PARTICULAR PURPOSE.
38:                
39:                IN NO EVENT WILL MICROCHIP BE LIABLE FOR ANY INDIRECT, SPECIAL, PUNITIVE, 
40:                INCIDENTAL OR CONSEQUENTIAL LOSS, DAMAGE, COST OR EXPENSE OF ANY KIND 
41:                WHATSOEVER RELATED TO THE SOFTWARE, HOWEVER CAUSED, EVEN IF MICROCHIP 
42:                HAS BEEN ADVISED OF THE POSSIBILITY OR THE DAMAGES ARE FORESEEABLE. TO 
43:                THE FULLEST EXTENT ALLOWED BY LAW, MICROCHIP'S TOTAL LIABILITY ON ALL 
44:                CLAIMS IN ANY WAY RELATED TO THIS SOFTWARE WILL NOT EXCEED THE AMOUNT 
45:                OF FEES, IF ANY, THAT YOU HAVE PAID DIRECTLY TO MICROCHIP FOR THIS 
46:                SOFTWARE.
47:            */
48:            
49:            #include "pin_manager.h"
50:            
51:            
52:            
53:            
54:            
55:            void PIN_MANAGER_Initialize(void)
56:            {
57:                /**
58:                LATx registers
59:                */
60:                LATE = 0x00;
04B2  6AC2     CLRF 0xFC2, ACCESS
61:                LATD = 0x1E;
04B4  0E1E     MOVLW 0x1E
04B6  6EC1     MOVWF 0xFC1, ACCESS
62:                LATA = 0x00;
04B8  6ABE     CLRF 0xFBE, ACCESS
63:                LATB = 0x0E;
04BA  0E0E     MOVLW 0xE
04BC  6EBF     MOVWF 0xFBF, ACCESS
64:                LATC = 0x04;
04BE  0E04     MOVLW 0x4
04C0  6EC0     MOVWF 0xFC0, ACCESS
65:            
66:                /**
67:                TRISx registers
68:                */
69:                TRISE = 0x00;
04C2  6ACA     CLRF 0xFCA, ACCESS
70:                TRISA = 0xEF;
04C4  0EEF     MOVLW 0xEF
04C6  6EC6     MOVWF 0xFC6, ACCESS
71:                TRISB = 0x09;
04C8  0E09     MOVLW 0x9
04CA  6EC7     MOVWF 0xFC7, ACCESS
72:                TRISC = 0x91;
04CC  0E91     MOVLW 0x91
04CE  6EC8     MOVWF 0xFC8, ACCESS
73:                TRISD = 0x01;
04D0  0E01     MOVLW 0x1
04D2  6EC9     MOVWF 0xFC9, ACCESS
74:            
75:                /**
76:                ANSELx registers
77:                */
78:                ANSELD = 0x00;
04D4  0104     MOVLB 0x4
04D6  6B18     CLRF 0x18, BANKED
79:                ANSELC = 0x00;
04D8  6B10     CLRF 0x10, BANKED
80:                ANSELB = 0xC0;
04DA  0EC0     MOVLW 0xC0
04DC  6F08     MOVWF 0x8, BANKED
81:                ANSELE = 0x00;
04DE  6B20     CLRF 0x20, BANKED
82:                ANSELA = 0xFF;
04E0  6900     SETF __smallconst, BANKED
83:            
84:                /**
85:                WPUx registers
86:                */
87:                WPUD = 0x00;
04E2  6B19     CLRF 0x19, BANKED
88:                WPUE = 0x00;
04E4  6B21     CLRF 0x21, BANKED
89:                WPUB = 0x01;
04E6  0E01     MOVLW 0x1
04E8  6F09     MOVWF 0x9, BANKED
90:                WPUA = 0x00;
04EA  6B01     CLRF __ptext283, BANKED
91:                WPUC = 0x01;
04EC  0E01     MOVLW 0x1
04EE  6F11     MOVWF 0x11, BANKED
92:            
93:                /**
94:                ODx registers
95:                */
96:                ODCONE = 0x00;
04F0  6B22     CLRF 0x22, BANKED
97:                ODCONA = 0x00;
04F2  6B02     CLRF ___rparam_used, BANKED
98:                ODCONB = 0x00;
04F4  6B0A     CLRF 0xA, BANKED
99:                ODCONC = 0x00;
04F6  6B12     CLRF 0x12, BANKED
100:               ODCOND = 0x00;
04F8  6B1A     CLRF 0x1A, BANKED
101:           
102:               /**
103:               SLRCONx registers
104:               */
105:               SLRCONA = 0xFF;
04FA  6903     SETF __activetblptr, BANKED
106:               SLRCONB = 0xFF;
04FC  690B     SETF 0xB, BANKED
107:               SLRCONC = 0xFF;
04FE  6913     SETF 0x13, BANKED
108:               SLRCOND = 0xFF;
0500  691B     SETF 0x1B, BANKED
109:               SLRCONE = 0x07;
0502  0E07     MOVLW 0x7
0504  6F23     MOVWF 0x23, BANKED
110:           
111:               /**
112:               INLVLx registers
113:               */
114:               INLVLA = 0xFF;
0506  6904     SETF __activetblptr, BANKED
115:               INLVLB = 0xFF;
0508  690C     SETF 0xC, BANKED
116:               INLVLC = 0xFF;
050A  6914     SETF 0x14, BANKED
117:               INLVLD = 0xFF;
050C  691C     SETF 0x1C, BANKED
118:               INLVLE = 0x0F;
050E  0E0F     MOVLW 0xF
0510  6F24     MOVWF 0x24, BANKED
119:           
120:           
121:           
122:           
123:           
124:              
125:               
126:           	
127:               U2RXPPS = 0x18;   //RD0->UART2:RX2;    
0512  0E18     MOVLW 0x18
0514  0102     MOVLB 0x2
0516  6F74     MOVWF CM2CON0, BANKED
128:               U5RXPPS = 0x10;   //RC0->UART5:RX5;    
0518  0E10     MOVLW 0x10
051A  6F7A     MOVWF WDTPSL, BANKED
129:               SPI1SCKPPS = 0x13;   //RC3->SPI1:SCK1;    
051C  0E13     MOVLW 0x13
051E  6F6A     MOVWF MD1CON0, BANKED
130:               RC3PPS = 0x31;   //RC3->SPI1:SCK1;    
0520  0E31     MOVLW 0x31
0522  6F14     MOVWF 0x14, BANKED
131:               RC1PPS = 0x2C;   //RC1->UART5:TX5;    
0524  0E2C     MOVLW 0x2C
0526  6F12     MOVWF 0x12, BANKED
132:               CANRXPPS = 0x08;   //RB0->CAN1:CANRX;    
0528  0E08     MOVLW 0x8
052A  6F3D     MOVWF 0x3D, BANKED
133:               RB4PPS = 0x46;   //RB4->CAN1:CANTX;    
052C  0E46     MOVLW 0x46
052E  6F0D     MOVWF 0xD, BANKED
134:               RC5PPS = 0x32;   //RC5->SPI1:SDO1;    
0530  0E32     MOVLW 0x32
0532  6F16     MOVWF 0x16, BANKED
135:               RC6PPS = 0x20;   //RC6->UART1:TX1;    
0534  0E20     MOVLW 0x20
0536  6F17     MOVWF 0x17, BANKED
136:               U1RXPPS = 0x17;   //RC7->UART1:RX1;    
0538  0E17     MOVLW 0x17
053A  6F72     MOVWF CM1NCH, BANKED
137:               RD6PPS = 0x23;   //RD6->UART2:TX2;    
053C  0E23     MOVLW 0x23
053E  6F1F     MOVWF 0x1F, BANKED
138:               SPI1SDIPPS = 0x14;   //RC4->SPI1:SDI1;    
0540  0E14     MOVLW 0x14
0542  6F6B     MOVWF MD1CON1, BANKED
139:           }
0544  0012     RETURN 0
140:             
141:           void PIN_MANAGER_IOC(void)
142:           {   
143:           }
144:           
145:           /**
146:            End of File
147:           */
---  /public/Q84vtouch/mateQ84.X/mcc_generated_files/mcc.c  ---------------------------------------------
1:             /**
2:               @Generated PIC10 / PIC12 / PIC16 / PIC18 MCUs Source File
3:             
4:               @Company:
5:                 Microchip Technology Inc.
6:             
7:               @File Name:
8:                 mcc.c
9:             
10:              @Summary:
11:                This is the mcc.c file generated using PIC10 / PIC12 / PIC16 / PIC18 MCUs
12:            
13:              @Description:
14:                This header file provides implementations for driver APIs for all modules selected in the GUI.
15:                Generation Information :
16:                    Product Revision  :  PIC10 / PIC12 / PIC16 / PIC18 MCUs - 1.81.8
17:                    Device            :  PIC18F47Q84
18:                    Driver Version    :  2.00
19:                The generated drivers are tested against the following:
20:                    Compiler          :  XC8 2.36 and above or later
21:                    MPLAB             :  MPLAB X 6.00
22:            */
23:            
24:            /*
25:                (c) 2018 Microchip Technology Inc. and its subsidiaries. 
26:                
27:                Subject to your compliance with these terms, you may use Microchip software and any 
28:                derivatives exclusively with Microchip products. It is your responsibility to comply with third party 
29:                license terms applicable to your use of third party software (including open source software) that 
30:                may accompany Microchip software.
31:                
32:                THIS SOFTWARE IS SUPPLIED BY MICROCHIP "AS IS". NO WARRANTIES, WHETHER 
33:                EXPRESS, IMPLIED OR STATUTORY, APPLY TO THIS SOFTWARE, INCLUDING ANY 
34:                IMPLIED WARRANTIES OF NON-INFRINGEMENT, MERCHANTABILITY, AND FITNESS 
35:                FOR A PARTICULAR PURPOSE.
36:                
37:                IN NO EVENT WILL MICROCHIP BE LIABLE FOR ANY INDIRECT, SPECIAL, PUNITIVE, 
38:                INCIDENTAL OR CONSEQUENTIAL LOSS, DAMAGE, COST OR EXPENSE OF ANY KIND 
39:                WHATSOEVER RELATED TO THE SOFTWARE, HOWEVER CAUSED, EVEN IF MICROCHIP 
40:                HAS BEEN ADVISED OF THE POSSIBILITY OR THE DAMAGES ARE FORESEEABLE. TO 
41:                THE FULLEST EXTENT ALLOWED BY LAW, MICROCHIP'S TOTAL LIABILITY ON ALL 
42:                CLAIMS IN ANY WAY RELATED TO THIS SOFTWARE WILL NOT EXCEED THE AMOUNT 
43:                OF FEES, IF ANY, THAT YOU HAVE PAID DIRECTLY TO MICROCHIP FOR THIS 
44:                SOFTWARE.
45:            */
46:            
47:            #include "mcc.h"
48:            
49:            
50:            void SYSTEM_Initialize(void)
51:            {
52:                INTERRUPT_Initialize();
15F8  ECDB     CALL 0xBB6, 0
15FA  F005     NOP
53:                PMD_Initialize();
15FC  ECDC     CALL 0x25B8, 0
15FE  F012     NOP
54:                ADC_Initialize();
1600  ECF7     CALL 0x7EE, 0
1602  F003     NOP
55:                PIN_MANAGER_Initialize();
1604  EC59     CALL 0x4B2, 0
1606  F002     NOP
56:                OSCILLATOR_Initialize();
1608  EC1D     CALL 0x263A, 0
160A  F013     NOP
57:                DMA1_Initialize();
160C  ECF6     CALL 0x9EC, 0
160E  F004     NOP
58:                TMR4_Initialize();
1610  ECE3     CALL 0x1DC6, 0
1612  F00E     NOP
59:                TMR2_Initialize();
1614  EC3A     CALL 0x1E74, 0
1616  F00F     NOP
60:                TMR0_Initialize();
1618  ECB6     CALL 0x1F6C, 0
161A  F00F     NOP
61:                TMR6_Initialize();
161C  ECCD     CALL 0x1D9A, 0
161E  F00E     NOP
62:                TMR5_Initialize();
1620  EC49     CALL 0x1492, 0
1622  F00A     NOP
63:                UART1_Initialize();
1624  EC35     CALL 0xE6A, 0
1626  F007     NOP
64:                UART2_Initialize();
1628  ECA3     CALL 0x546, 0
162A  F002     NOP
65:                UART5_Initialize();
162C  ECEB     CALL 0x5D6, 0
162E  F002     NOP
66:                SPI1_Initialize();
1630  ECCF     CALL 0x259E, 0
1632  F012     NOP
67:                CAN1_Initialize();
1634  ECED     CALL 0x11DA, 0
1636  F008     NOP
68:                SystemArbiter_Initialize();
1638  EC50     CALL 0x26A0, 0
163A  F013     NOP
69:            }
163C  0012     RETURN 0
70:            
71:            void OSCILLATOR_Initialize(void)
72:            {
73:                // NOSC EXTOSC   with 4x PLL; NDIV 1; 
74:                OSCCON1 = 0x20;
263A  0E20     MOVLW 0x20
263C  0100     MOVLB 0x0
263E  6FAD     MOVWF OSCCON1, BANKED
75:                // CSWHOLD may proceed; SOSCPWR Low power; 
76:                OSCCON3 = 0x00;
2640  6BAF     CLRF OSCCON3, BANKED
77:                // MFOEN disabled; LFOEN enabled; ADOEN disabled; PLLEN enabled; SOSCEN disabled; EXTOEN disabled; HFOEN disabled; 
78:                OSCEN = 0x11;
2642  0E11     MOVLW 0x11
2644  6FB3     MOVWF OSCEN, BANKED
79:                // HFFRQ 16_MHz; 
80:                OSCFRQ = 0x05;
2646  0E05     MOVLW 0x5
2648  6FB1     MOVWF OSCFRQ, BANKED
81:                // TUN 0; 
82:                OSCTUNE = 0x00;
264A  6BB0     CLRF OSCTUNE, BANKED
83:            }
264C  0012     RETURN 0
84:            
85:            void PMD_Initialize(void)
86:            {
87:                // CLKRMD CLKR enabled; SYSCMD SYSCLK enabled; SCANMD SCANNER enabled; FVRMD FVR enabled; IOCMD IOC enabled; CRCMD CRC enabled; HLVDMD HLVD enabled; 
88:                PMD0 = 0x00;
25B8  0100     MOVLB 0x0
25BA  6B60     CLRF PMD0, BANKED
89:                // TMR0MD TMR0 enabled; TMR1MD TMR1 enabled; TMR4MD TMR4 enabled; SMT1MD SMT1 enabled; TMR5MD TMR5 enabled; TMR2MD TMR2 enabled; TMR3MD TMR3 enabled; TMR6MD TMR6 enabled; 
90:                PMD1 = 0x00;
25BC  6B61     CLRF PMD1, BANKED
91:                // TU1MD UT16A enabled; CANMD CAN enabled; TU2MD UT16B enabled; 
92:                PMD2 = 0x00;
25BE  6B62     CLRF PMD2, BANKED
93:                // ZCDMD ZCD enabled; DACMD DAC enabled; ADCMD ADC enabled; ACTMD ACT enabled; CM2MD CM2 enabled; CM1MD CM1 enabled; 
94:                PMD3 = 0x00;
25C0  6B63     CLRF PMD3, BANKED
95:                // NCO1MD NCO1 enabled; NCO2MD NCO2 enabled; DSM1MD DSM1 enabled; CWG3MD CWG3 enabled; CWG2MD CWG2 enabled; CWG1MD CWG1 enabled; NCO3MD NCO3 enabled; 
96:                PMD4 = 0x00;
25C2  6B64     CLRF PMD4, BANKED
97:                // CCP2MD CCP2 enabled; CCP1MD CCP1 enabled; PWM2MD PWM2 enabled; CCP3MD CCP3 enabled; PWM1MD PWM1 enabled; PWM4MD PWM4 enabled; PWM3MD PWM3 enabled; 
98:                PMD5 = 0x00;
25C4  6B65     CLRF PMD5, BANKED
99:                // U5MD UART5 enabled; U4MD UART4 disabled; U3MD UART3 disabled; U2MD UART2 enabled; U1MD UART1 enabled; SPI2MD SPI2 disabled; SPI1MD SPI1 enabled; I2C1MD I2C1 disabled; 
100:               PMD6 = 0x65;
25C6  0E65     MOVLW 0x65
25C8  6F66     MOVWF PMD6, BANKED
101:               // CLC5MD CLC5 enabled; CLC6MD CLC6 enabled; CLC3MD CLC3 enabled; CLC4MD CLC4 enabled; CLC7MD CLC7 enabled; CLC8MD CLC8 enabled; CLC1MD CLC1 enabled; CLC2MD CLC2 enabled; 
102:               PMD7 = 0x00;
25CA  6B67     CLRF PMD7, BANKED
103:               // DMA5MD DMA5 enabled; DMA6MD DMA6 enabled; DMA8MD DMA8 enabled; DMA7MD DMA7 enabled; DMA1MD DMA1 enabled; DMA2MD DMA2 enabled; DMA3MD DMA3 enabled; DMA4MD DMA4 enabled; 
104:               PMD8 = 0x00;
25CC  6B68     CLRF PMD8, BANKED
105:           }
25CE  0012     RETURN 0
106:           
107:           
108:           void SystemArbiter_Initialize(void)
109:           {
110:               // This function is dependant on the PR1WAY CONFIG bit
111:               PRLOCK = 0x55;
26A0  0E55     MOVLW 0x55
26A2  0100     MOVLB 0x0
26A4  6FB4     MOVWF PRLOCK, BANKED
112:               PRLOCK = 0xAA;
26A6  0EAA     MOVLW 0xAA
26A8  6FB4     MOVWF PRLOCK, BANKED
113:               PRLOCKbits.PRLOCKED = 1;
26AA  81B4     BSF PRLOCK, 0, BANKED
114:           }
26AC  0012     RETURN 0
115:           /**
116:            End of File
117:           */
---  /public/Q84vtouch/mateQ84.X/mcc_generated_files/interrupt_manager.c  -------------------------------
1:             /**
2:               Generated Interrupt Manager Header File
3:             
4:               @Company:
5:                 Microchip Technology Inc.
6:             
7:               @File Name:
8:                 interrupt_manager.h
9:             
10:              @Summary:
11:                This is the Interrupt Manager file generated using PIC10 / PIC12 / PIC16 / PIC18 MCUs
12:            
13:              @Description:
14:                This header file provides implementations for global interrupt handling.
15:                For individual peripheral handlers please see the peripheral driver for
16:                all modules selected in the GUI.
17:                Generation Information :
18:                    Product Revision  :  PIC10 / PIC12 / PIC16 / PIC18 MCUs - 1.81.8
19:                    Device            :  PIC18F47Q84
20:                    Driver Version    :  2.12
21:                The generated drivers are tested against the following:
22:                    Compiler          :  XC8 2.36 and above or later
23:                    MPLAB 	          :  MPLAB X 6.00
24:            */
25:            
26:            /*
27:                (c) 2018 Microchip Technology Inc. and its subsidiaries. 
28:                
29:                Subject to your compliance with these terms, you may use Microchip software and any 
30:                derivatives exclusively with Microchip products. It is your responsibility to comply with third party 
31:                license terms applicable to your use of third party software (including open source software) that 
32:                may accompany Microchip software.
33:                
34:                THIS SOFTWARE IS SUPPLIED BY MICROCHIP "AS IS". NO WARRANTIES, WHETHER 
35:                EXPRESS, IMPLIED OR STATUTORY, APPLY TO THIS SOFTWARE, INCLUDING ANY 
36:                IMPLIED WARRANTIES OF NON-INFRINGEMENT, MERCHANTABILITY, AND FITNESS 
37:                FOR A PARTICULAR PURPOSE.
38:                
39:                IN NO EVENT WILL MICROCHIP BE LIABLE FOR ANY INDIRECT, SPECIAL, PUNITIVE, 
40:                INCIDENTAL OR CONSEQUENTIAL LOSS, DAMAGE, COST OR EXPENSE OF ANY KIND 
41:                WHATSOEVER RELATED TO THE SOFTWARE, HOWEVER CAUSED, EVEN IF MICROCHIP 
42:                HAS BEEN ADVISED OF THE POSSIBILITY OR THE DAMAGES ARE FORESEEABLE. TO 
43:                THE FULLEST EXTENT ALLOWED BY LAW, MICROCHIP'S TOTAL LIABILITY ON ALL 
44:                CLAIMS IN ANY WAY RELATED TO THIS SOFTWARE WILL NOT EXCEED THE AMOUNT 
45:                OF FEES, IF ANY, THAT YOU HAVE PAID DIRECTLY TO MICROCHIP FOR THIS 
46:                SOFTWARE.
47:            */
48:            
49:            #include "interrupt_manager.h"
50:            #include "mcc.h"
51:            
52:            void  INTERRUPT_Initialize (void)
0BB6  52E6     MOVF 0xFE6, F, ACCESS
53:            {
54:                INTCON0bits.IPEN = 1;
0BB8  8AD6     BSF 0xFD6, 5, ACCESS
55:            
56:                bool state = (unsigned char)GIE;
0BBA  AED6     BTFSS 0xFD6, 7, ACCESS
0BBC  D003     BRA 0xBC4
0BBE  6A0C     CLRF 0xC, ACCESS
0BC0  2A0C     INCF 0xC, F, ACCESS
0BC2  D001     BRA 0xBC6
0BC4  6A0C     CLRF 0xC, ACCESS
0BC6  0EFF     MOVLW 0xFF
0BC8  0061     MOVFFL 0x50C, PLUSW1
0BCA  F430     NOP
0BCC  F4E3     NOP
57:                GIE = 0;
0BCE  9ED6     BCF 0xFD6, 7, ACCESS
58:                IVTLOCK = 0x55;
0BD0  0E55     MOVLW 0x55
0BD2  0104     MOVLB 0x4
0BD4  6F59     MOVWF 0x59, BANKED
59:                IVTLOCK = 0xAA;
0BD6  0EAA     MOVLW 0xAA
0BD8  6F59     MOVWF 0x59, BANKED
60:                IVTLOCKbits.IVTLOCKED = 0x00; // unlock IVT
0BDA  9159     BCF 0x59, 0, BANKED
61:            
62:                IVTBASEU = 0;
0BDC  6B5F     CLRF 0x5F, BANKED
63:                IVTBASEH = 0;
0BDE  6B5E     CLRF 0x5E, BANKED
64:                IVTBASEL = 8;
0BE0  0E08     MOVLW 0x8
0BE2  6F5D     MOVWF 0x5D, BANKED
65:            
66:                IVTLOCK = 0x55;
0BE4  0E55     MOVLW 0x55
0BE6  6F59     MOVWF 0x59, BANKED
67:                IVTLOCK = 0xAA;
0BE8  0EAA     MOVLW 0xAA
0BEA  6F59     MOVWF 0x59, BANKED
68:                IVTLOCKbits.IVTLOCKED = 0x01; // lock IVT
0BEC  8159     BSF 0x59, 0, BANKED
69:            
70:                GIE = state;
0BEE  0EFF     MOVLW 0xFF
0BF0  B0E3     BTFSC 0xFE3, 0, ACCESS
0BF2  D002     BRA 0xBF8
0BF4  9ED6     BCF 0xFD6, 7, ACCESS
0BF6  D001     BRA 0xBFA
0BF8  8ED6     BSF 0xFD6, 7, ACCESS
71:            
72:                // Assign peripheral interrupt priority vectors
73:                IPR2bits.DMA1AIP = 1;
0BFA  0103     MOVLB 0x3
0BFC  8F64     BSF PMD4, 7, BANKED
74:                IPR2bits.DMA1SCNTIP = 1;
0BFE  8964     BSF PMD4, 4, BANKED
75:                IPR2bits.DMA1ORIP = 1;
0C00  8D64     BSF PMD4, 6, BANKED
76:                IPR0bits.CANIP = 1;
0C02  8D62     BSF PMD2, 6, BANKED
77:                IPR4bits.CANTXIP = 1;
0C04  8B66     BSF PMD6, 5, BANKED
78:                IPR4bits.CANRXIP = 1;
0C06  8966     BSF PMD6, 4, BANKED
79:                IPR8bits.U2TXIP = 1;
0C08  836A     BSF MD1CON0, 1, BANKED
80:                IPR8bits.U2RXIP = 1;
0C0A  816A     BSF MD1CON0, 0, BANKED
81:                IPR13bits.U5TXIP = 1;
0C0C  836F     BSF CMOUT, 1, BANKED
82:                IPR13bits.U5RXIP = 1;
0C0E  816F     BSF CMOUT, 0, BANKED
83:                IPR3bits.TMR0IP = 0;
0C10  9F65     BCF PMD5, 7, BANKED
84:                IPR15bits.TMR6IP = 0;
0C12  9771     BCF CM1CON1, 3, BANKED
85:                IPR8bits.TMR5IP = 0;
0C14  996A     BCF MD1CON0, 4, BANKED
86:                IPR11bits.TMR4IP = 1;
0C16  876D     BSF MD1CARL, 3, BANKED
87:                IPR3bits.TMR2IP = 0;
0C18  9765     BCF PMD5, 3, BANKED
88:            }
0C1A  52E5     MOVF 0xFE5, F, ACCESS
0C1A  52E5     MOVF 0xFE5, F, ACCESS
89:            
90:            void __interrupt(irq(default),base(8)) Default_ISR()
2770  EE17     LFSR 1, 0x1FAA
2772  F3AA     NOP
91:            {
92:            }
0F80  C4FA     MOVFF PCLATH, 0x5C6
2774  0011     RETFIE 1
93:            
94:            /**
95:             End of File
96:            */
---  /public/Q84vtouch/mateQ84.X/mcc_generated_files/dma1.c  --------------------------------------------
1:             /**
2:               DMA1 Generated Driver File
3:             
4:               @Company
5:                 Microchip Technology Inc.
6:             
7:               @File Name
8:                 dma1.c
9:             
10:              @Summary
11:                This is the generated driver implementation file for the DMA1 driver using PIC10 / PIC12 / PIC16 / PIC18 MCUs
12:            
13:              @Description
14:                This source file provides APIs for DMA1.
15:                Generation Information :
16:                    Product Revision  :  PIC10 / PIC12 / PIC16 / PIC18 MCUs - 1.81.8
17:                    Device            :  PIC18F47Q84
18:                    Driver Version    :  1.0.0
19:                The generated drivers are tested against the following:
20:                    Compiler          :  XC8 2.36 and above
21:                    MPLAB 	          :  MPLAB X 6.00
22:            */
23:            
24:            /*
25:                (c) 2018 Microchip Technology Inc. and its subsidiaries. 
26:                
27:                Subject to your compliance with these terms, you may use Microchip software and any 
28:                derivatives exclusively with Microchip products. It is your responsibility to comply with third party 
29:                license terms applicable to your use of third party software (including open source software) that 
30:                may accompany Microchip software.
31:                
32:                THIS SOFTWARE IS SUPPLIED BY MICROCHIP "AS IS". NO WARRANTIES, WHETHER 
33:                EXPRESS, IMPLIED OR STATUTORY, APPLY TO THIS SOFTWARE, INCLUDING ANY 
34:                IMPLIED WARRANTIES OF NON-INFRINGEMENT, MERCHANTABILITY, AND FITNESS 
35:                FOR A PARTICULAR PURPOSE.
36:                
37:                IN NO EVENT WILL MICROCHIP BE LIABLE FOR ANY INDIRECT, SPECIAL, PUNITIVE, 
38:                INCIDENTAL OR CONSEQUENTIAL LOSS, DAMAGE, COST OR EXPENSE OF ANY KIND 
39:                WHATSOEVER RELATED TO THE SOFTWARE, HOWEVER CAUSED, EVEN IF MICROCHIP 
40:                HAS BEEN ADVISED OF THE POSSIBILITY OR THE DAMAGES ARE FORESEEABLE. TO 
41:                THE FULLEST EXTENT ALLOWED BY LAW, MICROCHIP'S TOTAL LIABILITY ON ALL 
42:                CLAIMS IN ANY WAY RELATED TO THIS SOFTWARE WILL NOT EXCEED THE AMOUNT 
43:                OF FEES, IF ANY, THAT YOU HAVE PAID DIRECTLY TO MICROCHIP FOR THIS 
44:                SOFTWARE.
45:            */
46:            
47:            /**
48:              Section: Included Files
49:            */
50:            
51:            #include <xc.h>
52:            #include "dma1.h"
53:            
54:            void (*DMA1_SCNTI_InterruptHandler)(void);
55:            void (*DMA1_AI_InterruptHandler)(void);
56:            void (*DMA1_ORI_InterruptHandler)(void);
57:            
58:            /**
59:              Section: DMA1 APIs
60:            */
61:            
62:            void DMA1_Initialize(void)
63:            {
64:                //DMA Instance Selection : 0x00
65:                DMASELECT = 0x00;
09EC  0100     MOVLB 0x0
09EE  6BE8     CLRF DMASELECT, BANKED
66:                //Source Address : lcd_dma_buf
67:                DMAnSSA = &lcd_dma_buf;
09F0  0EC4     MOVLW 0xC4
09F2  6FF9     MOVWF DMAnSSA, BANKED
09F4  0E0A     MOVLW 0xA
09F6  6FFA     MOVWF DMAnSSAH, BANKED
09F8  0E00     MOVLW 0x0
09FA  6FFB     MOVWF DMAnSSAU, BANKED
68:                //Destination Address : &SPI1TXB
69:                DMAnDSA = &SPI1TXB;
09FC  0E00     MOVLW 0x0
09FE  6FF1     MOVWF DMAnDSAH, BANKED
0A00  0E81     MOVLW 0x81
0A02  6FF0     MOVWF DMAnDSA, BANKED
70:                //DMODE unchanged; DSTP not cleared; SMR GPR; SMODE incremented; SSTP cleared; 
71:                DMAnCON1 = 0x03;
0A04  0E03     MOVLW 0x3
0A06  6FFD     MOVWF DMAnCON1, BANKED
72:                //Source Message Size : 1
73:                DMAnSSZ = 1;
0A08  0E00     MOVLW 0x0
0A0A  6FF8     MOVWF DMAnSSZH, BANKED
0A0C  0E01     MOVLW 0x1
0A0E  6FF7     MOVWF DMAnSSZ, BANKED
74:                //Destination Message Size : 1
75:                DMAnDSZ = 1;
0A10  0E00     MOVLW 0x0
0A12  6FEF     MOVWF DMAnDSZH, BANKED
0A14  0E01     MOVLW 0x1
0A16  6FEE     MOVWF DMAnDSZ, BANKED
76:                //Start Trigger : SIRQ SPI1TX; 
77:                DMAnSIRQ = 0x19;
0A18  0E19     MOVLW 0x19
0A1A  6FFF     MOVWF DMAnSIRQ, BANKED
78:                //Abort Trigger : AIRQ None; 
79:                DMAnAIRQ = 0x00;
0A1C  6BFE     CLRF DMAnAIRQ, BANKED
80:            	
81:                // Clear Destination Count Interrupt Flag bit
82:                PIR2bits.DMA1DCNTIF = 0; 
0A1E  9AB0     BCF 0xFB0, 5, ACCESS
83:                // Clear Source Count Interrupt Flag bit
84:                PIR2bits.DMA1SCNTIF = 0; 
0A20  98B0     BCF 0xFB0, 4, ACCESS
85:                // Clear Abort Interrupt Flag bit
86:                PIR2bits.DMA1AIF = 0; 
0A22  9EB0     BCF 0xFB0, 7, ACCESS
87:                // Clear Overrun Interrupt Flag bit
88:                PIR2bits.DMA1ORIF =0; 
0A24  9CB0     BCF 0xFB0, 6, ACCESS
89:                
90:                PIE2bits.DMA1DCNTIE = 0;
0A26  9AA0     BCF 0xFA0, 5, ACCESS
91:                PIE2bits.DMA1SCNTIE = 1; 
0A28  88A0     BSF 0xFA0, 4, ACCESS
92:            	DMA1_SetSCNTIInterruptHandler(DMA1_DefaultInterruptHandler);
0A2A  0EA8     MOVLW 0xA8
0A2C  6EE6     MOVWF 0xFE6, ACCESS
0A2E  0E27     MOVLW 0x27
0A30  6EE6     MOVWF 0xFE6, ACCESS
0A32  0E00     MOVLW 0x0
0A34  6EE6     MOVWF 0xFE6, ACCESS
0A36  EC27     CALL 0x224E, 0
0A38  F011     NOP
93:                PIE2bits.DMA1AIE = 1; 
0A3A  8EA0     BSF 0xFA0, 7, ACCESS
94:            	DMA1_SetAIInterruptHandler(DMA1_DefaultInterruptHandler);
0A3C  0EA8     MOVLW 0xA8
0A3E  6EE6     MOVWF 0xFE6, ACCESS
0A40  0E27     MOVLW 0x27
0A42  6EE6     MOVWF 0xFE6, ACCESS
0A44  0E00     MOVLW 0x0
0A46  6EE6     MOVWF 0xFE6, ACCESS
0A48  EC49     CALL 0x2292, 0
0A4A  F011     NOP
95:                PIE2bits.DMA1ORIE =1; 
0A4C  8CA0     BSF 0xFA0, 6, ACCESS
96:            	DMA1_SetORIInterruptHandler(DMA1_DefaultInterruptHandler);
0A4E  0EA8     MOVLW 0xA8
0A50  6EE6     MOVWF 0xFE6, ACCESS
0A52  0E27     MOVLW 0x27
0A54  6EE6     MOVWF 0xFE6, ACCESS
0A56  0E00     MOVLW 0x0
0A58  6EE6     MOVWF 0xFE6, ACCESS
0A5A  EC38     CALL 0x2270, 0
0A5C  F011     NOP
97:            	
98:                //EN enabled; SIRQEN enabled; DGO not in progress; AIRQEN disabled; 
99:                DMAnCON0 = 0xC0;
0A5E  0EC0     MOVLW 0xC0
0A60  0100     MOVLB 0x0
0A62  6FFC     MOVWF DMAnCON0, BANKED
100:           	
101:           }
0A64  0012     RETURN 0
102:           
103:           void DMA1_SelectSourceRegion(uint8_t region)
104:           {
105:               DMASELECT = 0x00;
106:           	DMAnCON1bits.SMR  = region;
107:           }
108:           
109:           void DMA1_SetSourceAddress(uint24_t address)
110:           {
111:               DMASELECT = 0x00;
112:           	DMAnSSA = address;
113:           }
114:           
115:           void DMA1_SetDestinationAddress(uint16_t address)
116:           {
117:               DMASELECT = 0x00;
118:           	DMAnDSA = address;
119:           }
120:           
121:           void DMA1_SetSourceSize(uint16_t size)
122:           {
123:               DMASELECT = 0x00;
25E6  0100     MOVLB 0x0
25E8  6BE8     CLRF DMASELECT, BANKED
124:           	DMAnSSZ= size;
25EA  0EFE     MOVLW 0xFE
25EC  C4E3     MOVFF PLUSW1, DMAnSSZ
25EE  F0F7     NOP
25F0  0EFF     MOVLW 0xFF
25F2  C4E3     MOVFF PLUSW1, DMAnSSZH
25F4  F0F8     NOP
125:           }
25F6  52E5     MOVF 0xFE5, F, ACCESS
25F6  52E5     MOVF 0xFE5, F, ACCESS
25F6  52E5     MOVF 0xFE5, F, ACCESS
126:           
127:           void DMA1_SetDestinationSize(uint16_t size)
128:           {                     
129:               DMASELECT = 0x00;
25FC  0100     MOVLB 0x0
25FE  6BE8     CLRF DMASELECT, BANKED
130:           	DMAnDSZ= size;
2600  0EFE     MOVLW 0xFE
2602  C4E3     MOVFF PLUSW1, DMAnDSZ
2604  F0EE     NOP
2606  0EFF     MOVLW 0xFF
2608  C4E3     MOVFF PLUSW1, DMAnDSZH
260A  F0EF     NOP
131:           }
260C  52E5     MOVF 0xFE5, F, ACCESS
260C  52E5     MOVF 0xFE5, F, ACCESS
260C  52E5     MOVF 0xFE5, F, ACCESS
132:           
133:           uint24_t DMA1_GetSourcePointer(void)
134:           {
135:               DMASELECT = 0x00;
136:           	return DMAnSPTR;
137:           }
138:           
139:           uint16_t DMA1_GetDestinationPointer(void)
140:           {
141:               DMASELECT = 0x00;
142:           	return DMAnDPTR;
143:           }
144:           
145:           void DMA1_SetStartTrigger(uint8_t sirq)
146:           {
147:               DMASELECT = 0x00;
148:           	DMAnSIRQ = sirq;
149:           }
150:           
151:           void DMA1_SetAbortTrigger(uint8_t airq)
152:           {
153:               DMASELECT = 0x00;
154:           	DMAnAIRQ = airq;
155:           }
156:           
157:           void DMA1_StartTransfer(void)
158:           {
159:               DMASELECT = 0x00;
160:           	DMAnCON0bits.DGO = 1;
161:           }
162:           
163:           void DMA1_StartTransferWithTrigger(void)
164:           {
165:               DMASELECT = 0x00;
270E  0100     MOVLB 0x0
2710  6BE8     CLRF DMASELECT, BANKED
166:           	DMAnCON0bits.SIRQEN = 1;
2712  8DFC     BSF DMAnCON0, 6, BANKED
167:           }
2714  0012     RETURN 0
168:           
169:           void DMA1_StopTransfer(void)
170:           {
171:               DMASELECT = 0x00;
26EC  0100     MOVLB 0x0
26EE  6BE8     CLRF DMASELECT, BANKED
172:           	DMAnCON0bits.SIRQEN = 0; 
26F0  9DFC     BCF DMAnCON0, 6, BANKED
173:           	DMAnCON0bits.DGO = 0;
26F2  9BFC     BCF DMAnCON0, 5, BANKED
174:           }
26F4  0012     RETURN 0
175:           
176:           void DMA1_SetDMAPriority(uint8_t priority)
177:           {
178:               // This function is dependant on the PR1WAY CONFIG bit
179:           	PRLOCK = 0x55;
246E  0E55     MOVLW 0x55
2470  0100     MOVLB 0x0
2472  6FB4     MOVWF PRLOCK, BANKED
180:           	PRLOCK = 0xAA;
2474  0EAA     MOVLW 0xAA
2476  6FB4     MOVWF PRLOCK, BANKED
181:           	PRLOCKbits.PRLOCKED = 0;
2478  91B4     BCF PRLOCK, 0, BANKED
182:           	DMA1PR = priority;
247A  0EFF     MOVLW 0xFF
247C  C4E3     MOVFF PLUSW1, DMA1PR
247E  F0B6     NOP
183:           	PRLOCK = 0x55;
2480  0E55     MOVLW 0x55
2482  6FB4     MOVWF PRLOCK, BANKED
184:           	PRLOCK = 0xAA;
2484  0EAA     MOVLW 0xAA
2486  6FB4     MOVWF PRLOCK, BANKED
185:           	PRLOCKbits.PRLOCKED = 1;
2488  81B4     BSF PRLOCK, 0, BANKED
186:           }
248A  52E5     MOVF 0xFE5, F, ACCESS
248A  52E5     MOVF 0xFE5, F, ACCESS
187:           
188:           void __interrupt(irq(IRQ_DMA1SCNT),base(8)) DMA1_DMASCNTI_ISR()
14DC  C4FA     MOVFF PCLATH, 0x7F8
189:           {
190:               // Clear the source count interrupt flag
191:               PIR2bits.DMA1SCNTIF = 0;
14EE  98B0     BCF 0xFB0, 4, ACCESS
192:           
193:               if (DMA1_SCNTI_InterruptHandler)
14F0  0107     MOVLB 0x7
14F2  519F     MOVF 0x9F, W, BANKED
14F4  11A0     IORWF 0xA0, W, BANKED
14F6  11A1     IORWF 0xA1, W, BANKED
14F8  B4D8     BTFSC 0xFD8, 2, ACCESS
14FA  D00C     BRA 0x1514
194:                       DMA1_SCNTI_InterruptHandler();
14FC  D801     RCALL 0x1500
14FE  D00A     BRA 0x1514
1500  0005     PUSH
1502  6EFA     MOVWF 0xFFA, ACCESS
1504  519F     MOVF 0x9F, W, BANKED
1506  6EFD     MOVWF 0xFFD, ACCESS
1508  51A0     MOVF 0xA0, W, BANKED
150A  6EFE     MOVWF 0xFFE, ACCESS
150C  51A1     MOVF 0xA1, W, BANKED
150E  6EFF     MOVWF 0xFFF, ACCESS
1510  50FA     MOVF 0xFFA, W, ACCESS
1512  0012     RETURN 0
195:           }
1514  0061     MOVFFL 0x7FA, 0x50C
1514  0061     MOVFFL 0x7FA, 0x50C
1514  0061     MOVFFL 0x7FA, 0x50C
1514  0061     MOVFFL 0x7FA, 0x50C
1514  0061     MOVFFL 0x7FA, 0x50C
1514  0061     MOVFFL 0x7FA, 0x50C
1514  0061     MOVFFL 0x7FA, 0x50C
1514  0061     MOVFFL 0x7FA, 0x50C
196:           
197:           void DMA1_SetSCNTIInterruptHandler(void (* InterruptHandler)(void))
198:           {
199:           	 DMA1_SCNTI_InterruptHandler = InterruptHandler;
224E  50E1     MOVF 0xFE1, W, ACCESS
2250  0FFD     ADDLW 0xFD
2252  6ED9     MOVWF 0xFD9, ACCESS
2254  50E2     MOVF 0xFE2, W, ACCESS
2256  6EDA     MOVWF __end_of_UART2_tx_vect_isr, ACCESS
2258  0EFF     MOVLW 0xFF
225A  22DA     ADDWFC __end_of_UART2_tx_vect_isr, F, ACCESS
225C  C4DE     MOVFF POSTINC2, DMA1_SCNTI_InterruptHandler
225E  F79F     NOP
2260  C4DE     MOVFF POSTINC2, 0x7A0
2262  F7A0     NOP
2264  C4DD     MOVFF POSTDEC2, 0x7A1
2266  F7A1     NOP
200:           }
2268  52E5     MOVF 0xFE5, F, ACCESS
2268  52E5     MOVF 0xFE5, F, ACCESS
2268  52E5     MOVF 0xFE5, F, ACCESS
2268  52E5     MOVF 0xFE5, F, ACCESS
201:           
202:           void __interrupt(irq(IRQ_DMA1A),base(8)) DMA1_DMAAI_ISR()
1980  C4FA     MOVFF PCLATH, __pcstackBANK9
1982  F9F7     NOP
1984  C4FB     MOVFF PCLATU, 0x9F8
1986  F9F8     NOP
1988  EE17     LFSR 1, 0x1FAA
198A  F3AA     NOP
203:           {
204:               // Clear the source count interrupt flag
205:               PIR2bits.DMA1AIF = 0;
198C  9EB0     BCF 0xFB0, 7, ACCESS
206:           
207:               if (DMA1_AI_InterruptHandler)
198E  0107     MOVLB 0x7
1990  519C     MOVF 0x9C, W, BANKED
1992  119D     IORWF 0x9D, W, BANKED
1994  119E     IORWF 0x9E, W, BANKED
1996  B4D8     BTFSC 0xFD8, 2, ACCESS
1998  D00C     BRA 0x19B2
208:                       DMA1_AI_InterruptHandler();
199A  D801     RCALL 0x199E
199C  D00A     BRA 0x19B2
199E  0005     PUSH
19A0  6EFA     MOVWF 0xFFA, ACCESS
19A2  519C     MOVF 0x9C, W, BANKED
19A4  6EFD     MOVWF 0xFFD, ACCESS
19A6  519D     MOVF 0x9D, W, BANKED
19A8  6EFE     MOVWF 0xFFE, ACCESS
19AA  519E     MOVF 0x9E, W, BANKED
19AC  6EFF     MOVWF 0xFFF, ACCESS
19AE  50FA     MOVF 0xFFA, W, ACCESS
19B0  0012     RETURN 0
209:           }
19B2  C9F8     MOVFF 0x9F8, PCLATU
19B2  C9F8     MOVFF 0x9F8, PCLATU
19B2  C9F8     MOVFF 0x9F8, PCLATU
19B2  C9F8     MOVFF 0x9F8, PCLATU
19B2  C9F8     MOVFF 0x9F8, PCLATU
210:           
211:           void DMA1_SetAIInterruptHandler(void (* InterruptHandler)(void))
212:           {
213:           	 DMA1_AI_InterruptHandler = InterruptHandler;
2292  50E1     MOVF 0xFE1, W, ACCESS
2294  0FFD     ADDLW 0xFD
2296  6ED9     MOVWF 0xFD9, ACCESS
2298  50E2     MOVF 0xFE2, W, ACCESS
229A  6EDA     MOVWF __end_of_UART2_tx_vect_isr, ACCESS
229C  0EFF     MOVLW 0xFF
229E  22DA     ADDWFC __end_of_UART2_tx_vect_isr, F, ACCESS
22A0  C4DE     MOVFF POSTINC2, DMA1_AI_InterruptHandler
22A2  F79C     NOP
22A4  C4DE     MOVFF POSTINC2, 0x79D
22A6  F79D     NOP
22A8  C4DD     MOVFF POSTDEC2, 0x79E
22AA  F79E     NOP
214:           }
22AC  52E5     MOVF 0xFE5, F, ACCESS
22AC  52E5     MOVF 0xFE5, F, ACCESS
22AC  52E5     MOVF 0xFE5, F, ACCESS
22AC  52E5     MOVF 0xFE5, F, ACCESS
215:           
216:           void __interrupt(irq(IRQ_DMA1OR),base(8)) DMA1_DMAORI_ISR()
1524  C4FA     MOVFF PCLATH, 0x9F9
1526  F9F9     NOP
1528  C4FB     MOVFF PCLATU, 0x9FA
152A  F9FA     NOP
152C  0061     MOVFFL 0x50C, 0x9FB
152E  F430     NOP
1530  F9FB     NOP
1532  EE17     LFSR 1, 0x1FAA
1534  F3AA     NOP
217:           {
218:               // Clear the source count interrupt flag
219:               PIR2bits.DMA1ORIF = 0;
1536  9CB0     BCF 0xFB0, 6, ACCESS
220:           
221:               if (DMA1_ORI_InterruptHandler)
1538  0107     MOVLB 0x7
153A  5199     MOVF SPI2CLK, W, BANKED
153C  119A     IORWF 0x9A, W, BANKED
153E  119B     IORWF 0x9B, W, BANKED
1540  B4D8     BTFSC 0xFD8, 2, ACCESS
1542  D00C     BRA 0x155C
222:                       DMA1_ORI_InterruptHandler();
1544  D801     RCALL 0x1548
1546  D00A     BRA 0x155C
1548  0005     PUSH
154A  6EFA     MOVWF 0xFFA, ACCESS
154C  5199     MOVF SPI2CLK, W, BANKED
154E  6EFD     MOVWF 0xFFD, ACCESS
1550  519A     MOVF 0x9A, W, BANKED
1552  6EFE     MOVWF 0xFFE, ACCESS
1554  519B     MOVF 0x9B, W, BANKED
1556  6EFF     MOVWF 0xFFF, ACCESS
1558  50FA     MOVF 0xFFA, W, ACCESS
155A  0012     RETURN 0
223:           }
1038  C4FA     MOVFF PCLATH, 0xAE5
103A  FAE5     NOP
103C  C4FB     MOVFF PCLATU, 0xAE6
103E  FAE6     NOP
1040  EE17     LFSR 1, 0x1FAA
1042  F3AA     NOP
155C  0062     MOVFFL 0x9FB, 0x50C
155C  0062     MOVFFL 0x9FB, 0x50C
155C  0062     MOVFFL 0x9FB, 0x50C
155C  0062     MOVFFL 0x9FB, 0x50C
155C  0062     MOVFFL 0x9FB, 0x50C
155C  0062     MOVFFL 0x9FB, 0x50C
155C  0062     MOVFFL 0x9FB, 0x50C
155C  0062     MOVFFL 0x9FB, 0x50C
224:           
225:           void DMA1_SetORIInterruptHandler(void (* InterruptHandler)(void))
226:           {
227:           	 DMA1_ORI_InterruptHandler = InterruptHandler;
2270  50E1     MOVF 0xFE1, W, ACCESS
2272  0FFD     ADDLW 0xFD
2274  6ED9     MOVWF 0xFD9, ACCESS
2276  50E2     MOVF 0xFE2, W, ACCESS
2278  6EDA     MOVWF __end_of_UART2_tx_vect_isr, ACCESS
227A  0EFF     MOVLW 0xFF
227C  22DA     ADDWFC __end_of_UART2_tx_vect_isr, F, ACCESS
227E  C4DE     MOVFF POSTINC2, DMA1_ORI_InterruptHandler
2280  F799     NOP
2282  C4DE     MOVFF POSTINC2, 0x79A
2284  F79A     NOP
2286  C4DD     MOVFF POSTDEC2, 0x79B
2288  F79B     NOP
228:           }
228A  52E5     MOVF 0xFE5, F, ACCESS
228A  52E5     MOVF 0xFE5, F, ACCESS
228A  52E5     MOVF 0xFE5, F, ACCESS
228A  52E5     MOVF 0xFE5, F, ACCESS
229:           
230:           void DMA1_DefaultInterruptHandler(void){
231:               // add your DMA1 interrupt custom code
232:               // or set custom function using DMA1_SetSCNTIInterruptHandler() /DMA1_SetDCNTIInterruptHandler() /DMA1_SetAIInterruptHandler() /DMA1_SetORIInterruptHandler()
233:           }
27A8  0012     RETURN 0
234:           /**
235:            End of File
236:           */
---  /public/Q84vtouch/mateQ84.X/mcc_generated_files/can1.c  --------------------------------------------
1:             /**
2:               CAN1 Generated Driver File
3:             
4:               @Company
5:                 Microchip Technology Inc.
6:             
7:               @File Name
8:                 can1.c
9:             
10:              @Summary
11:                This is the generated driver implementation file for the CAN1 driver using PIC10 / PIC12 / PIC16 / PIC18 MCUs
12:            
13:              @Description
14:                This header file provides implementations for driver APIs for CAN1.
15:                Generation Information :
16:            	Product Revision  :  PIC10 / PIC12 / PIC16 / PIC18 MCUs - 1.81.8
17:            	Device            :  PIC18F47Q84
18:            	Driver Version    :  1.1.1
19:                The generated drivers are tested against the following:
20:            	Compiler          :  XC8 2.36 and above or later
21:            	MPLAB             :  MPLAB X 6.00
22:             */
23:            
24:            /*
25:                (c) 2018 Microchip Technology Inc. and its subsidiaries. 
26:                
27:                Subject to your compliance with these terms, you may use Microchip software and any 
28:                derivatives exclusively with Microchip products. It is your responsibility to comply with third party 
29:                license terms applicable to your use of third party software (including open source software) that 
30:                may accompany Microchip software.
31:                
32:                THIS SOFTWARE IS SUPPLIED BY MICROCHIP "AS IS". NO WARRANTIES, WHETHER 
33:                EXPRESS, IMPLIED OR STATUTORY, APPLY TO THIS SOFTWARE, INCLUDING ANY 
34:                IMPLIED WARRANTIES OF NON-INFRINGEMENT, MERCHANTABILITY, AND FITNESS 
35:                FOR A PARTICULAR PURPOSE.
36:                
37:                IN NO EVENT WILL MICROCHIP BE LIABLE FOR ANY INDIRECT, SPECIAL, PUNITIVE, 
38:                INCIDENTAL OR CONSEQUENTIAL LOSS, DAMAGE, COST OR EXPENSE OF ANY KIND 
39:                WHATSOEVER RELATED TO THE SOFTWARE, HOWEVER CAUSED, EVEN IF MICROCHIP 
40:                HAS BEEN ADVISED OF THE POSSIBILITY OR THE DAMAGES ARE FORESEEABLE. TO 
41:                THE FULLEST EXTENT ALLOWED BY LAW, MICROCHIP'S TOTAL LIABILITY ON ALL 
42:                CLAIMS IN ANY WAY RELATED TO THIS SOFTWARE WILL NOT EXCEED THE AMOUNT 
43:                OF FEES, IF ANY, THAT YOU HAVE PAID DIRECTLY TO MICROCHIP FOR THIS 
44:                SOFTWARE.
45:             */
46:            
47:            #include <xc.h>
48:            #include <stdint.h>
49:            #include <string.h>
50:            #include "can1.h"
51:            
52:            #define RX_FIFO_MSG_DATA                (64U)
53:            #define NUM_OF_RX_FIFO                  (1U)
54:            
55:            #define SID_LOW_WIDTH                   (8U)
56:            #define SID_HIGH_MASK                   (0x07U)
57:            #define EID_LOW_WIDTH                   (5U)
58:            #define EID_LOW_POSN                    (3U)
59:            #define EID_LOW_MASK                    (0xF8U)
60:            #define EID_MID_WIDTH                   (8U)
61:            #define EID_HIGH_WIDTH                  (5U)
62:            #define EID_HIGH_MASK                   (0x1FU)
63:            #define IDE_POSN                        (4U)
64:            #define RTR_POSN                        (5U)
65:            #define BRS_POSN                        (6U)
66:            #define FDF_POSN                        (7U)
67:            
68:            #define DLCToPayloadBytes(x)            (DLC_BYTES[(x)])
69:            #define PLSIZEToPayloadBytes(x)         (DLCToPayloadBytes(8u + (x)))
70:            
71:            struct CAN_FIFOREG
72:            {
73:            	uint8_t CONL;
74:            	uint8_t CONH;
75:            	uint8_t CONU;
76:            	uint8_t CONT;
77:            	uint8_t STAL;
78:            	uint8_t STAH;
79:            	uint8_t STAU;
80:            	uint8_t STAT;
81:            	uint32_t UA;
82:            };
83:            
84:            typedef enum
85:            {
86:                CAN_RX_MSG_NOT_AVAILABLE = 0U,
87:                CAN_RX_MSG_AVAILABLE = 1U,
88:                CAN_RX_MSG_OVERFLOW = 8U
89:            } CAN_RX_FIFO_STATUS;
90:            
91:            
92:            struct CAN1_RX_FIFO
93:            {
94:                CAN1_RX_FIFO_CHANNELS channel;
95:                volatile uint8_t fifoHead;
96:            };
97:            
98:            //CAN RX FIFO Message object data field 
99:            static volatile uint8_t rxMsgData[RX_FIFO_MSG_DATA];
100:           
101:           static struct CAN1_RX_FIFO rxFifos[] = 
102:           {
103:               {FIFO1, 0u}
104:           };
105:           
106:           static volatile struct CAN_FIFOREG * const FIFO = (struct CAN_FIFOREG *)&C1TXQCONL;
107:           static const uint8_t DLC_BYTES[] = {0U, 1U, 2U, 3U, 4U, 5U, 6U, 7U, 8U, 12U, 16U, 20U, 24U, 32U, 48U, 64U};
108:           
109:           static void (*CAN1_TXQNotFullHandler)(void);
110:           static void (*CAN1_FIFO1NotEmptyHandler)(void);
111:           static void (*CAN1_InvalidMessageHandler)(void);
112:           static void (*CAN1_BusWakeUpActivityHandler)(void);
113:           static void (*CAN1_BusErrorHandler)(void);
114:           static void (*CAN1_ModeChangeHandler)(void);
115:           static void (*CAN1_SystemErrorHandler)(void);
116:           static void (*CAN1_TxAttemptHandler)(void);
117:           static void (*CAN1_RxBufferOverflowHandler)(void);
118:           
119:           static void DefaultTXQNotFullHandler(void)
120:           {
121:           }
279A  0012     RETURN 0
122:           
123:           static void DefaultFIFO1NotEmptyHandler(void)
124:           {
125:           }
278E  0012     RETURN 0
126:           
127:           static void DefaultInvalidMessageHandler(void)
128:           {
129:           }
2794  0012     RETURN 0
130:           
131:           static void DefaultBusWakeUpActivityHandler(void)
132:           {
133:           }
2796  0012     RETURN 0
134:           
135:           static void DefaultBusErrorHandler(void)
136:           {
137:           }
2798  0012     RETURN 0
138:           
139:           static void DefaultModeChangeHandler(void)
140:           {
141:           }
2792  0012     RETURN 0
142:           
143:           static void DefaultSystemErrorHandler(void)
144:           {
145:           }
278C  0012     RETURN 0
146:           
147:           static void DefaultTxAttemptHandler(void)
148:           {
149:           }
278A  0012     RETURN 0
150:           
151:           static void DefaultRxBufferOverflowHandler(void)
152:           {
153:           }
2790  0012     RETURN 0
154:           
155:           void CAN1_RX_FIFO_ResetInfo(void)
1E9E  52E6     MOVF 0xFE6, F, ACCESS
156:           {
157:               uint8_t index;
158:           
159:               for (index = 0; index < NUM_OF_RX_FIFO; index++)
1EA0  0EFF     MOVLW 0xFF
1EA2  6AE3     CLRF 0xFE3, ACCESS
160:               {
161:                   rxFifos[index].fifoHead = 0;
1EA4  0EFF     MOVLW 0xFF
1EA6  50E3     MOVF 0xFE3, W, ACCESS
1EA8  0D02     MULLW 0x2
1EAA  0EAE     MOVLW 0xAE
1EAC  24F3     ADDWF 0xFF3, W, ACCESS
1EAE  6ED9     MOVWF 0xFD9, ACCESS
1EB0  0E05     MOVLW 0x5
1EB2  20F4     ADDWFC 0xFF4, W, ACCESS
1EB4  6EDA     MOVWF __end_of_UART2_tx_vect_isr, ACCESS
1EB6  6ADF     CLRF 0xFDF, ACCESS
162:               }
1EB8  0EFF     MOVLW 0xFF
1EBA  2AE3     INCF 0xFE3, F, ACCESS
1EBC  0EFF     MOVLW 0xFF
1EBE  50E3     MOVF 0xFE3, W, ACCESS
1EC0  B4D8     BTFSC 0xFD8, 2, ACCESS
1EC2  D7F0     BRA 0x1EA4
163:           }
1EC4  52E5     MOVF 0xFE5, F, ACCESS
1EC4  52E5     MOVF 0xFE5, F, ACCESS
164:           
165:           static void CAN1_RX_FIFO_Configuration(void)
166:           {
167:               // TXEN disabled; RTREN disabled; RXTSEN disabled; TXATIE disabled; RXOVIE enabled; TFERFFIE disabled; TFHRFHIE disabled; TFNRFNIE enabled; 
168:               C1FIFOCON1L = 0x09;
1DF2  0E09     MOVLW 0x9
1DF4  0101     MOVLB 0x1
1DF6  6F5C     MOVWF 0x5C, BANKED
169:               
170:               // FRESET enabled; TXREQ disabled; UINC disabled; 
171:               C1FIFOCON1H = 0x04;
1DF8  0E04     MOVLW 0x4
1DFA  6F5D     MOVWF 0x5D, BANKED
172:               
173:               // TXAT Unlimited number of retransmission attempts; TXPRI 1; 
174:               C1FIFOCON1U = 0x60;
1DFC  0E60     MOVLW 0x60
1DFE  6F5E     MOVWF 0x5E, BANKED
175:               
176:               // PLSIZE 64; FSIZE 8; 
177:               C1FIFOCON1T = 0xE7;
1E00  0EE7     MOVLW 0xE7
1E02  6F5F     MOVWF 0x5F, BANKED
178:               
179:               CAN1_SetFIFO1NotEmptyHandler(DefaultFIFO1NotEmptyHandler);
1E04  0E8E     MOVLW 0x8E
1E06  6EE6     MOVWF 0xFE6, ACCESS
1E08  0E27     MOVLW 0x27
1E0A  6EE6     MOVWF 0xFE6, ACCESS
1E0C  0E00     MOVLW 0x0
1E0E  6EE6     MOVWF 0xFE6, ACCESS
1E10  EC6B     CALL 0x22D6, 0
1E12  F011     NOP
180:               
181:               C1INTUbits.RXIE = 1;
1E14  0101     MOVLB 0x1
1E16  831E     BSF 0x1E, 1, BANKED
182:               
183:               PIR4bits.CANRXIF = 0;
1E18  98B2     BCF 0xFB2, 4, ACCESS
184:               PIE4bits.CANRXIE = 1;
1E1A  88A2     BSF 0xFA2, 4, ACCESS
185:           }
1E1C  0012     RETURN 0
186:           
187:           static void CAN1_RX_FIFO_FilterMaskConfiguration(void)
188:           {
189:               // FLTEN1 enabled; F1BP FIFO 1; 
190:               C1FLTOBJ1L = 0x0F;
2528  0E0F     MOVLW 0xF
252A  0101     MOVLB 0x1
252C  6F94     MOVWF SPI2STATUS, BANKED
191:               C1FLTOBJ1H = 0x60;
252E  0E60     MOVLW 0x60
2530  6F95     MOVWF SPI2TWIDTH, BANKED
192:               C1FLTOBJ1U = 0x00;
2532  6B96     CLRF SPI2BAUD, BANKED
193:               C1FLTOBJ1T = 0x00;
2534  6B97     CLRF SPI2INTF, BANKED
194:               C1MASK1L = 0xFF;
2536  6998     SETF SPI2INTE, BANKED
195:               C1MASK1H = 0xFF;
2538  6999     SETF SPI2CLK, BANKED
196:               C1MASK1U = 0xFF;
253A  699A     SETF 0x9A, BANKED
197:               C1MASK1T = 0x5F;
253C  0E5F     MOVLW 0x5F
253E  6F9B     MOVWF 0x9B, BANKED
198:               C1FLTCON0H = 0x81; 
2540  0E81     MOVLW 0x81
2542  6F81     MOVWF SPI1TXB, BANKED
199:               
200:           }
2544  0012     RETURN 0
201:           
202:           static void CAN1_TX_FIFO_Configuration(void)
203:           {
204:               // TXATIE enabled; TXQEIE disabled; TXQNIE enabled; 
205:               C1TXQCONL = 0x11;
136A  0E11     MOVLW 0x11
136C  0101     MOVLB 0x1
136E  6F50     MOVWF 0x50, BANKED
206:           
207:           	// FRESET enabled; UINC disabled; 
208:           	C1TXQCONH = 0x04;
1370  0E04     MOVLW 0x4
1372  6F51     MOVWF 0x51, BANKED
209:           
210:               // TXAT 3; TXPRI 2; 
211:               C1TXQCONU = 0x61;
1374  0E61     MOVLW 0x61
1376  6F52     MOVWF 0x52, BANKED
212:           
213:               // PLSIZE 64; FSIZE 10; 
214:               C1TXQCONT = 0xE9;
1378  0EE9     MOVLW 0xE9
137A  6F53     MOVWF 0x53, BANKED
215:           
216:               // TXEN enabled; RTREN disabled; RXTSEN disabled; TXATIE enabled; RXOVIE disabled; TFERFFIE disabled; TFHRFHIE disabled; TFNRFNIE disabled; 
217:               C1FIFOCON2L = 0x90;
137C  0E90     MOVLW 0x90
137E  6F68     MOVWF PMD8, BANKED
218:               
219:               // FRESET enabled; TXREQ disabled; UINC disabled; 
220:               C1FIFOCON2H = 0x04;
1380  0E04     MOVLW 0x4
1382  6F69     MOVWF 0x69, BANKED
221:               
222:               // TXAT Unlimited number of retransmission attempts; TXPRI 4; 
223:               C1FIFOCON2U = 0x63;
1384  0E63     MOVLW 0x63
1386  6F6A     MOVWF MD1CON0, BANKED
224:               
225:               // PLSIZE 64; FSIZE 4; 
226:               C1FIFOCON2T = 0xE3;
1388  0EE3     MOVLW 0xE3
138A  6F6B     MOVWF MD1CON1, BANKED
227:               
228:               // TXEN enabled; RTREN disabled; RXTSEN disabled; TXATIE enabled; RXOVIE disabled; TFERFFIE disabled; TFHRFHIE disabled; TFNRFNIE disabled; 
229:               C1FIFOCON3L = 0x90;
138C  0E90     MOVLW 0x90
138E  6F74     MOVWF CM2CON0, BANKED
230:               
231:               // FRESET enabled; TXREQ disabled; UINC disabled; 
232:               C1FIFOCON3H = 0x04;
1390  0E04     MOVLW 0x4
1392  6F75     MOVWF CM2CON1, BANKED
233:               
234:               // TXAT Unlimited number of retransmission attempts; TXPRI 3; 
235:               C1FIFOCON3U = 0x62;
1394  0E62     MOVLW 0x62
1396  6F76     MOVWF CM2NCH, BANKED
236:               
237:               // PLSIZE 64; FSIZE 4; 
238:               C1FIFOCON3T = 0xE3;
1398  0EE3     MOVLW 0xE3
139A  6F77     MOVWF CM2PCH, BANKED
239:               
240:               CAN1_SetTXQNotFullHandler(DefaultTXQNotFullHandler);
139C  0E9A     MOVLW 0x9A
139E  6EE6     MOVWF 0xFE6, ACCESS
13A0  0E27     MOVLW 0x27
13A2  6EE6     MOVWF 0xFE6, ACCESS
13A4  0E00     MOVLW 0x0
13A6  6EE6     MOVWF 0xFE6, ACCESS
13A8  EC5A     CALL 0x22B4, 0
13AA  F011     NOP
241:               
242:               C1INTUbits.TXIE = 1;
13AC  0101     MOVLB 0x1
13AE  811E     BSF 0x1E, 0, BANKED
243:               
244:               PIR4bits.CANTXIF = 0;
13B0  9AB2     BCF 0xFB2, 5, ACCESS
245:               PIE4bits.CANTXIE = 1;
13B2  8AA2     BSF 0xFA2, 5, ACCESS
246:           }
13B4  0012     RETURN 0
247:           
248:           static void CAN1_BitRateConfiguration(void)
249:           {
250:               // SJW 9; 
251:               C1NBTCFGL = 0x09;
1F94  0E09     MOVLW 0x9
1F96  0101     MOVLB 0x1
1F98  6F04     MOVWF __activetblptr, BANKED
252:           
253:               // TSEG2 9; 
254:               C1NBTCFGH = 0x09;
1F9A  0E09     MOVLW 0x9
1F9C  6F05     MOVWF 0x5, BANKED
255:           
256:               // TSEG1 28; 
257:               C1NBTCFGU = 0x1C;
1F9E  0E1C     MOVLW 0x1C
1FA0  6F06     MOVWF 0x6, BANKED
258:           
259:               // BRP 0; 
260:               C1NBTCFGT = 0x00;
1FA2  6B07     CLRF 0x7, BANKED
261:           
262:               // SJW 1; 
263:               C1DBTCFGL = 0x01;
1FA4  0E01     MOVLW 0x1
1FA6  6F08     MOVWF 0x8, BANKED
264:           
265:               // TSEG2 1; 
266:               C1DBTCFGH = 0x01;
1FA8  0E01     MOVLW 0x1
1FAA  6F09     MOVWF 0x9, BANKED
267:           
268:               // TSEG1 4; 
269:               C1DBTCFGU = 0x04;
1FAC  0E04     MOVLW 0x4
1FAE  6F0A     MOVWF 0xA, BANKED
270:           
271:               // BRP 0; 
272:               C1DBTCFGT = 0x00;
1FB0  6B0B     CLRF 0xB, BANKED
273:           
274:               // TDCO 5; 
275:               C1TDCH = 0x05;
1FB2  0E05     MOVLW 0x5
1FB4  6F0D     MOVWF 0xD, BANKED
276:           
277:           	// TDCMOD Auto; 
278:           	C1TDCU = 0x02;
1FB6  0E02     MOVLW 0x2
1FB8  6F0E     MOVWF 0xE, BANKED
279:           }
1FBA  0012     RETURN 0
280:           
281:           static void CAN1_ErrorNotificationInterruptEnable(void)
076A  0E94     MOVLW 0x94
282:           {
283:               CAN1_SetInvalidMessageInterruptHandler(DefaultInvalidMessageHandler);
076C  6EE6     MOVWF 0xFE6, ACCESS
076E  0E27     MOVLW 0x27
0770  6EE6     MOVWF 0xFE6, ACCESS
0772  0E00     MOVLW 0x0
0774  6EE6     MOVWF 0xFE6, ACCESS
0776  ECC0     CALL 0x2380, 0
0778  F011     NOP
284:               CAN1_SetBusWakeUpActivityInterruptHandler(DefaultBusWakeUpActivityHandler);
077A  0E96     MOVLW 0x96
077C  6EE6     MOVWF 0xFE6, ACCESS
077E  0E27     MOVLW 0x27
0780  6EE6     MOVWF 0xFE6, ACCESS
0782  0E00     MOVLW 0x0
0784  6EE6     MOVWF 0xFE6, ACCESS
0786  ECD1     CALL 0x23A2, 0
0788  F011     NOP
285:               CAN1_SetBusErrorInterruptHandler(DefaultBusErrorHandler);
078A  0E98     MOVLW 0x98
078C  6EE6     MOVWF 0xFE6, ACCESS
078E  0E27     MOVLW 0x27
0790  6EE6     MOVWF 0xFE6, ACCESS
0792  0E00     MOVLW 0x0
0794  6EE6     MOVWF 0xFE6, ACCESS
0796  ECE2     CALL 0x23C4, 0
0798  F011     NOP
286:               CAN1_SetModeChangeInterruptHandler(DefaultModeChangeHandler);
079A  0E92     MOVLW 0x92
079C  6EE6     MOVWF 0xFE6, ACCESS
079E  0E27     MOVLW 0x27
07A0  6EE6     MOVWF 0xFE6, ACCESS
07A2  0E00     MOVLW 0x0
07A4  6EE6     MOVWF 0xFE6, ACCESS
07A6  ECAF     CALL 0x235E, 0
07A8  F011     NOP
287:               CAN1_SetSystemErrorInterruptHandler(DefaultSystemErrorHandler);
07AA  0E8C     MOVLW 0x8C
07AC  6EE6     MOVWF 0xFE6, ACCESS
07AE  0E27     MOVLW 0x27
07B0  6EE6     MOVWF 0xFE6, ACCESS
07B2  0E00     MOVLW 0x0
07B4  6EE6     MOVWF 0xFE6, ACCESS
07B6  EC8D     CALL 0x231A, 0
07B8  F011     NOP
288:               CAN1_SetTxAttemptInterruptHandler(DefaultTxAttemptHandler);
07BA  0E8A     MOVLW 0x8A
07BC  6EE6     MOVWF 0xFE6, ACCESS
07BE  0E27     MOVLW 0x27
07C0  6EE6     MOVWF 0xFE6, ACCESS
07C2  0E00     MOVLW 0x0
07C4  6EE6     MOVWF 0xFE6, ACCESS
07C6  EC7C     CALL 0x22F8, 0
07C8  F011     NOP
289:               CAN1_SetRxBufferOverFlowInterruptHandler(DefaultRxBufferOverflowHandler);
07CA  0E90     MOVLW 0x90
07CC  6EE6     MOVWF 0xFE6, ACCESS
07CE  0E27     MOVLW 0x27
07D0  6EE6     MOVWF 0xFE6, ACCESS
07D2  0E00     MOVLW 0x0
07D4  6EE6     MOVWF 0xFE6, ACCESS
07D6  EC9E     CALL 0x233C, 0
07D8  F011     NOP
290:               PIR0bits.CANIF = 0;
07DA  9CAE     BCF 0xFAE, 6, ACCESS
291:           
292:               // MODIF disabled; TBCIF disabled; 
293:               C1INTL = 0x00;
07DC  0101     MOVLB 0x1
07DE  6B1C     CLRF 0x1C, BANKED
294:               
295:               // IVMIF disabled; WAKIF disabled; CERRIF disabled; SERRIF disabled; 
296:               C1INTH = 0x00;
07E0  6B1D     CLRF 0x1D, BANKED
297:               
298:               // TEFIE disabled; MODIE enabled; TBCIE disabled; RXIE enabled; TXIE enabled; 
299:               C1INTU = 0x0B;
07E2  0E0B     MOVLW 0xB
07E4  6F1E     MOVWF 0x1E, BANKED
300:               
301:               // IVMIE enabled; WAKIE enabled; CERRIE enabled; SERRIE enabled; RXOVIE enabled; TXATIE enabled; 
302:               C1INTT = 0xFC;
07E6  0EFC     MOVLW 0xFC
07E8  6F1F     MOVWF 0x1F, BANKED
303:               
304:               PIE0bits.CANIE = 1;
07EA  8C9E     BSF 0xF9E, 6, ACCESS
305:           }
07EC  0012     RETURN 0
306:           
307:           void CAN1_Initialize(void)
308:           {
309:           	/* Enable the CAN module */
310:           	C1CONHbits.ON = 1;
11DA  0101     MOVLB 0x1
11DC  8F01     BSF __ptext283, 7, BANKED
311:           
312:               if (CAN_OP_MODE_REQUEST_SUCCESS == CAN1_OperationModeSet(CAN_CONFIGURATION_MODE))
11DE  0E04     MOVLW 0x4
11E0  6EE6     MOVWF 0xFE6, ACCESS
11E2  EC30     CALL 0x660, 0
11E4  F003     NOP
11E6  5001     MOVF __ptext283, W, ACCESS
11E8  A4D8     BTFSS 0xFD8, 2, ACCESS
11EA  0012     RETURN 0
313:               {
314:           		/* Initialize the C1FIFOBA with the start address of the CAN FIFO message object area. */
315:           		C1FIFOBA = 0x3800;
11EC  0E00     MOVLW 0x0
11EE  6F4C     MOVWF ZCDCON, BANKED
11F0  0E38     MOVLW 0x38
11F2  6F4D     MOVWF 0x4D, BANKED
11F4  0E00     MOVLW 0x0
11F6  6F4E     MOVWF 0x4E, BANKED
11F8  0E00     MOVLW 0x0
11FA  6F4F     MOVWF 0x4F, BANKED
316:           
317:                   // CLKSEL0 disabled; PXEDIS enabled; ISOCRCEN enabled; DNCNT 0; 
318:                   C1CONL = 0x60;
11FC  0E60     MOVLW 0x60
11FE  6F00     MOVWF __smallconst, BANKED
319:           
320:           		// ON enabled; FRZ disabled; SIDL disabled; BRSDIS disabled; WFT T11 Filter; WAKFIL enabled; 
321:           		C1CONH = 0x87;
1200  0E87     MOVLW 0x87
1202  6F01     MOVWF __ptext283, BANKED
322:           
323:           		// TXQEN enabled; STEF disabled; SERR2LOM disabled; ESIGM disabled; RTXAT disabled; 
324:           		C1CONU = 0x10;
1204  0E10     MOVLW 0x10
1206  6F02     MOVWF ___rparam_used, BANKED
325:           
326:           		CAN1_BitRateConfiguration();
1208  ECCA     CALL 0x1F94, 0
120A  F00F     NOP
327:           		CAN1_TX_FIFO_Configuration();
120C  ECB5     CALL 0x136A, 0
120E  F009     NOP
328:                   CAN1_RX_FIFO_Configuration();
1210  ECF9     CALL 0x1DF2, 0
1212  F00E     NOP
329:                   CAN1_RX_FIFO_FilterMaskConfiguration();
1214  EC94     CALL 0x2528, 0
1216  F012     NOP
330:                   CAN1_RX_FIFO_ResetInfo();
1218  EC4F     CALL 0x1E9E, 0
121A  F00F     NOP
331:                   CAN1_ErrorNotificationInterruptEnable();
121C  ECB5     CALL 0x76A, 0
121E  F003     NOP
332:                   CAN1_OperationModeSet(CAN_NORMAL_FD_MODE);    
1220  0E00     MOVLW 0x0
1222  6EE6     MOVWF 0xFE6, ACCESS
1224  EC30     CALL 0x660, 0
1226  F003     NOP
333:           	}
334:           }
1228  0012     RETURN 0
335:           
336:           CAN_OP_MODE_STATUS CAN1_OperationModeSet(const CAN_OP_MODES requestMode)
0660  52E6     MOVF 0xFE6, F, ACCESS
0662  52E6     MOVF 0xFE6, F, ACCESS
337:           {
338:           	CAN_OP_MODE_STATUS status = CAN_OP_MODE_REQUEST_SUCCESS;
0664  0EFE     MOVLW 0xFE
0666  6AE3     CLRF 0xFE3, ACCESS
339:           	CAN_OP_MODES opMode = CAN1_OperationModeGet();
0668  EC70     CALL 0x26E0, 0
066A  F013     NOP
066C  0EFF     MOVLW 0xFF
066E  0061     MOVFFL ltemp0, PLUSW1
0670  F404     NOP
0672  F4E3     NOP
340:           
341:           	if (CAN_CONFIGURATION_MODE == opMode
0674  0EFF     MOVLW 0xFF
0676  0061     MOVFFL PLUSW1, ltemp0
0678  F38C     NOP
067A  F501     NOP
067C  0E04     MOVLW 0x4
067E  1801     XORWF __ptext283, W, ACCESS
0680  B4D8     BTFSC 0xFD8, 2, ACCESS
0682  D00C     BRA 0x69C
0684  0EFD     MOVLW 0xFD
0686  04E3     DECF 0xFE3, W, ACCESS
0688  B4D8     BTFSC 0xFD8, 2, ACCESS
068A  D008     BRA 0x69C
068C  0EFD     MOVLW 0xFD
068E  0061     MOVFFL PLUSW1, ltemp0
0690  F38C     NOP
0692  F501     NOP
0694  0E04     MOVLW 0x4
0696  1801     XORWF __ptext283, W, ACCESS
0698  A4D8     BTFSS 0xFD8, 2, ACCESS
069A  D01A     BRA 0x6D0
342:           		|| CAN_DISABLE_MODE == requestMode
343:                       || CAN_CONFIGURATION_MODE == requestMode)
344:               {
345:           		C1CONTbits.REQOP = requestMode;
069C  0EFD     MOVLW 0xFD
069E  0061     MOVFFL PLUSW1, 0x50C
06A0  F38C     NOP
06A2  F50C     NOP
06A4  5103     MOVF __activetblptr, W, BANKED
06A6  180C     XORWF 0xC, W, ACCESS
06A8  0BF8     ANDLW 0xF8
06AA  180C     XORWF 0xC, W, ACCESS
06AC  6F03     MOVWF __activetblptr, BANKED
346:           
347:                   while (C1CONUbits.OPMOD != requestMode)
06AE  D006     BRA 0x6BC
06BC  3902     SWAPF ___rparam_used, W, BANKED
06BE  32E8     RRCF 0xFE8, F, ACCESS
06C0  0B07     ANDLW 0x7
06C2  6E0C     MOVWF 0xC, ACCESS
06C4  0EFD     MOVLW 0xFD
06C6  50E3     MOVF 0xFE3, W, ACCESS
06C8  180C     XORWF 0xC, W, ACCESS
06CA  B4D8     BTFSC 0xFD8, 2, ACCESS
06CC  D004     BRA 0x6D6
06CE  D7F0     BRA 0x6B0
348:                   {
349:           			//This condition is avoiding the system error case endless loop
350:                       if (1 == C1INTHbits.SERRIF)
06B0  A91D     BTFSS 0x1D, 4, BANKED
06B2  D004     BRA 0x6BC
351:                       {
352:           				status = CAN_OP_MODE_SYS_ERROR_OCCURED;
06B4  0EFE     MOVLW 0xFE
06B6  6AE3     CLRF 0xFE3, ACCESS
06B8  82E3     BSF 0xFE3, 1, ACCESS
353:           				break;
06BA  D00D     BRA 0x6D6
354:           			}
355:           		}
356:               }
357:               else
358:               {
359:           		status = CAN_OP_MODE_REQUEST_FAIL;
06D0  0EFE     MOVLW 0xFE
06D2  6AE3     CLRF 0xFE3, ACCESS
06D4  2AE3     INCF 0xFE3, F, ACCESS
360:           	}
361:           
362:           	return status;
06D6  0EFE     MOVLW 0xFE
06D8  0061     MOVFFL PLUSW1, ltemp0
06DA  F38C     NOP
06DC  F501     NOP
363:           }
06DE  52E5     MOVF 0xFE5, F, ACCESS
06DE  52E5     MOVF 0xFE5, F, ACCESS
06DE  52E5     MOVF 0xFE5, F, ACCESS
06DE  52E5     MOVF 0xFE5, F, ACCESS
364:           
365:           CAN_OP_MODES CAN1_OperationModeGet(void)
366:           {
367:           	return C1CONUbits.OPMOD;
26E0  0101     MOVLB 0x1
26E2  3902     SWAPF ___rparam_used, W, BANKED
26E4  32E8     RRCF 0xFE8, F, ACCESS
26E6  0B07     ANDLW 0x7
26E8  6E01     MOVWF __ptext283, ACCESS
368:           }
26EA  0012     RETURN 0
369:           
370:           static uint8_t GetRxFifoDepth(uint8_t validChannel)
371:           {
372:               return 1U + (FIFO[validChannel].CONT & _C1FIFOCON1T_FSIZE_MASK);
244C  0EFF     MOVLW 0xFF
244E  50E3     MOVF 0xFE3, W, ACCESS
2450  0D0C     MULLW 0xC
2452  0E53     MOVLW 0x53
2454  24F3     ADDWF 0xFF3, W, ACCESS
2456  6ED9     MOVWF 0xFD9, ACCESS
2458  0E01     MOVLW 0x1
245A  20F4     ADDWFC 0xFF4, W, ACCESS
245C  6EDA     MOVWF __end_of_UART2_tx_vect_isr, ACCESS
245E  50DF     MOVF 0xFDF, W, ACCESS
2460  6E01     MOVWF __ptext283, ACCESS
2462  0E1F     MOVLW 0x1F
2464  1601     ANDWF __ptext283, F, ACCESS
2466  0E01     MOVLW 0x1
2468  2601     ADDWF __ptext283, F, ACCESS
373:           }
246A  52E5     MOVF 0xFE5, F, ACCESS
246A  52E5     MOVF 0xFE5, F, ACCESS
374:           
375:           static CAN_RX_FIFO_STATUS GetRxFifoStatus(uint8_t validChannel)
376:           {
377:               return FIFO[validChannel].STAL & (CAN_RX_MSG_AVAILABLE | CAN_RX_MSG_OVERFLOW);
2546  0EFF     MOVLW 0xFF
2548  50E3     MOVF 0xFE3, W, ACCESS
254A  0D0C     MULLW 0xC
254C  0E54     MOVLW 0x54
254E  24F3     ADDWF 0xFF3, W, ACCESS
2550  6ED9     MOVWF 0xFD9, ACCESS
2552  0E01     MOVLW 0x1
2554  20F4     ADDWFC 0xFF4, W, ACCESS
2556  6EDA     MOVWF __end_of_UART2_tx_vect_isr, ACCESS
2558  50DF     MOVF 0xFDF, W, ACCESS
255A  6E01     MOVWF __ptext283, ACCESS
255C  0E09     MOVLW 0x9
255E  1601     ANDWF __ptext283, F, ACCESS
378:           }
2560  52E5     MOVF 0xFE5, F, ACCESS
2560  52E5     MOVF 0xFE5, F, ACCESS
379:           
380:           static void ReadMessageFromFifo(uint8_t *rxFifoObj, CAN_MSG_OBJ *rxCanMsg)
1964E  0E05     MOVLW 0x5
19650  26E1     ADDWF 0xFE1, F, ACCESS
19652  0E00     MOVLW 0x0
19654  22E2     ADDWFC 0xFE2, F, ACCESS
381:           {
382:               uint32_t msgId;
383:               uint8_t status = rxFifoObj[4];
19656  0EF9     MOVLW 0xF9
19658  0061     MOVFFL PLUSW1, wtemp5
1965A  F38C     NOP
1965C  F50B     NOP
1965E  0EFA     MOVLW 0xFA
19660  0061     MOVFFL PLUSW1, 0x50C
19662  F38C     NOP
19664  F50C     NOP
19666  0E04     MOVLW 0x4
19668  240B     ADDWF 0xB, W, ACCESS
1966A  6ED9     MOVWF 0xFD9, ACCESS
1966C  0E00     MOVLW 0x0
1966E  200C     ADDWFC 0xC, W, ACCESS
19670  6EDA     MOVWF __end_of_UART2_tx_vect_isr, ACCESS
19672  50DF     MOVF 0xFDF, W, ACCESS
19674  6E0C     MOVWF 0xC, ACCESS
19676  0EFF     MOVLW 0xFF
19678  0061     MOVFFL 0x50C, PLUSW1
1967A  F430     NOP
1967C  F4E3     NOP
384:               const uint8_t payloadOffsetBytes =
385:                         4U    // ID
386:                       + 1U    // FDF, BRS, RTR, ...
387:                       + 1U    // FILHIT, ...
388:                       + 2U;   // Unimplemented
389:               
390:               rxCanMsg->field.dlc = status;
1967E  0EFF     MOVLW 0xFF
19680  0061     MOVFFL PLUSW1, 0x50C
19682  F38C     NOP
19684  F50C     NOP
19686  0EF7     MOVLW 0xF7
19688  0061     MOVFFL PLUSW1, ltemp2
1968A  F38C     NOP
1968C  F509     NOP
1968E  0EF8     MOVLW 0xF8
19690  0061     MOVFFL PLUSW1, ttemp3
19692  F38C     NOP
19694  F50A     NOP
19696  0E04     MOVLW 0x4
19698  2409     ADDWF 0x9, W, ACCESS
1969A  6ED9     MOVWF 0xFD9, ACCESS
1969C  0E00     MOVLW 0x0
1969E  200A     ADDWFC 0xA, W, ACCESS
196A0  6EDA     MOVWF __end_of_UART2_tx_vect_isr, ACCESS
196A2  460C     RLNCF 0xC, F, ACCESS
196A4  460C     RLNCF 0xC, F, ACCESS
196A6  50DF     MOVF 0xFDF, W, ACCESS
196A8  180C     XORWF 0xC, W, ACCESS
196AA  0BC3     ANDLW 0xC3
196AC  180C     XORWF 0xC, W, ACCESS
196AE  6EDF     MOVWF 0xFDF, ACCESS
391:               rxCanMsg->field.idType = (status & (1UL << IDE_POSN)) ? CAN_FRAME_EXT : CAN_FRAME_STD;
196B0  0EFF     MOVLW 0xFF
196B2  A8E3     BTFSS 0xFE3, 4, ACCESS
196B4  D003     BRA 0x96BC
196B6  6A0C     CLRF 0xC, ACCESS
196B8  2A0C     INCF 0xC, F, ACCESS
196BA  D001     BRA 0x96BE
196BC  6A0C     CLRF 0xC, ACCESS
196BE  0EF7     MOVLW 0xF7
196C0  0061     MOVFFL PLUSW1, ltemp2
196C2  F38C     NOP
196C4  F509     NOP
196C6  0EF8     MOVLW 0xF8
196C8  0061     MOVFFL PLUSW1, ttemp3
196CA  F38C     NOP
196CC  F50A     NOP
196CE  0E04     MOVLW 0x4
196D0  2409     ADDWF 0x9, W, ACCESS
196D2  6ED9     MOVWF 0xFD9, ACCESS
196D4  0E00     MOVLW 0x0
196D6  200A     ADDWFC 0xA, W, ACCESS
196D8  6EDA     MOVWF __end_of_UART2_tx_vect_isr, ACCESS
196DA  50DF     MOVF 0xFDF, W, ACCESS
196DC  180C     XORWF 0xC, W, ACCESS
196DE  0BFE     ANDLW 0xFE
196E0  180C     XORWF 0xC, W, ACCESS
196E2  6EDF     MOVWF 0xFDF, ACCESS
392:               rxCanMsg->field.frameType = (status & (1UL << RTR_POSN)) ? CAN_FRAME_RTR : CAN_FRAME_DATA;
196E4  0EFF     MOVLW 0xFF
196E6  AAE3     BTFSS 0xFE3, 5, ACCESS
196E8  D003     BRA 0x96F0
196EA  6A0C     CLRF 0xC, ACCESS
196EC  2A0C     INCF 0xC, F, ACCESS
196EE  D001     BRA 0x96F2
196F0  6A0C     CLRF 0xC, ACCESS
196F2  0EF7     MOVLW 0xF7
196F4  0061     MOVFFL PLUSW1, ltemp2
196F6  F38C     NOP
196F8  F509     NOP
196FA  0EF8     MOVLW 0xF8
196FC  0061     MOVFFL PLUSW1, ttemp3
196FE  F38C     NOP
19700  F50A     NOP
19702  0E04     MOVLW 0x4
19704  2409     ADDWF 0x9, W, ACCESS
19706  6ED9     MOVWF 0xFD9, ACCESS
19708  0E00     MOVLW 0x0
1970A  200A     ADDWFC 0xA, W, ACCESS
1970C  6EDA     MOVWF __end_of_UART2_tx_vect_isr, ACCESS
1970E  460C     RLNCF 0xC, F, ACCESS
19710  50DF     MOVF 0xFDF, W, ACCESS
19712  180C     XORWF 0xC, W, ACCESS
19714  0BFD     ANDLW 0xFD
19716  180C     XORWF 0xC, W, ACCESS
19718  6EDF     MOVWF 0xFDF, ACCESS
393:               rxCanMsg->field.brs = (status & (1UL << BRS_POSN)) ? CAN_BRS_MODE : CAN_NON_BRS_MODE;
1971A  0EFF     MOVLW 0xFF
1971C  ACE3     BTFSS 0xFE3, 6, ACCESS
1971E  D003     BRA 0x9726
19720  6A0C     CLRF 0xC, ACCESS
19722  2A0C     INCF 0xC, F, ACCESS
19724  D001     BRA 0x9728
19726  6A0C     CLRF 0xC, ACCESS
19728  0EF7     MOVLW 0xF7
1972A  0061     MOVFFL PLUSW1, ltemp2
1972C  F38C     NOP
1972E  F509     NOP
19730  0EF8     MOVLW 0xF8
19732  0061     MOVFFL PLUSW1, ttemp3
19734  F38C     NOP
19736  F50A     NOP
19738  0E04     MOVLW 0x4
1973A  2409     ADDWF 0x9, W, ACCESS
1973C  6ED9     MOVWF 0xFD9, ACCESS
1973E  0E00     MOVLW 0x0
19740  200A     ADDWFC 0xA, W, ACCESS
19742  6EDA     MOVWF __end_of_UART2_tx_vect_isr, ACCESS
19744  320C     RRCF 0xC, F, ACCESS
19746  320C     RRCF 0xC, F, ACCESS
19748  50DF     MOVF 0xFDF, W, ACCESS
1974A  180C     XORWF 0xC, W, ACCESS
1974C  0B7F     ANDLW 0x7F
1974E  180C     XORWF 0xC, W, ACCESS
19750  6EDF     MOVWF 0xFDF, ACCESS
394:               rxCanMsg->field.formatType = (status & (1UL << FDF_POSN)) ? CAN_FRAME_EXT : CAN_FRAME_STD;
19752  0EFF     MOVLW 0xFF
19754  AEE3     BTFSS 0xFE3, 7, ACCESS
19756  D003     BRA 0x975E
19758  6A0C     CLRF 0xC, ACCESS
1975A  2A0C     INCF 0xC, F, ACCESS
1975C  D001     BRA 0x9760
1975E  6A0C     CLRF 0xC, ACCESS
19760  0EF7     MOVLW 0xF7
19762  0061     MOVFFL PLUSW1, ltemp2
19764  F38C     NOP
19766  F509     NOP
19768  0EF8     MOVLW 0xF8
1976A  0061     MOVFFL PLUSW1, ttemp3
1976C  F38C     NOP
1976E  F50A     NOP
19770  0E04     MOVLW 0x4
19772  2409     ADDWF 0x9, W, ACCESS
19774  6ED9     MOVWF 0xFD9, ACCESS
19776  0E00     MOVLW 0x0
19778  200A     ADDWFC 0xA, W, ACCESS
1977A  6EDA     MOVWF __end_of_UART2_tx_vect_isr, ACCESS
1977C  3A0C     SWAPF 0xC, F, ACCESS
1977E  460C     RLNCF 0xC, F, ACCESS
19780  460C     RLNCF 0xC, F, ACCESS
19782  50DF     MOVF 0xFDF, W, ACCESS
19784  180C     XORWF 0xC, W, ACCESS
19786  0BBF     ANDLW 0xBF
19788  180C     XORWF 0xC, W, ACCESS
1978A  6EDF     MOVWF 0xFDF, ACCESS
395:                  
396:               msgId = rxFifoObj[1] & SID_HIGH_MASK;
1978C  0EF9     MOVLW 0xF9
1978E  0061     MOVFFL PLUSW1, wtemp5
19790  F38C     NOP
19792  F50B     NOP
19794  0EFA     MOVLW 0xFA
19796  0061     MOVFFL PLUSW1, 0x50C
19798  F38C     NOP
1979A  F50C     NOP
1979C  0E01     MOVLW 0x1
1979E  240B     ADDWF 0xB, W, ACCESS
197A0  6ED9     MOVWF 0xFD9, ACCESS
197A2  0E00     MOVLW 0x0
197A4  200C     ADDWFC 0xC, W, ACCESS
197A6  6EDA     MOVWF __end_of_UART2_tx_vect_isr, ACCESS
197A8  50DF     MOVF 0xFDF, W, ACCESS
197AA  6E0C     MOVWF 0xC, ACCESS
197AC  0E07     MOVLW 0x7
197AE  160C     ANDWF 0xC, F, ACCESS
197B0  0061     MOVFFL 0x50C, ltemp1
197B2  F430     NOP
197B4  F505     NOP
197B6  6A06     CLRF 0x6, ACCESS
197B8  6A07     CLRF 0x7, ACCESS
197BA  6A08     CLRF 0x8, ACCESS
197BC  0EFB     MOVLW 0xFB
197BE  0061     MOVFFL ltemp1, PLUSW1
197C0  F414     NOP
197C2  F4E3     NOP
197C4  0EFC     MOVLW 0xFC
197C6  0061     MOVFFL 0x506, PLUSW1
197C8  F418     NOP
197CA  F4E3     NOP
197CC  0EFD     MOVLW 0xFD
197CE  0061     MOVFFL ttemp2, PLUSW1
197D0  F41C     NOP
197D2  F4E3     NOP
197D4  0EFE     MOVLW 0xFE
197D6  0061     MOVFFL 0x508, PLUSW1
197D8  F420     NOP
197DA  F4E3     NOP
397:               msgId <<= SID_LOW_WIDTH;
197DC  50E1     MOVF 0xFE1, W, ACCESS
197DE  0FFB     ADDLW 0xFB
197E0  6ED9     MOVWF 0xFD9, ACCESS
197E2  50E2     MOVF 0xFE2, W, ACCESS
197E4  6EDA     MOVWF __end_of_UART2_tx_vect_isr, ACCESS
197E6  0EFF     MOVLW 0xFF
197E8  22DA     ADDWFC __end_of_UART2_tx_vect_isr, F, ACCESS
197EA  0E08     MOVLW 0x8
197EC  90D8     BCF 0xFD8, 0, ACCESS
197EE  36DE     RLCF 0xFDE, F, ACCESS
197F0  36DE     RLCF 0xFDE, F, ACCESS
197F2  36DE     RLCF 0xFDE, F, ACCESS
197F4  36DD     RLCF 0xFDD, F, ACCESS
197F6  52DD     MOVF 0xFDD, F, ACCESS
197F8  52DD     MOVF 0xFDD, F, ACCESS
197FA  2EE8     DECFSZ 0xFE8, F, ACCESS
197FC  D7F7     BRA 0x97EC
398:               msgId |= rxFifoObj[0];
197FE  50E1     MOVF 0xFE1, W, ACCESS
19800  0FFB     ADDLW 0xFB
19802  6ED9     MOVWF 0xFD9, ACCESS
19804  50E2     MOVF 0xFE2, W, ACCESS
19806  6EDA     MOVWF __end_of_UART2_tx_vect_isr, ACCESS
19808  0EFF     MOVLW 0xFF
1980A  22DA     ADDWFC __end_of_UART2_tx_vect_isr, F, ACCESS
1980C  0EF9     MOVLW 0xF9
1980E  C4E3     MOVFF PLUSW1, FSR0
19810  F4E9     NOP
19812  0EFA     MOVLW 0xFA
19814  C4E3     MOVFF PLUSW1, FSR0H
19816  F4EA     NOP
19818  50EF     MOVF 0xFEF, W, ACCESS
1981A  12DE     IORWF 0xFDE, F, ACCESS
1981C  0E00     MOVLW 0x0
1981E  12DE     IORWF 0xFDE, F, ACCESS
19820  12DE     IORWF 0xFDE, F, ACCESS
19822  12DE     IORWF 0xFDE, F, ACCESS
399:               if (CAN_FRAME_EXT == rxCanMsg->field.idType)
19824  0EF7     MOVLW 0xF7
19826  0061     MOVFFL PLUSW1, wtemp5
19828  F38C     NOP
1982A  F50B     NOP
1982C  0EF8     MOVLW 0xF8
1982E  0061     MOVFFL PLUSW1, 0x50C
19830  F38C     NOP
19832  F50C     NOP
19834  0E04     MOVLW 0x4
19836  240B     ADDWF 0xB, W, ACCESS
19838  6ED9     MOVWF 0xFD9, ACCESS
1983A  0E00     MOVLW 0x0
1983C  200C     ADDWFC 0xC, W, ACCESS
1983E  6EDA     MOVWF __end_of_UART2_tx_vect_isr, ACCESS
19840  A0DF     BTFSS 0xFDF, 0, ACCESS
19842  D08D     BRA 0x995E
400:               {
401:                   msgId <<= EID_HIGH_WIDTH;
19844  50E1     MOVF 0xFE1, W, ACCESS
19846  0FFB     ADDLW 0xFB
19848  6ED9     MOVWF 0xFD9, ACCESS
1984A  50E2     MOVF 0xFE2, W, ACCESS
1984C  6EDA     MOVWF __end_of_UART2_tx_vect_isr, ACCESS
1984E  0EFF     MOVLW 0xFF
19850  22DA     ADDWFC __end_of_UART2_tx_vect_isr, F, ACCESS
19852  0E05     MOVLW 0x5
19854  90D8     BCF 0xFD8, 0, ACCESS
19856  36DE     RLCF 0xFDE, F, ACCESS
19858  36DE     RLCF 0xFDE, F, ACCESS
1985A  36DE     RLCF 0xFDE, F, ACCESS
1985C  36DD     RLCF 0xFDD, F, ACCESS
1985E  52DD     MOVF 0xFDD, F, ACCESS
19860  52DD     MOVF 0xFDD, F, ACCESS
19862  2EE8     DECFSZ 0xFE8, F, ACCESS
19864  D7F7     BRA 0x9854
402:                   msgId |= (rxFifoObj[3] & EID_HIGH_MASK);
19866  50E1     MOVF 0xFE1, W, ACCESS
19868  0FFB     ADDLW 0xFB
1986A  6ED9     MOVWF 0xFD9, ACCESS
1986C  50E2     MOVF 0xFE2, W, ACCESS
1986E  6EDA     MOVWF __end_of_UART2_tx_vect_isr, ACCESS
19870  0EFF     MOVLW 0xFF
19872  22DA     ADDWFC __end_of_UART2_tx_vect_isr, F, ACCESS
19874  0EF9     MOVLW 0xF9
19876  0061     MOVFFL PLUSW1, wtemp5
19878  F38C     NOP
1987A  F50B     NOP
1987C  0EFA     MOVLW 0xFA
1987E  0061     MOVFFL PLUSW1, 0x50C
19880  F38C     NOP
19882  F50C     NOP
19884  0E03     MOVLW 0x3
19886  240B     ADDWF 0xB, W, ACCESS
19888  6EE9     MOVWF 0xFE9, ACCESS
1988A  0E00     MOVLW 0x0
1988C  200C     ADDWFC 0xC, W, ACCESS
1988E  6EEA     MOVWF 0xFEA, ACCESS
19890  50EF     MOVF 0xFEF, W, ACCESS
19892  0B1F     ANDLW 0x1F
19894  12DE     IORWF 0xFDE, F, ACCESS
19896  0E00     MOVLW 0x0
19898  12DE     IORWF 0xFDE, F, ACCESS
1989A  12DE     IORWF 0xFDE, F, ACCESS
1989C  12DE     IORWF 0xFDE, F, ACCESS
403:                   msgId <<= EID_MID_WIDTH;
1989E  50E1     MOVF 0xFE1, W, ACCESS
198A0  0FFB     ADDLW 0xFB
198A2  6ED9     MOVWF 0xFD9, ACCESS
198A4  50E2     MOVF 0xFE2, W, ACCESS
198A6  6EDA     MOVWF __end_of_UART2_tx_vect_isr, ACCESS
198A8  0EFF     MOVLW 0xFF
198AA  22DA     ADDWFC __end_of_UART2_tx_vect_isr, F, ACCESS
198AC  0E08     MOVLW 0x8
198AE  90D8     BCF 0xFD8, 0, ACCESS
198B0  36DE     RLCF 0xFDE, F, ACCESS
198B2  36DE     RLCF 0xFDE, F, ACCESS
198B4  36DE     RLCF 0xFDE, F, ACCESS
198B6  36DD     RLCF 0xFDD, F, ACCESS
198B8  52DD     MOVF 0xFDD, F, ACCESS
198BA  52DD     MOVF 0xFDD, F, ACCESS
198BC  2EE8     DECFSZ 0xFE8, F, ACCESS
198BE  D7F7     BRA 0x98AE
404:                   msgId |= rxFifoObj[2];
198C0  50E1     MOVF 0xFE1, W, ACCESS
198C2  0FFB     ADDLW 0xFB
198C4  6ED9     MOVWF 0xFD9, ACCESS
198C6  50E2     MOVF 0xFE2, W, ACCESS
198C8  6EDA     MOVWF __end_of_UART2_tx_vect_isr, ACCESS
198CA  0EFF     MOVLW 0xFF
198CC  22DA     ADDWFC __end_of_UART2_tx_vect_isr, F, ACCESS
198CE  0EF9     MOVLW 0xF9
198D0  0061     MOVFFL PLUSW1, wtemp5
198D2  F38C     NOP
198D4  F50B     NOP
198D6  0EFA     MOVLW 0xFA
198D8  0061     MOVFFL PLUSW1, 0x50C
198DA  F38C     NOP
198DC  F50C     NOP
198DE  0E02     MOVLW 0x2
198E0  240B     ADDWF 0xB, W, ACCESS
198E2  6EE9     MOVWF 0xFE9, ACCESS
198E4  0E00     MOVLW 0x0
198E6  200C     ADDWFC 0xC, W, ACCESS
198E8  6EEA     MOVWF 0xFEA, ACCESS
198EA  50EF     MOVF 0xFEF, W, ACCESS
198EC  12DE     IORWF 0xFDE, F, ACCESS
198EE  0E00     MOVLW 0x0
198F0  12DE     IORWF 0xFDE, F, ACCESS
198F2  12DE     IORWF 0xFDE, F, ACCESS
198F4  12DE     IORWF 0xFDE, F, ACCESS
405:                   msgId <<= EID_LOW_WIDTH;
198F6  50E1     MOVF 0xFE1, W, ACCESS
198F8  0FFB     ADDLW 0xFB
198FA  6ED9     MOVWF 0xFD9, ACCESS
198FC  50E2     MOVF 0xFE2, W, ACCESS
198FE  6EDA     MOVWF __end_of_UART2_tx_vect_isr, ACCESS
19900  0EFF     MOVLW 0xFF
19902  22DA     ADDWFC __end_of_UART2_tx_vect_isr, F, ACCESS
19904  0E05     MOVLW 0x5
19906  90D8     BCF 0xFD8, 0, ACCESS
19908  36DE     RLCF 0xFDE, F, ACCESS
1990A  36DE     RLCF 0xFDE, F, ACCESS
1990C  36DE     RLCF 0xFDE, F, ACCESS
1990E  36DD     RLCF 0xFDD, F, ACCESS
19910  52DD     MOVF 0xFDD, F, ACCESS
19912  52DD     MOVF 0xFDD, F, ACCESS
19914  2EE8     DECFSZ 0xFE8, F, ACCESS
19916  D7F7     BRA 0x9906
406:                   msgId |= (rxFifoObj[1] & EID_LOW_MASK) >> EID_LOW_POSN;
19918  50E1     MOVF 0xFE1, W, ACCESS
1991A  0FFB     ADDLW 0xFB
1991C  6ED9     MOVWF 0xFD9, ACCESS
1991E  50E2     MOVF 0xFE2, W, ACCESS
19920  6EDA     MOVWF __end_of_UART2_tx_vect_isr, ACCESS
19922  0EFF     MOVLW 0xFF
19924  22DA     ADDWFC __end_of_UART2_tx_vect_isr, F, ACCESS
19926  0EF9     MOVLW 0xF9
19928  0061     MOVFFL PLUSW1, wtemp5
1992A  F38C     NOP
1992C  F50B     NOP
1992E  0EFA     MOVLW 0xFA
19930  0061     MOVFFL PLUSW1, 0x50C
19932  F38C     NOP
19934  F50C     NOP
19936  0E01     MOVLW 0x1
19938  240B     ADDWF 0xB, W, ACCESS
1993A  6EE9     MOVWF 0xFE9, ACCESS
1993C  0E00     MOVLW 0x0
1993E  200C     ADDWFC 0xC, W, ACCESS
19940  6EEA     MOVWF 0xFEA, ACCESS
19942  50EF     MOVF 0xFEF, W, ACCESS
19944  6E0C     MOVWF 0xC, ACCESS
19946  90D8     BCF 0xFD8, 0, ACCESS
19948  320C     RRCF 0xC, F, ACCESS
1994A  90D8     BCF 0xFD8, 0, ACCESS
1994C  320C     RRCF 0xC, F, ACCESS
1994E  90D8     BCF 0xFD8, 0, ACCESS
19950  300C     RRCF 0xC, W, ACCESS
19952  0B1F     ANDLW 0x1F
19954  12DE     IORWF 0xFDE, F, ACCESS
19956  0E00     MOVLW 0x0
19958  12DE     IORWF 0xFDE, F, ACCESS
1995A  12DE     IORWF 0xFDE, F, ACCESS
1995C  12DE     IORWF 0xFDE, F, ACCESS
407:               }
408:               rxCanMsg->msgId = msgId;
1995E  50E1     MOVF 0xFE1, W, ACCESS
19960  0FFB     ADDLW 0xFB
19962  6ED9     MOVWF 0xFD9, ACCESS
19964  50E2     MOVF 0xFE2, W, ACCESS
19966  6EDA     MOVWF __end_of_UART2_tx_vect_isr, ACCESS
19968  0EFF     MOVLW 0xFF
1996A  22DA     ADDWFC __end_of_UART2_tx_vect_isr, F, ACCESS
1996C  0EF7     MOVLW 0xF7
1996E  C4E3     MOVFF PLUSW1, FSR0
19970  F4E9     NOP
19972  0EF8     MOVLW 0xF8
19974  C4E3     MOVFF PLUSW1, FSR0H
19976  F4EA     NOP
19978  C4DE     MOVFF POSTINC2, POSTINC0
1997A  F4EE     NOP
1997C  C4DE     MOVFF POSTINC2, POSTINC0
1997E  F4EE     NOP
19980  C4DE     MOVFF POSTINC2, POSTINC0
19982  F4EE     NOP
19984  C4DE     MOVFF POSTINC2, POSTINC0
19986  F4EE     NOP
409:               
410:               memcpy(rxMsgData, rxFifoObj + payloadOffsetBytes, DLCToPayloadBytes(rxCanMsg->field.dlc));
19988  0EF7     MOVLW 0xF7
1998A  0061     MOVFFL PLUSW1, wtemp5
1998C  F38C     NOP
1998E  F50B     NOP
19990  0EF8     MOVLW 0xF8
19992  0061     MOVFFL PLUSW1, 0x50C
19994  F38C     NOP
19996  F50C     NOP
19998  0E04     MOVLW 0x4
1999A  240B     ADDWF 0xB, W, ACCESS
1999C  6ED9     MOVWF 0xFD9, ACCESS
1999E  0E00     MOVLW 0x0
199A0  200C     ADDWFC 0xC, W, ACCESS
199A2  6EDA     MOVWF __end_of_UART2_tx_vect_isr, ACCESS
199A4  30DF     RRCF 0xFDF, W, ACCESS
199A6  32E8     RRCF 0xFE8, F, ACCESS
199A8  0B0F     ANDLW 0xF
199AA  6E0B     MOVWF 0xB, ACCESS
199AC  6A0C     CLRF 0xC, ACCESS
199AE  0E41     MOVLW 0x41
199B0  240B     ADDWF 0xB, W, ACCESS
199B2  6EF6     MOVWF 0xFF6, ACCESS
199B4  0EFA     MOVLW 0xFA
199B6  200C     ADDWFC 0xC, W, ACCESS
199B8  6EF7     MOVWF 0xFF7, ACCESS
199BA  6AF8     CLRF 0xFF8, ACCESS
199BC  0E00     MOVLW 0x0
199BE  22F8     ADDWFC 0xFF8, F, ACCESS
199C0  0008     TBLRD*
199C2  50F5     MOVF 0xFF5, W, ACCESS
199C4  6EE6     MOVWF 0xFE6, ACCESS
199C6  0E00     MOVLW 0x0
199C8  6EE6     MOVWF 0xFE6, ACCESS
199CA  0EF7     MOVLW 0xF7
199CC  0061     MOVFFL PLUSW1, wtemp5
199CE  F38C     NOP
199D0  F50B     NOP
199D2  0EF8     MOVLW 0xF8
199D4  0061     MOVFFL PLUSW1, 0x50C
199D6  F38C     NOP
199D8  F50C     NOP
199DA  0E08     MOVLW 0x8
199DC  240B     ADDWF 0xB, W, ACCESS
199DE  6E09     MOVWF 0x9, ACCESS
199E0  0E00     MOVLW 0x0
199E2  200C     ADDWFC 0xC, W, ACCESS
199E4  6E0A     MOVWF 0xA, ACCESS
199E6  0061     MOVFFL ltemp2, POSTINC1
199E8  F424     NOP
199EA  F4E6     NOP
199EC  0061     MOVFFL ttemp3, POSTINC1
199EE  F428     NOP
199F0  F4E6     NOP
199F2  0EA9     MOVLW 0xA9
199F4  6EE6     MOVWF 0xFE6, ACCESS
199F6  0E0D     MOVLW 0xD
199F8  6EE6     MOVWF 0xFE6, ACCESS
199FA  EC81     CALL 0x1E502, 0
199FC  F0F2     NOP
411:               rxCanMsg->data = rxMsgData;
199FE  0EF7     MOVLW 0xF7
19A00  0061     MOVFFL PLUSW1, wtemp5
19A02  F38C     NOP
19A04  F50B     NOP
19A06  0EF8     MOVLW 0xF8
19A08  0061     MOVFFL PLUSW1, 0x50C
19A0A  F38C     NOP
19A0C  F50C     NOP
19A0E  0E05     MOVLW 0x5
19A10  240B     ADDWF 0xB, W, ACCESS
19A12  6ED9     MOVWF 0xFD9, ACCESS
19A14  0E00     MOVLW 0x0
19A16  200C     ADDWFC 0xC, W, ACCESS
19A18  6EDA     MOVWF __end_of_UART2_tx_vect_isr, ACCESS
19A1A  0EA9     MOVLW 0xA9
19A1C  6EDE     MOVWF 0xFDE, ACCESS
19A1E  0E0D     MOVLW 0xD
19A20  6EDD     MOVWF 0xFDD, ACCESS
412:           }
19A22  0EF7     MOVLW 0xF7
19A22  0EF7     MOVLW 0xF7
19A22  0EF7     MOVLW 0xF7
19A22  0EF7     MOVLW 0xF7
19A22  0EF7     MOVLW 0xF7
413:           
414:           static bool Receive(uint8_t index, CAN1_RX_FIFO_CHANNELS channel, CAN_MSG_OBJ *rxCanMsg)
1E3F0  52E6     MOVF 0xFE6, F, ACCESS
1E3F2  52E6     MOVF 0xFE6, F, ACCESS
1E3F4  52E6     MOVF 0xFE6, F, ACCESS
1E3F6  52E6     MOVF 0xFE6, F, ACCESS
415:           {
416:               bool status = false;
1E3F8  0EFF     MOVLW 0xFF
1E3FA  6AE3     CLRF 0xFE3, ACCESS
417:               CAN_RX_FIFO_STATUS rxMsgStatus = GetRxFifoStatus(channel);
1E3FC  0EFA     MOVLW 0xFA
1E3FE  50E3     MOVF 0xFE3, W, ACCESS
1E400  6EE6     MOVWF 0xFE6, ACCESS
1E402  ECA3     CALL 0x2546, 0
1E404  F012     NOP
1E406  0EFE     MOVLW 0xFE
1E408  0061     MOVFFL ltemp0, PLUSW1
1E40A  F404     NOP
1E40C  F4E3     NOP
418:           
419:               if (CAN_RX_MSG_AVAILABLE == (rxMsgStatus & CAN_RX_MSG_AVAILABLE))
1E40E  0EFE     MOVLW 0xFE
1E410  A0E3     BTFSS 0xFE3, 0, ACCESS
1E412  D06E     BRA 0xE4F0
420:               {
421:                   uint8_t *rxFifoObj = (uint8_t *) FIFO[channel].UA;
1E414  0EFA     MOVLW 0xFA
1E416  50E3     MOVF 0xFE3, W, ACCESS
1E418  0D0C     MULLW 0xC
1E41A  0E58     MOVLW 0x58
1E41C  24F3     ADDWF 0xFF3, W, ACCESS
1E41E  6ED9     MOVWF 0xFD9, ACCESS
1E420  0E01     MOVLW 0x1
1E422  20F4     ADDWFC 0xFF4, W, ACCESS
1E424  6EDA     MOVWF __end_of_UART2_tx_vect_isr, ACCESS
1E426  0061     MOVFFL POSTINC2, wtemp5
1E428  F378     NOP
1E42A  F50B     NOP
1E42C  0061     MOVFFL POSTDEC2, 0x50C
1E42E  F374     NOP
1E430  F50C     NOP
1E432  0EFD     MOVLW 0xFD
1E434  0061     MOVFFL 0x50C, PLUSW1
1E436  F430     NOP
1E438  F4E3     NOP
1E43A  0EFC     MOVLW 0xFC
1E43C  0061     MOVFFL wtemp5, PLUSW1
1E43E  F42C     NOP
1E440  F4E3     NOP
422:           
423:                   if (rxFifoObj != NULL)
1E442  0EFC     MOVLW 0xFC
1E444  0061     MOVFFL PLUSW1, ltemp0
1E446  F38C     NOP
1E448  F501     NOP
1E44A  0EFD     MOVLW 0xFD
1E44C  50E3     MOVF 0xFE3, W, ACCESS
1E44E  1001     IORWF __ptext283, W, ACCESS
1E450  B4D8     BTFSC 0xFD8, 2, ACCESS
1E452  D04E     BRA 0xE4F0
424:                   {
425:                       ReadMessageFromFifo(rxFifoObj, rxCanMsg);
1E454  0EF8     MOVLW 0xF8
1E456  C4E3     MOVFF PLUSW1, POSTINC1
1E458  F4E6     NOP
1E45A  C4E3     MOVFF PLUSW1, POSTINC1
1E45C  F4E6     NOP
1E45E  0EFA     MOVLW 0xFA
1E460  C4E3     MOVFF PLUSW1, POSTINC1
1E462  F4E6     NOP
1E464  C4E3     MOVFF PLUSW1, POSTINC1
1E466  F4E6     NOP
1E468  EC27     CALL 0x1964E, 0
1E46A  F0CB     NOP
426:                       FIFO[channel].CONH |= _C1FIFOCON1H_UINC_MASK;
1E46C  0EFA     MOVLW 0xFA
1E46E  50E3     MOVF 0xFE3, W, ACCESS
1E470  0D0C     MULLW 0xC
1E472  0E51     MOVLW 0x51
1E474  24F3     ADDWF 0xFF3, W, ACCESS
1E476  6ED9     MOVWF 0xFD9, ACCESS
1E478  0E01     MOVLW 0x1
1E47A  20F4     ADDWFC 0xFF4, W, ACCESS
1E47C  6EDA     MOVWF __end_of_UART2_tx_vect_isr, ACCESS
1E47E  0E00     MOVLW 0x0
1E480  80DB     BSF __end_of_UART2_tx_vect_isr, 0, ACCESS
427:           
428:                       rxFifos[index].fifoHead += 1;
1E482  0EFB     MOVLW 0xFB
1E484  50E3     MOVF 0xFE3, W, ACCESS
1E486  0D02     MULLW 0x2
1E488  0EAE     MOVLW 0xAE
1E48A  24F3     ADDWF 0xFF3, W, ACCESS
1E48C  6ED9     MOVWF 0xFD9, ACCESS
1E48E  0E05     MOVLW 0x5
1E490  20F4     ADDWFC 0xFF4, W, ACCESS
1E492  6EDA     MOVWF __end_of_UART2_tx_vect_isr, ACCESS
1E494  2ADF     INCF 0xFDF, F, ACCESS
429:                       if (rxFifos[index].fifoHead >= GetRxFifoDepth(channel))
1E496  0EFA     MOVLW 0xFA
1E498  50E3     MOVF 0xFE3, W, ACCESS
1E49A  6EE6     MOVWF 0xFE6, ACCESS
1E49C  EC26     CALL 0x244C, 0
1E49E  F012     NOP
1E4A0  0EFB     MOVLW 0xFB
1E4A2  50E3     MOVF 0xFE3, W, ACCESS
1E4A4  0D02     MULLW 0x2
1E4A6  0EAE     MOVLW 0xAE
1E4A8  24F3     ADDWF 0xFF3, W, ACCESS
1E4AA  6ED9     MOVWF 0xFD9, ACCESS
1E4AC  0E05     MOVLW 0x5
1E4AE  20F4     ADDWFC 0xFF4, W, ACCESS
1E4B0  6EDA     MOVWF __end_of_UART2_tx_vect_isr, ACCESS
1E4B2  5001     MOVF __ptext283, W, ACCESS
1E4B4  5CDE     SUBWF 0xFDE, W, ACCESS
1E4B6  A0D8     BTFSS 0xFD8, 0, ACCESS
1E4B8  D00A     BRA 0xE4CE
430:                       {
431:                           rxFifos[index].fifoHead = 0;
1E4BA  0EFB     MOVLW 0xFB
1E4BC  50E3     MOVF 0xFE3, W, ACCESS
1E4BE  0D02     MULLW 0x2
1E4C0  0EAE     MOVLW 0xAE
1E4C2  24F3     ADDWF 0xFF3, W, ACCESS
1E4C4  6ED9     MOVWF 0xFD9, ACCESS
1E4C6  0E05     MOVLW 0x5
1E4C8  20F4     ADDWFC 0xFF4, W, ACCESS
1E4CA  6EDA     MOVWF __end_of_UART2_tx_vect_isr, ACCESS
1E4CC  6ADF     CLRF 0xFDF, ACCESS
432:                       }
433:           
434:                       if (CAN_RX_MSG_OVERFLOW == (rxMsgStatus & CAN_RX_MSG_OVERFLOW))
1E4CE  0EFE     MOVLW 0xFE
1E4D0  A6E3     BTFSS 0xFE3, 3, ACCESS
1E4D2  D00B     BRA 0xE4EA
435:                       {
436:                           FIFO[channel].STAL &= ~_C1FIFOSTA1L_RXOVIF_MASK;
1E4D4  0EFA     MOVLW 0xFA
1E4D6  50E3     MOVF 0xFE3, W, ACCESS
1E4D8  0D0C     MULLW 0xC
1E4DA  0E54     MOVLW 0x54
1E4DC  24F3     ADDWF 0xFF3, W, ACCESS
1E4DE  6ED9     MOVWF 0xFD9, ACCESS
1E4E0  0E01     MOVLW 0x1
1E4E2  20F4     ADDWFC 0xFF4, W, ACCESS
1E4E4  6EDA     MOVWF __end_of_UART2_tx_vect_isr, ACCESS
1E4E6  0EF7     MOVLW 0xF7
1E4E8  16DF     ANDWF 0xFDF, F, ACCESS
437:                       }
438:           
439:                       status = true;
1E4EA  0EFF     MOVLW 0xFF
1E4EC  6AE3     CLRF 0xFE3, ACCESS
1E4EE  2AE3     INCF 0xFE3, F, ACCESS
440:                   }
441:               }
442:               
443:               return status;
1E4F0  0EFF     MOVLW 0xFF
1E4F2  0061     MOVFFL PLUSW1, ltemp0
1E4F4  F38C     NOP
1E4F6  F501     NOP
444:           }
1E4F8  0EF8     MOVLW 0xF8
1E4F8  0EF8     MOVLW 0xF8
1E4F8  0EF8     MOVLW 0xF8
1E4F8  0EF8     MOVLW 0xF8
1E4F8  0EF8     MOVLW 0xF8
445:           
446:           bool CAN1_Receive(CAN_MSG_OBJ *rxCanMsg)
447:           {
448:               uint8_t index;
449:               bool status = false;
450:               
451:               for (index = 0; index < NUM_OF_RX_FIFO; index++)
452:               {
453:                   status = Receive(index, rxFifos[index].channel, rxCanMsg);
454:                   
455:                   if (status)
456:                   {
457:                       break;
458:                   }
459:               }
460:               
461:               return status;
462:           }
463:           
464:           bool CAN1_ReceiveFrom(const CAN1_RX_FIFO_CHANNELS channel, CAN_MSG_OBJ *rxCanMsg)
0B4C  52E6     MOVF 0xFE6, F, ACCESS
0B4E  52E6     MOVF 0xFE6, F, ACCESS
465:           {
466:               uint8_t index;
467:               bool status = false;
0B50  0EFF     MOVLW 0xFF
0B52  6AE3     CLRF 0xFE3, ACCESS
468:               
469:               for (index = 0; index < NUM_OF_RX_FIFO; index++)
0B54  0EFE     MOVLW 0xFE
0B56  6AE3     CLRF 0xFE3, ACCESS
470:               {
471:                   if (channel == rxFifos[index].channel)
0B58  0EFE     MOVLW 0xFE
0B5A  50E3     MOVF 0xFE3, W, ACCESS
0B5C  0D02     MULLW 0x2
0B5E  0EAD     MOVLW 0xAD
0B60  24F3     ADDWF 0xFF3, W, ACCESS
0B62  6ED9     MOVWF 0xFD9, ACCESS
0B64  0E05     MOVLW 0x5
0B66  20F4     ADDWFC 0xFF4, W, ACCESS
0B68  6EDA     MOVWF __end_of_UART2_tx_vect_isr, ACCESS
0B6A  0EFD     MOVLW 0xFD
0B6C  50E3     MOVF 0xFE3, W, ACCESS
0B6E  18DE     XORWF 0xFDE, W, ACCESS
0B70  A4D8     BTFSS 0xFD8, 2, ACCESS
0B72  D012     BRA 0xB98
472:                   {
473:                       status = Receive(index, channel, rxCanMsg);
0B74  0EFB     MOVLW 0xFB
0B76  C4E3     MOVFF PLUSW1, POSTINC1
0B78  F4E6     NOP
0B7A  C4E3     MOVFF PLUSW1, POSTINC1
0B7C  F4E6     NOP
0B7E  0EFB     MOVLW 0xFB
0B80  50E3     MOVF 0xFE3, W, ACCESS
0B82  6EE6     MOVWF 0xFE6, ACCESS
0B84  0EFB     MOVLW 0xFB
0B86  50E3     MOVF 0xFE3, W, ACCESS
0B88  6EE6     MOVWF 0xFE6, ACCESS
0B8A  ECF8     CALL 0x1E3F0, 0
0B8C  F0F1     NOP
0B8E  0EFF     MOVLW 0xFF
0B90  0061     MOVFFL ltemp0, PLUSW1
0B92  F404     NOP
0B94  F4E3     NOP
474:                       break;
0B96  D006     BRA 0xBA4
475:                   }
476:               }
0B98  0EFE     MOVLW 0xFE
0B9A  2AE3     INCF 0xFE3, F, ACCESS
0B9C  0EFE     MOVLW 0xFE
0B9E  50E3     MOVF 0xFE3, W, ACCESS
0BA0  B4D8     BTFSC 0xFD8, 2, ACCESS
0BA2  D7DA     BRA 0xB58
477:               
478:               return status;
0BA4  0EFF     MOVLW 0xFF
0BA6  0061     MOVFFL PLUSW1, ltemp0
0BA8  F38C     NOP
0BAA  F501     NOP
479:           }
0BAC  0EFB     MOVLW 0xFB
0BAC  0EFB     MOVLW 0xFB
0BAC  0EFB     MOVLW 0xFB
0BAC  0EFB     MOVLW 0xFB
0BAC  0EFB     MOVLW 0xFB
480:           
481:           uint8_t CAN1_ReceivedMessageCountGet(void)
482:           {
483:               uint8_t index, totalMsgObj = 0;
484:           
485:               for (index = 0; index < NUM_OF_RX_FIFO; index++)
486:               {
487:                   CAN1_RX_FIFO_CHANNELS channel = rxFifos[index].channel;
488:                   CAN_RX_FIFO_STATUS rxMsgStatus = GetRxFifoStatus(channel);
489:           
490:                   if (CAN_RX_MSG_AVAILABLE == (rxMsgStatus & CAN_RX_MSG_AVAILABLE))
491:                   {
492:                       uint8_t numOfMsg, fifoDepth = GetRxFifoDepth(channel);
493:                       
494:                       if (CAN_RX_MSG_OVERFLOW == (rxMsgStatus & CAN_RX_MSG_OVERFLOW))
495:                       {
496:                           numOfMsg = fifoDepth;
497:                       }
498:                       else
499:                       {
500:                           uint8_t fifoTail = FIFO[channel].STAH & _C1FIFOSTA1H_FIFOCI_MASK;
501:                           uint8_t fifoHead = rxFifos[index].fifoHead;
502:           
503:                           if (fifoTail < fifoHead)
504:                           {
505:                               numOfMsg = ((fifoTail + fifoDepth) - fifoHead); // wrap
506:                           }
507:                           else if (fifoTail > fifoHead)
508:                           {
509:                               numOfMsg = fifoTail - fifoHead;
510:                           }
511:                           else
512:                           {
513:                               numOfMsg = fifoDepth;
514:                           }
515:                       }
516:           
517:                       totalMsgObj += numOfMsg;
518:                   }
519:               }
520:           
521:               return totalMsgObj;
522:           }
523:           
524:           static bool isTxChannel(uint8_t channel)
180E  52E6     MOVF 0xFE6, F, ACCESS
525:           {
526:           	return channel < 4u && (FIFO[channel].CONL & _C1FIFOCON1L_TXEN_MASK);
1810  0EFF     MOVLW 0xFF
1812  6AE3     CLRF 0xFE3, ACCESS
1814  0EFE     MOVLW 0xFE
1816  0061     MOVFFL PLUSW1, ltemp0
1818  F38C     NOP
181A  F501     NOP
181C  0E04     MOVLW 0x4
181E  6001     CPFSLT __ptext283, ACCESS
1820  D00F     BRA 0x1840
1822  0EFE     MOVLW 0xFE
1824  50E3     MOVF 0xFE3, W, ACCESS
1826  0D0C     MULLW 0xC
1828  0E50     MOVLW 0x50
182A  24F3     ADDWF 0xFF3, W, ACCESS
182C  6ED9     MOVWF 0xFD9, ACCESS
182E  0E01     MOVLW 0x1
1830  20F4     ADDWFC 0xFF4, W, ACCESS
1832  6EDA     MOVWF __end_of_UART2_tx_vect_isr, ACCESS
1834  0101     MOVLB 0x1
1836  AEDF     BTFSS 0xFDF, 7, ACCESS
1838  D003     BRA 0x1840
183A  0EFF     MOVLW 0xFF
183C  6AE3     CLRF 0xFE3, ACCESS
183E  2AE3     INCF 0xFE3, F, ACCESS
1840  0EFF     MOVLW 0xFF
1842  0061     MOVFFL PLUSW1, ltemp0
1844  F38C     NOP
1846  F501     NOP
527:           }
1848  52E5     MOVF 0xFE5, F, ACCESS
1848  52E5     MOVF 0xFE5, F, ACCESS
1848  52E5     MOVF 0xFE5, F, ACCESS
528:           
529:           static CAN_TX_FIFO_STATUS GetTxFifoStatus(uint8_t validChannel)
530:           {
531:               return (FIFO[validChannel].STAL & _C1FIFOSTA1L_TFNRFNIF_MASK);
250A  0EFF     MOVLW 0xFF
250C  50E3     MOVF 0xFE3, W, ACCESS
250E  0D0C     MULLW 0xC
2510  0E54     MOVLW 0x54
2512  24F3     ADDWF 0xFF3, W, ACCESS
2514  6ED9     MOVWF 0xFD9, ACCESS
2516  0E01     MOVLW 0x1
2518  20F4     ADDWFC 0xFF4, W, ACCESS
251A  6EDA     MOVWF __end_of_UART2_tx_vect_isr, ACCESS
251C  50DF     MOVF 0xFDF, W, ACCESS
251E  6E01     MOVWF __ptext283, ACCESS
2520  0E01     MOVLW 0x1
2522  1601     ANDWF __ptext283, F, ACCESS
532:           }
2524  52E5     MOVF 0xFE5, F, ACCESS
2524  52E5     MOVF 0xFE5, F, ACCESS
533:           
534:           static void WriteMessageToFifo(uint8_t *txFifoObj, CAN_MSG_OBJ *txCanMsg)
191E4  0E05     MOVLW 0x5
191E6  26E1     ADDWF 0xFE1, F, ACCESS
191E8  0E00     MOVLW 0x0
191EA  22E2     ADDWFC 0xFE2, F, ACCESS
535:           {
536:           	uint32_t msgId = txCanMsg->msgId;
191EC  0EF7     MOVLW 0xF7
191EE  C4E3     MOVFF PLUSW1, FSR2
191F0  F4D9     NOP
191F2  0EF8     MOVLW 0xF8
191F4  C4E3     MOVFF PLUSW1, FSR2H
191F6  F4DA     NOP
191F8  0061     MOVFFL POSTINC2, ltemp2
191FA  F378     NOP
191FC  F509     NOP
191FE  0061     MOVFFL POSTINC2, ttemp3
19200  F378     NOP
19202  F50A     NOP
19204  0061     MOVFFL POSTINC2, wtemp5
19206  F378     NOP
19208  F50B     NOP
1920A  0061     MOVFFL POSTINC2, 0x50C
1920C  F378     NOP
1920E  F50C     NOP
19210  0EFB     MOVLW 0xFB
19212  0061     MOVFFL ltemp2, PLUSW1
19214  F424     NOP
19216  F4E3     NOP
19218  0EFC     MOVLW 0xFC
1921A  0061     MOVFFL ttemp3, PLUSW1
1921C  F428     NOP
1921E  F4E3     NOP
19220  0EFD     MOVLW 0xFD
19222  0061     MOVFFL wtemp5, PLUSW1
19224  F42C     NOP
19226  F4E3     NOP
19228  0EFE     MOVLW 0xFE
1922A  0061     MOVFFL 0x50C, PLUSW1
1922C  F430     NOP
1922E  F4E3     NOP
537:           	uint8_t status;
538:           	const uint8_t payloadOffsetBytes =
539:                         4U    // ID
540:                       + 1U    // FDF, BRS, RTR, ...
541:                       + 1U    // SEQ[6:0], ESI
542:                       + 2U;   // SEQ
543:           
544:               if (CAN_FRAME_EXT == txCanMsg->field.idType)
19230  0EF7     MOVLW 0xF7
19232  0061     MOVFFL PLUSW1, wtemp5
19234  F38C     NOP
19236  F50B     NOP
19238  0EF8     MOVLW 0xF8
1923A  0061     MOVFFL PLUSW1, 0x50C
1923C  F38C     NOP
1923E  F50C     NOP
19240  0E04     MOVLW 0x4
19242  240B     ADDWF 0xB, W, ACCESS
19244  6ED9     MOVWF 0xFD9, ACCESS
19246  0E00     MOVLW 0x0
19248  200C     ADDWFC 0xC, W, ACCESS
1924A  6EDA     MOVWF __end_of_UART2_tx_vect_isr, ACCESS
1924C  A0DF     BTFSS 0xFDF, 0, ACCESS
1924E  D08E     BRA 0x936C
545:               {
546:           		txFifoObj[1] = (msgId << EID_LOW_POSN) & EID_LOW_MASK;
19250  0EF9     MOVLW 0xF9
19252  0061     MOVFFL PLUSW1, wtemp5
19254  F38C     NOP
19256  F50B     NOP
19258  0EFA     MOVLW 0xFA
1925A  0061     MOVFFL PLUSW1, 0x50C
1925C  F38C     NOP
1925E  F50C     NOP
19260  0E01     MOVLW 0x1
19262  240B     ADDWF 0xB, W, ACCESS
19264  6ED9     MOVWF 0xFD9, ACCESS
19266  0E00     MOVLW 0x0
19268  200C     ADDWFC 0xC, W, ACCESS
1926A  6EDA     MOVWF __end_of_UART2_tx_vect_isr, ACCESS
1926C  0EFB     MOVLW 0xFB
1926E  0061     MOVFFL PLUSW1, 0x50C
19270  F38C     NOP
19272  F50C     NOP
19274  90D8     BCF 0xFD8, 0, ACCESS
19276  360C     RLCF 0xC, F, ACCESS
19278  90D8     BCF 0xFD8, 0, ACCESS
1927A  360C     RLCF 0xC, F, ACCESS
1927C  90D8     BCF 0xFD8, 0, ACCESS
1927E  340C     RLCF 0xC, W, ACCESS
19280  0BF8     ANDLW 0xF8
19282  6EDF     MOVWF 0xFDF, ACCESS
547:           		msgId >>= EID_LOW_WIDTH;
19284  0E05     MOVLW 0x5
19286  6E0C     MOVWF 0xC, ACCESS
19288  50E1     MOVF 0xFE1, W, ACCESS
1928A  0FFB     ADDLW 0xFB
1928C  6ED9     MOVWF 0xFD9, ACCESS
1928E  50E2     MOVF 0xFE2, W, ACCESS
19290  6EDA     MOVWF __end_of_UART2_tx_vect_isr, ACCESS
19292  0EFF     MOVLW 0xFF
19294  22DA     ADDWFC __end_of_UART2_tx_vect_isr, F, ACCESS
19296  280C     INCF 0xC, W, ACCESS
19298  52DE     MOVF 0xFDE, F, ACCESS
1929A  D007     BRA 0x92AA
1929C  52DE     MOVF 0xFDE, F, ACCESS
1929E  52DE     MOVF 0xFDE, F, ACCESS
192A0  90D8     BCF 0xFD8, 0, ACCESS
192A2  32DD     RRCF 0xFDD, F, ACCESS
192A4  32DD     RRCF 0xFDD, F, ACCESS
192A6  32DD     RRCF 0xFDD, F, ACCESS
192A8  32DE     RRCF 0xFDE, F, ACCESS
192AA  2EE8     DECFSZ 0xFE8, F, ACCESS
192AC  D7F7     BRA 0x929C
548:           		txFifoObj[2] = msgId;
192AE  0EF9     MOVLW 0xF9
192B0  0061     MOVFFL PLUSW1, wtemp5
192B2  F38C     NOP
192B4  F50B     NOP
192B6  0EFA     MOVLW 0xFA
192B8  0061     MOVFFL PLUSW1, 0x50C
192BA  F38C     NOP
192BC  F50C     NOP
192BE  0E02     MOVLW 0x2
192C0  240B     ADDWF 0xB, W, ACCESS
192C2  6ED9     MOVWF 0xFD9, ACCESS
192C4  0E00     MOVLW 0x0
192C6  200C     ADDWFC 0xC, W, ACCESS
192C8  6EDA     MOVWF __end_of_UART2_tx_vect_isr, ACCESS
192CA  0EFB     MOVLW 0xFB
192CC  C4E3     MOVFF PLUSW1, INDF2
192CE  F4DF     NOP
549:           		msgId >>= EID_MID_WIDTH;
192D0  0EFC     MOVLW 0xFC
192D2  24E1     ADDWF 0xFE1, W, ACCESS
192D4  6ED9     MOVWF 0xFD9, ACCESS
192D6  0EFF     MOVLW 0xFF
192D8  20E2     ADDWFC 0xFE2, W, ACCESS
192DA  6EDA     MOVWF __end_of_UART2_tx_vect_isr, ACCESS
192DC  0061     MOVFFL POSTINC2, ttemp3
192DE  F378     NOP
192E0  F50A     NOP
192E2  0061     MOVFFL POSTINC2, wtemp5
192E4  F378     NOP
192E6  F50B     NOP
192E8  0061     MOVFFL POSTINC2, 0x50C
192EA  F378     NOP
192EC  F50C     NOP
192EE  500A     MOVF 0xA, W, ACCESS
192F0  6E05     MOVWF 0x5, ACCESS
192F2  500B     MOVF 0xB, W, ACCESS
192F4  6E06     MOVWF 0x6, ACCESS
192F6  500C     MOVF 0xC, W, ACCESS
192F8  6E07     MOVWF 0x7, ACCESS
192FA  6A08     CLRF 0x8, ACCESS
192FC  0EFB     MOVLW 0xFB
192FE  0061     MOVFFL ltemp1, PLUSW1
19300  F414     NOP
19302  F4E3     NOP
19304  0EFC     MOVLW 0xFC
19306  0061     MOVFFL 0x506, PLUSW1
19308  F418     NOP
1930A  F4E3     NOP
1930C  0EFD     MOVLW 0xFD
1930E  0061     MOVFFL ttemp2, PLUSW1
19310  F41C     NOP
19312  F4E3     NOP
19314  0EFE     MOVLW 0xFE
19316  0061     MOVFFL 0x508, PLUSW1
19318  F420     NOP
1931A  F4E3     NOP
550:           		txFifoObj[3] = (msgId & EID_HIGH_MASK);
1931C  0EF9     MOVLW 0xF9
1931E  0061     MOVFFL PLUSW1, wtemp5
19320  F38C     NOP
19322  F50B     NOP
19324  0EFA     MOVLW 0xFA
19326  0061     MOVFFL PLUSW1, 0x50C
19328  F38C     NOP
1932A  F50C     NOP
1932C  0E03     MOVLW 0x3
1932E  240B     ADDWF 0xB, W, ACCESS
19330  6ED9     MOVWF 0xFD9, ACCESS
19332  0E00     MOVLW 0x0
19334  200C     ADDWFC 0xC, W, ACCESS
19336  6EDA     MOVWF __end_of_UART2_tx_vect_isr, ACCESS
19338  0EFB     MOVLW 0xFB
1933A  50E3     MOVF 0xFE3, W, ACCESS
1933C  0B1F     ANDLW 0x1F
1933E  6EDF     MOVWF 0xFDF, ACCESS
551:           		msgId >>= EID_HIGH_WIDTH;
19340  0E05     MOVLW 0x5
19342  6E0C     MOVWF 0xC, ACCESS
19344  50E1     MOVF 0xFE1, W, ACCESS
19346  0FFB     ADDLW 0xFB
19348  6ED9     MOVWF 0xFD9, ACCESS
1934A  50E2     MOVF 0xFE2, W, ACCESS
1934C  6EDA     MOVWF __end_of_UART2_tx_vect_isr, ACCESS
1934E  0EFF     MOVLW 0xFF
19350  22DA     ADDWFC __end_of_UART2_tx_vect_isr, F, ACCESS
19352  280C     INCF 0xC, W, ACCESS
19354  52DE     MOVF 0xFDE, F, ACCESS
19356  D007     BRA 0x9366
19358  52DE     MOVF 0xFDE, F, ACCESS
1935A  52DE     MOVF 0xFDE, F, ACCESS
1935C  90D8     BCF 0xFD8, 0, ACCESS
1935E  32DD     RRCF 0xFDD, F, ACCESS
19360  32DD     RRCF 0xFDD, F, ACCESS
19362  32DD     RRCF 0xFDD, F, ACCESS
19364  32DE     RRCF 0xFDE, F, ACCESS
19366  2EE8     DECFSZ 0xFE8, F, ACCESS
19368  D7F7     BRA 0x9358
552:               }
1936A  D02F     BRA 0x93CA
553:               else
554:               {
555:           		txFifoObj[1] = txFifoObj[2] = txFifoObj[3] = 0;
1936C  0EF9     MOVLW 0xF9
1936E  0061     MOVFFL PLUSW1, wtemp5
19370  F38C     NOP
19372  F50B     NOP
19374  0EFA     MOVLW 0xFA
19376  0061     MOVFFL PLUSW1, 0x50C
19378  F38C     NOP
1937A  F50C     NOP
1937C  0E03     MOVLW 0x3
1937E  240B     ADDWF 0xB, W, ACCESS
19380  6ED9     MOVWF 0xFD9, ACCESS
19382  0E00     MOVLW 0x0
19384  200C     ADDWFC 0xC, W, ACCESS
19386  6EDA     MOVWF __end_of_UART2_tx_vect_isr, ACCESS
19388  6ADF     CLRF 0xFDF, ACCESS
1938A  0EF9     MOVLW 0xF9
1938C  0061     MOVFFL PLUSW1, wtemp5
1938E  F38C     NOP
19390  F50B     NOP
19392  0EFA     MOVLW 0xFA
19394  0061     MOVFFL PLUSW1, 0x50C
19396  F38C     NOP
19398  F50C     NOP
1939A  0E02     MOVLW 0x2
1939C  240B     ADDWF 0xB, W, ACCESS
1939E  6EE9     MOVWF 0xFE9, ACCESS
193A0  0E00     MOVLW 0x0
193A2  200C     ADDWFC 0xC, W, ACCESS
193A4  6EEA     MOVWF 0xFEA, ACCESS
193A6  C4DF     MOVFF INDF2, INDF0
193A8  F4EF     NOP
193AA  0EF9     MOVLW 0xF9
193AC  0061     MOVFFL PLUSW1, wtemp5
193AE  F38C     NOP
193B0  F50B     NOP
193B2  0EFA     MOVLW 0xFA
193B4  0061     MOVFFL PLUSW1, 0x50C
193B6  F38C     NOP
193B8  F50C     NOP
193BA  0E01     MOVLW 0x1
193BC  240B     ADDWF 0xB, W, ACCESS
193BE  6ED9     MOVWF 0xFD9, ACCESS
193C0  0E00     MOVLW 0x0
193C2  200C     ADDWFC 0xC, W, ACCESS
193C4  6EDA     MOVWF __end_of_UART2_tx_vect_isr, ACCESS
193C6  C4EF     MOVFF INDF0, INDF2
193C8  F4DF     NOP
556:           	}
557:           
558:           	txFifoObj[0] = msgId;
193CA  0EF9     MOVLW 0xF9
193CC  C4E3     MOVFF PLUSW1, FSR2
193CE  F4D9     NOP
193D0  0EFA     MOVLW 0xFA
193D2  C4E3     MOVFF PLUSW1, FSR2H
193D4  F4DA     NOP
193D6  0EFB     MOVLW 0xFB
193D8  C4E3     MOVFF PLUSW1, INDF2
193DA  F4DF     NOP
559:           	msgId >>= SID_LOW_WIDTH;
193DC  0EFC     MOVLW 0xFC
193DE  24E1     ADDWF 0xFE1, W, ACCESS
193E0  6ED9     MOVWF 0xFD9, ACCESS
193E2  0EFF     MOVLW 0xFF
193E4  20E2     ADDWFC 0xFE2, W, ACCESS
193E6  6EDA     MOVWF __end_of_UART2_tx_vect_isr, ACCESS
193E8  0061     MOVFFL POSTINC2, ttemp3
193EA  F378     NOP
193EC  F50A     NOP
193EE  0061     MOVFFL POSTINC2, wtemp5
193F0  F378     NOP
193F2  F50B     NOP
193F4  0061     MOVFFL POSTINC2, 0x50C
193F6  F378     NOP
193F8  F50C     NOP
193FA  500A     MOVF 0xA, W, ACCESS
193FC  6E05     MOVWF 0x5, ACCESS
193FE  500B     MOVF 0xB, W, ACCESS
19400  6E06     MOVWF 0x6, ACCESS
19402  500C     MOVF 0xC, W, ACCESS
19404  6E07     MOVWF 0x7, ACCESS
19406  6A08     CLRF 0x8, ACCESS
19408  0EFB     MOVLW 0xFB
1940A  0061     MOVFFL ltemp1, PLUSW1
1940C  F414     NOP
1940E  F4E3     NOP
19410  0EFC     MOVLW 0xFC
19412  0061     MOVFFL 0x506, PLUSW1
19414  F418     NOP
19416  F4E3     NOP
19418  0EFD     MOVLW 0xFD
1941A  0061     MOVFFL ttemp2, PLUSW1
1941C  F41C     NOP
1941E  F4E3     NOP
19420  0EFE     MOVLW 0xFE
19422  0061     MOVFFL 0x508, PLUSW1
19424  F420     NOP
19426  F4E3     NOP
560:           	txFifoObj[1] |= (msgId & SID_HIGH_MASK);
19428  0EFB     MOVLW 0xFB
1942A  0061     MOVFFL PLUSW1, 0x50C
1942C  F38C     NOP
1942E  F50C     NOP
19430  0E07     MOVLW 0x7
19432  160C     ANDWF 0xC, F, ACCESS
19434  0EF9     MOVLW 0xF9
19436  0061     MOVFFL PLUSW1, ltemp2
19438  F38C     NOP
1943A  F509     NOP
1943C  0EFA     MOVLW 0xFA
1943E  0061     MOVFFL PLUSW1, ttemp3
19440  F38C     NOP
19442  F50A     NOP
19444  0E01     MOVLW 0x1
19446  2409     ADDWF 0x9, W, ACCESS
19448  6ED9     MOVWF 0xFD9, ACCESS
1944A  0E00     MOVLW 0x0
1944C  200A     ADDWFC 0xA, W, ACCESS
1944E  6EDA     MOVWF __end_of_UART2_tx_vect_isr, ACCESS
19450  500C     MOVF 0xC, W, ACCESS
19452  12DF     IORWF 0xFDF, F, ACCESS
561:           
562:           	status = txCanMsg->field.dlc;
19454  0EF7     MOVLW 0xF7
19456  0061     MOVFFL PLUSW1, wtemp5
19458  F38C     NOP
1945A  F50B     NOP
1945C  0EF8     MOVLW 0xF8
1945E  0061     MOVFFL PLUSW1, 0x50C
19460  F38C     NOP
19462  F50C     NOP
19464  0E04     MOVLW 0x4
19466  240B     ADDWF 0xB, W, ACCESS
19468  6ED9     MOVWF 0xFD9, ACCESS
1946A  0E00     MOVLW 0x0
1946C  200C     ADDWFC 0xC, W, ACCESS
1946E  6EDA     MOVWF __end_of_UART2_tx_vect_isr, ACCESS
19470  30DF     RRCF 0xFDF, W, ACCESS
19472  32E8     RRCF 0xFE8, F, ACCESS
19474  0B0F     ANDLW 0xF
19476  6E0C     MOVWF 0xC, ACCESS
19478  0EFF     MOVLW 0xFF
1947A  0061     MOVFFL 0x50C, PLUSW1
1947C  F430     NOP
1947E  F4E3     NOP
563:           	status |= (txCanMsg->field.idType << IDE_POSN);
19480  0EF7     MOVLW 0xF7
19482  0061     MOVFFL PLUSW1, wtemp5
19484  F38C     NOP
19486  F50B     NOP
19488  0EF8     MOVLW 0xF8
1948A  0061     MOVFFL PLUSW1, 0x50C
1948C  F38C     NOP
1948E  F50C     NOP
19490  0E04     MOVLW 0x4
19492  240B     ADDWF 0xB, W, ACCESS
19494  6ED9     MOVWF 0xFD9, ACCESS
19496  0E00     MOVLW 0x0
19498  200C     ADDWFC 0xC, W, ACCESS
1949A  6EDA     MOVWF __end_of_UART2_tx_vect_isr, ACCESS
1949C  A0DF     BTFSS 0xFDF, 0, ACCESS
1949E  D003     BRA 0x94A6
194A0  0E10     MOVLW 0x10
194A2  6E0C     MOVWF 0xC, ACCESS
194A4  D001     BRA 0x94A8
194A6  6A0C     CLRF 0xC, ACCESS
194A8  50E1     MOVF 0xFE1, W, ACCESS
194AA  0FFF     ADDLW 0xFF
194AC  6ED9     MOVWF 0xFD9, ACCESS
194AE  50E2     MOVF 0xFE2, W, ACCESS
194B0  6EDA     MOVWF __end_of_UART2_tx_vect_isr, ACCESS
194B2  0EFF     MOVLW 0xFF
194B4  22DA     ADDWFC __end_of_UART2_tx_vect_isr, F, ACCESS
194B6  500C     MOVF 0xC, W, ACCESS
194B8  12DF     IORWF 0xFDF, F, ACCESS
564:           	status |= (txCanMsg->field.frameType << RTR_POSN);
194BA  0EF7     MOVLW 0xF7
194BC  0061     MOVFFL PLUSW1, wtemp5
194BE  F38C     NOP
194C0  F50B     NOP
194C2  0EF8     MOVLW 0xF8
194C4  0061     MOVFFL PLUSW1, 0x50C
194C6  F38C     NOP
194C8  F50C     NOP
194CA  0E04     MOVLW 0x4
194CC  240B     ADDWF 0xB, W, ACCESS
194CE  6ED9     MOVWF 0xFD9, ACCESS
194D0  0E00     MOVLW 0x0
194D2  200C     ADDWFC 0xC, W, ACCESS
194D4  6EDA     MOVWF __end_of_UART2_tx_vect_isr, ACCESS
194D6  A2DF     BTFSS 0xFDF, 1, ACCESS
194D8  D003     BRA 0x94E0
194DA  0E20     MOVLW 0x20
194DC  6E0C     MOVWF 0xC, ACCESS
194DE  D001     BRA 0x94E2
194E0  6A0C     CLRF 0xC, ACCESS
194E2  50E1     MOVF 0xFE1, W, ACCESS
194E4  0FFF     ADDLW 0xFF
194E6  6ED9     MOVWF 0xFD9, ACCESS
194E8  50E2     MOVF 0xFE2, W, ACCESS
194EA  6EDA     MOVWF __end_of_UART2_tx_vect_isr, ACCESS
194EC  0EFF     MOVLW 0xFF
194EE  22DA     ADDWFC __end_of_UART2_tx_vect_isr, F, ACCESS
194F0  500C     MOVF 0xC, W, ACCESS
194F2  12DF     IORWF 0xFDF, F, ACCESS
565:           	status |= (txCanMsg->field.brs << BRS_POSN);
194F4  0EF7     MOVLW 0xF7
194F6  0061     MOVFFL PLUSW1, wtemp5
194F8  F38C     NOP
194FA  F50B     NOP
194FC  0EF8     MOVLW 0xF8
194FE  0061     MOVFFL PLUSW1, 0x50C
19500  F38C     NOP
19502  F50C     NOP
19504  0E04     MOVLW 0x4
19506  240B     ADDWF 0xB, W, ACCESS
19508  6ED9     MOVWF 0xFD9, ACCESS
1950A  0E00     MOVLW 0x0
1950C  200C     ADDWFC 0xC, W, ACCESS
1950E  6EDA     MOVWF __end_of_UART2_tx_vect_isr, ACCESS
19510  AEDF     BTFSS 0xFDF, 7, ACCESS
19512  D003     BRA 0x951A
19514  0E40     MOVLW 0x40
19516  6E0C     MOVWF 0xC, ACCESS
19518  D001     BRA 0x951C
1951A  6A0C     CLRF 0xC, ACCESS
1951C  50E1     MOVF 0xFE1, W, ACCESS
1951E  0FFF     ADDLW 0xFF
19520  6ED9     MOVWF 0xFD9, ACCESS
19522  50E2     MOVF 0xFE2, W, ACCESS
19524  6EDA     MOVWF __end_of_UART2_tx_vect_isr, ACCESS
19526  0EFF     MOVLW 0xFF
19528  22DA     ADDWFC __end_of_UART2_tx_vect_isr, F, ACCESS
1952A  500C     MOVF 0xC, W, ACCESS
1952C  12DF     IORWF 0xFDF, F, ACCESS
566:           	status |= (txCanMsg->field.formatType << FDF_POSN);
1952E  0EF7     MOVLW 0xF7
19530  0061     MOVFFL PLUSW1, wtemp5
19532  F38C     NOP
19534  F50B     NOP
19536  0EF8     MOVLW 0xF8
19538  0061     MOVFFL PLUSW1, 0x50C
1953A  F38C     NOP
1953C  F50C     NOP
1953E  0E04     MOVLW 0x4
19540  240B     ADDWF 0xB, W, ACCESS
19542  6ED9     MOVWF 0xFD9, ACCESS
19544  0E00     MOVLW 0x0
19546  200C     ADDWFC 0xC, W, ACCESS
19548  6EDA     MOVWF __end_of_UART2_tx_vect_isr, ACCESS
1954A  ACDF     BTFSS 0xFDF, 6, ACCESS
1954C  D003     BRA 0x9554
1954E  0E80     MOVLW 0x80
19550  6E0C     MOVWF 0xC, ACCESS
19552  D001     BRA 0x9556
19554  6A0C     CLRF 0xC, ACCESS
19556  50E1     MOVF 0xFE1, W, ACCESS
19558  0FFF     ADDLW 0xFF
1955A  6ED9     MOVWF 0xFD9, ACCESS
1955C  50E2     MOVF 0xFE2, W, ACCESS
1955E  6EDA     MOVWF __end_of_UART2_tx_vect_isr, ACCESS
19560  0EFF     MOVLW 0xFF
19562  22DA     ADDWFC __end_of_UART2_tx_vect_isr, F, ACCESS
19564  500C     MOVF 0xC, W, ACCESS
19566  12DF     IORWF 0xFDF, F, ACCESS
567:           	txFifoObj[4] = status;
19568  0EF9     MOVLW 0xF9
1956A  0061     MOVFFL PLUSW1, wtemp5
1956C  F38C     NOP
1956E  F50B     NOP
19570  0EFA     MOVLW 0xFA
19572  0061     MOVFFL PLUSW1, 0x50C
19574  F38C     NOP
19576  F50C     NOP
19578  0E04     MOVLW 0x4
1957A  240B     ADDWF 0xB, W, ACCESS
1957C  6ED9     MOVWF 0xFD9, ACCESS
1957E  0E00     MOVLW 0x0
19580  200C     ADDWFC 0xC, W, ACCESS
19582  6EDA     MOVWF __end_of_UART2_tx_vect_isr, ACCESS
19584  0EFF     MOVLW 0xFF
19586  C4E3     MOVFF PLUSW1, INDF2
19588  F4DF     NOP
568:           
569:               if (CAN_FRAME_DATA == txCanMsg->field.frameType)
1958A  0EF7     MOVLW 0xF7
1958C  0061     MOVFFL PLUSW1, wtemp5
1958E  F38C     NOP
19590  F50B     NOP
19592  0EF8     MOVLW 0xF8
19594  0061     MOVFFL PLUSW1, 0x50C
19596  F38C     NOP
19598  F50C     NOP
1959A  0E04     MOVLW 0x4
1959C  240B     ADDWF 0xB, W, ACCESS
1959E  6ED9     MOVWF 0xFD9, ACCESS
195A0  0E00     MOVLW 0x0
195A2  200C     ADDWFC 0xC, W, ACCESS
195A4  6EDA     MOVWF __end_of_UART2_tx_vect_isr, ACCESS
195A6  B2DF     BTFSC 0xFDF, 1, ACCESS
195A8  D04D     BRA 0x9644
570:               {
571:           		memcpy(txFifoObj + payloadOffsetBytes, txCanMsg->data, DLCToPayloadBytes(txCanMsg->field.dlc));
195AA  0EF7     MOVLW 0xF7
195AC  0061     MOVFFL PLUSW1, wtemp5
195AE  F38C     NOP
195B0  F50B     NOP
195B2  0EF8     MOVLW 0xF8
195B4  0061     MOVFFL PLUSW1, 0x50C
195B6  F38C     NOP
195B8  F50C     NOP
195BA  0E04     MOVLW 0x4
195BC  240B     ADDWF 0xB, W, ACCESS
195BE  6ED9     MOVWF 0xFD9, ACCESS
195C0  0E00     MOVLW 0x0
195C2  200C     ADDWFC 0xC, W, ACCESS
195C4  6EDA     MOVWF __end_of_UART2_tx_vect_isr, ACCESS
195C6  30DF     RRCF 0xFDF, W, ACCESS
195C8  32E8     RRCF 0xFE8, F, ACCESS
195CA  0B0F     ANDLW 0xF
195CC  6E0B     MOVWF 0xB, ACCESS
195CE  6A0C     CLRF 0xC, ACCESS
195D0  0E41     MOVLW 0x41
195D2  240B     ADDWF 0xB, W, ACCESS
195D4  6EF6     MOVWF 0xFF6, ACCESS
195D6  0EFA     MOVLW 0xFA
195D8  200C     ADDWFC 0xC, W, ACCESS
195DA  6EF7     MOVWF 0xFF7, ACCESS
195DC  6AF8     CLRF 0xFF8, ACCESS
195DE  0E00     MOVLW 0x0
195E0  22F8     ADDWFC 0xFF8, F, ACCESS
195E2  0008     TBLRD*
195E4  50F5     MOVF 0xFF5, W, ACCESS
195E6  6EE6     MOVWF 0xFE6, ACCESS
195E8  0E00     MOVLW 0x0
195EA  6EE6     MOVWF 0xFE6, ACCESS
195EC  0EF5     MOVLW 0xF5
195EE  0061     MOVFFL PLUSW1, wtemp5
195F0  F38C     NOP
195F2  F50B     NOP
195F4  0EF6     MOVLW 0xF6
195F6  0061     MOVFFL PLUSW1, 0x50C
195F8  F38C     NOP
195FA  F50C     NOP
195FC  0E05     MOVLW 0x5
195FE  240B     ADDWF 0xB, W, ACCESS
19600  6ED9     MOVWF 0xFD9, ACCESS
19602  0E00     MOVLW 0x0
19604  200C     ADDWFC 0xC, W, ACCESS
19606  6EDA     MOVWF __end_of_UART2_tx_vect_isr, ACCESS
19608  0061     MOVFFL POSTINC2, wtemp5
1960A  F378     NOP
1960C  F50B     NOP
1960E  0061     MOVFFL POSTDEC2, 0x50C
19610  F374     NOP
19612  F50C     NOP
19614  0061     MOVFFL wtemp5, POSTINC1
19616  F42C     NOP
19618  F4E6     NOP
1961A  0061     MOVFFL 0x50C, POSTINC1
1961C  F430     NOP
1961E  F4E6     NOP
19620  0EF5     MOVLW 0xF5
19622  50E3     MOVF 0xFE3, W, ACCESS
19624  0F08     ADDLW 0x8
19626  6E0B     MOVWF 0xB, ACCESS
19628  0EF6     MOVLW 0xF6
1962A  0061     MOVFFL PLUSW1, 0x50C
1962C  F38C     NOP
1962E  F50C     NOP
19630  0E00     MOVLW 0x0
19632  220C     ADDWFC 0xC, F, ACCESS
19634  0061     MOVFFL wtemp5, POSTINC1
19636  F42C     NOP
19638  F4E6     NOP
1963A  0061     MOVFFL 0x50C, POSTINC1
1963C  F430     NOP
1963E  F4E6     NOP
19640  EC81     CALL 0x1E502, 0
19642  F0F2     NOP
572:           	}
573:           }
19644  0EF7     MOVLW 0xF7
19644  0EF7     MOVLW 0xF7
19644  0EF7     MOVLW 0xF7
19644  0EF7     MOVLW 0xF7
19644  0EF7     MOVLW 0xF7
574:           
575:           static CAN_TX_MSG_REQUEST_STATUS ValidateTransmission(uint8_t validChannel, CAN_MSG_OBJ *txCanMsg)
1D822  52E6     MOVF 0xFE6, F, ACCESS
1D824  52E6     MOVF 0xFE6, F, ACCESS
1D826  52E6     MOVF 0xFE6, F, ACCESS
576:           {
577:           	CAN_TX_MSG_REQUEST_STATUS txMsgStatus = CAN_TX_MSG_REQUEST_SUCCESS;
1D828  0EFE     MOVLW 0xFE
1D82A  6AE3     CLRF 0xFE3, ACCESS
578:           	CAN_MSG_FIELD field = txCanMsg->field;
1D82C  0EFA     MOVLW 0xFA
1D82E  0061     MOVFFL PLUSW1, wtemp5
1D830  F38C     NOP
1D832  F50B     NOP
1D834  0EFB     MOVLW 0xFB
1D836  0061     MOVFFL PLUSW1, 0x50C
1D838  F38C     NOP
1D83A  F50C     NOP
1D83C  0E04     MOVLW 0x4
1D83E  240B     ADDWF 0xB, W, ACCESS
1D840  6ED9     MOVWF 0xFD9, ACCESS
1D842  0E00     MOVLW 0x0
1D844  200C     ADDWFC 0xC, W, ACCESS
1D846  6EDA     MOVWF __end_of_UART2_tx_vect_isr, ACCESS
1D848  50DF     MOVF 0xFDF, W, ACCESS
1D84A  6E0C     MOVWF 0xC, ACCESS
1D84C  0EFD     MOVLW 0xFD
1D84E  0061     MOVFFL 0x50C, PLUSW1
1D850  F430     NOP
1D852  F4E3     NOP
579:           	uint8_t plsize = (FIFO[validChannel].CONT & _C1FIFOCON1T_PLSIZE_MASK) >> _C1FIFOCON1T_PLSIZE_POSN;
1D854  0EFC     MOVLW 0xFC
1D856  50E3     MOVF 0xFE3, W, ACCESS
1D858  0D0C     MULLW 0xC
1D85A  0E53     MOVLW 0x53
1D85C  24F3     ADDWF 0xFF3, W, ACCESS
1D85E  6ED9     MOVWF 0xFD9, ACCESS
1D860  0E01     MOVLW 0x1
1D862  20F4     ADDWFC 0xFF4, W, ACCESS
1D864  6EDA     MOVWF __end_of_UART2_tx_vect_isr, ACCESS
1D866  50DF     MOVF 0xFDF, W, ACCESS
1D868  6E0C     MOVWF 0xC, ACCESS
1D86A  0E05     MOVLW 0x5
1D86C  6E01     MOVWF __ptext283, ACCESS
1D86E  90D8     BCF 0xFD8, 0, ACCESS
1D870  320C     RRCF 0xC, F, ACCESS
1D872  2E01     DECFSZ __ptext283, F, ACCESS
1D874  D7FC     BRA 0xD86E
1D876  0E07     MOVLW 0x7
1D878  160C     ANDWF 0xC, F, ACCESS
1D87A  0EFF     MOVLW 0xFF
1D87C  0061     MOVFFL 0x50C, PLUSW1
1D87E  F430     NOP
1D880  F4E3     NOP
580:           
581:               if (CAN_BRS_MODE == field.brs && (1 == C1CONHbits.BRSDIS || CAN_NORMAL_2_0_MODE == CAN1_OperationModeGet()))
1D882  50E1     MOVF 0xFE1, W, ACCESS
1D884  0FFD     ADDLW 0xFD
1D886  6ED9     MOVWF 0xFD9, ACCESS
1D888  50E2     MOVF 0xFE2, W, ACCESS
1D88A  6EDA     MOVWF __end_of_UART2_tx_vect_isr, ACCESS
1D88C  0EFF     MOVLW 0xFF
1D88E  22DA     ADDWFC __end_of_UART2_tx_vect_isr, F, ACCESS
1D890  AEDF     BTFSS 0xFDF, 7, ACCESS
1D892  D00B     BRA 0xD8AA
1D894  0101     MOVLB 0x1
1D896  B901     BTFSC __ptext283, 4, BANKED
1D898  D006     BRA 0xD8A6
1D89A  EC70     CALL 0x26E0, 0
1D89C  F013     NOP
1D89E  0E06     MOVLW 0x6
1D8A0  1801     XORWF __ptext283, W, ACCESS
1D8A2  A4D8     BTFSS 0xFD8, 2, ACCESS
1D8A4  D002     BRA 0xD8AA
582:               {
583:           		txMsgStatus |= CAN_TX_MSG_REQUEST_BRS_ERROR;
1D8A6  0EFE     MOVLW 0xFE
1D8A8  82E3     BSF 0xFE3, 1, ACCESS
584:           	}
585:           
586:               if (field.dlc > DLC_8 && (CAN_2_0_FORMAT == field.formatType || CAN_NORMAL_2_0_MODE == CAN1_OperationModeGet()))
1D8AA  50E1     MOVF 0xFE1, W, ACCESS
1D8AC  0FFD     ADDLW 0xFD
1D8AE  6ED9     MOVWF 0xFD9, ACCESS
1D8B0  50E2     MOVF 0xFE2, W, ACCESS
1D8B2  6EDA     MOVWF __end_of_UART2_tx_vect_isr, ACCESS
1D8B4  0EFF     MOVLW 0xFF
1D8B6  22DA     ADDWFC __end_of_UART2_tx_vect_isr, F, ACCESS
1D8B8  30DF     RRCF 0xFDF, W, ACCESS
1D8BA  32E8     RRCF 0xFE8, F, ACCESS
1D8BC  0B0F     ANDLW 0xF
1D8BE  6E0C     MOVWF 0xC, ACCESS
1D8C0  0E08     MOVLW 0x8
1D8C2  640C     CPFSGT 0xC, ACCESS
1D8C4  D011     BRA 0xD8E8
1D8C6  50E1     MOVF 0xFE1, W, ACCESS
1D8C8  0FFD     ADDLW 0xFD
1D8CA  6ED9     MOVWF 0xFD9, ACCESS
1D8CC  50E2     MOVF 0xFE2, W, ACCESS
1D8CE  6EDA     MOVWF __end_of_UART2_tx_vect_isr, ACCESS
1D8D0  0EFF     MOVLW 0xFF
1D8D2  22DA     ADDWFC __end_of_UART2_tx_vect_isr, F, ACCESS
1D8D4  ACDF     BTFSS 0xFDF, 6, ACCESS
1D8D6  D006     BRA 0xD8E4
1D8D8  EC70     CALL 0x26E0, 0
1D8DA  F013     NOP
1D8DC  0E06     MOVLW 0x6
1D8DE  1801     XORWF __ptext283, W, ACCESS
1D8E0  A4D8     BTFSS 0xFD8, 2, ACCESS
1D8E2  D002     BRA 0xD8E8
587:               {
588:           		txMsgStatus |= CAN_TX_MSG_REQUEST_DLC_EXCEED_ERROR;
1D8E4  0EFE     MOVLW 0xFE
1D8E6  80E3     BSF 0xFE3, 0, ACCESS
589:           	}
590:           
591:               if (DLCToPayloadBytes(field.dlc) > PLSIZEToPayloadBytes(plsize))
1D8E8  0EFF     MOVLW 0xFF
1D8EA  50E3     MOVF 0xFE3, W, ACCESS
1D8EC  6E0B     MOVWF 0xB, ACCESS
1D8EE  6A0C     CLRF 0xC, ACCESS
1D8F0  0E08     MOVLW 0x8
1D8F2  260B     ADDWF 0xB, F, ACCESS
1D8F4  0E00     MOVLW 0x0
1D8F6  220C     ADDWFC 0xC, F, ACCESS
1D8F8  0E41     MOVLW 0x41
1D8FA  240B     ADDWF 0xB, W, ACCESS
1D8FC  6EF6     MOVWF 0xFF6, ACCESS
1D8FE  0EFA     MOVLW 0xFA
1D900  200C     ADDWFC 0xC, W, ACCESS
1D902  6EF7     MOVWF 0xFF7, ACCESS
1D904  6AF8     CLRF 0xFF8, ACCESS
1D906  0E00     MOVLW 0x0
1D908  22F8     ADDWFC 0xFF8, F, ACCESS
1D90A  0008     TBLRD*
1D90C  0061     MOVFFL TABLAT, 0x50C
1D90E  F3D4     NOP
1D910  F50C     NOP
1D912  50E1     MOVF 0xFE1, W, ACCESS
1D914  0FFD     ADDLW 0xFD
1D916  6ED9     MOVWF 0xFD9, ACCESS
1D918  50E2     MOVF 0xFE2, W, ACCESS
1D91A  6EDA     MOVWF __end_of_UART2_tx_vect_isr, ACCESS
1D91C  0EFF     MOVLW 0xFF
1D91E  22DA     ADDWFC __end_of_UART2_tx_vect_isr, F, ACCESS
1D920  30DF     RRCF 0xFDF, W, ACCESS
1D922  32E8     RRCF 0xFE8, F, ACCESS
1D924  0B0F     ANDLW 0xF
1D926  6E09     MOVWF 0x9, ACCESS
1D928  6A0A     CLRF 0xA, ACCESS
1D92A  0E41     MOVLW 0x41
1D92C  2409     ADDWF 0x9, W, ACCESS
1D92E  6EF6     MOVWF 0xFF6, ACCESS
1D930  0EFA     MOVLW 0xFA
1D932  200A     ADDWFC 0xA, W, ACCESS
1D934  6EF7     MOVWF 0xFF7, ACCESS
1D936  6AF8     CLRF 0xFF8, ACCESS
1D938  0E00     MOVLW 0x0
1D93A  22F8     ADDWFC 0xFF8, F, ACCESS
1D93C  0008     TBLRD*
1D93E  50F5     MOVF 0xFF5, W, ACCESS
1D940  5C0C     SUBWF 0xC, W, ACCESS
1D942  B0D8     BTFSC 0xFD8, 0, ACCESS
1D944  D002     BRA 0xD94A
592:               {
593:           		txMsgStatus |= CAN_TX_MSG_REQUEST_DLC_EXCEED_ERROR;
1D946  0EFE     MOVLW 0xFE
1D948  80E3     BSF 0xFE3, 0, ACCESS
594:           	}
595:           
596:               if (CAN_TX_FIFO_FULL == GetTxFifoStatus(validChannel))
1D94A  0EFC     MOVLW 0xFC
1D94C  50E3     MOVF 0xFE3, W, ACCESS
1D94E  6EE6     MOVWF 0xFE6, ACCESS
1D950  EC85     CALL 0x250A, 0
1D952  F012     NOP
1D954  5001     MOVF __ptext283, W, ACCESS
1D956  A4D8     BTFSS 0xFD8, 2, ACCESS
1D958  D003     BRA 0xD960
597:               {
598:           		txMsgStatus |= CAN_TX_MSG_REQUEST_FIFO_FULL;
1D95A  0EFE     MOVLW 0xFE
1D95C  80E3     BSF 0xFE3, 0, ACCESS
1D95E  82E3     BSF 0xFE3, 1, ACCESS
599:           	}
600:           
601:           	return txMsgStatus;
1D960  0EFE     MOVLW 0xFE
1D962  0061     MOVFFL PLUSW1, ltemp0
1D964  F38C     NOP
1D966  F501     NOP
602:           }
1D968  0EFA     MOVLW 0xFA
1D968  0EFA     MOVLW 0xFA
1D968  0EFA     MOVLW 0xFA
1D968  0EFA     MOVLW 0xFA
1D968  0EFA     MOVLW 0xFA
603:           
604:           CAN_TX_MSG_REQUEST_STATUS CAN1_Transmit(const CAN1_TX_FIFO_CHANNELS fifoChannel, CAN_MSG_OBJ *txCanMsg)
1FB66  52E6     MOVF 0xFE6, F, ACCESS
1FB68  52E6     MOVF 0xFE6, F, ACCESS
1FB6A  52E6     MOVF 0xFE6, F, ACCESS
605:           {
606:           	CAN_TX_MSG_REQUEST_STATUS status = CAN_TX_MSG_REQUEST_FIFO_FULL;
607:           
608:               if (isTxChannel(fifoChannel))
1FB6C  0EFC     MOVLW 0xFC
1FB6E  50E3     MOVF 0xFE3, W, ACCESS
1FB70  6EE6     MOVWF 0xFE6, ACCESS
1FB72  EC07     CALL 0x180E, 0
1FB74  F00C     NOP
1FB76  5001     MOVF __ptext283, W, ACCESS
1FB78  B4D8     BTFSC 0xFD8, 2, ACCESS
1FB7A  D049     BRA 0xFC0E
609:               {
610:           		status = ValidateTransmission(fifoChannel, txCanMsg);
1FB7C  0EFA     MOVLW 0xFA
1FB7E  C4E3     MOVFF PLUSW1, POSTINC1
1FB80  F4E6     NOP
1FB82  C4E3     MOVFF PLUSW1, POSTINC1
1FB84  F4E6     NOP
1FB86  0EFA     MOVLW 0xFA
1FB88  50E3     MOVF 0xFE3, W, ACCESS
1FB8A  6EE6     MOVWF 0xFE6, ACCESS
1FB8C  EC11     CALL 0x1D822, 0
1FB8E  F0EC     NOP
1FB90  0EFF     MOVLW 0xFF
1FB92  0061     MOVFFL ltemp0, PLUSW1
1FB94  F404     NOP
1FB96  F4E3     NOP
611:                   if (CAN_TX_MSG_REQUEST_SUCCESS == status)
1FB98  0EFF     MOVLW 0xFF
1FB9A  50E3     MOVF 0xFE3, W, ACCESS
1FB9C  A4D8     BTFSS 0xFD8, 2, ACCESS
1FB9E  D037     BRA 0xFC0E
612:                   {
613:           			uint8_t *txFifoObj = (uint8_t *) FIFO[fifoChannel].UA;
1FBA0  0EFC     MOVLW 0xFC
1FBA2  50E3     MOVF 0xFE3, W, ACCESS
1FBA4  0D0C     MULLW 0xC
1FBA6  0E58     MOVLW 0x58
1FBA8  24F3     ADDWF 0xFF3, W, ACCESS
1FBAA  6ED9     MOVWF 0xFD9, ACCESS
1FBAC  0E01     MOVLW 0x1
1FBAE  20F4     ADDWFC 0xFF4, W, ACCESS
1FBB0  6EDA     MOVWF __end_of_UART2_tx_vect_isr, ACCESS
1FBB2  0061     MOVFFL POSTINC2, wtemp5
1FBB4  F378     NOP
1FBB6  F50B     NOP
1FBB8  0061     MOVFFL POSTDEC2, 0x50C
1FBBA  F374     NOP
1FBBC  F50C     NOP
1FBBE  0EFE     MOVLW 0xFE
1FBC0  0061     MOVFFL 0x50C, PLUSW1
1FBC2  F430     NOP
1FBC4  F4E3     NOP
1FBC6  0EFD     MOVLW 0xFD
1FBC8  0061     MOVFFL wtemp5, PLUSW1
1FBCA  F42C     NOP
1FBCC  F4E3     NOP
614:           
615:                       if (txFifoObj != NULL)
1FBCE  0EFD     MOVLW 0xFD
1FBD0  0061     MOVFFL PLUSW1, ltemp0
1FBD2  F38C     NOP
1FBD4  F501     NOP
1FBD6  0EFE     MOVLW 0xFE
1FBD8  50E3     MOVF 0xFE3, W, ACCESS
1FBDA  1001     IORWF __ptext283, W, ACCESS
1FBDC  B4D8     BTFSC 0xFD8, 2, ACCESS
1FBDE  D017     BRA 0xFC0E
616:                       {
617:           				WriteMessageToFifo(txFifoObj, txCanMsg);
1FBE0  0EFA     MOVLW 0xFA
1FBE2  C4E3     MOVFF PLUSW1, POSTINC1
1FBE4  F4E6     NOP
1FBE6  C4E3     MOVFF PLUSW1, POSTINC1
1FBE8  F4E6     NOP
1FBEA  0EFB     MOVLW 0xFB
1FBEC  C4E3     MOVFF PLUSW1, POSTINC1
1FBEE  F4E6     NOP
1FBF0  C4E3     MOVFF PLUSW1, POSTINC1
1FBF2  F4E6     NOP
1FBF4  ECF2     CALL 0x191E4, 0
1FBF6  F0C8     NOP
618:           				FIFO[fifoChannel].CONH |= (_C1FIFOCON1H_TXREQ_MASK | _C1FIFOCON1H_UINC_MASK);
1FBF8  0EFC     MOVLW 0xFC
1FBFA  50E3     MOVF 0xFE3, W, ACCESS
1FBFC  0D0C     MULLW 0xC
1FBFE  0E51     MOVLW 0x51
1FC00  24F3     ADDWF 0xFF3, W, ACCESS
1FC02  6ED9     MOVWF 0xFD9, ACCESS
1FC04  0E01     MOVLW 0x1
1FC06  20F4     ADDWFC 0xFF4, W, ACCESS
1FC08  6EDA     MOVWF __end_of_UART2_tx_vect_isr, ACCESS
1FC0A  0E03     MOVLW 0x3
1FC0C  12DF     IORWF 0xFDF, F, ACCESS
619:           			}
620:           		}
621:           	}
622:           
623:           	return status;
624:           }
1FC0E  0EFA     MOVLW 0xFA
1FC10  26E1     ADDWF 0xFE1, F, ACCESS
1FC12  0EFF     MOVLW 0xFF
1FC14  22E2     ADDWFC 0xFE2, F, ACCESS
1FC14  22E2     ADDWFC 0xFE2, F, ACCESS
625:           
626:           CAN_TX_FIFO_STATUS CAN1_TransmitFIFOStatusGet(const CAN1_TX_FIFO_CHANNELS fifoChannel)
1BEC  52E6     MOVF 0xFE6, F, ACCESS
627:           {
628:           	CAN_TX_FIFO_STATUS status = CAN_TX_FIFO_FULL;
1BEE  0EFF     MOVLW 0xFF
1BF0  6AE3     CLRF 0xFE3, ACCESS
629:           
630:               if (isTxChannel(fifoChannel)) 
1BF2  0EFE     MOVLW 0xFE
1BF4  50E3     MOVF 0xFE3, W, ACCESS
1BF6  6EE6     MOVWF 0xFE6, ACCESS
1BF8  EC07     CALL 0x180E, 0
1BFA  F00C     NOP
1BFC  5001     MOVF __ptext283, W, ACCESS
1BFE  B4D8     BTFSC 0xFD8, 2, ACCESS
1C00  D009     BRA 0x1C14
631:               {
632:           		status = GetTxFifoStatus(fifoChannel);
1C02  0EFE     MOVLW 0xFE
1C04  50E3     MOVF 0xFE3, W, ACCESS
1C06  6EE6     MOVWF 0xFE6, ACCESS
1C08  EC85     CALL 0x250A, 0
1C0A  F012     NOP
1C0C  0EFF     MOVLW 0xFF
1C0E  0061     MOVFFL ltemp0, PLUSW1
1C10  F404     NOP
1C12  F4E3     NOP
633:           	}
634:           
635:           	return status;
1C14  0EFF     MOVLW 0xFF
1C16  0061     MOVFFL PLUSW1, ltemp0
1C18  F38C     NOP
1C1A  F501     NOP
636:           }
1C1C  52E5     MOVF 0xFE5, F, ACCESS
1C1C  52E5     MOVF 0xFE5, F, ACCESS
1C1C  52E5     MOVF 0xFE5, F, ACCESS
637:           
638:           bool CAN1_IsBusOff(void)
639:           {
640:           	return C1TRECUbits.TXBO;
641:           }
642:           
643:           bool CAN1_IsRxErrorPassive(void)
644:           {
645:           	return C1TRECUbits.RXBP;
646:           }
647:           
648:           bool CAN1_IsRxErrorWarning(void)
649:           {
650:           	return C1TRECUbits.RXWARN;
651:           }
652:           
653:           bool CAN1_IsRxErrorActive(void)
654:           {
655:           	return !CAN1_IsRxErrorPassive();
656:           }
657:           
658:           bool CAN1_IsTxErrorPassive(void)
659:           {
660:           	return C1TRECUbits.TXBP;
661:           }
662:           
663:           bool CAN1_IsTxErrorWarning(void)
664:           {
665:           	return C1TRECUbits.TXWARN;
666:           }
667:           
668:           bool CAN1_IsTxErrorActive(void)
669:           {
670:           	return !CAN1_IsTxErrorPassive();
671:           }
672:           
673:           void CAN1_Sleep(void)
674:           {
675:           	C1INTHbits.WAKIF = 0;
676:           	C1INTTbits.WAKIE = 1;
677:           
678:           	CAN1_OperationModeSet(CAN_DISABLE_MODE);
679:           }
680:           
681:           void CAN1_SetInvalidMessageInterruptHandler(void (*handler)(void))
682:           {
683:               CAN1_InvalidMessageHandler = handler;
2380  50E1     MOVF 0xFE1, W, ACCESS
2382  0FFD     ADDLW 0xFD
2384  6ED9     MOVWF 0xFD9, ACCESS
2386  50E2     MOVF 0xFE2, W, ACCESS
2388  6EDA     MOVWF __end_of_UART2_tx_vect_isr, ACCESS
238A  0EFF     MOVLW 0xFF
238C  22DA     ADDWFC __end_of_UART2_tx_vect_isr, F, ACCESS
238E  C4DE     MOVFF POSTINC2, CAN1_InvalidMessageHandler
2390  F64F     NOP
2392  C4DE     MOVFF POSTINC2, 0x650
2394  F650     NOP
2396  C4DD     MOVFF POSTDEC2, 0x651
2398  F651     NOP
684:           }
239A  52E5     MOVF 0xFE5, F, ACCESS
239A  52E5     MOVF 0xFE5, F, ACCESS
239A  52E5     MOVF 0xFE5, F, ACCESS
239A  52E5     MOVF 0xFE5, F, ACCESS
685:           
686:           void CAN1_SetBusWakeUpActivityInterruptHandler(void (*handler)(void))
687:           {
688:               CAN1_BusWakeUpActivityHandler = handler;
23A2  50E1     MOVF 0xFE1, W, ACCESS
23A4  0FFD     ADDLW 0xFD
23A6  6ED9     MOVWF 0xFD9, ACCESS
23A8  50E2     MOVF 0xFE2, W, ACCESS
23AA  6EDA     MOVWF __end_of_UART2_tx_vect_isr, ACCESS
23AC  0EFF     MOVLW 0xFF
23AE  22DA     ADDWFC __end_of_UART2_tx_vect_isr, F, ACCESS
23B0  C4DE     MOVFF POSTINC2, CAN1_BusWakeUpActivityHandler
23B2  F64C     NOP
23B4  C4DE     MOVFF POSTINC2, 0x64D
23B6  F64D     NOP
23B8  C4DD     MOVFF POSTDEC2, 0x64E
23BA  F64E     NOP
689:           }
23BC  52E5     MOVF 0xFE5, F, ACCESS
23BC  52E5     MOVF 0xFE5, F, ACCESS
23BC  52E5     MOVF 0xFE5, F, ACCESS
23BC  52E5     MOVF 0xFE5, F, ACCESS
690:           
691:           void CAN1_SetBusErrorInterruptHandler(void (*handler)(void))
692:           {
693:               CAN1_BusErrorHandler = handler;
23C4  50E1     MOVF 0xFE1, W, ACCESS
23C6  0FFD     ADDLW 0xFD
23C8  6ED9     MOVWF 0xFD9, ACCESS
23CA  50E2     MOVF 0xFE2, W, ACCESS
23CC  6EDA     MOVWF __end_of_UART2_tx_vect_isr, ACCESS
23CE  0EFF     MOVLW 0xFF
23D0  22DA     ADDWFC __end_of_UART2_tx_vect_isr, F, ACCESS
23D2  C4DE     MOVFF POSTINC2, CAN1_BusErrorHandler
23D4  F649     NOP
23D6  C4DE     MOVFF POSTINC2, 0x64A
23D8  F64A     NOP
23DA  C4DD     MOVFF POSTDEC2, 0x64B
23DC  F64B     NOP
694:           }
23DE  52E5     MOVF 0xFE5, F, ACCESS
23DE  52E5     MOVF 0xFE5, F, ACCESS
23DE  52E5     MOVF 0xFE5, F, ACCESS
23DE  52E5     MOVF 0xFE5, F, ACCESS
695:           
696:           void CAN1_SetModeChangeInterruptHandler(void (*handler)(void))
697:           {
698:               CAN1_ModeChangeHandler = handler;
235E  50E1     MOVF 0xFE1, W, ACCESS
2360  0FFD     ADDLW 0xFD
2362  6ED9     MOVWF 0xFD9, ACCESS
2364  50E2     MOVF 0xFE2, W, ACCESS
2366  6EDA     MOVWF __end_of_UART2_tx_vect_isr, ACCESS
2368  0EFF     MOVLW 0xFF
236A  22DA     ADDWFC __end_of_UART2_tx_vect_isr, F, ACCESS
236C  C4DE     MOVFF POSTINC2, CAN1_ModeChangeHandler
236E  F646     NOP
2370  C4DE     MOVFF POSTINC2, 0x647
2372  F647     NOP
2374  C4DD     MOVFF POSTDEC2, 0x648
2376  F648     NOP
699:           }
2378  52E5     MOVF 0xFE5, F, ACCESS
2378  52E5     MOVF 0xFE5, F, ACCESS
2378  52E5     MOVF 0xFE5, F, ACCESS
2378  52E5     MOVF 0xFE5, F, ACCESS
700:           
701:           void CAN1_SetSystemErrorInterruptHandler(void (*handler)(void))
702:           {
703:               CAN1_SystemErrorHandler = handler;
231A  50E1     MOVF 0xFE1, W, ACCESS
231C  0FFD     ADDLW 0xFD
231E  6ED9     MOVWF 0xFD9, ACCESS
2320  50E2     MOVF 0xFE2, W, ACCESS
2322  6EDA     MOVWF __end_of_UART2_tx_vect_isr, ACCESS
2324  0EFF     MOVLW 0xFF
2326  22DA     ADDWFC __end_of_UART2_tx_vect_isr, F, ACCESS
2328  C4DE     MOVFF POSTINC2, CAN1_SystemErrorHandler
232A  F643     NOP
232C  C4DE     MOVFF POSTINC2, 0x644
232E  F644     NOP
2330  C4DD     MOVFF POSTDEC2, 0x645
2332  F645     NOP
704:           }
2334  52E5     MOVF 0xFE5, F, ACCESS
2334  52E5     MOVF 0xFE5, F, ACCESS
2334  52E5     MOVF 0xFE5, F, ACCESS
2334  52E5     MOVF 0xFE5, F, ACCESS
705:           
706:           void CAN1_SetTxAttemptInterruptHandler(void (*handler)(void))
707:           {
708:               CAN1_TxAttemptHandler = handler;
22F8  50E1     MOVF 0xFE1, W, ACCESS
22FA  0FFD     ADDLW 0xFD
22FC  6ED9     MOVWF 0xFD9, ACCESS
22FE  50E2     MOVF 0xFE2, W, ACCESS
2300  6EDA     MOVWF __end_of_UART2_tx_vect_isr, ACCESS
2302  0EFF     MOVLW 0xFF
2304  22DA     ADDWFC __end_of_UART2_tx_vect_isr, F, ACCESS
2306  C4DE     MOVFF POSTINC2, CAN1_TxAttemptHandler
2308  F640     NOP
230A  C4DE     MOVFF POSTINC2, 0x641
230C  F641     NOP
230E  C4DD     MOVFF POSTDEC2, 0x642
2310  F642     NOP
709:           }
2312  52E5     MOVF 0xFE5, F, ACCESS
2312  52E5     MOVF 0xFE5, F, ACCESS
2312  52E5     MOVF 0xFE5, F, ACCESS
2312  52E5     MOVF 0xFE5, F, ACCESS
710:           
711:           void CAN1_SetRxBufferOverFlowInterruptHandler(void (*handler)(void))
712:           {
713:               CAN1_RxBufferOverflowHandler = handler;
233C  50E1     MOVF 0xFE1, W, ACCESS
233E  0FFD     ADDLW 0xFD
2340  6ED9     MOVWF 0xFD9, ACCESS
2342  50E2     MOVF 0xFE2, W, ACCESS
2344  6EDA     MOVWF __end_of_UART2_tx_vect_isr, ACCESS
2346  0EFF     MOVLW 0xFF
2348  22DA     ADDWFC __end_of_UART2_tx_vect_isr, F, ACCESS
234A  C4DE     MOVFF POSTINC2, CAN1_RxBufferOverflowHandler
234C  F63D     NOP
234E  C4DE     MOVFF POSTINC2, 0x63E
2350  F63E     NOP
2352  C4DD     MOVFF POSTDEC2, 0x63F
2354  F63F     NOP
714:           }
2356  52E5     MOVF 0xFE5, F, ACCESS
2356  52E5     MOVF 0xFE5, F, ACCESS
2356  52E5     MOVF 0xFE5, F, ACCESS
2356  52E5     MOVF 0xFE5, F, ACCESS
715:           
716:           void __interrupt(irq(CAN),base(8)) CAN1_ISR(void)
1CBA0  C4FA     MOVFF PCLATH, __pcstackCOMRAM
1CBA2  F539     NOP
1CBA4  C4FB     MOVFF PCLATU, 0x53A
1CBA6  F53A     NOP
1CBA8  C4F6     MOVFF TBLPTR, 0x53B
1CBAA  F53B     NOP
1CBAC  C4F7     MOVFF TBLPTRH, 0x53C
1CBAE  F53C     NOP
1CBB0  C4F8     MOVFF TBLPTRU, 0x53D
1CBB2  F53D     NOP
1CBB4  C4F5     MOVFF TABLAT, 0x53E
1CBB6  F53E     NOP
1CBB8  0061     MOVFFL ltemp0, 0x53F
1CBBA  F404     NOP
1CBBC  F53F     NOP
1CBBE  0061     MOVFFL ttemp5, 0x540
1CBC0  F408     NOP
1CBC2  F540     NOP
1CBC4  0061     MOVFFL wtemp1, 0x541
1CBC6  F40C     NOP
1CBC8  F541     NOP
1CBCA  0061     MOVFFL ttemp1, 0x542
1CBCC  F410     NOP
1CBCE  F542     NOP
1CBD0  0061     MOVFFL ltemp1, 0x543
1CBD2  F414     NOP
1CBD4  F543     NOP
1CBD6  0061     MOVFFL 0x506, 0x544
1CBD8  F418     NOP
1CBDA  F544     NOP
1CBDC  0061     MOVFFL ttemp2, 0x545
1CBDE  F41C     NOP
1CBE0  F545     NOP
1CBE2  0061     MOVFFL 0x508, _UART2_Initialize
1CBE4  F420     NOP
1CBE6  F546     NOP
1CBE8  0061     MOVFFL ltemp2, 0x547
1CBEA  F424     NOP
1CBEC  F547     NOP
1CBEE  0061     MOVFFL ttemp3, 0x548
1CBF0  F428     NOP
1CBF2  F548     NOP
1CBF4  0061     MOVFFL wtemp5, 0x549
1CBF6  F42C     NOP
1CBF8  F549     NOP
1CBFA  0061     MOVFFL 0x50C, 0x54A
1CBFC  F430     NOP
1CBFE  F54A     NOP
1CC00  EE17     LFSR 1, 0x1FAA
1CC02  F3AA     NOP
1CC04  0101     MOVLB 0x1
1CC06  AF1D     BTFSS 0x1D, 7, BANKED
1CC08  D00F     BRA 0xCC28
717:           {
718:               if (1 == C1INTHbits.IVMIF)
1CC04  0101     MOVLB 0x1
1CC06  AF1D     BTFSS 0x1D, 7, BANKED
1CC08  D00F     BRA 0xCC28
1CC0A  D801     RCALL 0xCC0E
1CC0C  D00B     BRA 0xCC24
719:               {
720:                   CAN1_InvalidMessageHandler();
1CC0A  D801     RCALL 0xCC0E
1CC0C  D00B     BRA 0xCC24
1CC0E  0005     PUSH
1CC10  6EFA     MOVWF 0xFFA, ACCESS
1CC12  0106     MOVLB 0x6
1CC14  514F     MOVF 0x4F, W, BANKED
1CC16  6EFD     MOVWF 0xFFD, ACCESS
1CC18  5150     MOVF 0x50, W, BANKED
1CC1A  6EFE     MOVWF 0xFFE, ACCESS
1CC1C  5151     MOVF 0x51, W, BANKED
1CC1E  6EFF     MOVWF 0xFFF, ACCESS
1CC20  50FA     MOVF 0xFFA, W, ACCESS
1CC22  0012     RETURN 0
1CC24  0101     MOVLB 0x1
1CC26  9F1D     BCF 0x1D, 7, BANKED
721:                   C1INTHbits.IVMIF = 0;
1CC24  0101     MOVLB 0x1
1CC26  9F1D     BCF 0x1D, 7, BANKED
722:               }
723:               
724:               if (1 == C1INTHbits.WAKIF)
1CC28  AD1D     BTFSS 0x1D, 6, BANKED
1CC2A  D00F     BRA 0xCC4A
1CC2C  D801     RCALL 0xCC30
1CC2E  D00B     BRA 0xCC46
725:               {
726:                   CAN1_BusWakeUpActivityHandler();
1CC2C  D801     RCALL 0xCC30
1CC2E  D00B     BRA 0xCC46
1CC30  0005     PUSH
1CC32  6EFA     MOVWF 0xFFA, ACCESS
1CC34  0106     MOVLB 0x6
1CC36  514C     MOVF ZCDCON, W, BANKED
1CC38  6EFD     MOVWF 0xFFD, ACCESS
1CC3A  514D     MOVF 0x4D, W, BANKED
1CC3C  6EFE     MOVWF 0xFFE, ACCESS
1CC3E  514E     MOVF 0x4E, W, BANKED
1CC40  6EFF     MOVWF 0xFFF, ACCESS
1CC42  50FA     MOVF 0xFFA, W, ACCESS
1CC44  0012     RETURN 0
1CC46  0101     MOVLB 0x1
1CC48  9D1D     BCF 0x1D, 6, BANKED
1CC4A  AB1D     BTFSS 0x1D, 5, BANKED
1CC4C  D00F     BRA 0xCC6C
727:                   C1INTHbits.WAKIF = 0;
1CC46  0101     MOVLB 0x1
1CC48  9D1D     BCF 0x1D, 6, BANKED
728:               }
729:               
730:               if (1 == C1INTHbits.CERRIF)
1CC4A  AB1D     BTFSS 0x1D, 5, BANKED
1CC4C  D00F     BRA 0xCC6C
1CC4E  D801     RCALL 0xCC52
1CC50  D00B     BRA 0xCC68
1CC52  0005     PUSH
731:               {
732:                   CAN1_BusErrorHandler();
1CC4E  D801     RCALL 0xCC52
1CC50  D00B     BRA 0xCC68
1CC52  0005     PUSH
1CC54  6EFA     MOVWF 0xFFA, ACCESS
1CC56  0106     MOVLB 0x6
1CC58  5149     MOVF BORCON, W, BANKED
1CC5A  6EFD     MOVWF 0xFFD, ACCESS
1CC5C  514A     MOVF HLVDCON0, W, BANKED
1CC5E  6EFE     MOVWF 0xFFE, ACCESS
1CC60  514B     MOVF HLVDCON1, W, BANKED
1CC62  6EFF     MOVWF 0xFFF, ACCESS
1CC64  50FA     MOVF 0xFFA, W, ACCESS
1CC66  0012     RETURN 0
1CC68  0101     MOVLB 0x1
1CC6A  9B1D     BCF 0x1D, 5, BANKED
733:                   C1INTHbits.CERRIF = 0;
1CC68  0101     MOVLB 0x1
1CC6A  9B1D     BCF 0x1D, 5, BANKED
734:               }
735:               
736:               if (1 == C1INTLbits.MODIF)
1CC6C  A71C     BTFSS 0x1C, 3, BANKED
1CC6E  D00F     BRA 0xCC8E
1CC70  D801     RCALL 0xCC74
1CC72  D00B     BRA 0xCC8A
737:               {
738:                   CAN1_ModeChangeHandler();
1CC70  D801     RCALL 0xCC74
1CC72  D00B     BRA 0xCC8A
1CC74  0005     PUSH
1CC76  6EFA     MOVWF 0xFFA, ACCESS
1CC78  0106     MOVLB 0x6
1CC7A  5146     MOVF NVMDAT, W, BANKED
1CC7C  6EFD     MOVWF 0xFFD, ACCESS
1CC7E  5147     MOVF NVMDATH, W, BANKED
1CC80  6EFE     MOVWF 0xFFE, ACCESS
1CC82  5148     MOVF VREGCON, W, BANKED
1CC84  6EFF     MOVWF 0xFFF, ACCESS
1CC86  50FA     MOVF 0xFFA, W, ACCESS
1CC88  0012     RETURN 0
1CC8A  0101     MOVLB 0x1
1CC8C  971C     BCF 0x1C, 3, BANKED
739:                   C1INTLbits.MODIF = 0;
1CC8A  0101     MOVLB 0x1
1CC8C  971C     BCF 0x1C, 3, BANKED
1CC8E  A91D     BTFSS 0x1D, 4, BANKED
1CC90  D00F     BRA 0xCCB0
1CC92  D801     RCALL 0xCC96
740:               }
741:               
742:               if (1 == C1INTHbits.SERRIF)
1CC8E  A91D     BTFSS 0x1D, 4, BANKED
1CC90  D00F     BRA 0xCCB0
743:               {
744:                   CAN1_SystemErrorHandler();
1CC92  D801     RCALL 0xCC96
1CC94  D00B     BRA 0xCCAC
1CC96  0005     PUSH
1CC98  6EFA     MOVWF 0xFFA, ACCESS
1CC9A  0106     MOVLB 0x6
1CC9C  5143     MOVF NVMADR, W, BANKED
1CC9E  6EFD     MOVWF 0xFFD, ACCESS
1CCA0  5144     MOVF NVMADRH, W, BANKED
1CCA2  6EFE     MOVWF 0xFFE, ACCESS
1CCA4  5145     MOVF NVMADRU, W, BANKED
1CCA6  6EFF     MOVWF 0xFFF, ACCESS
1CCA8  50FA     MOVF 0xFFA, W, ACCESS
1CCAA  0012     RETURN 0
1CCAC  0101     MOVLB 0x1
1CCAE  991D     BCF 0x1D, 4, BANKED
1CCB0  A51D     BTFSS 0x1D, 2, BANKED
1CCB2  D014     BRA 0xCCDC
1CCB4  D801     RCALL 0xCCB8
1CCB6  D00B     BRA 0xCCCE
745:                   C1INTHbits.SERRIF = 0;
1CCAC  0101     MOVLB 0x1
1CCAE  991D     BCF 0x1D, 4, BANKED
746:               }
747:               
748:               if (1 == C1INTHbits.TXATIF)
1CCB0  A51D     BTFSS 0x1D, 2, BANKED
1CCB2  D014     BRA 0xCCDC
749:               {
750:                   CAN1_TxAttemptHandler();
1CCB4  D801     RCALL 0xCCB8
1CCB6  D00B     BRA 0xCCCE
1CCB8  0005     PUSH
1CCBA  6EFA     MOVWF 0xFFA, ACCESS
1CCBC  0106     MOVLB 0x6
1CCBE  5140     MOVF NVMCON0, W, BANKED
1CCC0  6EFD     MOVWF 0xFFD, ACCESS
1CCC2  5141     MOVF NVMCON1, W, BANKED
1CCC4  6EFE     MOVWF 0xFFE, ACCESS
1CCC6  5142     MOVF NVMLOCK, W, BANKED
1CCC8  6EFF     MOVWF 0xFFF, ACCESS
1CCCA  50FA     MOVF 0xFFA, W, ACCESS
1CCCC  0012     RETURN 0
751:                   if (1 == C1TXQSTALbits.TXATIF)
1CCCE  0101     MOVLB 0x1
1CCD0  B954     BTFSC 0x54, 4, BANKED
752:                   {
753:                       C1TXQSTALbits.TXATIF = 0;
1CCD2  9954     BCF 0x54, 4, BANKED
1CCD4  B96C     BTFSC MD1SRC, 4, BANKED
1CCD6  996C     BCF MD1SRC, 4, BANKED
754:                   }
755:                   if (1 == C1FIFOSTA2Lbits.TXATIF)
1CCD4  B96C     BTFSC MD1SRC, 4, BANKED
756:                   {
757:                       C1FIFOSTA2Lbits.TXATIF = 0;
1CCD6  996C     BCF MD1SRC, 4, BANKED
1CCD8  B978     BTFSC WDTCON0, 4, BANKED
1CCDA  9978     BCF WDTCON0, 4, BANKED
1CCDC  A71D     BTFSS 0x1D, 3, BANKED
1CCDE  D010     BRA 0xCD00
1CCE0  D801     RCALL 0xCCE4
1CCE2  D00B     BRA 0xCCFA
1CCE4  0005     PUSH
758:                   }
759:                   if (1 == C1FIFOSTA3Lbits.TXATIF)
1CCD8  B978     BTFSC WDTCON0, 4, BANKED
760:                   {
761:                       C1FIFOSTA3Lbits.TXATIF = 0;
1CCDA  9978     BCF WDTCON0, 4, BANKED
762:                   }
763:               }
764:               
765:               if (1 == C1INTHbits.RXOVIF)
1CCDC  A71D     BTFSS 0x1D, 3, BANKED
1CCDE  D010     BRA 0xCD00
766:               {
767:                   CAN1_RxBufferOverflowHandler();
1CCE0  D801     RCALL 0xCCE4
1CCE2  D00B     BRA 0xCCFA
1CCE4  0005     PUSH
1CCE6  6EFA     MOVWF 0xFFA, ACCESS
1CCE8  0106     MOVLB 0x6
1CCEA  513D     MOVF 0x3D, W, BANKED
1CCEC  6EFD     MOVWF 0xFFD, ACCESS
1CCEE  513E     MOVF 0x3E, W, BANKED
1CCF0  6EFE     MOVWF 0xFFE, ACCESS
1CCF2  513F     MOVF 0x3F, W, BANKED
1CCF4  6EFF     MOVWF 0xFFF, ACCESS
1CCF6  50FA     MOVF 0xFFA, W, ACCESS
1CCF8  0012     RETURN 0
768:                   if (1 == C1FIFOSTA1Lbits.RXOVIF)
1CCFA  0101     MOVLB 0x1
1CCFC  B760     BTFSC PMD0, 3, BANKED
769:                   {
770:                       C1FIFOSTA1Lbits.RXOVIF = 0;
1CCFE  9760     BCF PMD0, 3, BANKED
771:                   }
772:               }
773:               
774:               PIR0bits.CANIF = 0;
1CD00  9CAE     BCF 0xFAE, 6, ACCESS
1CD02  0061     MOVFFL 0x54A, 0x50C
1CD04  F528     NOP
1CD06  F50C     NOP
1CD08  0061     MOVFFL 0x549, wtemp5
1CD0A  F524     NOP
1CD0C  F50B     NOP
1CD0E  0061     MOVFFL 0x548, ttemp3
1CD10  F520     NOP
1CD12  F50A     NOP
1CD14  0061     MOVFFL 0x547, ltemp2
1CD16  F51C     NOP
1CD18  F509     NOP
1CD1A  0061     MOVFFL _UART2_Initialize, 0x508
1CD1C  F518     NOP
1CD1E  F508     NOP
1CD20  0061     MOVFFL 0x545, ttemp2
1CD22  F514     NOP
1CD24  F507     NOP
1CD26  0061     MOVFFL 0x544, 0x506
1CD28  F510     NOP
1CD2A  F506     NOP
1CD2C  0061     MOVFFL 0x543, ltemp1
1CD2E  F50C     NOP
1CD30  F505     NOP
1CD32  0061     MOVFFL 0x542, ttemp1
1CD34  F508     NOP
1CD36  F504     NOP
1CD38  0061     MOVFFL 0x541, wtemp1
1CD3A  F504     NOP
1CD3C  F503     NOP
1CD3E  0061     MOVFFL 0x540, ttemp5
1CD40  F500     NOP
1CD42  F502     NOP
1CD44  0061     MOVFFL 0x53F, ltemp0
1CD46  F4FC     NOP
1CD48  F501     NOP
1CD4A  C53E     MOVFF 0x53E, TABLAT
1CD4C  F4F5     NOP
1CD4E  C53D     MOVFF 0x53D, TBLPTRU
1CD50  F4F8     NOP
1CD52  C53C     MOVFF 0x53C, TBLPTRH
1CD54  F4F7     NOP
1CD56  C53B     MOVFF 0x53B, TBLPTR
1CD58  F4F6     NOP
1CD5A  C53A     MOVFF 0x53A, PCLATU
1CD5C  F4FB     NOP
1CD5E  C539     MOVFF __pcstackCOMRAM, PCLATH
1CD60  F4FA     NOP
775:           }
1CD02  0061     MOVFFL 0x54A, 0x50C
1CD02  0061     MOVFFL 0x54A, 0x50C
1CD02  0061     MOVFFL 0x54A, 0x50C
1CD02  0061     MOVFFL 0x54A, 0x50C
1CD02  0061     MOVFFL 0x54A, 0x50C
1CD02  0061     MOVFFL 0x54A, 0x50C
1CD02  0061     MOVFFL 0x54A, 0x50C
1CD02  0061     MOVFFL 0x54A, 0x50C
1CD02  0061     MOVFFL 0x54A, 0x50C
1CD02  0061     MOVFFL 0x54A, 0x50C
1CD02  0061     MOVFFL 0x54A, 0x50C
1CD02  0061     MOVFFL 0x54A, 0x50C
1CD02  0061     MOVFFL 0x54A, 0x50C
1CD02  0061     MOVFFL 0x54A, 0x50C
1CD02  0061     MOVFFL 0x54A, 0x50C
1CD02  0061     MOVFFL 0x54A, 0x50C
1CD02  0061     MOVFFL 0x54A, 0x50C
1CD02  0061     MOVFFL 0x54A, 0x50C
1CD02  0061     MOVFFL 0x54A, 0x50C
1CD02  0061     MOVFFL 0x54A, 0x50C
1CD02  0061     MOVFFL 0x54A, 0x50C
1CD02  0061     MOVFFL 0x54A, 0x50C
1CD02  0061     MOVFFL 0x54A, 0x50C
1CD02  0061     MOVFFL 0x54A, 0x50C
1CD02  0061     MOVFFL 0x54A, 0x50C
1CD02  0061     MOVFFL 0x54A, 0x50C
1CD02  0061     MOVFFL 0x54A, 0x50C
1CD02  0061     MOVFFL 0x54A, 0x50C
1CD02  0061     MOVFFL 0x54A, 0x50C
1CD02  0061     MOVFFL 0x54A, 0x50C
1CD02  0061     MOVFFL 0x54A, 0x50C
1CD02  0061     MOVFFL 0x54A, 0x50C
1CD02  0061     MOVFFL 0x54A, 0x50C
1CD02  0061     MOVFFL 0x54A, 0x50C
1CD02  0061     MOVFFL 0x54A, 0x50C
1CD02  0061     MOVFFL 0x54A, 0x50C
1CD02  0061     MOVFFL 0x54A, 0x50C
1CD02  0061     MOVFFL 0x54A, 0x50C
1CD02  0061     MOVFFL 0x54A, 0x50C
1CD02  0061     MOVFFL 0x54A, 0x50C
1CD02  0061     MOVFFL 0x54A, 0x50C
1CD02  0061     MOVFFL 0x54A, 0x50C
1CD02  0061     MOVFFL 0x54A, 0x50C
1CD02  0061     MOVFFL 0x54A, 0x50C
1CD02  0061     MOVFFL 0x54A, 0x50C
1CD02  0061     MOVFFL 0x54A, 0x50C
1CD02  0061     MOVFFL 0x54A, 0x50C
1CD02  0061     MOVFFL 0x54A, 0x50C
1CD02  0061     MOVFFL 0x54A, 0x50C
776:           
777:           void CAN1_SetFIFO1NotEmptyHandler(void (*handler)(void))
778:           {
779:               CAN1_FIFO1NotEmptyHandler = handler;
22D6  50E1     MOVF 0xFE1, W, ACCESS
22D8  0FFD     ADDLW 0xFD
22DA  6ED9     MOVWF 0xFD9, ACCESS
22DC  50E2     MOVF 0xFE2, W, ACCESS
22DE  6EDA     MOVWF __end_of_UART2_tx_vect_isr, ACCESS
22E0  0EFF     MOVLW 0xFF
22E2  22DA     ADDWFC __end_of_UART2_tx_vect_isr, F, ACCESS
22E4  C4DE     MOVFF POSTINC2, CAN1_FIFO1NotEmptyHandler
22E6  F652     NOP
22E8  C4DE     MOVFF POSTINC2, 0x653
22EA  F653     NOP
22EC  C4DD     MOVFF POSTDEC2, 0x654
22EE  F654     NOP
780:           }
22F0  52E5     MOVF 0xFE5, F, ACCESS
22F0  52E5     MOVF 0xFE5, F, ACCESS
22F0  52E5     MOVF 0xFE5, F, ACCESS
22F0  52E5     MOVF 0xFE5, F, ACCESS
781:           
782:           void CAN1_SetTXQNotFullHandler(void (*handler)(void))
783:           {
784:               CAN1_TXQNotFullHandler = handler;
22B4  50E1     MOVF 0xFE1, W, ACCESS
22B6  0FFD     ADDLW 0xFD
22B8  6ED9     MOVWF 0xFD9, ACCESS
22BA  50E2     MOVF 0xFE2, W, ACCESS
22BC  6EDA     MOVWF __end_of_UART2_tx_vect_isr, ACCESS
22BE  0EFF     MOVLW 0xFF
22C0  22DA     ADDWFC __end_of_UART2_tx_vect_isr, F, ACCESS
22C2  C4DE     MOVFF POSTINC2, CAN1_TXQNotFullHandler
22C4  F655     NOP
22C6  C4DE     MOVFF POSTINC2, 0x656
22C8  F656     NOP
22CA  C4DD     MOVFF POSTDEC2, 0x657
22CC  F657     NOP
785:           }
22CE  52E5     MOVF 0xFE5, F, ACCESS
22CE  52E5     MOVF 0xFE5, F, ACCESS
22CE  52E5     MOVF 0xFE5, F, ACCESS
22CE  52E5     MOVF 0xFE5, F, ACCESS
786:           
787:           
788:           void __interrupt(irq(CANRX),base(8)) CAN1_RXI_ISR(void)
1F4E8  C4FA     MOVFF PCLATH, __pcstackBANK5
1F4EA  F5B0     NOP
1F4EC  C4FB     MOVFF PCLATU, 0x5B1
1F4EE  F5B1     NOP
1F4F0  C4F6     MOVFF TBLPTR, 0x5B2
1F4F2  F5B2     NOP
1F4F4  C4F7     MOVFF TBLPTRH, 0x5B3
1F4F6  F5B3     NOP
1F4F8  C4F8     MOVFF TBLPTRU, 0x5B4
1F4FA  F5B4     NOP
1F4FC  C4F5     MOVFF TABLAT, 0x5B5
1F4FE  F5B5     NOP
1F500  0061     MOVFFL ltemp0, 0x5B6
1F502  F404     NOP
1F504  F5B6     NOP
1F506  0061     MOVFFL ttemp5, 0x5B7
1F508  F408     NOP
1F50A  F5B7     NOP
1F50C  0061     MOVFFL wtemp1, 0x5B8
1F50E  F40C     NOP
1F510  F5B8     NOP
1F512  0061     MOVFFL ttemp1, 0x5B9
1F514  F410     NOP
1F516  F5B9     NOP
1F518  0061     MOVFFL ltemp1, 0x5BA
1F51A  F414     NOP
1F51C  F5BA     NOP
1F51E  0061     MOVFFL 0x506, 0x5BB
1F520  F418     NOP
1F522  F5BB     NOP
1F524  0061     MOVFFL ttemp2, 0x5BC
1F526  F41C     NOP
1F528  F5BC     NOP
1F52A  0061     MOVFFL 0x508, 0x5BD
1F52C  F420     NOP
1F52E  F5BD     NOP
1F530  0061     MOVFFL ltemp2, 0x5BE
1F532  F424     NOP
1F534  F5BE     NOP
1F536  0061     MOVFFL ttemp3, 0x5BF
1F538  F428     NOP
1F53A  F5BF     NOP
1F53C  0061     MOVFFL wtemp5, 0x5C0
1F53E  F42C     NOP
1F540  F5C0     NOP
1F542  0061     MOVFFL 0x50C, 0x5C1
1F544  F430     NOP
1F546  F5C1     NOP
1F548  EE17     LFSR 1, 0x1FAA
1F54A  F3AA     NOP
789:           {
790:               if (1 == C1FIFOSTA1Lbits.TFNRFNIF)
1F54C  0101     MOVLB 0x1
1F54E  A160     BTFSS PMD0, 0, BANKED
1F550  D00D     BRA 0xF56C
791:               {
792:                   CAN1_FIFO1NotEmptyHandler();
1F552  D801     RCALL 0xF556
1F554  D00B     BRA 0xF56C
1F556  0005     PUSH
1F558  6EFA     MOVWF 0xFFA, ACCESS
1F55A  0106     MOVLB 0x6
1F55C  5152     MOVF 0x52, W, BANKED
1F55E  6EFD     MOVWF 0xFFD, ACCESS
1F560  5153     MOVF 0x53, W, BANKED
1F562  6EFE     MOVWF 0xFFE, ACCESS
1F564  5154     MOVF 0x54, W, BANKED
1F566  6EFF     MOVWF 0xFFF, ACCESS
1F568  50FA     MOVF 0xFFA, W, ACCESS
1F56A  0012     RETURN 0
793:                   // flag readonly
794:               }
795:               
796:           }
1F56C  0061     MOVFFL 0x5C1, 0x50C
1F56C  0061     MOVFFL 0x5C1, 0x50C
1F56C  0061     MOVFFL 0x5C1, 0x50C
1F56C  0061     MOVFFL 0x5C1, 0x50C
1F56C  0061     MOVFFL 0x5C1, 0x50C
1F56C  0061     MOVFFL 0x5C1, 0x50C
1F56C  0061     MOVFFL 0x5C1, 0x50C
1F56C  0061     MOVFFL 0x5C1, 0x50C
1F56C  0061     MOVFFL 0x5C1, 0x50C
1F56C  0061     MOVFFL 0x5C1, 0x50C
1F56C  0061     MOVFFL 0x5C1, 0x50C
1F56C  0061     MOVFFL 0x5C1, 0x50C
1F56C  0061     MOVFFL 0x5C1, 0x50C
1F56C  0061     MOVFFL 0x5C1, 0x50C
1F56C  0061     MOVFFL 0x5C1, 0x50C
1F56C  0061     MOVFFL 0x5C1, 0x50C
1F56C  0061     MOVFFL 0x5C1, 0x50C
1F56C  0061     MOVFFL 0x5C1, 0x50C
1F56C  0061     MOVFFL 0x5C1, 0x50C
1F56C  0061     MOVFFL 0x5C1, 0x50C
1F56C  0061     MOVFFL 0x5C1, 0x50C
1F56C  0061     MOVFFL 0x5C1, 0x50C
1F56C  0061     MOVFFL 0x5C1, 0x50C
1F56C  0061     MOVFFL 0x5C1, 0x50C
1F56C  0061     MOVFFL 0x5C1, 0x50C
1F56C  0061     MOVFFL 0x5C1, 0x50C
1F56C  0061     MOVFFL 0x5C1, 0x50C
1F56C  0061     MOVFFL 0x5C1, 0x50C
1F56C  0061     MOVFFL 0x5C1, 0x50C
1F56C  0061     MOVFFL 0x5C1, 0x50C
1F56C  0061     MOVFFL 0x5C1, 0x50C
1F56C  0061     MOVFFL 0x5C1, 0x50C
1F56C  0061     MOVFFL 0x5C1, 0x50C
1F56C  0061     MOVFFL 0x5C1, 0x50C
1F56C  0061     MOVFFL 0x5C1, 0x50C
1F56C  0061     MOVFFL 0x5C1, 0x50C
1F56C  0061     MOVFFL 0x5C1, 0x50C
1F56C  0061     MOVFFL 0x5C1, 0x50C
1F56C  0061     MOVFFL 0x5C1, 0x50C
1F56C  0061     MOVFFL 0x5C1, 0x50C
1F56C  0061     MOVFFL 0x5C1, 0x50C
1F56C  0061     MOVFFL 0x5C1, 0x50C
1F56C  0061     MOVFFL 0x5C1, 0x50C
1F56C  0061     MOVFFL 0x5C1, 0x50C
1F56C  0061     MOVFFL 0x5C1, 0x50C
1F56C  0061     MOVFFL 0x5C1, 0x50C
1F56C  0061     MOVFFL 0x5C1, 0x50C
1F56C  0061     MOVFFL 0x5C1, 0x50C
1F56C  0061     MOVFFL 0x5C1, 0x50C
797:           
798:           void __interrupt(irq(CANTX),base(8)) CAN1_TXI_ISR(void)
174C  C4FA     MOVFF PCLATH, 0x5C2
174E  F5C2     NOP
1750  C4FB     MOVFF PCLATU, 0x5C3
1752  F5C3     NOP
1754  0061     MOVFFL 0x50C, 0x5C4
1756  F430     NOP
1758  F5C4     NOP
175A  EE17     LFSR 1, 0x1FAA
175C  F3AA     NOP
799:           {
800:               if (1 == C1TXQSTALbits.TXQNIF)
175E  0101     MOVLB 0x1
1760  A154     BTFSS 0x54, 0, BANKED
1762  D00D     BRA 0x177E
801:               {
802:                   CAN1_TXQNotFullHandler();
1764  D801     RCALL 0x1768
1766  D00B     BRA 0x177E
1768  0005     PUSH
176A  6EFA     MOVWF 0xFFA, ACCESS
176C  0106     MOVLB 0x6
176E  5155     MOVF 0x55, W, BANKED
1770  6EFD     MOVWF 0xFFD, ACCESS
1772  5156     MOVF 0x56, W, BANKED
1774  6EFE     MOVWF 0xFFE, ACCESS
1776  5157     MOVF 0x57, W, BANKED
1778  6EFF     MOVWF 0xFFF, ACCESS
177A  50FA     MOVF 0xFFA, W, ACCESS
177C  0012     RETURN 0
803:                   // flag readonly
804:               }
805:               
806:           }
177E  0061     MOVFFL 0x5C4, 0x50C
177E  0061     MOVFFL 0x5C4, 0x50C
177E  0061     MOVFFL 0x5C4, 0x50C
177E  0061     MOVFFL 0x5C4, 0x50C
177E  0061     MOVFFL 0x5C4, 0x50C
177E  0061     MOVFFL 0x5C4, 0x50C
177E  0061     MOVFFL 0x5C4, 0x50C
177E  0061     MOVFFL 0x5C4, 0x50C
---  /public/Q84vtouch/mateQ84.X/mcc_generated_files/adc.c  ---------------------------------------------
1:             /**
2:               ADC Generated Driver File
3:             
4:               @Company
5:                 Microchip Technology Inc.
6:             
7:               @File Name
8:                 adc.c
9:             
10:              @Summary
11:                This is the generated driver implementation file for the ADC driver using PIC10 / PIC12 / PIC16 / PIC18 MCUs
12:            
13:              @Description
14:                This header file provides implementations for driver APIs for ADC.
15:                Generation Information :
16:                    Product Revision  :  PIC10 / PIC12 / PIC16 / PIC18 MCUs - 1.81.8
17:                    Device            :  PIC18F47Q84
18:                    Driver Version    :  1.0.0
19:                The generated drivers are tested against the following:
20:                    Compiler          :  XC8 2.36 and above
21:                    MPLAB             :  MPLAB X 6.00
22:            */
23:            
24:            /*
25:                (c) 2018 Microchip Technology Inc. and its subsidiaries. 
26:                
27:                Subject to your compliance with these terms, you may use Microchip software and any 
28:                derivatives exclusively with Microchip products. It is your responsibility to comply with third party 
29:                license terms applicable to your use of third party software (including open source software) that 
30:                may accompany Microchip software.
31:                
32:                THIS SOFTWARE IS SUPPLIED BY MICROCHIP "AS IS". NO WARRANTIES, WHETHER 
33:                EXPRESS, IMPLIED OR STATUTORY, APPLY TO THIS SOFTWARE, INCLUDING ANY 
34:                IMPLIED WARRANTIES OF NON-INFRINGEMENT, MERCHANTABILITY, AND FITNESS 
35:                FOR A PARTICULAR PURPOSE.
36:                
37:                IN NO EVENT WILL MICROCHIP BE LIABLE FOR ANY INDIRECT, SPECIAL, PUNITIVE, 
38:                INCIDENTAL OR CONSEQUENTIAL LOSS, DAMAGE, COST OR EXPENSE OF ANY KIND 
39:                WHATSOEVER RELATED TO THE SOFTWARE, HOWEVER CAUSED, EVEN IF MICROCHIP 
40:                HAS BEEN ADVISED OF THE POSSIBILITY OR THE DAMAGES ARE FORESEEABLE. TO 
41:                THE FULLEST EXTENT ALLOWED BY LAW, MICROCHIP'S TOTAL LIABILITY ON ALL 
42:                CLAIMS IN ANY WAY RELATED TO THIS SOFTWARE WILL NOT EXCEED THE AMOUNT 
43:                OF FEES, IF ANY, THAT YOU HAVE PAID DIRECTLY TO MICROCHIP FOR THIS 
44:                SOFTWARE.
45:            */
46:            
47:            /**
48:              Section: Included Files
49:            */
50:            
51:            #include <xc.h>
52:            #include "adc.h"
53:            
54:            //Pointers to ADC interrupt handlers
55:            //User can use them in application code to initialize with custom ISRs
56:            static void (*ADC_ConversionComplete_ISR)(void);
57:            static void (*ADC_Context1Thereshld_ISR)(void);
58:            static void (*ADC_ActiveClockTuning_ISR)(void);
59:            
60:            static void ADC_DefaultADI_ISR(void);
61:            static void ADC_DefaultContext1Threshold_ISR(void);
62:            static void ADC_DefaultActiveClockTuning_ISR(void);
63:            
64:            
65:            void ADC_Initialize(void)
66:            {
67:                //ADACT disabled; 
68:                ADACT = 0x00;
07EE  0103     MOVLB 0x3
07F0  6BF9     CLRF DMAnSSA, BANKED
69:            
70:                //ADCCS FOSC/4; 
71:                ADCLK = 0x01;
07F2  0E01     MOVLW 0x1
07F4  6FFA     MOVWF DMAnSSAH, BANKED
72:                
73:                //ADC charge pump control
74:                ADCP = 0x00;
07F6  6BD8     CLRF CLCnSEL0, BANKED
75:                
76:            
77:                /****************************************
78:                 *         Configure Context-1          *
79:                 ****************************************/
80:                ADCTX = 0x0;
07F8  6BFB     CLRF DMAnSSAU, BANKED
81:            
82:                //ADLTHL 0; 
83:                ADLTHL = 0x00;
07FA  6BD9     CLRF CLCnSEL1, BANKED
84:            
85:                //ADLTHH 0; 
86:                ADLTHH = 0x00;
07FC  6BDA     CLRF CLCnSEL2, BANKED
87:            
88:                //ADUTHL 0; 
89:                ADUTHL = 0x00;
07FE  6BDB     CLRF CLCnSEL3, BANKED
90:            
91:                //ADUTHH 0; 
92:                ADUTHH = 0x00;
0800  6BDC     CLRF CLCnGLS0, BANKED
93:            
94:                //ADSTPTL 0; 
95:                ADSTPTL = 0x00;
0802  6BDF     CLRF CLCnGLS3, BANKED
96:            
97:                //ADSTPTH 0; 
98:                ADSTPTH = 0x00;
0804  6BE0     CLRF 0xE0, BANKED
99:            
100:               //ADACCL 0; 
101:               ADACCL = 0x00;
0806  6BE3     CLRF 0xE3, BANKED
102:           
103:               //ADACCH 0; 
104:               ADACCH = 0x00;
0808  6BE4     CLRF 0xE4, BANKED
105:           
106:               //ADACCU 0; 
107:               ADACCU = 0x00;
080A  6BE5     CLRF 0xE5, BANKED
108:           
109:               //ADCNT 0; 
110:               ADCNT = 0x00;
080C  6BE6     CLRF 0xE6, BANKED
111:           
112:               //ADRPT 0; 
113:               ADRPT = 0x00;
080E  6BE7     CLRF 0xE7, BANKED
114:           
115:               //ADRESL 0; 
116:               ADRESL = 0x00;
0810  6BEA     CLRF DMAnDCNT, BANKED
117:           
118:               //ADRESH 0; 
119:               ADRESH = 0x00;
0812  6BEB     CLRF DMAnDCNTH, BANKED
120:           
121:               //ADCHS ANA0; 
122:               ADPCH = 0x00;
0814  6BEC     CLRF DMAnDPTR, BANKED
123:           
124:               //ADACQL 10; 
125:               ADACQL = 0x0A;
0816  0E0A     MOVLW 0xA
0818  6FEE     MOVWF DMAnDSZ, BANKED
126:           
127:               //ADACQH 0; 
128:               ADACQH = 0x00;
081A  6BEF     CLRF DMAnDSZH, BANKED
129:           
130:               //ADCAP Additional uC disabled; 
131:               ADCAP = 0x00;
081C  6BF0     CLRF DMAnDSA, BANKED
132:           
133:               //ADPREL 0; 
134:               ADPREL = 0x00;
081E  6BF1     CLRF DMAnDSAH, BANKED
135:           
136:               //ADPREH 0; 
137:               ADPREH = 0x00;
0820  6BF2     CLRF DMAnSCNT, BANKED
138:               
139:               //ADCONT disabled; 
140:               ADCON0 = 0x00;
0822  6BF3     CLRF DMAnSCNTH, BANKED
141:           
142:               //ADPPOL Vss; ADIPEN disabled; ADGPOL digital_low; ADDSEN disabled; 
143:               ADCON1 = 0x00;
0824  6BF4     CLRF DMAnSPTR, BANKED
144:           
145:               //ADPSIS RES; ADCRS 1; ADACLR disabled; ADMD Basic_mode; 
146:               ADCON2 = 0x10;
0826  0E10     MOVLW 0x10
0828  6FF5     MOVWF DMAnSPTRH, BANKED
147:           
148:               //ADCALC First derivative of Single measurement; ADSOI ADGO not cleared; ADTMD disabled; 
149:               ADCON3 = 0x00;
082A  6BF6     CLRF DMAnSPTRU, BANKED
150:           
151:               //ADMATH registers not updated; 
152:               ADSTAT = 0x00;
082C  6BF7     CLRF DMAnSSZ, BANKED
153:           
154:               //ADNREF VSS; ADPREF external; 
155:               ADREF = 0x02;
082E  0E02     MOVLW 0x2
0830  6FF8     MOVWF DMAnSSZH, BANKED
156:               
157:               //CHEN channel content is not included; SSI scan sequence continues; 
158:               ADCSEL1 = 0x00;
0832  6BFC     CLRF DMAnCON0, BANKED
159:               
160:               //Clear ADC Interrupt Flag
161:               PIR1bits.ADIF = 0;
0834  94AF     BCF 0xFAF, 2, ACCESS
162:               
163:               //Clear ADC active clock tuning interrupt flag
164:               PIR1bits.ACTIF = 0;
0836  96AF     BCF 0xFAF, 3, ACCESS
165:               
166:               //Clear ADC Context Threshold Interrupt Flag
167:               PIR2bits.ADCH1IF = 0;
0838  90B0     BCF 0xFB0, 0, ACCESS
168:               
169:           
170:               //Configure interrupt handlers
171:               ADC_SetADIInterruptHandler(ADC_DefaultADI_ISR);
083A  0EA0     MOVLW 0xA0
083C  6EE6     MOVWF 0xFE6, ACCESS
083E  0E27     MOVLW 0x27
0840  6EE6     MOVWF 0xFE6, ACCESS
0842  0E00     MOVLW 0x0
0844  6EE6     MOVWF 0xFE6, ACCESS
0846  EC15     CALL 0x242A, 0
0848  F012     NOP
172:               ADC_SetContext1ThresholdInterruptHandler(ADC_DefaultContext1Threshold_ISR);
084A  0EA4     MOVLW 0xA4
084C  6EE6     MOVWF 0xFE6, ACCESS
084E  0E27     MOVLW 0x27
0850  6EE6     MOVWF 0xFE6, ACCESS
0852  0E00     MOVLW 0x0
0854  6EE6     MOVWF 0xFE6, ACCESS
0856  ECF3     CALL 0x23E6, 0
0858  F011     NOP
173:               ADC_SetActiveClockTuningInterruptHandler(ADC_DefaultActiveClockTuning_ISR);
085A  0EA2     MOVLW 0xA2
085C  6EE6     MOVWF 0xFE6, ACCESS
085E  0E27     MOVLW 0x27
0860  6EE6     MOVWF 0xFE6, ACCESS
0862  0E00     MOVLW 0x0
0864  6EE6     MOVWF 0xFE6, ACCESS
0866  EC04     CALL 0x2408, 0
0868  F012     NOP
174:                   
175:               //ADON enabled; CSEN disabled; ADCS FOSC/ADCLK; ADFM right; GO_nDONE stop; 
176:               ADCON0 = 0x84;
086A  0E84     MOVLW 0x84
086C  0103     MOVLB 0x3
086E  6FF3     MOVWF DMAnSCNTH, BANKED
177:           }
0870  0012     RETURN 0
178:           
179:           inline void ADC_EnableChannelSequencer(void)
180:           {
181:               ADCON0bits.CSEN = 1;
182:           }
183:           
184:           inline void ADC_DisableChannelSequencer(void)
185:           {
186:               ADCON0bits.CSEN = 0;
187:           }
188:           
189:           inline void ADC_StartChannelSequencer(void)
190:           {
191:               ADCON0bits.GO = 1;
192:           }
193:           
194:           inline void ADC_SelectContext(ADC_context_t context)
195:           {
196:               ADCTX = context;
197:           }
198:           
199:           void ADC_EnableChannelScan(ADC_context_t context)
200:           {
201:               switch (context)
202:               {
203:               case CONTEXT_1:
204:                   ADCSEL1bits.CHEN = 1;
205:                   break;
206:               default:
207:                   break;
208:               }
209:           }
210:           
211:           void ADC_DisableChannelScan(ADC_context_t context)
212:           {
213:               switch (context)
214:               {
215:               case CONTEXT_1:
216:                   ADCSEL1bits.CHEN = 0;
217:                   break;
218:               default:
219:                   break;
220:               }
221:           }
222:           
223:           void ADC_StartConversion(ADC_channel_t channel)
224:           {
225:               //Select the A/D channel
226:               ADPCH = channel;
227:           
228:               //Turn ON the ADC module
229:               ADCON0bits.ON = 1;
230:           
231:               //Start the conversion
232:               ADCON0bits.GO = 1;
233:           }
234:           
235:           bool ADC_IsConversionDone(void)
236:           {
237:               return (bool) (!ADCON0bits.GO);
238:           }
239:           
240:           adc_result_t ADC_GetConversionResult(void)
241:           {
242:               //Return result of A/D conversion
243:               return ((adc_result_t) ((ADRESH << 8) + ADRESL));
244:           }
245:           
246:           adc_result_t ADC_GetSingleConversion(ADC_channel_t channel)
247:           {
248:               //Select the A/D channel
249:               ADPCH = channel;
250:           
251:               //Turn ON the ADC module
252:               ADCON0bits.ON = 1;
253:           
254:               //Disable the continuous mode
255:               ADCON0bits.CONT = 0;
256:           
257:               //Start the conversion
258:               ADCON0bits.GO = 1;
259:           
260:               //Wait for the conversion to finish
261:               while(ADCON0bits.GO)
262:               {
263:           
264:               }
265:           
266:               return ((adc_result_t) ((ADRESH << 8) + ADRESL));
267:           }
268:           
269:           inline void ADC_StopConversion(void)
270:           {
271:               //Reset the ADGO bit to manually stop conversion
272:               ADCON0bits.GO = 0;
273:           }
274:           
275:           inline void ADC_SetStopOnInterrupt(void)
276:           {
277:               ADCON3bits.SOI = 1;
278:           }
279:           
280:           inline void ADC_DischargeSampleCapacitor(void)
281:           {
282:               //Set ADC channel to AVss
283:               ADPCH = 0x3b;
284:           }
285:           
286:           void ADC_LoadAcquisitionRegister(uint16_t acquisitionValue)
287:           {
288:               ADACQH = acquisitionValue >> 8;
289:               ADACQL = acquisitionValue;
290:           }
291:           
292:           void ADC_SetPrechargeTime(uint16_t prechargeTime)
293:           {
294:               ADPREH = prechargeTime >> 8;
295:               ADPREL = prechargeTime;
296:           }
297:           
298:           inline void ADC_SetRepeatCount(uint8_t repeatCount)
299:           {
300:               ADRPT = repeatCount;
301:           }
302:           
303:           uint8_t ADC_GetCurrentCountofConversions(void)
304:           {
305:               return ADCNT;
306:           }
307:           
308:           inline void ADC_ClearAccumulator(void)
309:           {
310:               ADCON2bits.ACLR = 1;
311:           }
312:           
313:           uint24_t ADC_GetAccumulatorValue(void)
314:           {
315:               return ((uint24_t) ((ADACCH << 8) + ADACCL));
316:           }
317:           
318:           bool ADC_HasAccumulatorOverflowed(void)
319:           {
320:               return ADSTATbits.ADAOV;
321:           }
322:           
323:           uint16_t ADC_GetFilterValue(void)
324:           {
325:               return ((uint16_t) ((ADFLTRH << 8) + ADFLTRL));
326:           }
327:           
328:           uint16_t ADC_GetPreviousResult(void)
329:           {
330:               return ((uint16_t) ((ADPREVH << 8) + ADPREVL));
331:           }
332:           
333:           void ADC_DefineSetPoint(uint16_t setPoint)
334:           {
335:               ADSTPTH = setPoint >> 8;
336:               ADSTPTL = setPoint;
337:           }
338:           
339:           void ADC_SetUpperThreshold(uint16_t upperThreshold)
340:           {
341:               ADUTHH = upperThreshold >> 8;
342:               ADUTHL = upperThreshold;
343:           }
344:           
345:           void ADC_SetLowerThreshold(uint16_t lowerThreshold)
346:           {
347:               ADLTHH = lowerThreshold >> 8;
348:               ADLTHL = lowerThreshold;
349:           }
350:           
351:           uint16_t ADC_GetErrorCalculation(void)
352:           {
353:               return ((uint16_t) ((ADERRH << 8) + ADERRL));
354:           }
355:           
356:           inline void ADC_EnableDoubleSampling(void)
357:           {
358:               ADCON1bits.DSEN = 1;
359:           }
360:           
361:           inline void ADC_EnableContinuousConversion(void)
362:           {
363:               ADCON0bits.CONT = 1;
364:           }
365:           
366:           inline void ADC_DisableContinuousConversion(void)
367:           {
368:               ADCON0bits.CONT = 0;
369:           }
370:           
371:           bool ADC_HasErrorCrossedUpperThreshold(void)
372:           {
373:               return ADSTATbits.ADUTHR;
374:           }
375:           
376:           bool ADC_HasErrorCrossedLowerThreshold(void)
377:           {
378:               return ADSTATbits.ADLTHR;
379:           }
380:           
381:           uint8_t ADC_GetConversionStageStatus(void)
382:           {
383:               return ADSTATbits.ADSTAT;
384:           }
385:           
386:           inline void ADC_EnableChargePump(void)
387:           {
388:               ADCPbits.CPON = 1;
389:           }
390:           
391:           inline void ADC_DisableChargePump(void)
392:           {
393:               ADCPbits.CPON = 0;
394:           }
395:           
396:           void __interrupt(irq(AD),base(8)) ADC_ADI_ISR(void)
18CC  C4FA     MOVFF PCLATH, __pcstackBANK6
397:           {
398:               PIR1bits.ADIF = 0;
18D8  94AF     BCF 0xFAF, 2, ACCESS
399:               if (ADC_ConversionComplete_ISR != NULL)
18DA  0107     MOVLB 0x7
18DC  51AE     MOVF OSCCON2, W, BANKED
18DE  11AF     IORWF OSCCON3, W, BANKED
18E0  11B0     IORWF OSCTUNE, W, BANKED
18E2  B4D8     BTFSC 0xFD8, 2, ACCESS
18E4  D00C     BRA 0x18FE
400:                   ADC_ConversionComplete_ISR();
18E6  D801     RCALL 0x18EA
18E8  D00A     BRA 0x18FE
18EA  0005     PUSH
18EC  6EFA     MOVWF 0xFFA, ACCESS
18EE  51AE     MOVF OSCCON2, W, BANKED
18F0  6EFD     MOVWF 0xFFD, ACCESS
18F2  51AF     MOVF OSCCON3, W, BANKED
18F4  6EFE     MOVWF 0xFFE, ACCESS
18F6  51B0     MOVF OSCTUNE, W, BANKED
18F8  6EFF     MOVWF 0xFFF, ACCESS
18FA  50FA     MOVF 0xFFA, W, ACCESS
18FC  0012     RETURN 0
401:           }
18FE  C6FF     MOVFF 0x6FF, PCLATU
18FE  C6FF     MOVFF 0x6FF, PCLATU
18FE  C6FF     MOVFF 0x6FF, PCLATU
18FE  C6FF     MOVFF 0x6FF, PCLATU
18FE  C6FF     MOVFF 0x6FF, PCLATU
402:           
403:           void __interrupt(irq(ACT),base(8)) ADC_ACTI_ISR(void)
404:           {
405:               PIR1bits.ACTIF = 0;
1914  96AF     BCF 0xFAF, 3, ACCESS
406:               if (ADC_ActiveClockTuning_ISR != NULL)
1916  0107     MOVLB 0x7
1918  51A8     MOVF 0xA8, W, BANKED
191A  11A9     IORWF 0xA9, W, BANKED
191C  11AA     IORWF 0xAA, W, BANKED
191E  B4D8     BTFSC 0xFD8, 2, ACCESS
1920  D00C     BRA 0x193A
407:                   ADC_ActiveClockTuning_ISR();
1922  D801     RCALL 0x1926
1924  D00A     BRA 0x193A
1926  0005     PUSH
1928  6EFA     MOVWF 0xFFA, ACCESS
192A  51A8     MOVF 0xA8, W, BANKED
192C  6EFD     MOVWF 0xFFD, ACCESS
192E  51A9     MOVF 0xA9, W, BANKED
1930  6EFE     MOVWF 0xFFE, ACCESS
1932  51AA     MOVF 0xAA, W, BANKED
1934  6EFF     MOVWF 0xFFF, ACCESS
1936  50FA     MOVF 0xFFA, W, ACCESS
1938  0012     RETURN 0
408:           }
193A  C7F5     MOVFF 0x7F5, PCLATU
409:           
410:           
411:           void __interrupt(irq(ADCH1),base(8)) ADC_ADCH1_ISR(void)
412:           {
413:               PIR2bits.ADCH1IF = 0;
1950  90B0     BCF 0xFB0, 0, ACCESS
414:               if (ADC_Context1Thereshld_ISR != NULL)
1952  0107     MOVLB 0x7
1954  51AB     MOVF 0xAB, W, BANKED
1956  11AC     IORWF ACTCON, W, BANKED
1958  11AD     IORWF OSCCON1, W, BANKED
195A  B4D8     BTFSC 0xFD8, 2, ACCESS
195C  D00C     BRA 0x1976
415:                   ADC_Context1Thereshld_ISR();
195E  D801     RCALL 0x1962
1960  D00A     BRA 0x1976
1962  0005     PUSH
1964  6EFA     MOVWF 0xFFA, ACCESS
1966  51AB     MOVF 0xAB, W, BANKED
1968  6EFD     MOVWF 0xFFD, ACCESS
196A  51AC     MOVF ACTCON, W, BANKED
196C  6EFE     MOVWF 0xFFE, ACCESS
196E  51AD     MOVF OSCCON1, W, BANKED
1970  6EFF     MOVWF 0xFFF, ACCESS
1972  50FA     MOVF 0xFFA, W, ACCESS
1974  0012     RETURN 0
416:           }
1976  C7F7     MOVFF 0x7F7, PCLATU
417:           
418:           void ADC_SetADIInterruptHandler(void (* InterruptHandler)(void))
419:           {
420:               ADC_ConversionComplete_ISR = InterruptHandler;
242A  50E1     MOVF 0xFE1, W, ACCESS
242C  0FFD     ADDLW 0xFD
242E  6ED9     MOVWF 0xFD9, ACCESS
2430  50E2     MOVF 0xFE2, W, ACCESS
2432  6EDA     MOVWF __end_of_UART2_tx_vect_isr, ACCESS
2434  0EFF     MOVLW 0xFF
2436  22DA     ADDWFC __end_of_UART2_tx_vect_isr, F, ACCESS
2438  C4DE     MOVFF POSTINC2, ADC_ConversionComplete_ISR
243A  F7AE     NOP
243C  C4DE     MOVFF POSTINC2, 0x7AF
243E  F7AF     NOP
2440  C4DD     MOVFF POSTDEC2, 0x7B0
2442  F7B0     NOP
421:           }
2444  52E5     MOVF 0xFE5, F, ACCESS
2444  52E5     MOVF 0xFE5, F, ACCESS
2444  52E5     MOVF 0xFE5, F, ACCESS
2444  52E5     MOVF 0xFE5, F, ACCESS
422:           
423:           void ADC_SetContext1ThresholdInterruptHandler(void (* InterruptHandler)(void))
424:           {
425:               ADC_Context1Thereshld_ISR = InterruptHandler;
23E6  50E1     MOVF 0xFE1, W, ACCESS
23E8  0FFD     ADDLW 0xFD
23EA  6ED9     MOVWF 0xFD9, ACCESS
23EC  50E2     MOVF 0xFE2, W, ACCESS
23EE  6EDA     MOVWF __end_of_UART2_tx_vect_isr, ACCESS
23F0  0EFF     MOVLW 0xFF
23F2  22DA     ADDWFC __end_of_UART2_tx_vect_isr, F, ACCESS
23F4  C4DE     MOVFF POSTINC2, ADC_Context1Thereshld_ISR
23F6  F7AB     NOP
23F8  C4DE     MOVFF POSTINC2, 0x7AC
23FA  F7AC     NOP
23FC  C4DD     MOVFF POSTDEC2, 0x7AD
23FE  F7AD     NOP
426:           }
2400  52E5     MOVF 0xFE5, F, ACCESS
2400  52E5     MOVF 0xFE5, F, ACCESS
2400  52E5     MOVF 0xFE5, F, ACCESS
2400  52E5     MOVF 0xFE5, F, ACCESS
427:           
428:           void ADC_SetActiveClockTuningInterruptHandler(void (* InterruptHandler)(void))
429:           {
430:               ADC_ActiveClockTuning_ISR = InterruptHandler;
2408  50E1     MOVF 0xFE1, W, ACCESS
240A  0FFD     ADDLW 0xFD
240C  6ED9     MOVWF 0xFD9, ACCESS
240E  50E2     MOVF 0xFE2, W, ACCESS
2410  6EDA     MOVWF __end_of_UART2_tx_vect_isr, ACCESS
2412  0EFF     MOVLW 0xFF
2414  22DA     ADDWFC __end_of_UART2_tx_vect_isr, F, ACCESS
2416  C4DE     MOVFF POSTINC2, ADC_ActiveClockTuning_ISR
2418  F7A8     NOP
241A  C4DE     MOVFF POSTINC2, 0x7A9
241C  F7A9     NOP
241E  C4DD     MOVFF POSTDEC2, 0x7AA
2420  F7AA     NOP
431:           }
2422  52E5     MOVF 0xFE5, F, ACCESS
2422  52E5     MOVF 0xFE5, F, ACCESS
2422  52E5     MOVF 0xFE5, F, ACCESS
2422  52E5     MOVF 0xFE5, F, ACCESS
432:           
433:           static void ADC_DefaultADI_ISR(void)
434:           {
435:               //Add your interrupt code here or
436:               //Use ADC_SetADIInterruptHandler() function to use Custom ISR
437:           }
1908  C4FA     MOVFF PCLATH, __pcstackBANK7
190A  F7F4     NOP
190C  C4FB     MOVFF PCLATU, 0x7F5
190E  F7F5     NOP
1910  EE17     LFSR 1, 0x1FAA
1912  F3AA     NOP
27A0  0012     RETURN 0
438:           
439:           
440:           static void ADC_DefaultContext1Threshold_ISR(void)
27A4  0012     RETURN 0
441:           {
442:               //Add your interrupt code here or
443:               //Use ADC_SetContext1ThresholdInterruptHandler() function to use Custom ISR
444:           }
0A68  C4FA     MOVFF PCLATH, __pcstackBANK8
445:           
446:           static void ADC_DefaultActiveClockTuning_ISR(void)
447:           {
448:               //Add your interrupt code here or
449:               //Use ADC_SetActiveClockTuningInterruptHandler() function to use Custom ISR
450:           }
1944  C4FA     MOVFF PCLATH, 0x7F6
1946  F7F6     NOP
1948  C4FB     MOVFF PCLATU, 0x7F7
194A  F7F7     NOP
194C  EE17     LFSR 1, 0x1FAA
194E  F3AA     NOP
27A2  0012     RETURN 0
451:           
452:           /**
453:             End of File
454:            */
---  /public/Q84vtouch/mateQ84.X/main.c  ----------------------------------------------------------------
1:             /**
2:               Generated Main Source File
3:             
4:               Company:
5:                 Microchip Technology Inc.
6:             
7:               File Name:
8:                 main.c
9:             
10:              Summary:
11:                This is the main file generated using PIC10 / PIC12 / PIC16 / PIC18 MCUs
12:            
13:              Description:
14:                This header file provides implementations for driver APIs for all modules selected in the GUI.
15:                Generation Information :
16:                Product Revision  :  PIC10 / PIC12 / PIC16 / PIC18 MCUs - 1.81.8
17:                Device            :  PIC18F14Q41
18:                Driver Version    :  2.00
19:             */
20:            
21:            /*
22:                (c) 2018 Microchip Technology Inc. and its subsidiaries.
23:            
24:                Subject to your compliance with these terms, you may use Microchip software and any
25:                derivatives exclusively with Microchip products. It is your responsibility to comply with third party
26:                license terms applicable to your use of third party software (including open source software) that
27:                may accompany Microchip software.
28:            
29:                THIS SOFTWARE IS SUPPLIED BY MICROCHIP "AS IS". NO WARRANTIES, WHETHER
30:                EXPRESS, IMPLIED OR STATUTORY, APPLY TO THIS SOFTWARE, INCLUDING ANY
31:                IMPLIED WARRANTIES OF NON-INFRINGEMENT, MERCHANTABILITY, AND FITNESS
32:                FOR A PARTICULAR PURPOSE.
33:            
34:                IN NO EVENT WILL MICROCHIP BE LIABLE FOR ANY INDIRECT, SPECIAL, PUNITIVE,
35:                INCIDENTAL OR CONSEQUENTIAL LOSS, DAMAGE, COST OR EXPENSE OF ANY KIND
36:                WHATSOEVER RELATED TO THE SOFTWARE, HOWEVER CAUSED, EVEN IF MICROCHIP
37:                HAS BEEN ADVISED OF THE POSSIBILITY OR THE DAMAGES ARE FORESEEABLE. TO
38:                THE FULLEST EXTENT ALLOWED BY LAW, MICROCHIP'S TOTAL LIABILITY ON ALL
39:                CLAIMS IN ANY WAY RELATED TO THIS SOFTWARE WILL NOT EXCEED THE AMOUNT
40:                OF FEES, IF ANY, THAT YOU HAVE PAID DIRECTLY TO MICROCHIP FOR THIS
41:                SOFTWARE.
42:             */
43:            #pragma warning disable 520
44:            #pragma warning disable 1090
45:            #pragma warning disable 1498
46:            #pragma warning disable 2053
47:            
48:            // PIC18F47Q84 Configuration Bit Settings
49:            // 'C' source line config statements
50:            // CONFIG1
51:            #pragma config FEXTOSC = ECH    // External Oscillator Selection (EC (external clock) above 8 MHz)
52:            #pragma config RSTOSC = EXTOSC_4PLL// Reset Oscillator Selection (EXTOSC with 4x PLL, with EXTOSC operating per FEXTOSC bits)
53:            
54:            // CONFIG2
55:            #pragma config CLKOUTEN = ON    // Clock out Enable bit (CLKOUT function is enabled)
56:            #pragma config PR1WAY = OFF     // PRLOCKED One-Way Set Enable bit (PRLOCKED bit can be set and cleared repeatedly)
57:            #pragma config CSWEN = ON       // Clock Switch Enable bit (Writing to NOSC and NDIV is allowed)
58:            #pragma config JTAGEN = OFF     // JTAG Enable bit (Disable JTAG Boundary Scan mode, JTAG pins revert to user functions)
59:            #pragma config FCMEN = ON       // Fail-Safe Clock Monitor Enable bit (Fail-Safe Clock Monitor enabled)
60:            #pragma config FCMENP = ON      // Fail-Safe Clock Monitor -Primary XTAL Enable bit (FSCM timer will set FSCMP bit and OSFIF interrupt on Primary XTAL failure)
61:            #pragma config FCMENS = ON      // Fail-Safe Clock Monitor -Secondary XTAL Enable bit (FSCM timer will set FSCMS bit and OSFIF interrupt on Secondary XTAL failure)
62:            
63:            // CONFIG3
64:            #pragma config MCLRE = EXTMCLR  // MCLR Enable bit (If LVP = 0, MCLR pin is MCLR; If LVP = 1, RE3 pin function is MCLR )
65:            #pragma config PWRTS = PWRT_OFF // Power-up timer selection bits (PWRT is disabled)
66:            #pragma config MVECEN = ON      // Multi-vector enable bit (Multi-vector enabled, Vector table used for interrupts)
67:            #pragma config IVT1WAY = ON     // IVTLOCK bit One-way set enable bit (IVTLOCKED bit can be cleared and set only once)
68:            #pragma config LPBOREN = OFF    // Low Power BOR Enable bit (Low-Power BOR disabled)
69:            #pragma config BOREN = SBORDIS  // Brown-out Reset Enable bits (Brown-out Reset enabled , SBOREN bit is ignored)
70:            
71:            // CONFIG4
72:            #pragma config BORV = VBOR_1P9  // Brown-out Reset Voltage Selection bits (Brown-out Reset Voltage (VBOR) set to 1.9V)
73:            #pragma config ZCD = OFF        // ZCD Disable bit (ZCD module is disabled. ZCD can be enabled by setting the ZCDSEN bit of ZCDCON)
74:            #pragma config PPS1WAY = OFF    // PPSLOCK bit One-Way Set Enable bit (PPSLOCKED bit can be set and cleared repeatedly (subject to the unlock sequence))
75:            #pragma config STVREN = ON      // Stack Full/Underflow Reset Enable bit (Stack full/underflow will cause Reset)
76:            #pragma config LVP = OFF        // Low Voltage Programming Enable bit (HV on MCLR/VPP must be used for programming)
77:            #pragma config XINST = OFF      // Extended Instruction Set Enable bit (Extended Instruction Set and Indexed Addressing Mode disabled)
78:            
79:            // CONFIG5
80:            #pragma config WDTCPS = WDTCPS_31// WDT Period selection bits (Divider ratio 1:65536; software control of WDTPS)
81:            #pragma config WDTE = OFF       // WDT operating mode (WDT Disabled; SWDTEN is ignored)
82:            
83:            // CONFIG6
84:            #pragma config WDTCWS = WDTCWS_7// WDT Window Select bits (window always open (100%); software control; keyed access not required)
85:            #pragma config WDTCCS = SC      // WDT input clock selector (Software Control)
86:            
87:            // CONFIG7
88:            #pragma config BBSIZE = BBSIZE_512// Boot Block Size selection bits (Boot Block size is 512 words)
89:            #pragma config BBEN = OFF       // Boot Block enable bit (Boot block disabled)
90:            #pragma config SAFEN = OFF      // Storage Area Flash enable bit (SAF disabled)
91:            #pragma config DEBUG = OFF      // Background Debugger (Background Debugger disabled)
92:            
93:            // CONFIG8
94:            #pragma config WRTB = OFF       // Boot Block Write Protection bit (Boot Block not Write protected)
95:            #pragma config WRTC = OFF       // Configuration Register Write Protection bit (Configuration registers not Write protected)
96:            #pragma config WRTD = OFF       // Data EEPROM Write Protection bit (Data EEPROM not Write protected)
97:            #pragma config WRTSAF = OFF     // SAF Write protection bit (SAF not Write Protected)
98:            #pragma config WRTAPP = OFF     // Application Block write protection bit (Application Block not write protected)
99:            
100:           // CONFIG9
101:           #pragma config BOOTPINSEL = RC5 // CRC on boot output pin selection (CRC on boot output pin is RC5)
102:           #pragma config BPEN = OFF       // CRC on boot output pin enable bit (CRC on boot output pin disabled)
103:           #pragma config ODCON = OFF      // CRC on boot output pin open drain bit (Pin drives both high-going and low-going signals)
104:           
105:           // CONFIG10
106:           #pragma config CP = OFF         // PFM and Data EEPROM Code Protection bit (PFM and Data EEPROM code protection disabled)
107:           
108:           // CONFIG11
109:           #pragma config BOOTSCEN = OFF   // CRC on boot scan enable for boot area (CRC on boot will not include the boot area of program memory in its calculation)
110:           #pragma config BOOTCOE = HALT   // CRC on boot Continue on Error for boot areas bit (CRC on boot will stop device if error is detected in boot areas)
111:           #pragma config APPSCEN = OFF    // CRC on boot application code scan enable (CRC on boot will not include the application area of program memory in its calculation)
112:           #pragma config SAFSCEN = OFF    // CRC on boot SAF area scan enable (CRC on boot will not include the SAF area of program memory in its calculation)
113:           #pragma config DATASCEN = OFF   // CRC on boot Data EEPROM scan enable (CRC on boot will not include data EEPROM in its calculation)
114:           #pragma config CFGSCEN = OFF    // CRC on boot Config fuses scan enable (CRC on boot will not include the configuration fuses in its calculation)
115:           #pragma config COE = HALT       // CRC on boot Continue on Error for non-boot areas bit (CRC on boot will stop device if error is detected in non-boot areas)
116:           #pragma config BOOTPOR = OFF    // Boot on CRC Enable bit (CRC on boot will not run)
117:           
118:           // CONFIG12
119:           #pragma config BCRCPOLT = hFF   // Boot Sector Polynomial for CRC on boot bits 31-24 (Bits 31:24 of BCRCPOL are 0xFF)
120:           
121:           // CONFIG13
122:           #pragma config BCRCPOLU = hFF   // Boot Sector Polynomial for CRC on boot bits 23-16 (Bits 23:16 of BCRCPOL are 0xFF)
123:           
124:           // CONFIG14
125:           #pragma config BCRCPOLH = hFF   // Boot Sector Polynomial for CRC on boot bits 15-8 (Bits 15:8 of BCRCPOL are 0xFF)
126:           
127:           // CONFIG15
128:           #pragma config BCRCPOLL = hFF   // Boot Sector Polynomial for CRC on boot bits 7-0 (Bits 7:0 of BCRCPOL are 0xFF)
129:           
130:           // CONFIG16
131:           #pragma config BCRCSEEDT = hFF  // Boot Sector Seed for CRC on boot bits 31-24 (Bits 31:24 of BCRCSEED are 0xFF)
132:           
133:           // CONFIG17
134:           #pragma config BCRCSEEDU = hFF  // Boot Sector Seed for CRC on boot bits 23-16 (Bits 23:16 of BCRCSEED are 0xFF)
135:           
136:           // CONFIG18
137:           #pragma config BCRCSEEDH = hFF  // Boot Sector Seed for CRC on boot bits 15-8 (Bits 15:8 of BCRCSEED are 0xFF)
138:           
139:           // CONFIG19
140:           #pragma config BCRCSEEDL = hFF  // Boot Sector Seed for CRC on boot bits 7-0 (Bits 7:0 of BCRCSEED are 0xFF)
141:           
142:           // CONFIG20
143:           #pragma config BCRCEREST = hFF  // Boot Sector Expected Result for CRC on boot bits 31-24 (Bits 31:24 of BCRCERES are 0xFF)
144:           
145:           // CONFIG21
146:           #pragma config BCRCERESU = hFF  // Boot Sector Expected Result for CRC on boot bits 23-16 (Bits 23:16 of BCRCERES are 0xFF)
147:           
148:           // CONFIG22
149:           #pragma config BCRCERESH = hFF  // Boot Sector Expected Result for CRC on boot bits 15-8 (Bits 15:8 of BCRCERES are 0xFF)
150:           
151:           // CONFIG23
152:           #pragma config BCRCERESL = hFF  // Boot Sector Expected Result for CRC on boot bits 7-0 (Bits 7:0 of BCRCERES are 0xFF)
153:           
154:           // CONFIG24
155:           #pragma config CRCPOLT = hFF    // Non-Boot Sector Polynomial for CRC on boot bits 31-24 (Bits 31:24 of CRCPOL are 0xFF)
156:           
157:           // CONFIG25
158:           #pragma config CRCPOLU = hFF    // Non-Boot Sector Polynomial for CRC on boot bits 23-16 (Bits 23:16 of CRCPOL are 0xFF)
159:           
160:           // CONFIG26
161:           #pragma config CRCPOLH = hFF    // Non-Boot Sector Polynomial for CRC on boot bits 15-8 (Bits 15:8 of CRCPOL are 0xFF)
162:           
163:           // CONFIG27
164:           #pragma config CRCPOLL = hFF    // Non-Boot Sector Polynomial for CRC on boot bits 7-0 (Bits 7:0 of CRCPOL are 0xFF)
165:           
166:           // CONFIG28
167:           #pragma config CRCSEEDT = hFF   // Non-Boot Sector Seed for CRC on boot bits 31-24 (Bits 31:24 of CRCSEED are 0xFF)
168:           
169:           // CONFIG29
170:           #pragma config CRCSEEDU = hFF   // Non-Boot Sector Seed for CRC on boot bits 23-16 (Bits 23:16 of CRCSEED are 0xFF)
171:           
172:           // CONFIG30
173:           #pragma config CRCSEEDH = hFF   // Non-Boot Sector Seed for CRC on boot bits 15-8 (Bits 15:8 of CRCSEED are 0xFF)
174:           
175:           // CONFIG31
176:           #pragma config CRCSEEDL = hFF   // Non-Boot Sector Seed for CRC on boot bits 7-0 (Bits 7:0 of CRCSEED are 0xFF)
177:           
178:           // CONFIG32
179:           #pragma config CRCEREST = hFF   // Non-Boot Sector Expected Result for CRC on boot bits 31-24 (Bits 31:24 of CRCERES are 0xFF)
180:           
181:           // CONFIG33
182:           #pragma config CRCERESU = hFF   // Non-Boot Sector Expected Result for CRC on boot bits 23-16 (Bits 23:16 of CRCERES are 0xFF)
183:           
184:           // CONFIG34
185:           #pragma config CRCERESH = hFF   // Non-Boot Sector Expected Result for CRC on boot bits 15-8 (Bits 15:8 of CRCERES are 0xFF)
186:           
187:           // CONFIG35
188:           #pragma config CRCERESL = hFF   // Non-Boot Sector Expected Result for CRC on boot bits 7-0 (Bits 7:0 of CRCERES are 0xFF)
189:           
190:           // #pragma config statements should precede project file includes.
191:           // Use project enums instead of #define for ON and OFF.
192:           
193:           
194:           #include <xc.h>
195:           #include "mxcmd.h"
196:           #include "../timers.h"
197:           #include "../modbus_master.h"
198:           #include "../canfd.h"
199:           #include "../batmon.h"
200:           
201:           #define PACE            31000	// commands delay in count units
202:           #define CMD_LEN         8
203:           #define REC_LEN         5
204:           #define REC_STATUS_LEN	16
205:           #define REC_LOG_LEN     17
206:           
207:           enum state_type {
208:           	state_init,
209:           	state_status,
210:           	state_panel,
211:           	state_batteryv,
212:           	state_batterya,
213:           	state_watts,
214:           	state_fwrev,
215:           	state_time,
216:           	state_date,
217:           	state_mx_log,
218:           	state_misc,
219:           	state_mx_status,
220:           	state_last,
221:           };
222:           
223:           static uint16_t abuf[FM_BUFFER], cbuf[FM_BUFFER + 2];
224:           volatile uint16_t cc_mode = STATUS_LAST, mx_code = 0x00;
225:           uint16_t volt_whole, bat_amp_whole = AMP_WHOLE_ZERO, panel_watts, volt_fract, vf, vw;
226:           volatile enum state_type state = state_init;
227:           char buffer[MAX_B_BUF] = "Boot Init Display   ", can_buffer[MAX_C_BUF], info_buffer[MAX_B_BUF], log_buffer[MAX_B_BUF];
228:           const char *build_date = __DATE__, *build_time = __TIME__;
229:           volatile uint16_t tickCount[TMR_COUNT];
230:           uint8_t fw_state = 0;
231:           
232:           time_t can_timer = 1694196350; /* default epoch time */
233:           struct tm *can_newtime;
234:           
235:           #ifdef DATA_DEBUG
236:           bool show_can;
237:           uint8_t time_show_can;
238:           #endif
239:           
240:           B_type B = {
241:           	.one_sec_flag = false,
242:           	.ten_sec_flag = false,
243:           	.pacing = 0,
244:           	.rx_count = 0,
245:           	.flush = 0,
246:           	.canbus_online = 0,
247:           	.modbus_online = 0,
248:           	.log.select = 1,
249:           	.pv_high = false,
250:           	.pv_prev = STATUS_SLEEPING,
251:           	.pv_update = false,
252:           };
253:           
254:           static EB_data *EB = &EBD;
255:           
256:           /*
257:            * show fixed point fractions
258:            */
259:           static void volt_f(const uint16_t);
260:           
261:           /*
262:            * FM80 send/recv functions
263:            */
264:           static void send_mx_cmd(const uint16_t *);
265:           static void rec_mx_cmd(void (* DataHandler)(void), const uint8_t);
266:           
267:           /*
268:            * callbacks to handle FM80 register data
269:            */
270:           void state_init_cb(void);
271:           void state_status_cb(void);
272:           void state_panelv_cb(void);
273:           void state_batteryv_cb(void);
274:           void state_batterya_cb(void);
275:           void state_watts_cb(void);
276:           void state_misc_cb(void);
277:           void state_mx_status_cb(void);
278:           void state_mx_log_cb(void);
279:           static void state_fwrev_cb(void);
280:           static void state_time_cb(void);
281:           static void state_date_cb(void);
282:           
283:           /*
284:            * busy loop delay with WDT reset
285:            */
286:           void wdtdelay(const uint32_t delay)
0C1E  52E6     MOVF 0xFE6, F, ACCESS
0C20  52E6     MOVF 0xFE6, F, ACCESS
0C22  52E6     MOVF 0xFE6, F, ACCESS
0C24  52E6     MOVF 0xFE6, F, ACCESS
287:           {
288:           	uint32_t dcount;
289:           
290:           	for (dcount = 0; dcount <= delay; dcount++) { // delay a bit
0C26  0EFC     MOVLW 0xFC
0C28  6AE3     CLRF 0xFE3, ACCESS
0C2A  0EFD     MOVLW 0xFD
0C2C  6AE3     CLRF 0xFE3, ACCESS
0C2E  0EFE     MOVLW 0xFE
0C30  6AE3     CLRF 0xFE3, ACCESS
0C32  0EFF     MOVLW 0xFF
0C34  6AE3     CLRF 0xFE3, ACCESS
291:           		ClrWdt(); // reset the WDT timer
0C36  0004     CLRWDT
292:           	};
0C38  50E1     MOVF 0xFE1, W, ACCESS
0C3A  0FFC     ADDLW 0xFC
0C3C  6ED9     MOVWF 0xFD9, ACCESS
0C3E  50E2     MOVF 0xFE2, W, ACCESS
0C40  6EDA     MOVWF __end_of_UART2_tx_vect_isr, ACCESS
0C42  0EFF     MOVLW 0xFF
0C44  22DA     ADDWFC __end_of_UART2_tx_vect_isr, F, ACCESS
0C46  2ADE     INCF 0xFDE, F, ACCESS
0C48  0E00     MOVLW 0x0
0C4A  22DE     ADDWFC 0xFDE, F, ACCESS
0C4C  22DE     ADDWFC 0xFDE, F, ACCESS
0C4E  22DE     ADDWFC 0xFDE, F, ACCESS
0C50  50E1     MOVF 0xFE1, W, ACCESS
0C52  0FF8     ADDLW 0xF8
0C54  6ED9     MOVWF 0xFD9, ACCESS
0C56  50E2     MOVF 0xFE2, W, ACCESS
0C58  6EDA     MOVWF __end_of_UART2_tx_vect_isr, ACCESS
0C5A  0EFF     MOVLW 0xFF
0C5C  22DA     ADDWFC __end_of_UART2_tx_vect_isr, F, ACCESS
0C5E  0EFC     MOVLW 0xFC
0C60  50E3     MOVF 0xFE3, W, ACCESS
0C62  5CDE     SUBWF 0xFDE, W, ACCESS
0C64  0EFD     MOVLW 0xFD
0C66  50E3     MOVF 0xFE3, W, ACCESS
0C68  58DE     SUBWFB 0xFDE, W, ACCESS
0C6A  0EFE     MOVLW 0xFE
0C6C  50E3     MOVF 0xFE3, W, ACCESS
0C6E  58DE     SUBWFB 0xFDE, W, ACCESS
0C70  0EFF     MOVLW 0xFF
0C72  50E3     MOVF 0xFE3, W, ACCESS
0C74  58DE     SUBWFB 0xFDE, W, ACCESS
0C76  B0D8     BTFSC 0xFD8, 0, ACCESS
0C78  D7DE     BRA 0xC36
293:           }
0C7A  0EF8     MOVLW 0xF8
0C7A  0EF8     MOVLW 0xF8
0C7A  0EF8     MOVLW 0xF8
0C7A  0EF8     MOVLW 0xF8
0C7A  0EF8     MOVLW 0xF8
294:           
295:           /*
296:            * Main application
297:            */
298:           void main(void)
14618  0E17     MOVLW 0x17
1461A  26E1     ADDWF 0xFE1, F, ACCESS
1461C  0E00     MOVLW 0x0
1461E  22E2     ADDWFC 0xFE2, F, ACCESS
299:           {
300:           	// Initialize the device
301:           	SYSTEM_Initialize();
14620  ECFC     CALL 0x15F8, 0
14622  F00A     NOP
302:           
303:           	/*
304:           	 * complete and correct the MCC CANBUS configuration
305:           	 */
306:           	can_setup();
14624  EC75     CALL 0xCEA, 0
14626  F006     NOP
307:           
308:           	// If using interrupts in PIC18 High/Low Priority Mode you need to enable the Global High and Low Interrupts
309:           	// If using interrupts in PIC Mid-Range Compatibility Mode you need to enable the Global Interrupts
310:           	// Use the following macros to:
311:           
312:           	// Enable high priority global interrupts
313:           	INTERRUPT_GlobalInterruptHighEnable();
14628  8ED6     BSF 0xFD6, 7, ACCESS
314:           
315:           	// Enable low priority global interrupts.
316:           	INTERRUPT_GlobalInterruptLowEnable();
1462A  8CD6     BSF 0xFD6, 6, ACCESS
317:           
318:           	// Disable high priority global interrupts
319:           	//INTERRUPT_GlobalInterruptHighDisable();
320:           
321:           	// Disable low priority global interrupts.
322:           	//INTERRUPT_GlobalInterruptLowDisable();
323:           
324:           	TMR4_SetInterruptHandler(FM_io);
1462C  0EC0     MOVLW 0xC0
1462E  6EE6     MOVWF 0xFE6, ACCESS
14630  0EDA     MOVLW 0xDA
14632  6EE6     MOVWF 0xFE6, ACCESS
14634  0E01     MOVLW 0x1
14636  6EE6     MOVWF 0xFE6, ACCESS
14638  ECF4     CALL 0x21E8, 0
1463A  F010     NOP
325:           	TMR4_StartTimer();
1463C  ECA9     CALL 0x2752, 0
1463E  F013     NOP
326:           	TMR0_SetInterruptHandler(onesec_io);
14640  0E82     MOVLW 0x82
14642  6EE6     MOVWF 0xFE6, ACCESS
14644  0E16     MOVLW 0x16
14646  6EE6     MOVWF 0xFE6, ACCESS
14648  0E00     MOVLW 0x0
1464A  6EE6     MOVWF 0xFE6, ACCESS
1464C  EC16     CALL 0x222C, 0
1464E  F011     NOP
327:           	TMR0_StartTimer();
14650  ECB5     CALL 0x276A, 0
14652  F013     NOP
328:           	TMR2_SetInterruptHandler(tensec_io);
14654  0E4E     MOVLW 0x4E
14656  6EE6     MOVWF 0xFE6, ACCESS
14658  0E0D     MOVLW 0xD
1465A  6EE6     MOVWF 0xFE6, ACCESS
1465C  0E00     MOVLW 0x0
1465E  6EE6     MOVWF 0xFE6, ACCESS
14660  EC05     CALL 0x220A, 0
14662  F011     NOP
329:           	TMR2_StartTimer();
14664  ECAF     CALL 0x275E, 0
14666  F013     NOP
330:           
331:           #ifdef MB_MASTER
332:           	init_mb_master_timers(); // pacing, spacing and timeouts
14668  EC25     CALL 0x1E4A, 0
1466A  F00F     NOP
333:           	UART5_SetRxInterruptHandler(my_modbus_rx_32); // install custom serial receive ISR
1466C  0EC6     MOVLW 0xC6
1466E  6EE6     MOVWF 0xFE6, ACCESS
14670  0E16     MOVLW 0x16
14672  6EE6     MOVWF 0xFE6, ACCESS
14674  0E00     MOVLW 0x0
14676  6EE6     MOVWF 0xFE6, ACCESS
14678  EC39     CALL 0x2072, 0
1467A  F010     NOP
334:           	StartTimer(TMR_MBTEST, 20);
1467C  0E14     MOVLW 0x14
1467E  6EE6     MOVWF 0xFE6, ACCESS
14680  0E00     MOVLW 0x0
14682  6EE6     MOVWF 0xFE6, ACCESS
14684  0E02     MOVLW 0x2
14686  6EE6     MOVWF 0xFE6, ACCESS
14688  ECE7     CALL 0x17CE, 0
1468A  F00B     NOP
335:           	void mb_setup(); // serial error handlers
336:           #endif
337:           	StartTimer(TMR_SPIN, SPINNER_SPEED);
1468C  0EC8     MOVLW 0xC8
1468E  6EE6     MOVWF 0xFE6, ACCESS
14690  0E00     MOVLW 0x0
14692  6EE6     MOVWF 0xFE6, ACCESS
14694  0E03     MOVLW 0x3
14696  6EE6     MOVWF 0xFE6, ACCESS
14698  ECE7     CALL 0x17CE, 0
1469A  F00B     NOP
338:           
339:           	init_display();
1469C  EC16     CALL 0x1F22C, 0
1469E  F0F9     NOP
340:           	snprintf(buffer, MAX_B_BUF, "%s   ", build_version);
146A0  0EF1     MOVLW 0xF1
146A2  6EE6     MOVWF 0xFE6, ACCESS
146A4  0EFB     MOVLW 0xFB
146A6  6EE6     MOVWF 0xFE6, ACCESS
146A8  0ED9     MOVLW 0xD9
146AA  6EE6     MOVWF 0xFE6, ACCESS
146AC  0EFF     MOVLW 0xFF
146AE  6EE6     MOVWF 0xFE6, ACCESS
146B0  0EFF     MOVLW 0xFF
146B2  6EE6     MOVWF 0xFE6, ACCESS
146B4  0E00     MOVLW 0x0
146B6  6EE6     MOVWF 0xFE6, ACCESS
146B8  0E00     MOVLW 0x0
146BA  6EE6     MOVWF 0xFE6, ACCESS
146BC  0E0B     MOVLW 0xB
146BE  6EE6     MOVWF 0xFE6, ACCESS
146C0  0E08     MOVLW 0x8
146C2  6EE6     MOVWF 0xFE6, ACCESS
146C4  EC35     CALL 0x1C06A, 0
146C6  F0E0     NOP
341:           	eaDogM_WriteStringAtPos(0, 0, buffer);
146C8  0E00     MOVLW 0x0
146CA  6EE6     MOVWF 0xFE6, ACCESS
146CC  0E0B     MOVLW 0xB
146CE  6EE6     MOVWF 0xFE6, ACCESS
146D0  0E00     MOVLW 0x0
146D2  6EE6     MOVWF 0xFE6, ACCESS
146D4  0E00     MOVLW 0x0
146D6  6EE6     MOVWF 0xFE6, ACCESS
146D8  ECD9     CALL 0x1B2, 0
146DA  F000     NOP
342:           	snprintf(buffer, MAX_B_BUF, "%s   ", build_date);
146DC  0EAC     MOVLW 0xAC
146DE  6EE6     MOVWF 0xFE6, ACCESS
146E0  0EFF     MOVLW 0xFF
146E2  6EE6     MOVWF 0xFE6, ACCESS
146E4  0ED9     MOVLW 0xD9
146E6  6EE6     MOVWF 0xFE6, ACCESS
146E8  0EFF     MOVLW 0xFF
146EA  6EE6     MOVWF 0xFE6, ACCESS
146EC  0EFF     MOVLW 0xFF
146EE  6EE6     MOVWF 0xFE6, ACCESS
146F0  0E00     MOVLW 0x0
146F2  6EE6     MOVWF 0xFE6, ACCESS
146F4  0E00     MOVLW 0x0
146F6  6EE6     MOVWF 0xFE6, ACCESS
146F8  0E0B     MOVLW 0xB
146FA  6EE6     MOVWF 0xFE6, ACCESS
146FC  0E08     MOVLW 0x8
146FE  6EE6     MOVWF 0xFE6, ACCESS
14700  EC35     CALL 0x1C06A, 0
14702  F0E0     NOP
343:           	eaDogM_WriteStringAtPos(1, 0, buffer);
14704  0E00     MOVLW 0x0
14706  6EE6     MOVWF 0xFE6, ACCESS
14708  0E0B     MOVLW 0xB
1470A  6EE6     MOVWF 0xFE6, ACCESS
1470C  0E00     MOVLW 0x0
1470E  6EE6     MOVWF 0xFE6, ACCESS
14710  0E01     MOVLW 0x1
14712  6EE6     MOVWF 0xFE6, ACCESS
14714  ECD9     CALL 0x1B2, 0
14716  F000     NOP
344:           	if (initbm_data((void*) EB)) {
14718  0E00     MOVLW 0x0
1471A  6EE6     MOVWF 0xFE6, ACCESS
1471C  0E08     MOVLW 0x8
1471E  6EE6     MOVWF 0xFE6, ACCESS
14720  EC15     CALL 0x1E82A, 0
14722  F0F4     NOP
14724  5001     MOVF __ptext283, W, ACCESS
14726  B4D8     BTFSC 0xFD8, 2, ACCESS
14728  D013     BRA 0x4750
345:           		B.alt_display = EB->alt_display;
1472A  C802     MOVFF 0x802, 0x573
1472C  F573     NOP
346:           		snprintf(buffer, MAX_B_BUF, "Battery data loaded   ");
1472E  0E76     MOVLW 0x76
14730  6EE6     MOVWF 0xFE6, ACCESS
14732  0EFE     MOVLW 0xFE
14734  6EE6     MOVWF 0xFE6, ACCESS
14736  0EFF     MOVLW 0xFF
14738  6EE6     MOVWF 0xFE6, ACCESS
1473A  0E00     MOVLW 0x0
1473C  6EE6     MOVWF 0xFE6, ACCESS
1473E  0E00     MOVLW 0x0
14740  6EE6     MOVWF 0xFE6, ACCESS
14742  0E0B     MOVLW 0xB
14744  6EE6     MOVWF 0xFE6, ACCESS
14746  0E06     MOVLW 0x6
14748  6EE6     MOVWF 0xFE6, ACCESS
1474A  EC35     CALL 0x1C06A, 0
1474C  F0E0     NOP
347:           	} else {
1474E  D020     BRA 0x4790
348:           		/* display build time and boot status codes 67 34 07, WDT reset 67 24 07 */
349:           		snprintf(buffer, MAX_B_BUF, "%s B:%X %X %X   ", build_time, STATUS, PCON0, PCON1);
14750  50F1     MOVF 0xFF1, W, ACCESS
14752  6EE6     MOVWF 0xFE6, ACCESS
14754  0E00     MOVLW 0x0
14756  6EE6     MOVWF 0xFE6, ACCESS
14758  50F0     MOVF 0xFF0, W, ACCESS
1475A  6EE6     MOVWF 0xFE6, ACCESS
1475C  0E00     MOVLW 0x0
1475E  6EE6     MOVWF 0xFE6, ACCESS
14760  50D8     MOVF 0xFD8, W, ACCESS
14762  6EE6     MOVWF 0xFE6, ACCESS
14764  0E00     MOVLW 0x0
14766  6EE6     MOVWF 0xFE6, ACCESS
14768  0EC3     MOVLW 0xC3
1476A  6EE6     MOVWF 0xFE6, ACCESS
1476C  0EFF     MOVLW 0xFF
1476E  6EE6     MOVWF 0xFE6, ACCESS
14770  0E6F     MOVLW 0x6F
14772  6EE6     MOVWF 0xFE6, ACCESS
14774  0EFF     MOVLW 0xFF
14776  6EE6     MOVWF 0xFE6, ACCESS
14778  0EFF     MOVLW 0xFF
1477A  6EE6     MOVWF 0xFE6, ACCESS
1477C  0E00     MOVLW 0x0
1477E  6EE6     MOVWF 0xFE6, ACCESS
14780  0E00     MOVLW 0x0
14782  6EE6     MOVWF 0xFE6, ACCESS
14784  0E0B     MOVLW 0xB
14786  6EE6     MOVWF 0xFE6, ACCESS
14788  0E0E     MOVLW 0xE
1478A  6EE6     MOVWF 0xFE6, ACCESS
1478C  EC35     CALL 0x1C06A, 0
1478E  F0E0     NOP
350:           	}
351:           	eaDogM_WriteStringAtPos(2, 0, buffer);
14790  0E00     MOVLW 0x0
14792  6EE6     MOVWF 0xFE6, ACCESS
14794  0E0B     MOVLW 0xB
14796  6EE6     MOVWF 0xFE6, ACCESS
14798  0E00     MOVLW 0x0
1479A  6EE6     MOVWF 0xFE6, ACCESS
1479C  0E02     MOVLW 0x2
1479E  6EE6     MOVWF 0xFE6, ACCESS
147A0  ECD9     CALL 0x1B2, 0
147A2  F000     NOP
352:           	snprintf(buffer, MAX_B_BUF, "%s ", "Start Up            ");
147A4  0EA3     MOVLW 0xA3
147A6  6EE6     MOVWF 0xFE6, ACCESS
147A8  0EFE     MOVLW 0xFE
147AA  6EE6     MOVWF 0xFE6, ACCESS
147AC  0EF7     MOVLW 0xF7
147AE  6EE6     MOVWF 0xFE6, ACCESS
147B0  0EFF     MOVLW 0xFF
147B2  6EE6     MOVWF 0xFE6, ACCESS
147B4  0EFF     MOVLW 0xFF
147B6  6EE6     MOVWF 0xFE6, ACCESS
147B8  0E00     MOVLW 0x0
147BA  6EE6     MOVWF 0xFE6, ACCESS
147BC  0E00     MOVLW 0x0
147BE  6EE6     MOVWF 0xFE6, ACCESS
147C0  0E0B     MOVLW 0xB
147C2  6EE6     MOVWF 0xFE6, ACCESS
147C4  0E08     MOVLW 0x8
147C6  6EE6     MOVWF 0xFE6, ACCESS
147C8  EC35     CALL 0x1C06A, 0
147CA  F0E0     NOP
353:           	eaDogM_WriteStringAtPos(3, 0, buffer);
147CC  0E00     MOVLW 0x0
147CE  6EE6     MOVWF 0xFE6, ACCESS
147D0  0E0B     MOVLW 0xB
147D2  6EE6     MOVWF 0xFE6, ACCESS
147D4  0E00     MOVLW 0x0
147D6  6EE6     MOVWF 0xFE6, ACCESS
147D8  0E03     MOVLW 0x3
147DA  6EE6     MOVWF 0xFE6, ACCESS
147DC  ECD9     CALL 0x1B2, 0
147DE  F000     NOP
354:           	wdtdelay(1000000);
147E0  0E40     MOVLW 0x40
147E2  6EE6     MOVWF 0xFE6, ACCESS
147E4  0E42     MOVLW 0x42
147E6  6EE6     MOVWF 0xFE6, ACCESS
147E8  0E0F     MOVLW 0xF
147EA  6EE6     MOVWF 0xFE6, ACCESS
147EC  0E00     MOVLW 0x0
147EE  6EE6     MOVWF 0xFE6, ACCESS
147F0  EC0F     CALL 0xC1E, 0
147F2  F006     NOP
355:           	snprintf(buffer, MAX_B_BUF, "%s ", "Polling FM80        ");
147F4  0ECD     MOVLW 0xCD
147F6  6EE6     MOVWF 0xFE6, ACCESS
147F8  0EFE     MOVLW 0xFE
147FA  6EE6     MOVWF 0xFE6, ACCESS
147FC  0EF7     MOVLW 0xF7
147FE  6EE6     MOVWF 0xFE6, ACCESS
14800  0EFF     MOVLW 0xFF
14802  6EE6     MOVWF 0xFE6, ACCESS
14804  0EFF     MOVLW 0xFF
14806  6EE6     MOVWF 0xFE6, ACCESS
14808  0E00     MOVLW 0x0
1480A  6EE6     MOVWF 0xFE6, ACCESS
1480C  0E00     MOVLW 0x0
1480E  6EE6     MOVWF 0xFE6, ACCESS
14810  0E0B     MOVLW 0xB
14812  6EE6     MOVWF 0xFE6, ACCESS
14814  0E08     MOVLW 0x8
14816  6EE6     MOVWF 0xFE6, ACCESS
14818  EC35     CALL 0x1C06A, 0
1481A  F0E0     NOP
356:           	eaDogM_WriteStringAtPos(2, 0, buffer);
1481C  0E00     MOVLW 0x0
1481E  6EE6     MOVWF 0xFE6, ACCESS
14820  0E0B     MOVLW 0xB
14822  6EE6     MOVWF 0xFE6, ACCESS
14824  0E00     MOVLW 0x0
14826  6EE6     MOVWF 0xFE6, ACCESS
14828  0E02     MOVLW 0x2
1482A  6EE6     MOVWF 0xFE6, ACCESS
1482C  ECD9     CALL 0x1B2, 0
1482E  F000     NOP
357:           
358:           	can_fd_tx(); // send the testing packet via CANBUS
14830  EC10     CALL 0x1B820, 0
14832  F0DC     NOP
359:           
360:           	/*
361:           	 * read and store the CPU_ID for PCB tracing
362:           	 */
363:           	for (uint8_t i = 0; i <= 8; i++) {
14834  0EFF     MOVLW 0xFF
14836  6AE3     CLRF 0xFE3, ACCESS
364:           		B.mui[i] = DeviceID_Read(DIA_MUI + (i * 2)); // Read CPU ID from memory and store in array
14838  0EFF     MOVLW 0xFF
1483A  50E3     MOVF 0xFE3, W, ACCESS
1483C  0D02     MULLW 0x2
1483E  0061     MOVFFL PROD, ltemp2
14840  F3CC     NOP
14842  F509     NOP
14844  0061     MOVFFL PRODH, ttemp3
14846  F3D0     NOP
14848  F50A     NOP
1484A  0E00     MOVLW 0x0
1484C  BE0A     BTFSC 0xA, 7, ACCESS
1484E  0EFF     MOVLW 0xFF
14850  6E0B     MOVWF 0xB, ACCESS
14852  6E0C     MOVWF 0xC, ACCESS
14854  0E00     MOVLW 0x0
14856  2409     ADDWF 0x9, W, ACCESS
14858  6E04     MOVWF __activetblptr, ACCESS
1485A  0E00     MOVLW 0x0
1485C  200A     ADDWFC 0xA, W, ACCESS
1485E  6E05     MOVWF 0x5, ACCESS
14860  0E2C     MOVLW 0x2C
14862  200B     ADDWFC 0xB, W, ACCESS
14864  6E06     MOVWF 0x6, ACCESS
14866  0061     MOVFFL ttemp1, POSTINC1
14868  F410     NOP
1486A  F4E6     NOP
1486C  0061     MOVFFL ltemp1, POSTINC1
1486E  F414     NOP
14870  F4E6     NOP
14872  0061     MOVFFL 0x506, POSTINC1
14874  F418     NOP
14876  F4E6     NOP
14878  EC02     CALL 0x1DC04, 0
1487A  F0EE     NOP
1487C  0EFF     MOVLW 0xFF
1487E  50E3     MOVF 0xFE3, W, ACCESS
14880  0D02     MULLW 0x2
14882  0E7C     MOVLW 0x7C
14884  24F3     ADDWF 0xFF3, W, ACCESS
14886  6ED9     MOVWF 0xFD9, ACCESS
14888  0E05     MOVLW 0x5
1488A  20F4     ADDWFC 0xFF4, W, ACCESS
1488C  6EDA     MOVWF __end_of_UART2_tx_vect_isr, ACCESS
1488E  0061     MOVFFL ltemp0, POSTINC2
14890  F404     NOP
14892  F4DE     NOP
14894  0061     MOVFFL ttemp5, POSTDEC2
14896  F408     NOP
14898  F4DD     NOP
365:           	}
1489A  0EFF     MOVLW 0xFF
1489C  2AE3     INCF 0xFE3, F, ACCESS
1489E  0EFF     MOVLW 0xFF
148A0  0061     MOVFFL PLUSW1, ltemp0
148A2  F38C     NOP
148A4  F501     NOP
148A6  0E08     MOVLW 0x8
148A8  6401     CPFSGT __ptext283, ACCESS
148AA  D7C6     BRA 0x4838
366:           	{
367:           		char s_buffer[22];
368:           		snprintf(s_buffer, 21, "0X%X%X%X%X%X%X%X%X         ", B.mui[0], B.mui[1], B.mui[2], B.mui[3], B.mui[4], B.mui[5], B.mui[6], B.mui[7]);
148AC  C58A     MOVFF 0x58A, POSTINC1
148AE  F4E6     NOP
148B0  C58B     MOVFF 0x58B, POSTINC1
148B2  F4E6     NOP
148B4  C588     MOVFF 0x588, POSTINC1
148B6  F4E6     NOP
148B8  C589     MOVFF 0x589, POSTINC1
148BA  F4E6     NOP
148BC  C586     MOVFF 0x586, POSTINC1
148BE  F4E6     NOP
148C0  C587     MOVFF 0x587, POSTINC1
148C2  F4E6     NOP
148C4  C584     MOVFF 0x584, POSTINC1
148C6  F4E6     NOP
148C8  C585     MOVFF 0x585, POSTINC1
148CA  F4E6     NOP
148CC  C582     MOVFF 0x582, POSTINC1
148CE  F4E6     NOP
148D0  C583     MOVFF 0x583, POSTINC1
148D2  F4E6     NOP
148D4  C580     MOVFF 0x580, POSTINC1
148D6  F4E6     NOP
148D8  C581     MOVFF 0x581, POSTINC1
148DA  F4E6     NOP
148DC  C57E     MOVFF 0x57E, POSTINC1
148DE  F4E6     NOP
148E0  C57F     MOVFF 0x57F, POSTINC1
148E2  F4E6     NOP
148E4  C57C     MOVFF 0x57C, POSTINC1
148E6  F4E6     NOP
148E8  C57D     MOVFF 0x57D, POSTINC1
148EA  F4E6     NOP
148EC  0E2A     MOVLW 0x2A
148EE  6EE6     MOVWF 0xFE6, ACCESS
148F0  0EFD     MOVLW 0xFD
148F2  6EE6     MOVWF 0xFE6, ACCESS
148F4  0E15     MOVLW 0x15
148F6  6EE6     MOVWF 0xFE6, ACCESS
148F8  0E00     MOVLW 0x0
148FA  6EE6     MOVWF 0xFE6, ACCESS
148FC  0ED5     MOVLW 0xD5
148FE  24E1     ADDWF 0xFE1, W, ACCESS
14900  6E01     MOVWF __ptext283, ACCESS
14902  0EFF     MOVLW 0xFF
14904  20E2     ADDWFC 0xFE2, W, ACCESS
14906  6E02     MOVWF ___rparam_used, ACCESS
14908  0061     MOVFFL ltemp0, POSTINC1
1490A  F404     NOP
1490C  F4E6     NOP
1490E  0061     MOVFFL ttemp5, POSTINC1
14910  F408     NOP
14912  F4E6     NOP
14914  0E16     MOVLW 0x16
14916  6EE6     MOVWF 0xFE6, ACCESS
14918  EC35     CALL 0x1C06A, 0
1491A  F0E0     NOP
369:           		eaDogM_Scroll_String(s_buffer);
1491C  0EE9     MOVLW 0xE9
1491E  24E1     ADDWF 0xFE1, W, ACCESS
14920  6E01     MOVWF __ptext283, ACCESS
14922  0EFF     MOVLW 0xFF
14924  20E2     ADDWFC 0xFE2, W, ACCESS
14926  6E02     MOVWF ___rparam_used, ACCESS
14928  0061     MOVFFL ltemp0, POSTINC1
1492A  F404     NOP
1492C  F4E6     NOP
1492E  0061     MOVFFL ttemp5, POSTINC1
14930  F408     NOP
14932  F4E6     NOP
14934  ECB1     CALL 0x1FF62, 0
14936  F0FF     NOP
370:           		can_newtime = localtime(&can_timer);
14938  0EFA     MOVLW 0xFA
1493A  6EE6     MOVWF 0xFE6, ACCESS
1493C  0E06     MOVLW 0x6
1493E  6EE6     MOVWF 0xFE6, ACCESS
14940  ECC1     CALL 0x2582, 0
14942  F012     NOP
14944  0061     MOVFFL ltemp0, can_newtime
14946  F404     NOP
14948  F5CD     NOP
1494A  0061     MOVFFL ttemp5, 0x5CE
1494C  F408     NOP
1494E  F5CE     NOP
371:           #ifdef SDEBUG
372:           		snprintf(s_buffer, 21, "%s", asctime(can_newtime));
373:           		eaDogM_Scroll_String(s_buffer);
374:           		snprintf(s_buffer, 21, "CheckSum %X", calc_checksum((uint8_t *) & cmd_panelv[1], 10));
375:           		eaDogM_Scroll_String(s_buffer);
376:           #endif
377:           	}
378:           	while (true) {
379:           #ifdef TRACE
380:           		IO_RD5_SetHigh(); // main loop timing
14950  8AC1     BSF 0xFC1, 5, ACCESS
381:           #endif
382:           		// Add your application code
383:           #ifdef MB_MASTER
384:           		master_controller_work(&C); // master MODBUS processing
14952  0E44     MOVLW 0x44
14954  6EE6     MOVWF 0xFE6, ACCESS
14956  0E08     MOVLW 0x8
14958  6EE6     MOVWF 0xFE6, ACCESS
1495A  ECC3     CALL 0x15186, 0
1495C  F0A8     NOP
385:           #endif
386:           		switch (state) {
1495E  D0F8     BRA 0x4B50
387:           		case state_init:
388:           			send_mx_cmd(cmd_id);
14960  0EE1     MOVLW 0xE1
14962  6EE6     MOVWF 0xFE6, ACCESS
14964  0EFB     MOVLW 0xFB
14966  6EE6     MOVWF 0xFE6, ACCESS
14968  EC85     CALL 0x170A, 0
1496A  F00B     NOP
389:           			rec_mx_cmd(state_init_cb, REC_LEN);
1496C  0E05     MOVLW 0x5
1496E  6EE6     MOVWF 0xFE6, ACCESS
14970  0E5A     MOVLW 0x5A
14972  6EE6     MOVWF 0xFE6, ACCESS
14974  0EC2     MOVLW 0xC2
14976  6EE6     MOVWF 0xFE6, ACCESS
14978  0E01     MOVLW 0x1
1497A  6EE6     MOVWF 0xFE6, ACCESS
1497C  EC09     CALL 0x1E612, 0
1497E  F0F3     NOP
390:           			break;
14980  D115     BRA 0x4BAC
391:           		case state_status:
392:           			send_mx_cmd(cmd_status);
14982  0ED1     MOVLW 0xD1
14984  6EE6     MOVWF 0xFE6, ACCESS
14986  0EFB     MOVLW 0xFB
14988  6EE6     MOVWF 0xFE6, ACCESS
1498A  EC85     CALL 0x170A, 0
1498C  F00B     NOP
393:           			rec_mx_cmd(state_status_cb, REC_LEN);
1498E  0E05     MOVLW 0x5
14990  6EE6     MOVWF 0xFE6, ACCESS
14992  0EC6     MOVLW 0xC6
14994  6EE6     MOVWF 0xFE6, ACCESS
14996  0EFC     MOVLW 0xFC
14998  6EE6     MOVWF 0xFE6, ACCESS
1499A  0E01     MOVLW 0x1
1499C  6EE6     MOVWF 0xFE6, ACCESS
1499E  EC09     CALL 0x1E612, 0
149A0  F0F3     NOP
394:           			break;
149A2  D104     BRA 0x4BAC
395:           		case state_panel:
396:           			send_mx_cmd(cmd_panelv);
149A4  0EB1     MOVLW 0xB1
149A6  6EE6     MOVWF 0xFE6, ACCESS
149A8  0EFB     MOVLW 0xFB
149AA  6EE6     MOVWF 0xFE6, ACCESS
149AC  EC85     CALL 0x170A, 0
149AE  F00B     NOP
397:           			rec_mx_cmd(state_panelv_cb, REC_LEN);
149B0  0E05     MOVLW 0x5
149B2  6EE6     MOVWF 0xFE6, ACCESS
149B4  0E06     MOVLW 0x6
149B6  6EE6     MOVWF 0xFE6, ACCESS
149B8  0E27     MOVLW 0x27
149BA  6EE6     MOVWF 0xFE6, ACCESS
149BC  0E00     MOVLW 0x0
149BE  6EE6     MOVWF 0xFE6, ACCESS
149C0  EC09     CALL 0x1E612, 0
149C2  F0F3     NOP
398:           			break;
149C4  D0F3     BRA 0x4BAC
399:           		case state_batteryv:
400:           			send_mx_cmd(cmd_batteryv);
149C6  0EA1     MOVLW 0xA1
149C8  6EE6     MOVWF 0xFE6, ACCESS
149CA  0EFB     MOVLW 0xFB
149CC  6EE6     MOVWF 0xFE6, ACCESS
149CE  EC85     CALL 0x170A, 0
149D0  F00B     NOP
401:           			rec_mx_cmd(state_batteryv_cb, REC_LEN);
149D2  0E05     MOVLW 0x5
149D4  6EE6     MOVWF 0xFE6, ACCESS
149D6  0E44     MOVLW 0x44
149D8  6EE6     MOVWF 0xFE6, ACCESS
149DA  0E1F     MOVLW 0x1F
149DC  6EE6     MOVWF 0xFE6, ACCESS
149DE  0E00     MOVLW 0x0
149E0  6EE6     MOVWF 0xFE6, ACCESS
149E2  EC09     CALL 0x1E612, 0
149E4  F0F3     NOP
402:           			break;
149E6  D0E2     BRA 0x4BAC
403:           		case state_batterya:
404:           			send_mx_cmd(cmd_batterya);
149E8  0E91     MOVLW 0x91
149EA  6EE6     MOVWF 0xFE6, ACCESS
149EC  0EFB     MOVLW 0xFB
149EE  6EE6     MOVWF 0xFE6, ACCESS
149F0  EC85     CALL 0x170A, 0
149F2  F00B     NOP
405:           			rec_mx_cmd(state_batterya_cb, REC_LEN);
149F4  0E05     MOVLW 0x5
149F6  6EE6     MOVWF 0xFE6, ACCESS
149F8  0E1C     MOVLW 0x1C
149FA  6EE6     MOVWF 0xFE6, ACCESS
149FC  0E1F     MOVLW 0x1F
149FE  6EE6     MOVWF 0xFE6, ACCESS
14A00  0E00     MOVLW 0x0
14A02  6EE6     MOVWF 0xFE6, ACCESS
14A04  EC09     CALL 0x1E612, 0
14A06  F0F3     NOP
406:           			break;
14A08  D0D1     BRA 0x4BAC
407:           		case state_watts:
408:           			send_mx_cmd(cmd_watts);
14A0A  0E81     MOVLW 0x81
14A0C  6EE6     MOVWF 0xFE6, ACCESS
14A0E  0EFB     MOVLW 0xFB
14A10  6EE6     MOVWF 0xFE6, ACCESS
14A12  EC85     CALL 0x170A, 0
14A14  F00B     NOP
409:           			rec_mx_cmd(state_watts_cb, REC_LEN);
14A16  0E05     MOVLW 0x5
14A18  6EE6     MOVWF 0xFE6, ACCESS
14A1A  0E6E     MOVLW 0x6E
14A1C  6EE6     MOVWF 0xFE6, ACCESS
14A1E  0E1D     MOVLW 0x1D
14A20  6EE6     MOVWF 0xFE6, ACCESS
14A22  0E00     MOVLW 0x0
14A24  6EE6     MOVWF 0xFE6, ACCESS
14A26  EC09     CALL 0x1E612, 0
14A28  F0F3     NOP
410:           			break;
14A2A  D0C0     BRA 0x4BAC
411:           		case state_mx_status: // wait for ten second flag in this state for logging
412:           			send_mx_cmd(cmd_mx_status);
14A2C  0EC1     MOVLW 0xC1
14A2E  6EE6     MOVWF 0xFE6, ACCESS
14A30  0EFB     MOVLW 0xFB
14A32  6EE6     MOVWF 0xFE6, ACCESS
14A34  EC85     CALL 0x170A, 0
14A36  F00B     NOP
413:           			rec_mx_cmd(state_mx_status_cb, REC_STATUS_LEN);
14A38  0E10     MOVLW 0x10
14A3A  6EE6     MOVWF 0xFE6, ACCESS
14A3C  0EA6     MOVLW 0xA6
14A3E  6EE6     MOVWF 0xFE6, ACCESS
14A40  0E67     MOVLW 0x67
14A42  6EE6     MOVWF 0xFE6, ACCESS
14A44  0E01     MOVLW 0x1
14A46  6EE6     MOVWF 0xFE6, ACCESS
14A48  EC09     CALL 0x1E612, 0
14A4A  F0F3     NOP
414:           			break;
14A4C  D0AF     BRA 0x4BAC
415:           		case state_fwrev:
416:           			switch (fw_state) {
417:           			case 0:
418:           				send_mx_cmd(cmd_fwreva);
14A4E  0E61     MOVLW 0x61
14A50  6EE6     MOVWF 0xFE6, ACCESS
14A52  0EFB     MOVLW 0xFB
14A54  6EE6     MOVWF 0xFE6, ACCESS
14A56  EC85     CALL 0x170A, 0
14A58  F00B     NOP
419:           				rec_mx_cmd(state_fwrev_cb, REC_LEN);
14A5A  0E05     MOVLW 0x5
14A5C  6EE6     MOVWF 0xFE6, ACCESS
14A5E  0E4A     MOVLW 0x4A
14A60  6EE6     MOVWF 0xFE6, ACCESS
14A62  0E1B     MOVLW 0x1B
14A64  6EE6     MOVWF 0xFE6, ACCESS
14A66  0E00     MOVLW 0x0
14A68  6EE6     MOVWF 0xFE6, ACCESS
14A6A  EC09     CALL 0x1E612, 0
14A6C  F0F3     NOP
420:           				break;
14A6E  D09E     BRA 0x4BAC
421:           			case 1:
422:           				send_mx_cmd(cmd_fwrevb);
14A70  0E51     MOVLW 0x51
14A72  6EE6     MOVWF 0xFE6, ACCESS
14A74  0EFB     MOVLW 0xFB
14A76  6EE6     MOVWF 0xFE6, ACCESS
14A78  EC85     CALL 0x170A, 0
14A7A  F00B     NOP
14A7C  D7EE     BRA 0x4A5A
423:           				rec_mx_cmd(state_fwrev_cb, REC_LEN);
424:           				break;
425:           			case 2:
426:           				send_mx_cmd(cmd_fwrevc);
14A7E  0E41     MOVLW 0x41
14A80  6EE6     MOVWF 0xFE6, ACCESS
14A82  0EFB     MOVLW 0xFB
14A84  6EE6     MOVWF 0xFE6, ACCESS
14A86  EC85     CALL 0x170A, 0
14A88  F00B     NOP
427:           				rec_mx_cmd(state_fwrev_cb, REC_LEN);
14A8A  0E05     MOVLW 0x5
14A8C  6EE6     MOVWF 0xFE6, ACCESS
14A8E  0E4A     MOVLW 0x4A
14A90  6EE6     MOVWF 0xFE6, ACCESS
14A92  0E1B     MOVLW 0x1B
14A94  6EE6     MOVWF 0xFE6, ACCESS
14A96  0E00     MOVLW 0x0
14A98  6EE6     MOVWF 0xFE6, ACCESS
14A9A  EC09     CALL 0x1E612, 0
14A9C  F0F3     NOP
428:           			default:
429:           				fw_state = 0;
14A9E  0105     MOVLB 0x5
14AA0  6BE2     CLRF 0xE2, BANKED
430:           				break;
14AA2  D084     BRA 0x4BAC
431:           			}
14AA4  51E2     MOVF 0xE2, W, BANKED
14AA6  6E0B     MOVWF 0xB, ACCESS
14AA8  6A0C     CLRF 0xC, ACCESS
14AAA  500C     MOVF 0xC, W, ACCESS
14AAC  0A00     XORLW 0x0
14AAE  A4D8     BTFSS 0xFD8, 2, ACCESS
14AB0  D7F6     BRA 0x4A9E
14AB2  500B     MOVF 0xB, W, ACCESS
14AB4  0A00     XORLW 0x0
14AB6  B4D8     BTFSC 0xFD8, 2, ACCESS
14AB8  D7CA     BRA 0x4A4E
14ABA  0A01     XORLW 0x1
14ABC  B4D8     BTFSC 0xFD8, 2, ACCESS
14ABE  D7D8     BRA 0x4A70
14AC0  0A03     XORLW 0x3
14AC2  B4D8     BTFSC 0xFD8, 2, ACCESS
14AC4  D7DC     BRA 0x4A7E
14AC6  D7EB     BRA 0x4A9E
432:           			break;
433:           		case state_mx_log: // FM80 log data
434:           			send_mx_cmd(cmd_mx_log);
14AC8  0E71     MOVLW 0x71
14ACA  6EE6     MOVWF 0xFE6, ACCESS
14ACC  0E08     MOVLW 0x8
14ACE  6EE6     MOVWF 0xFE6, ACCESS
14AD0  EC85     CALL 0x170A, 0
14AD2  F00B     NOP
435:           			rec_mx_cmd(state_mx_log_cb, REC_LOG_LEN);
14AD4  0E11     MOVLW 0x11
14AD6  6EE6     MOVWF 0xFE6, ACCESS
14AD8  0EC0     MOVLW 0xC0
14ADA  6EE6     MOVWF 0xFE6, ACCESS
14ADC  0EB5     MOVLW 0xB5
14ADE  6EE6     MOVWF 0xFE6, ACCESS
14AE0  0E01     MOVLW 0x1
14AE2  6EE6     MOVWF 0xFE6, ACCESS
14AE4  EC09     CALL 0x1E612, 0
14AE6  F0F3     NOP
436:           			break;
14AE8  D061     BRA 0x4BAC
437:           		case state_time: // FM80 send time data
438:           			send_mx_cmd(cmd_time);
14AEA  0EE4     MOVLW 0xE4
14AEC  6EE6     MOVWF 0xFE6, ACCESS
14AEE  0E07     MOVLW 0x7
14AF0  6EE6     MOVWF 0xFE6, ACCESS
14AF2  EC85     CALL 0x170A, 0
14AF4  F00B     NOP
439:           			rec_mx_cmd(state_time_cb, REC_LEN);
14AF6  0E05     MOVLW 0x5
14AF8  6EE6     MOVWF 0xFE6, ACCESS
14AFA  0EFE     MOVLW 0xFE
14AFC  6EE6     MOVWF 0xFE6, ACCESS
14AFE  0E26     MOVLW 0x26
14B00  6EE6     MOVWF 0xFE6, ACCESS
14B02  0E00     MOVLW 0x0
14B04  6EE6     MOVWF 0xFE6, ACCESS
14B06  EC09     CALL 0x1E612, 0
14B08  F0F3     NOP
440:           			break;
14B0A  D050     BRA 0x4BAC
441:           		case state_date: // FM80 send date data
442:           			send_mx_cmd(cmd_date);
14B0C  0ED4     MOVLW 0xD4
14B0E  6EE6     MOVWF 0xFE6, ACCESS
14B10  0E07     MOVLW 0x7
14B12  6EE6     MOVWF 0xFE6, ACCESS
14B14  EC85     CALL 0x170A, 0
14B16  F00B     NOP
443:           			rec_mx_cmd(state_date_cb, REC_LEN);
14B18  0E05     MOVLW 0x5
14B1A  6EE6     MOVWF 0xFE6, ACCESS
14B1C  0EF6     MOVLW 0xF6
14B1E  6EE6     MOVWF 0xFE6, ACCESS
14B20  0E26     MOVLW 0x26
14B22  6EE6     MOVWF 0xFE6, ACCESS
14B24  0E00     MOVLW 0x0
14B26  6EE6     MOVWF 0xFE6, ACCESS
14B28  EC09     CALL 0x1E612, 0
14B2A  F0F3     NOP
444:           			break;
14B2C  D03F     BRA 0x4BAC
445:           		case state_misc:
446:           			send_mx_cmd(cmd_misc);
14B2E  0E71     MOVLW 0x71
14B30  6EE6     MOVWF 0xFE6, ACCESS
14B32  0EFB     MOVLW 0xFB
14B34  6EE6     MOVWF 0xFE6, ACCESS
14B36  EC85     CALL 0x170A, 0
14B38  F00B     NOP
447:           			rec_mx_cmd(state_misc_cb, REC_LEN);
14B3A  0E05     MOVLW 0x5
14B3C  6EE6     MOVWF 0xFE6, ACCESS
14B3E  0E42     MOVLW 0x42
14B40  6EE6     MOVWF 0xFE6, ACCESS
14B42  0E1D     MOVLW 0x1D
14B44  6EE6     MOVWF 0xFE6, ACCESS
14B46  0E00     MOVLW 0x0
14B48  6EE6     MOVWF 0xFE6, ACCESS
14B4A  EC09     CALL 0x1E612, 0
14B4C  F0F3     NOP
448:           			break;
14B4E  D02E     BRA 0x4BAC
449:           		default:
450:           			send_mx_cmd(cmd_id);
451:           			rec_mx_cmd(state_init_cb, REC_LEN);
452:           			break;
453:           		}
14B50  0105     MOVLB 0x5
14B52  51E3     MOVF 0xE3, W, BANKED
14B54  6E0B     MOVWF 0xB, ACCESS
14B56  6A0C     CLRF 0xC, ACCESS
14B58  500C     MOVF 0xC, W, ACCESS
14B5A  0A00     XORLW 0x0
14B5C  A4D8     BTFSS 0xFD8, 2, ACCESS
14B5E  D700     BRA 0x4960
14B60  500B     MOVF 0xB, W, ACCESS
14B62  0A00     XORLW 0x0
14B64  B4D8     BTFSC 0xFD8, 2, ACCESS
14B66  D6FC     BRA 0x4960
14B68  0A01     XORLW 0x1
14B6A  B4D8     BTFSC 0xFD8, 2, ACCESS
14B6C  D70A     BRA 0x4982
14B6E  0A03     XORLW 0x3
14B70  B4D8     BTFSC 0xFD8, 2, ACCESS
14B72  D718     BRA 0x49A4
14B74  0A01     XORLW 0x1
14B76  B4D8     BTFSC 0xFD8, 2, ACCESS
14B78  D726     BRA 0x49C6
14B7A  0A07     XORLW 0x7
14B7C  B4D8     BTFSC 0xFD8, 2, ACCESS
14B7E  D734     BRA 0x49E8
14B80  0A01     XORLW 0x1
14B82  B4D8     BTFSC 0xFD8, 2, ACCESS
14B84  D742     BRA 0x4A0A
14B86  0A03     XORLW 0x3
14B88  B4D8     BTFSC 0xFD8, 2, ACCESS
14B8A  D78C     BRA 0x4AA4
14B8C  0A01     XORLW 0x1
14B8E  B4D8     BTFSC 0xFD8, 2, ACCESS
14B90  D7AC     BRA 0x4AEA
14B92  0A0F     XORLW 0xF
14B94  B4D8     BTFSC 0xFD8, 2, ACCESS
14B96  D7BA     BRA 0x4B0C
14B98  0A01     XORLW 0x1
14B9A  B4D8     BTFSC 0xFD8, 2, ACCESS
14B9C  D795     BRA 0x4AC8
14B9E  0A03     XORLW 0x3
14BA0  B4D8     BTFSC 0xFD8, 2, ACCESS
14BA2  D7C5     BRA 0x4B2E
14BA4  0A01     XORLW 0x1
14BA6  B4D8     BTFSC 0xFD8, 2, ACCESS
14BA8  D741     BRA 0x4A2C
14BAA  D6DA     BRA 0x4960
454:           
455:           		if (B.one_sec_flag) { // one second tasks
14BAC  0105     MOVLB 0x5
14BAE  5161     MOVF PMD1, W, BANKED
14BB0  B4D8     BTFSC 0xFD8, 2, ACCESS
14BB2  D014     BRA 0x4BDC
456:           			eaDogM_Scroll_Task();
14BB4  ECD9     CALL 0x15B2, 0
14BB6  F00A     NOP
457:           			B.one_sec_flag = false;
14BB8  0105     MOVLB 0x5
14BBA  6B61     CLRF PMD1, BANKED
458:           			B.canbus_online = (!C1TXQCONHbits.TXREQ)&0x01;
14BBC  0101     MOVLB 0x1
14BBE  B351     BTFSC 0x51, 1, BANKED
14BC0  D002     BRA 0x4BC6
14BC2  0E01     MOVLW 0x1
14BC4  D001     BRA 0x4BC8
14BC6  0E00     MOVLW 0x0
14BC8  0B01     ANDLW 0x1
14BCA  0105     MOVLB 0x5
14BCC  6F71     MOVWF CM1CON1, BANKED
459:           			if (!B.canbus_online) {
14BCE  5171     MOVF CM1CON1, W, BANKED
14BD0  A4D8     BTFSS 0xFD8, 2, ACCESS
14BD2  D002     BRA 0x4BD8
460:           				C.tm_ok = false;
14BD4  0108     MOVLB 0x8
14BD6  6B51     CLRF 0x51, BANKED
461:           			}
462:           			B.modbus_online = C.data_ok;
14BD8  C84D     MOVFF 0x84D, 0x572
14BDA  F572     NOP
463:           #ifdef CAN_REMOTE
464:           			snprintf(buffer, MAX_B_BUF, "%X %X %X %X  %lu %lu %lu      ", C1BDIAG0T, C1BDIAG0U, C1BDIAG0H, C1BDIAG0L, can_rec_count.rec_count, msg[0].msgId, msg[1].msgId);
465:           			//			eaDogM_WriteStringAtPos(0, 0, buffer);
466:           			can_newtime = localtime(&can_timer);
467:           			snprintf(buffer, 21, "%s", asctime(can_newtime));
468:           			//			eaDogM_WriteStringAtPos(1, 0, buffer);
469:           #endif
470:           		}
471:           		if (TimerDone(TMR_SPIN)) { // LCD status spinner for charger MODE
14BDC  0E03     MOVLW 0x3
14BDE  6EE6     MOVWF 0xFE6, ACCESS
14BE0  ECF1     CALL 0x1FE2, 0
14BE2  F00F     NOP
14BE4  5001     MOVF __ptext283, W, ACCESS
14BE6  B4D8     BTFSC 0xFD8, 2, ACCESS
14BE8  D2CB     BRA 0x5180
472:           			{
473:           #define E_UPDATE	10
474:           #define E_SAVE		3
475:           				static uint8_t s_update = 0, e_update = 0;
476:           				static float ac = 0.0f;
477:           				static float wac = 0.0f;
478:           				static float wva = 0.0f;
479:           				static uint32_t error_save = E_SAVE;
480:           
481:           				if (s_update++ >= SPIN_VAL_UPDATE) {
14BEA  0105     MOVLB 0x5
14BEC  2BE1     INCF 0xE1, F, BANKED
14BEE  05E1     DECF 0xE1, W, BANKED
14BF0  6E0C     MOVWF 0xC, ACCESS
14BF2  0E04     MOVLW 0x4
14BF4  640C     CPFSGT 0xC, ACCESS
14BF6  D0C2     BRA 0x4D7C
482:           					ac = lp_filter(((float) em.vl1l2) / 10.0f, F_ac, false);
14BF8  0E00     MOVLW 0x0
14BFA  6EE6     MOVWF 0xFE6, ACCESS
14BFC  0E00     MOVLW 0x0
14BFE  6EE6     MOVWF 0xFE6, ACCESS
14C00  0E00     MOVLW 0x0
14C02  6EE6     MOVWF 0xFE6, ACCESS
14C04  0E00     MOVLW 0x0
14C06  6EE6     MOVWF 0xFE6, ACCESS
14C08  0E20     MOVLW 0x20
14C0A  6EE6     MOVWF 0xFE6, ACCESS
14C0C  0E41     MOVLW 0x41
14C0E  6EE6     MOVWF 0xFE6, ACCESS
14C10  C673     MOVFF 0x673, POSTINC1
14C12  F4E6     NOP
14C14  C674     MOVFF 0x674, POSTINC1
14C16  F4E6     NOP
14C18  C675     MOVFF 0x675, POSTINC1
14C1A  F4E6     NOP
14C1C  C676     MOVFF 0x676, POSTINC1
14C1E  F4E6     NOP
14C20  0E01     MOVLW 0x1
14C22  6EE6     MOVWF 0xFE6, ACCESS
14C24  EC35     CALL 0x1BA6A, 0
14C26  F0DD     NOP
14C28  0061     MOVFFL ltemp0, POSTINC1
14C2A  F404     NOP
14C2C  F4E6     NOP
14C2E  0061     MOVFFL ttemp5, POSTINC1
14C30  F408     NOP
14C32  F4E6     NOP
14C34  0061     MOVFFL wtemp1, POSTINC1
14C36  F40C     NOP
14C38  F4E6     NOP
14C3A  0061     MOVFFL ttemp1, POSTINC1
14C3C  F410     NOP
14C3E  F4E6     NOP
14C40  ECD2     CALL 0x187A4, 0
14C42  F0C3     NOP
14C44  0061     MOVFFL ltemp0, POSTINC1
14C46  F404     NOP
14C48  F4E6     NOP
14C4A  0061     MOVFFL ttemp5, POSTINC1
14C4C  F408     NOP
14C4E  F4E6     NOP
14C50  0061     MOVFFL wtemp1, POSTINC1
14C52  F40C     NOP
14C54  F4E6     NOP
14C56  0061     MOVFFL ttemp1, POSTINC1
14C58  F410     NOP
14C5A  F4E6     NOP
14C5C  EC91     CALL 0x1CF22, 0
14C5E  F0E7     NOP
14C60  0061     MOVFFL ltemp0, ac
14C62  F404     NOP
14C64  F629     NOP
14C66  0061     MOVFFL ttemp5, 0x62A
14C68  F408     NOP
14C6A  F62A     NOP
14C6C  0061     MOVFFL wtemp1, 0x62B
14C6E  F40C     NOP
14C70  F62B     NOP
14C72  0061     MOVFFL ttemp1, 0x62C
14C74  F410     NOP
14C76  F62C     NOP
483:           					wac = lp_filter(((float) em.wl1) / 10.0f, F_wac, false);
14C78  0E00     MOVLW 0x0
14C7A  6EE6     MOVWF 0xFE6, ACCESS
14C7C  0E01     MOVLW 0x1
14C7E  6EE6     MOVWF 0xFE6, ACCESS
14C80  0E00     MOVLW 0x0
14C82  6EE6     MOVWF 0xFE6, ACCESS
14C84  0E00     MOVLW 0x0
14C86  6EE6     MOVWF 0xFE6, ACCESS
14C88  0E20     MOVLW 0x20
14C8A  6EE6     MOVWF 0xFE6, ACCESS
14C8C  0E41     MOVLW 0x41
14C8E  6EE6     MOVWF 0xFE6, ACCESS
14C90  C68B     MOVFF 0x68B, POSTINC1
14C92  F4E6     NOP
14C94  C68C     MOVFF 0x68C, POSTINC1
14C96  F4E6     NOP
14C98  C68D     MOVFF 0x68D, POSTINC1
14C9A  F4E6     NOP
14C9C  C68E     MOVFF 0x68E, POSTINC1
14C9E  F4E6     NOP
14CA0  0E01     MOVLW 0x1
14CA2  6EE6     MOVWF 0xFE6, ACCESS
14CA4  EC35     CALL 0x1BA6A, 0
14CA6  F0DD     NOP
14CA8  0061     MOVFFL ltemp0, POSTINC1
14CAA  F404     NOP
14CAC  F4E6     NOP
14CAE  0061     MOVFFL ttemp5, POSTINC1
14CB0  F408     NOP
14CB2  F4E6     NOP
14CB4  0061     MOVFFL wtemp1, POSTINC1
14CB6  F40C     NOP
14CB8  F4E6     NOP
14CBA  0061     MOVFFL ttemp1, POSTINC1
14CBC  F410     NOP
14CBE  F4E6     NOP
14CC0  ECD2     CALL 0x187A4, 0
14CC2  F0C3     NOP
14CC4  0061     MOVFFL ltemp0, POSTINC1
14CC6  F404     NOP
14CC8  F4E6     NOP
14CCA  0061     MOVFFL ttemp5, POSTINC1
14CCC  F408     NOP
14CCE  F4E6     NOP
14CD0  0061     MOVFFL wtemp1, POSTINC1
14CD2  F40C     NOP
14CD4  F4E6     NOP
14CD6  0061     MOVFFL ttemp1, POSTINC1
14CD8  F410     NOP
14CDA  F4E6     NOP
14CDC  EC91     CALL 0x1CF22, 0
14CDE  F0E7     NOP
14CE0  0061     MOVFFL ltemp0, wac
14CE2  F404     NOP
14CE4  F625     NOP
14CE6  0061     MOVFFL ttemp5, 0x626
14CE8  F408     NOP
14CEA  F626     NOP
14CEC  0061     MOVFFL wtemp1, 0x627
14CEE  F40C     NOP
14CF0  F627     NOP
14CF2  0061     MOVFFL ttemp1, 0x628
14CF4  F410     NOP
14CF6  F628     NOP
484:           					wva = lp_filter(((float) em.val1) / 10.0f, F_wva, false);
14CF8  0E00     MOVLW 0x0
14CFA  6EE6     MOVWF 0xFE6, ACCESS
14CFC  0E02     MOVLW 0x2
14CFE  6EE6     MOVWF 0xFE6, ACCESS
14D00  0E00     MOVLW 0x0
14D02  6EE6     MOVWF 0xFE6, ACCESS
14D04  0E00     MOVLW 0x0
14D06  6EE6     MOVWF 0xFE6, ACCESS
14D08  0E20     MOVLW 0x20
14D0A  6EE6     MOVWF 0xFE6, ACCESS
14D0C  0E41     MOVLW 0x41
14D0E  6EE6     MOVWF 0xFE6, ACCESS
14D10  C697     MOVFF 0x697, POSTINC1
14D12  F4E6     NOP
14D14  C698     MOVFF 0x698, POSTINC1
14D16  F4E6     NOP
14D18  C699     MOVFF 0x699, POSTINC1
14D1A  F4E6     NOP
14D1C  C69A     MOVFF 0x69A, POSTINC1
14D1E  F4E6     NOP
14D20  0E01     MOVLW 0x1
14D22  6EE6     MOVWF 0xFE6, ACCESS
14D24  EC35     CALL 0x1BA6A, 0
14D26  F0DD     NOP
14D28  0061     MOVFFL ltemp0, POSTINC1
14D2A  F404     NOP
14D2C  F4E6     NOP
14D2E  0061     MOVFFL ttemp5, POSTINC1
14D30  F408     NOP
14D32  F4E6     NOP
14D34  0061     MOVFFL wtemp1, POSTINC1
14D36  F40C     NOP
14D38  F4E6     NOP
14D3A  0061     MOVFFL ttemp1, POSTINC1
14D3C  F410     NOP
14D3E  F4E6     NOP
14D40  ECD2     CALL 0x187A4, 0
14D42  F0C3     NOP
14D44  0061     MOVFFL ltemp0, POSTINC1
14D46  F404     NOP
14D48  F4E6     NOP
14D4A  0061     MOVFFL ttemp5, POSTINC1
14D4C  F408     NOP
14D4E  F4E6     NOP
14D50  0061     MOVFFL wtemp1, POSTINC1
14D52  F40C     NOP
14D54  F4E6     NOP
14D56  0061     MOVFFL ttemp1, POSTINC1
14D58  F410     NOP
14D5A  F4E6     NOP
14D5C  EC91     CALL 0x1CF22, 0
14D5E  F0E7     NOP
14D60  0061     MOVFFL ltemp0, wva
14D62  F404     NOP
14D64  F621     NOP
14D66  0061     MOVFFL ttemp5, 0x622
14D68  F408     NOP
14D6A  F622     NOP
14D6C  0061     MOVFFL wtemp1, 0x623
14D6E  F40C     NOP
14D70  F623     NOP
14D72  0061     MOVFFL ttemp1, 0x624
14D74  F410     NOP
14D76  F624     NOP
485:           					s_update = 0;
14D78  0105     MOVLB 0x5
14D7A  6BE1     CLRF 0xE1, BANKED
486:           				}
487:           				StartTimer(TMR_SPIN, SPINNER_SPEED);
14D7C  0EC8     MOVLW 0xC8
14D7E  6EE6     MOVWF 0xFE6, ACCESS
14D80  0E00     MOVLW 0x0
14D82  6EE6     MOVWF 0xFE6, ACCESS
14D84  0E03     MOVLW 0x3
14D86  6EE6     MOVWF 0xFE6, ACCESS
14D88  ECE7     CALL 0x17CE, 0
14D8A  F00B     NOP
488:           				if (C.data_ok && (M.error > error_save)) {
14D8C  0108     MOVLB 0x8
14D8E  514D     MOVF 0x4D, W, BANKED
14D90  B4D8     BTFSC 0xFD8, 2, ACCESS
14D92  D117     BRA 0x4FC2
14D94  0106     MOVLB 0x6
14D96  51E3     MOVF 0xE3, W, BANKED
14D98  6E09     MOVWF 0x9, ACCESS
14D9A  51E4     MOVF 0xE4, W, BANKED
14D9C  6E0A     MOVWF 0xA, ACCESS
14D9E  6A0B     CLRF 0xB, ACCESS
14DA0  6A0C     CLRF 0xC, ACCESS
14DA2  5009     MOVF 0x9, W, ACCESS
14DA4  0107     MOVLB 0x7
14DA6  5DD0     SUBWF 0xD0, W, BANKED
14DA8  500A     MOVF 0xA, W, ACCESS
14DAA  59D1     SUBWFB 0xD1, W, BANKED
14DAC  500B     MOVF 0xB, W, ACCESS
14DAE  59D2     SUBWFB 0xD2, W, BANKED
14DB0  500C     MOVF 0xC, W, ACCESS
14DB2  59D3     SUBWFB 0xD3, W, BANKED
14DB4  B0D8     BTFSC 0xFD8, 0, ACCESS
14DB6  D105     BRA 0x4FC2
489:           					snprintf(buffer, MAX_B_BUF, "EMon  %4.1fVAC   %c%c    ", lp_filter(ac, F_ac, false), spinners((uint8_t) 5 - (uint8_t) cc_mode, 0), spinners((uint8_t) 5 - (uint8_t) cc_mode, 0));
14DB8  0E00     MOVLW 0x0
14DBA  6EE6     MOVWF 0xFE6, ACCESS
14DBC  504B     MOVF HLVDCON1, W, ACCESS
14DBE  0805     SUBLW 0x5
14DC0  6EE6     MOVWF 0xFE6, ACCESS
14DC2  EC8C     CALL 0x1F318, 0
14DC4  F0F9     NOP
14DC6  5001     MOVF __ptext283, W, ACCESS
14DC8  6EE6     MOVWF 0xFE6, ACCESS
14DCA  0E00     MOVLW 0x0
14DCC  6EE6     MOVWF 0xFE6, ACCESS
14DCE  0E00     MOVLW 0x0
14DD0  6EE6     MOVWF 0xFE6, ACCESS
14DD2  504B     MOVF HLVDCON1, W, ACCESS
14DD4  0805     SUBLW 0x5
14DD6  6EE6     MOVWF 0xFE6, ACCESS
14DD8  EC8C     CALL 0x1F318, 0
14DDA  F0F9     NOP
14DDC  5001     MOVF __ptext283, W, ACCESS
14DDE  6EE6     MOVWF 0xFE6, ACCESS
14DE0  0E00     MOVLW 0x0
14DE2  6EE6     MOVWF 0xFE6, ACCESS
14DE4  0E00     MOVLW 0x0
14DE6  6EE6     MOVWF 0xFE6, ACCESS
14DE8  0E00     MOVLW 0x0
14DEA  6EE6     MOVWF 0xFE6, ACCESS
14DEC  C629     MOVFF ac, POSTINC1
14DEE  F4E6     NOP
14DF0  C62A     MOVFF 0x62A, POSTINC1
14DF2  F4E6     NOP
14DF4  C62B     MOVFF 0x62B, POSTINC1
14DF6  F4E6     NOP
14DF8  C62C     MOVFF 0x62C, POSTINC1
14DFA  F4E6     NOP
14DFC  EC91     CALL 0x1CF22, 0
14DFE  F0E7     NOP
14E00  0061     MOVFFL ltemp0, POSTINC1
14E02  F404     NOP
14E04  F4E6     NOP
14E06  0061     MOVFFL ttemp5, POSTINC1
14E08  F408     NOP
14E0A  F4E6     NOP
14E0C  0061     MOVFFL wtemp1, POSTINC1
14E0E  F40C     NOP
14E10  F4E6     NOP
14E12  0061     MOVFFL ttemp1, POSTINC1
14E14  F410     NOP
14E16  F4E6     NOP
14E18  0E7C     MOVLW 0x7C
14E1A  6EE6     MOVWF 0xFE6, ACCESS
14E1C  0EFD     MOVLW 0xFD
14E1E  6EE6     MOVWF 0xFE6, ACCESS
14E20  0EFF     MOVLW 0xFF
14E22  6EE6     MOVWF 0xFE6, ACCESS
14E24  0E00     MOVLW 0x0
14E26  6EE6     MOVWF 0xFE6, ACCESS
14E28  0E00     MOVLW 0x0
14E2A  6EE6     MOVWF 0xFE6, ACCESS
14E2C  0E0B     MOVLW 0xB
14E2E  6EE6     MOVWF 0xFE6, ACCESS
14E30  0E0E     MOVLW 0xE
14E32  6EE6     MOVWF 0xFE6, ACCESS
14E34  EC35     CALL 0x1C06A, 0
14E36  F0E0     NOP
490:           					eaDogM_WriteStringAtPos(1, 0, buffer);
14E38  0E00     MOVLW 0x0
14E3A  6EE6     MOVWF 0xFE6, ACCESS
14E3C  0E0B     MOVLW 0xB
14E3E  6EE6     MOVWF 0xFE6, ACCESS
14E40  0E00     MOVLW 0x0
14E42  6EE6     MOVWF 0xFE6, ACCESS
14E44  0E01     MOVLW 0x1
14E46  6EE6     MOVWF 0xFE6, ACCESS
14E48  ECD9     CALL 0x1B2, 0
14E4A  F000     NOP
491:           					snprintf(info_buffer, MAX_B_BUF, " error logged \r\n");
14E4C  0E5E     MOVLW 0x5E
14E4E  6EE6     MOVWF 0xFE6, ACCESS
14E50  0EFF     MOVLW 0xFF
14E52  6EE6     MOVWF 0xFE6, ACCESS
14E54  0EFF     MOVLW 0xFF
14E56  6EE6     MOVWF 0xFE6, ACCESS
14E58  0E00     MOVLW 0x0
14E5A  6EE6     MOVWF 0xFE6, ACCESS
14E5C  0E00     MOVLW 0x0
14E5E  6EE6     MOVWF 0xFE6, ACCESS
14E60  0E12     MOVLW 0x12
14E62  6EE6     MOVWF 0xFE6, ACCESS
14E64  0E06     MOVLW 0x6
14E66  6EE6     MOVWF 0xFE6, ACCESS
14E68  EC35     CALL 0x1C06A, 0
14E6A  F0E0     NOP
492:           					if (e_update == 0) {
14E6C  0105     MOVLB 0x5
14E6E  51E0     MOVF 0xE0, W, BANKED
14E70  A4D8     BTFSS 0xFD8, 2, ACCESS
14E72  D08D     BRA 0x4F8E
493:           #ifdef SHOW_MODBUS_DEBUG
494:           						snprintf(buffer, MAX_B_BUF, "C%u CRC%lu RC%u EC%u          ", C.modbus_command, M.crc_error, M.recv_count, C.req_length);
495:           #else
496:           						snprintf(buffer, MAX_B_BUF, "%6.1fW %6.1fVA %c%c%c   ", lp_filter(wac, F_wac, false), lp_filter(wva, F_wva, false), state_name[cc_mode][0], canbus_name[B.canbus_online][0], modbus_name[B.modbus_online][0]);
14E74  5172     MOVF CM1NCH, W, BANKED
14E76  0D0C     MULLW 0xC
14E78  0E11     MOVLW 0x11
14E7A  24F3     ADDWF 0xFF3, W, ACCESS
14E7C  6EF6     MOVWF 0xFF6, ACCESS
14E7E  0EFA     MOVLW 0xFA
14E80  20F4     ADDWFC 0xFF4, W, ACCESS
14E82  6EF7     MOVWF 0xFF7, ACCESS
14E84  6AF8     CLRF 0xFF8, ACCESS
14E86  0E00     MOVLW 0x0
14E88  22F8     ADDWFC 0xFF8, F, ACCESS
14E8A  0008     TBLRD*
14E8C  50F5     MOVF 0xFF5, W, ACCESS
14E8E  6EE6     MOVWF 0xFE6, ACCESS
14E90  0E00     MOVLW 0x0
14E92  6EE6     MOVWF 0xFE6, ACCESS
14E94  5171     MOVF CM1CON1, W, BANKED
14E96  0D0C     MULLW 0xC
14E98  0E29     MOVLW 0x29
14E9A  24F3     ADDWF 0xFF3, W, ACCESS
14E9C  6EF6     MOVWF 0xFF6, ACCESS
14E9E  0EFA     MOVLW 0xFA
14EA0  20F4     ADDWFC 0xFF4, W, ACCESS
14EA2  6EF7     MOVWF 0xFF7, ACCESS
14EA4  6AF8     CLRF 0xFF8, ACCESS
14EA6  0E00     MOVLW 0x0
14EA8  22F8     ADDWFC 0xFF8, F, ACCESS
14EAA  0008     TBLRD*
14EAC  50F5     MOVF 0xFF5, W, ACCESS
14EAE  6EE6     MOVWF 0xFE6, ACCESS
14EB0  0E00     MOVLW 0x0
14EB2  6EE6     MOVWF 0xFE6, ACCESS
14EB4  0061     MOVFFL cc_mode, wtemp5
14EB6  F52C     NOP
14EB8  F50B     NOP
14EBA  0061     MOVFFL 0x54C, 0x50C
14EBC  F530     NOP
14EBE  F50C     NOP
14EC0  0E0C     MOVLW 0xC
14EC2  020B     MULWF 0xB, ACCESS
14EC4  0061     MOVFFL PROD, ltemp2
14EC6  F3CC     NOP
14EC8  F509     NOP
14ECA  0061     MOVFFL PRODH, ttemp3
14ECC  F3D0     NOP
14ECE  F50A     NOP
14ED0  020C     MULWF 0xC, ACCESS
14ED2  50F3     MOVF 0xFF3, W, ACCESS
14ED4  260A     ADDWF 0xA, F, ACCESS
14ED6  0EC9     MOVLW 0xC9
14ED8  2409     ADDWF 0x9, W, ACCESS
14EDA  6EF6     MOVWF 0xFF6, ACCESS
14EDC  0EF9     MOVLW 0xF9
14EDE  200A     ADDWFC 0xA, W, ACCESS
14EE0  6EF7     MOVWF 0xFF7, ACCESS
14EE2  6AF8     CLRF 0xFF8, ACCESS
14EE4  0E00     MOVLW 0x0
14EE6  22F8     ADDWFC 0xFF8, F, ACCESS
14EE8  0008     TBLRD*
14EEA  50F5     MOVF 0xFF5, W, ACCESS
14EEC  6EE6     MOVWF 0xFE6, ACCESS
14EEE  0E00     MOVLW 0x0
14EF0  6EE6     MOVWF 0xFE6, ACCESS
14EF2  0E00     MOVLW 0x0
14EF4  6EE6     MOVWF 0xFE6, ACCESS
14EF6  0E02     MOVLW 0x2
14EF8  6EE6     MOVWF 0xFE6, ACCESS
14EFA  C621     MOVFF wva, POSTINC1
14EFC  F4E6     NOP
14EFE  C622     MOVFF 0x622, POSTINC1
14F00  F4E6     NOP
14F02  C623     MOVFF 0x623, POSTINC1
14F04  F4E6     NOP
14F06  C624     MOVFF 0x624, POSTINC1
14F08  F4E6     NOP
14F0A  EC91     CALL 0x1CF22, 0
14F0C  F0E7     NOP
14F0E  0061     MOVFFL ltemp0, POSTINC1
14F10  F404     NOP
14F12  F4E6     NOP
14F14  0061     MOVFFL ttemp5, POSTINC1
14F16  F408     NOP
14F18  F4E6     NOP
14F1A  0061     MOVFFL wtemp1, POSTINC1
14F1C  F40C     NOP
14F1E  F4E6     NOP
14F20  0061     MOVFFL ttemp1, POSTINC1
14F22  F410     NOP
14F24  F4E6     NOP
14F26  0E00     MOVLW 0x0
14F28  6EE6     MOVWF 0xFE6, ACCESS
14F2A  0E01     MOVLW 0x1
14F2C  6EE6     MOVWF 0xFE6, ACCESS
14F2E  C625     MOVFF wac, POSTINC1
14F30  F4E6     NOP
14F32  C626     MOVFF 0x626, POSTINC1
14F34  F4E6     NOP
14F36  C627     MOVFF 0x627, POSTINC1
14F38  F4E6     NOP
14F3A  C628     MOVFF 0x628, POSTINC1
14F3C  F4E6     NOP
14F3E  EC91     CALL 0x1CF22, 0
14F40  F0E7     NOP
14F42  0061     MOVFFL ltemp0, POSTINC1
14F44  F404     NOP
14F46  F4E6     NOP
14F48  0061     MOVFFL ttemp5, POSTINC1
14F4A  F408     NOP
14F4C  F4E6     NOP
14F4E  0061     MOVFFL wtemp1, POSTINC1
14F50  F40C     NOP
14F52  F4E6     NOP
14F54  0061     MOVFFL ttemp1, POSTINC1
14F56  F410     NOP
14F58  F4E6     NOP
14F5A  0E2D     MOVLW 0x2D
14F5C  6EE6     MOVWF 0xFE6, ACCESS
14F5E  0EFE     MOVLW 0xFE
14F60  6EE6     MOVWF 0xFE6, ACCESS
14F62  0EFF     MOVLW 0xFF
14F64  6EE6     MOVWF 0xFE6, ACCESS
14F66  0E00     MOVLW 0x0
14F68  6EE6     MOVWF 0xFE6, ACCESS
14F6A  0E00     MOVLW 0x0
14F6C  6EE6     MOVWF 0xFE6, ACCESS
14F6E  0E0B     MOVLW 0xB
14F70  6EE6     MOVWF 0xFE6, ACCESS
14F72  0E14     MOVLW 0x14
14F74  6EE6     MOVWF 0xFE6, ACCESS
14F76  EC35     CALL 0x1C06A, 0
14F78  F0E0     NOP
497:           #endif
498:           						eaDogM_WriteStringAtPos(0, 0, buffer);
14F7A  0E00     MOVLW 0x0
14F7C  6EE6     MOVWF 0xFE6, ACCESS
14F7E  0E0B     MOVLW 0xB
14F80  6EE6     MOVWF 0xFE6, ACCESS
14F82  0E00     MOVLW 0x0
14F84  6EE6     MOVWF 0xFE6, ACCESS
14F86  0E00     MOVLW 0x0
14F88  6EE6     MOVWF 0xFE6, ACCESS
14F8A  ECD9     CALL 0x1B2, 0
14F8C  F000     NOP
499:           					}
500:           					if (e_update++ >= E_UPDATE) {
14F8E  0105     MOVLB 0x5
14F90  2BE0     INCF 0xE0, F, BANKED
14F92  05E0     DECF 0xE0, W, BANKED
14F94  6E0C     MOVWF 0xC, ACCESS
14F96  0E09     MOVLW 0x9
14F98  640C     CPFSGT 0xC, ACCESS
14F9A  D0F2     BRA 0x5180
501:           						error_save = M.error + E_SAVE;
14F9C  0E03     MOVLW 0x3
14F9E  0106     MOVLB 0x6
14FA0  25E3     ADDWF 0xE3, W, BANKED
14FA2  6E0B     MOVWF 0xB, ACCESS
14FA4  0E00     MOVLW 0x0
14FA6  21E4     ADDWFC 0xE4, W, BANKED
14FA8  6E0C     MOVWF 0xC, ACCESS
14FAA  0061     MOVFFL wtemp5, error_save
14FAC  F42C     NOP
14FAE  F7D0     NOP
14FB0  0061     MOVFFL 0x50C, 0x7D1
14FB2  F430     NOP
14FB4  F7D1     NOP
14FB6  0107     MOVLB 0x7
14FB8  6BD2     CLRF 0xD2, BANKED
14FBA  6BD3     CLRF 0xD3, BANKED
502:           						e_update = 0;
14FBC  0105     MOVLB 0x5
14FBE  6BE0     CLRF 0xE0, BANKED
14FC0  D0DF     BRA 0x5180
503:           					}
504:           				} else {
505:           					M.error = 0;
14FC2  0106     MOVLB 0x6
14FC4  6BE3     CLRF 0xE3, BANKED
14FC6  6BE4     CLRF 0xE4, BANKED
506:           #ifdef CAN_REMOTE
507:           #ifdef DATA_DEBUG
508:           #ifdef LCD_MIRROR
509:           #else
510:           					if (show_can) {
511:           						rxMsgData[0][42] = 0;
512:           						snprintf(buffer, MAX_B_BUF, "%s          ", &rxMsgData[CAN_LOW_BUF][2]);
513:           						eaDogM_WriteStringAtPos(2, 0, buffer);
514:           						rxMsgData[0][42] = 0;
515:           						snprintf(buffer, MAX_B_BUF, "%s          ", &rxMsgData[CAN_LOW_BUF][22]);
516:           						eaDogM_WriteStringAtPos(3, 0, buffer);
517:           					} else {
518:           						snprintf(buffer, MAX_B_BUF, "%s          ", &rxMsgData[CAN_INFO_BUF][3]);
519:           						eaDogM_WriteStringAtPos(2, 0, buffer);
520:           						snprintf(buffer, MAX_B_BUF, "%s          ", &rxMsgData[CAN_INFO_BUF][22]);
521:           						eaDogM_WriteStringAtPos(3, 0, buffer);
522:           					}
523:           					if (time_show_can++ >= 64) {
524:           						show_can = !show_can;
525:           						time_show_can = 0;
526:           					}
527:           #endif
528:           #else
529:           					snprintf(buffer, MAX_B_BUF, "%X %X %X %X %X %X %X %X           ", C1INTL, C1INTH, C1INTU, C1INTT, C1TRECL, C1FLTOBJ0T, C1FLTCON0L, CAN1_OperationModeGet());
530:           					eaDogM_WriteStringAtPos(2, 0, buffer);
531:           					snprintf(buffer, MAX_B_BUF, "%X %X %X %X %X %X %X %X           ", C1FIFOCON1L, C1FIFOCON1H, C1FIFOCON1U, C1FIFOCON1T, C1FIFOSTA1L, C1FIFOSTA1H, C1FIFOSTA1U, C1FIFOSTA1T);
532:           					eaDogM_WriteStringAtPos(3, 0, buffer);
533:           #endif
534:           #else
535:           					snprintf(buffer, MAX_B_BUF, "EMon  %6.1fWh   %c%c    ", EB->bat_energy / TEN_SEC_HOUR, spinners((uint8_t) 5 - (uint8_t) cc_mode, 0), spinners((uint8_t) 5 - (uint8_t) cc_mode, 0));
14FC8  0E00     MOVLW 0x0
14FCA  6EE6     MOVWF 0xFE6, ACCESS
14FCC  504B     MOVF HLVDCON1, W, ACCESS
14FCE  0805     SUBLW 0x5
14FD0  6EE6     MOVWF 0xFE6, ACCESS
14FD2  EC8C     CALL 0x1F318, 0
14FD4  F0F9     NOP
14FD6  5001     MOVF __ptext283, W, ACCESS
14FD8  6EE6     MOVWF 0xFE6, ACCESS
14FDA  0E00     MOVLW 0x0
14FDC  6EE6     MOVWF 0xFE6, ACCESS
14FDE  0E00     MOVLW 0x0
14FE0  6EE6     MOVWF 0xFE6, ACCESS
14FE2  504B     MOVF HLVDCON1, W, ACCESS
14FE4  0805     SUBLW 0x5
14FE6  6EE6     MOVWF 0xFE6, ACCESS
14FE8  EC8C     CALL 0x1F318, 0
14FEA  F0F9     NOP
14FEC  5001     MOVF __ptext283, W, ACCESS
14FEE  6EE6     MOVWF 0xFE6, ACCESS
14FF0  0E00     MOVLW 0x0
14FF2  6EE6     MOVWF 0xFE6, ACCESS
14FF4  0E00     MOVLW 0x0
14FF6  6EE6     MOVWF 0xFE6, ACCESS
14FF8  0E00     MOVLW 0x0
14FFA  6EE6     MOVWF 0xFE6, ACCESS
14FFC  0EB4     MOVLW 0xB4
14FFE  6EE6     MOVWF 0xFE6, ACCESS
15000  0E43     MOVLW 0x43
15002  6EE6     MOVWF 0xFE6, ACCESS
15004  C82C     MOVFF 0x82C, POSTINC1
15006  F4E6     NOP
15008  C82D     MOVFF 0x82D, POSTINC1
1500A  F4E6     NOP
1500C  C82E     MOVFF 0x82E, POSTINC1
1500E  F4E6     NOP
15010  C82F     MOVFF 0x82F, POSTINC1
15012  F4E6     NOP
15014  ECD2     CALL 0x187A4, 0
15016  F0C3     NOP
15018  0061     MOVFFL ltemp0, POSTINC1
1501A  F404     NOP
1501C  F4E6     NOP
1501E  0061     MOVFFL ttemp5, POSTINC1
15020  F408     NOP
15022  F4E6     NOP
15024  0061     MOVFFL wtemp1, POSTINC1
15026  F40C     NOP
15028  F4E6     NOP
1502A  0061     MOVFFL ttemp1, POSTINC1
1502C  F410     NOP
1502E  F4E6     NOP
15030  0E14     MOVLW 0x14
15032  6EE6     MOVWF 0xFE6, ACCESS
15034  0EFE     MOVLW 0xFE
15036  6EE6     MOVWF 0xFE6, ACCESS
15038  0EFF     MOVLW 0xFF
1503A  6EE6     MOVWF 0xFE6, ACCESS
1503C  0E00     MOVLW 0x0
1503E  6EE6     MOVWF 0xFE6, ACCESS
15040  0E00     MOVLW 0x0
15042  6EE6     MOVWF 0xFE6, ACCESS
15044  0E0B     MOVLW 0xB
15046  6EE6     MOVWF 0xFE6, ACCESS
15048  0E0E     MOVLW 0xE
1504A  6EE6     MOVWF 0xFE6, ACCESS
1504C  EC35     CALL 0x1C06A, 0
1504E  F0E0     NOP
536:           					eaDogM_WriteStringAtPos(1, 0, buffer);
15050  0E00     MOVLW 0x0
15052  6EE6     MOVWF 0xFE6, ACCESS
15054  0E0B     MOVLW 0xB
15056  6EE6     MOVWF 0xFE6, ACCESS
15058  0E00     MOVLW 0x0
1505A  6EE6     MOVWF 0xFE6, ACCESS
1505C  0E01     MOVLW 0x1
1505E  6EE6     MOVWF 0xFE6, ACCESS
15060  ECD9     CALL 0x1B2, 0
15062  F000     NOP
537:           					snprintf(buffer, MAX_B_BUF, "%6.1fW %6.1fVA %c%c%c   ", lp_filter(wac, F_wac, false), lp_filter(wva, F_wva, false), state_name[cc_mode][0], canbus_name[B.canbus_online][0], modbus_name[B.modbus_online][0]);
15064  0105     MOVLB 0x5
15066  5172     MOVF CM1NCH, W, BANKED
15068  0D0C     MULLW 0xC
1506A  0E11     MOVLW 0x11
1506C  24F3     ADDWF 0xFF3, W, ACCESS
1506E  6EF6     MOVWF 0xFF6, ACCESS
15070  0EFA     MOVLW 0xFA
15072  20F4     ADDWFC 0xFF4, W, ACCESS
15074  6EF7     MOVWF 0xFF7, ACCESS
15076  6AF8     CLRF 0xFF8, ACCESS
15078  0E00     MOVLW 0x0
1507A  22F8     ADDWFC 0xFF8, F, ACCESS
1507C  0008     TBLRD*
1507E  50F5     MOVF 0xFF5, W, ACCESS
15080  6EE6     MOVWF 0xFE6, ACCESS
15082  0E00     MOVLW 0x0
15084  6EE6     MOVWF 0xFE6, ACCESS
15086  5171     MOVF CM1CON1, W, BANKED
15088  0D0C     MULLW 0xC
1508A  0E29     MOVLW 0x29
1508C  24F3     ADDWF 0xFF3, W, ACCESS
1508E  6EF6     MOVWF 0xFF6, ACCESS
15090  0EFA     MOVLW 0xFA
15092  20F4     ADDWFC 0xFF4, W, ACCESS
15094  6EF7     MOVWF 0xFF7, ACCESS
15096  6AF8     CLRF 0xFF8, ACCESS
15098  0E00     MOVLW 0x0
1509A  22F8     ADDWFC 0xFF8, F, ACCESS
1509C  0008     TBLRD*
1509E  50F5     MOVF 0xFF5, W, ACCESS
150A0  6EE6     MOVWF 0xFE6, ACCESS
150A2  0E00     MOVLW 0x0
150A4  6EE6     MOVWF 0xFE6, ACCESS
150A6  0061     MOVFFL cc_mode, wtemp5
150A8  F52C     NOP
150AA  F50B     NOP
150AC  0061     MOVFFL 0x54C, 0x50C
150AE  F530     NOP
150B0  F50C     NOP
150B2  0E0C     MOVLW 0xC
150B4  020B     MULWF 0xB, ACCESS
150B6  0061     MOVFFL PROD, ltemp2
150B8  F3CC     NOP
150BA  F509     NOP
150BC  0061     MOVFFL PRODH, ttemp3
150BE  F3D0     NOP
150C0  F50A     NOP
150C2  020C     MULWF 0xC, ACCESS
150C4  50F3     MOVF 0xFF3, W, ACCESS
150C6  260A     ADDWF 0xA, F, ACCESS
150C8  0EC9     MOVLW 0xC9
150CA  2409     ADDWF 0x9, W, ACCESS
150CC  6EF6     MOVWF 0xFF6, ACCESS
150CE  0EF9     MOVLW 0xF9
150D0  200A     ADDWFC 0xA, W, ACCESS
150D2  6EF7     MOVWF 0xFF7, ACCESS
150D4  6AF8     CLRF 0xFF8, ACCESS
150D6  0E00     MOVLW 0x0
150D8  22F8     ADDWFC 0xFF8, F, ACCESS
150DA  0008     TBLRD*
150DC  50F5     MOVF 0xFF5, W, ACCESS
150DE  6EE6     MOVWF 0xFE6, ACCESS
150E0  0E00     MOVLW 0x0
150E2  6EE6     MOVWF 0xFE6, ACCESS
150E4  0E00     MOVLW 0x0
150E6  6EE6     MOVWF 0xFE6, ACCESS
150E8  0E02     MOVLW 0x2
150EA  6EE6     MOVWF 0xFE6, ACCESS
150EC  C621     MOVFF wva, POSTINC1
150EE  F4E6     NOP
150F0  C622     MOVFF 0x622, POSTINC1
150F2  F4E6     NOP
150F4  C623     MOVFF 0x623, POSTINC1
150F6  F4E6     NOP
150F8  C624     MOVFF 0x624, POSTINC1
150FA  F4E6     NOP
150FC  EC91     CALL 0x1CF22, 0
150FE  F0E7     NOP
15100  0061     MOVFFL ltemp0, POSTINC1
15102  F404     NOP
15104  F4E6     NOP
15106  0061     MOVFFL ttemp5, POSTINC1
15108  F408     NOP
1510A  F4E6     NOP
1510C  0061     MOVFFL wtemp1, POSTINC1
1510E  F40C     NOP
15110  F4E6     NOP
15112  0061     MOVFFL ttemp1, POSTINC1
15114  F410     NOP
15116  F4E6     NOP
15118  0E00     MOVLW 0x0
1511A  6EE6     MOVWF 0xFE6, ACCESS
1511C  0E01     MOVLW 0x1
1511E  6EE6     MOVWF 0xFE6, ACCESS
15120  C625     MOVFF wac, POSTINC1
15122  F4E6     NOP
15124  C626     MOVFF 0x626, POSTINC1
15126  F4E6     NOP
15128  C627     MOVFF 0x627, POSTINC1
1512A  F4E6     NOP
1512C  C628     MOVFF 0x628, POSTINC1
1512E  F4E6     NOP
15130  EC91     CALL 0x1CF22, 0
15132  F0E7     NOP
15134  0061     MOVFFL ltemp0, POSTINC1
15136  F404     NOP
15138  F4E6     NOP
1513A  0061     MOVFFL ttemp5, POSTINC1
1513C  F408     NOP
1513E  F4E6     NOP
15140  0061     MOVFFL wtemp1, POSTINC1
15142  F40C     NOP
15144  F4E6     NOP
15146  0061     MOVFFL ttemp1, POSTINC1
15148  F410     NOP
1514A  F4E6     NOP
1514C  0E2D     MOVLW 0x2D
1514E  6EE6     MOVWF 0xFE6, ACCESS
15150  0EFE     MOVLW 0xFE
15152  6EE6     MOVWF 0xFE6, ACCESS
15154  0EFF     MOVLW 0xFF
15156  6EE6     MOVWF 0xFE6, ACCESS
15158  0E00     MOVLW 0x0
1515A  6EE6     MOVWF 0xFE6, ACCESS
1515C  0E00     MOVLW 0x0
1515E  6EE6     MOVWF 0xFE6, ACCESS
15160  0E0B     MOVLW 0xB
15162  6EE6     MOVWF 0xFE6, ACCESS
15164  0E14     MOVLW 0x14
15166  6EE6     MOVWF 0xFE6, ACCESS
15168  EC35     CALL 0x1C06A, 0
1516A  F0E0     NOP
538:           					eaDogM_WriteStringAtPos(0, 0, buffer);
1516C  0E00     MOVLW 0x0
1516E  6EE6     MOVWF 0xFE6, ACCESS
15170  0E0B     MOVLW 0xB
15172  6EE6     MOVWF 0xFE6, ACCESS
15174  0E00     MOVLW 0x0
15176  6EE6     MOVWF 0xFE6, ACCESS
15178  0E00     MOVLW 0x0
1517A  6EE6     MOVWF 0xFE6, ACCESS
1517C  ECD9     CALL 0x1B2, 0
1517E  F000     NOP
539:           #endif
540:           				}
541:           			}
542:           		}
543:           #ifdef TRACE
544:           		IO_RD5_SetLow();
15180  9AC1     BCF 0xFC1, 5, ACCESS
15180  9AC1     BCF 0xFC1, 5, ACCESS
15180  9AC1     BCF 0xFC1, 5, ACCESS
545:           #endif
546:           	}
547:           }
548:           
549:           /*
550:            * display  div 10 integer to fraction without FP
551:            * %d.%01d  volt_whole, volt_fract
552:            */
553:           static void volt_f(const uint16_t voltage)
0F24  0E0A     MOVLW 0xA
554:           {
555:           	volt_fract = (uint16_t) abs(voltage % 10);
0F26  6EE6     MOVWF 0xFE6, ACCESS
0F28  0E00     MOVLW 0x0
0F2A  6EE6     MOVWF 0xFE6, ACCESS
0F2C  0EFC     MOVLW 0xFC
0F2E  C4E3     MOVFF PLUSW1, POSTINC1
0F30  F4E6     NOP
0F32  C4E3     MOVFF PLUSW1, POSTINC1
0F34  F4E6     NOP
0F36  ECC2     CALL 0x1F784, 0
0F38  F0FB     NOP
0F3A  0061     MOVFFL ltemp0, POSTINC1
0F3C  F404     NOP
0F3E  F4E6     NOP
0F40  0061     MOVFFL ttemp5, POSTINC1
0F42  F408     NOP
0F44  F4E6     NOP
0F46  ECB6     CALL 0x156C, 0
0F48  F00A     NOP
0F4A  0061     MOVFFL ltemp0, volt_fract
0F4C  F404     NOP
0F4E  F5D3     NOP
0F50  0061     MOVFFL ttemp5, 0x5D4
0F52  F408     NOP
0F54  F5D4     NOP
556:           	volt_whole = voltage / 10;
0F56  0E0A     MOVLW 0xA
0F58  6EE6     MOVWF 0xFE6, ACCESS
0F5A  0E00     MOVLW 0x0
0F5C  6EE6     MOVWF 0xFE6, ACCESS
0F5E  0EFC     MOVLW 0xFC
0F60  C4E3     MOVFF PLUSW1, POSTINC1
0F62  F4E6     NOP
0F64  C4E3     MOVFF PLUSW1, POSTINC1
0F66  F4E6     NOP
0F68  EC1E     CALL 0x1EA3C, 0
0F6A  F0F5     NOP
0F6C  0061     MOVFFL ltemp0, volt_whole
0F6E  F404     NOP
0F70  F5D9     NOP
0F72  0061     MOVFFL ttemp5, 0x5DA
0F74  F408     NOP
0F76  F5DA     NOP
557:           }
0F78  52E5     MOVF 0xFE5, F, ACCESS
0F78  52E5     MOVF 0xFE5, F, ACCESS
0F78  52E5     MOVF 0xFE5, F, ACCESS
558:           
559:           /*
560:            * transmit the cmd data
561:            */
562:           static void send_mx_cmd(const uint16_t * cmd)
563:           {
564:           	if (FM_tx_empty()) {
170A  EC27     CALL 0x264E, 0
170C  F013     NOP
170E  5001     MOVF __ptext283, W, ACCESS
1710  B4D8     BTFSC 0xFD8, 2, ACCESS
1712  D019     BRA 0x1746
565:           		if (B.pacing++ > PACE) {
1714  0105     MOVLB 0x5
1716  5165     MOVF PMD5, W, BANKED
1718  6E0B     MOVWF 0xB, ACCESS
171A  5166     MOVF PMD6, W, BANKED
171C  6E0C     MOVWF 0xC, ACCESS
171E  4B65     INFSNZ PMD5, F, BANKED
1720  2B66     INCF PMD6, F, BANKED
1722  0E19     MOVLW 0x19
1724  5C0B     SUBWF 0xB, W, ACCESS
1726  0E79     MOVLW 0x79
1728  580C     SUBWFB 0xC, W, ACCESS
172A  A0D8     BTFSS 0xFD8, 0, ACCESS
172C  D00C     BRA 0x1746
566:           			FM_tx(cmd, CMD_LEN); // send 8 9-bits command data stream
172E  0E08     MOVLW 0x8
1730  6EE6     MOVWF 0xFE6, ACCESS
1732  0EFD     MOVLW 0xFD
1734  C4E3     MOVFF PLUSW1, POSTINC1
1736  F4E6     NOP
1738  C4E3     MOVFF PLUSW1, POSTINC1
173A  F4E6     NOP
173C  EC49     CALL 0x1092, 0
173E  F008     NOP
567:           			B.pacing = 0;
1740  0105     MOVLB 0x5
1742  6B65     CLRF PMD5, BANKED
1744  6B66     CLRF PMD6, BANKED
568:           		}
569:           	}
570:           }
1746  52E5     MOVF 0xFE5, F, ACCESS
1746  52E5     MOVF 0xFE5, F, ACCESS
1746  52E5     MOVF 0xFE5, F, ACCESS
571:           
572:           /*
573:            * process received data from the FM80 9n1 serial in abuf 16-bit buffer array with callbacks
574:            */
575:           static void rec_mx_cmd(void (* DataHandler)(void), const uint8_t rec_len)
576:           {
577:           	static uint16_t online_count = 0;
578:           
579:           	if (FM_rx_ready()) {
1E612  EC30     CALL 0x2660, 0
1E614  F013     NOP
1E616  5001     MOVF __ptext283, W, ACCESS
1E618  B4D8     BTFSC 0xFD8, 2, ACCESS
1E61A  D04B     BRA 0xE6B2
580:           		if (FM_rx_count() >= rec_len) {
1E61C  EC09     CALL 0x2612, 0
1E61E  F013     NOP
1E620  0EFC     MOVLW 0xFC
1E622  50E3     MOVF 0xFE3, W, ACCESS
1E624  5C01     SUBWF __ptext283, W, ACCESS
1E626  A0D8     BTFSS 0xFD8, 0, ACCESS
1E628  D02D     BRA 0xE684
581:           			online_count = 0;
1E62A  0106     MOVLB 0x6
1E62C  6B5A     CLRF 0x5A, BANKED
1E62E  6B5B     CLRF 0x5B, BANKED
582:           			if (rec_len == REC_LOG_LEN) {
1E630  0EFC     MOVLW 0xFC
1E632  0061     MOVFFL PLUSW1, ltemp0
1E634  F38C     NOP
1E636  F501     NOP
1E638  0E11     MOVLW 0x11
1E63A  1801     XORWF __ptext283, W, ACCESS
1E63C  A4D8     BTFSS 0xFD8, 2, ACCESS
1E63E  D007     BRA 0xE64E
583:           				FM_rx(cbuf);
1E640  0E80     MOVLW 0x80
1E642  6EE6     MOVWF 0xFE6, ACCESS
1E644  0E09     MOVLW 0x9
1E646  6EE6     MOVWF 0xFE6, ACCESS
1E648  ECDB     CALL 0x13B6, 0
1E64A  F009     NOP
584:           			} else {
1E64C  D006     BRA 0xE65A
585:           				FM_rx(abuf);
1E64E  0E35     MOVLW 0x35
1E650  6EE6     MOVWF 0xFE6, ACCESS
1E652  0E07     MOVLW 0x7
1E654  6EE6     MOVWF 0xFE6, ACCESS
1E656  ECDB     CALL 0x13B6, 0
1E658  F009     NOP
586:           			}
587:           			B.FM80_io = false;
1E65A  0105     MOVLB 0x5
1E65C  6B70     CLRF CM1CON0, BANKED
588:           			DataHandler(); // execute callback to process data in abuf
1E65E  50E1     MOVF 0xFE1, W, ACCESS
1E660  0FFD     ADDLW 0xFD
1E662  6ED9     MOVWF 0xFD9, ACCESS
1E664  50E2     MOVF 0xFE2, W, ACCESS
1E666  6EDA     MOVWF __end_of_UART2_tx_vect_isr, ACCESS
1E668  0EFF     MOVLW 0xFF
1E66A  22DA     ADDWFC __end_of_UART2_tx_vect_isr, F, ACCESS
1E66C  D801     RCALL 0xE670
1E66E  D021     BRA 0xE6B2
1E670  0005     PUSH
1E672  6EFA     MOVWF 0xFFA, ACCESS
1E674  50DE     MOVF 0xFDE, W, ACCESS
1E676  6EFD     MOVWF 0xFFD, ACCESS
1E678  50DE     MOVF 0xFDE, W, ACCESS
1E67A  6EFE     MOVWF 0xFFE, ACCESS
1E67C  50DE     MOVF 0xFDE, W, ACCESS
1E67E  6EFF     MOVWF 0xFFF, ACCESS
1E680  50FA     MOVF 0xFFA, W, ACCESS
1E682  0012     RETURN 0
589:           		} else {
590:           			if (online_count++ > ONLINE_TIMEOUT) {
1E684  0106     MOVLB 0x6
1E686  515A     MOVF 0x5A, W, BANKED
1E688  6E0B     MOVWF 0xB, ACCESS
1E68A  515B     MOVF 0x5B, W, BANKED
1E68C  6E0C     MOVWF 0xC, ACCESS
1E68E  4B5A     INFSNZ 0x5A, F, BANKED
1E690  2B5B     INCF 0x5B, F, BANKED
1E692  0E31     MOVLW 0x31
1E694  5C0B     SUBWF 0xB, W, ACCESS
1E696  0E75     MOVLW 0x75
1E698  580C     SUBWFB 0xC, W, ACCESS
1E69A  A0D8     BTFSS 0xFD8, 0, ACCESS
1E69C  D00A     BRA 0xE6B2
591:           				online_count = 0;
1E69E  6B5A     CLRF 0x5A, BANKED
1E6A0  6B5B     CLRF 0x5B, BANKED
592:           				B.FM80_online = false;
1E6A2  0105     MOVLB 0x5
1E6A4  6B6F     CLRF CMOUT, BANKED
593:           				B.FM80_io = false;
1E6A6  6B70     CLRF CM1CON0, BANKED
594:           				cc_mode = STATUS_LAST;
1E6A8  0E00     MOVLW 0x0
1E6AA  6E4C     MOVWF ZCDCON, ACCESS
1E6AC  0E05     MOVLW 0x5
1E6AE  6E4B     MOVWF HLVDCON1, ACCESS
595:           				state = state_init;
1E6B0  6BE3     CLRF 0xE3, BANKED
596:           			}
597:           		}
598:           	}
599:           	if ((B.FM80_online == false) && online_count++ > ONLINE_TIMEOUT) {
1E6B2  0105     MOVLB 0x5
1E6B4  516F     MOVF CMOUT, W, BANKED
1E6B6  A4D8     BTFSS 0xFD8, 2, ACCESS
1E6B8  D02D     BRA 0xE714
1E6BA  0106     MOVLB 0x6
1E6BC  515A     MOVF 0x5A, W, BANKED
1E6BE  6E0B     MOVWF 0xB, ACCESS
1E6C0  515B     MOVF 0x5B, W, BANKED
1E6C2  6E0C     MOVWF 0xC, ACCESS
1E6C4  4B5A     INFSNZ 0x5A, F, BANKED
1E6C6  2B5B     INCF 0x5B, F, BANKED
1E6C8  0E31     MOVLW 0x31
1E6CA  5C0B     SUBWF 0xB, W, ACCESS
1E6CC  0E75     MOVLW 0x75
1E6CE  580C     SUBWFB 0xC, W, ACCESS
1E6D0  A0D8     BTFSS 0xFD8, 0, ACCESS
1E6D2  D020     BRA 0xE714
600:           		online_count = 0;
1E6D4  6B5A     CLRF 0x5A, BANKED
1E6D6  6B5B     CLRF 0x5B, BANKED
601:           		B.FM80_online = false;
1E6D8  0105     MOVLB 0x5
1E6DA  6B6F     CLRF CMOUT, BANKED
602:           		B.FM80_io = false;
1E6DC  6B70     CLRF CM1CON0, BANKED
603:           		cc_mode = STATUS_LAST;
1E6DE  0E00     MOVLW 0x0
1E6E0  6E4C     MOVWF ZCDCON, ACCESS
1E6E2  0E05     MOVLW 0x5
1E6E4  6E4B     MOVWF HLVDCON1, ACCESS
604:           		state = state_watts;
1E6E6  0E05     MOVLW 0x5
1E6E8  6FE3     MOVWF 0xE3, BANKED
605:           		mx_code = 0x0;
1E6EA  6BDB     CLRF CLCnSEL3, BANKED
1E6EC  6BDC     CLRF CLCnGLS0, BANKED
606:           		DataHandler();
1E6EE  50E1     MOVF 0xFE1, W, ACCESS
1E6F0  0FFD     ADDLW 0xFD
1E6F2  6ED9     MOVWF 0xFD9, ACCESS
1E6F4  50E2     MOVF 0xFE2, W, ACCESS
1E6F6  6EDA     MOVWF __end_of_UART2_tx_vect_isr, ACCESS
1E6F8  0EFF     MOVLW 0xFF
1E6FA  22DA     ADDWFC __end_of_UART2_tx_vect_isr, F, ACCESS
1E6FC  D801     RCALL 0xE700
1E6FE  D00A     BRA 0xE714
1E700  0005     PUSH
1E702  6EFA     MOVWF 0xFFA, ACCESS
1E704  50DE     MOVF 0xFDE, W, ACCESS
1E706  6EFD     MOVWF 0xFFD, ACCESS
1E708  50DE     MOVF 0xFDE, W, ACCESS
1E70A  6EFE     MOVWF 0xFFE, ACCESS
1E70C  50DE     MOVF 0xFDE, W, ACCESS
1E70E  6EFF     MOVWF 0xFFF, ACCESS
1E710  50FA     MOVF 0xFFA, W, ACCESS
1E712  0012     RETURN 0
607:           	}
608:           
609:           }
1E714  52E5     MOVF 0xFE5, F, ACCESS
1E714  52E5     MOVF 0xFE5, F, ACCESS
1E714  52E5     MOVF 0xFE5, F, ACCESS
1E714  52E5     MOVF 0xFE5, F, ACCESS
1E714  52E5     MOVF 0xFE5, F, ACCESS
610:           
611:           void state_init_cb(void)
1C25A  52E6     MOVF 0xFE6, F, ACCESS
1C25C  52E6     MOVF 0xFE6, F, ACCESS
1C25E  52E6     MOVF 0xFE6, F, ACCESS
1C260  52E6     MOVF 0xFE6, F, ACCESS
612:           {
613:           	float Soc;
614:           	static uint8_t off_delay = 0;
615:           
616:           	mx_code = abuf[2]&0xf;
1C262  0E0F     MOVLW 0xF
1C264  0107     MOVLB 0x7
1C266  1539     ANDWF CLKRCON, W, BANKED
1C268  0105     MOVLB 0x5
1C26A  6FDB     MOVWF CLCnSEL3, BANKED
1C26C  6BDC     CLRF CLCnGLS0, BANKED
617:           	if (mx_code == FM80_ID) {
1C26E  0E03     MOVLW 0x3
1C270  19DB     XORWF CLCnSEL3, W, BANKED
1C272  11DC     IORWF CLCnGLS0, W, BANKED
1C274  A4D8     BTFSS 0xFD8, 2, ACCESS
1C276  D0B5     BRA 0xC3E2
618:           		printf("\r\n\r\n%5d %3x %3x %3x %3x %3x   INIT: FM80 Online\r\n", B.rx_count++, abuf[0], abuf[1], abuf[2], abuf[3], abuf[4]);
1C278  C73D     MOVFF 0x73D, POSTINC1
1C27A  F4E6     NOP
1C27C  C73E     MOVFF 0x73E, POSTINC1
1C27E  F4E6     NOP
1C280  C73B     MOVFF 0x73B, POSTINC1
1C282  F4E6     NOP
1C284  C73C     MOVFF 0x73C, POSTINC1
1C286  F4E6     NOP
1C288  C739     MOVFF 0x739, POSTINC1
1C28A  F4E6     NOP
1C28C  C73A     MOVFF 0x73A, POSTINC1
1C28E  F4E6     NOP
1C290  C737     MOVFF 0x737, POSTINC1
1C292  F4E6     NOP
1C294  C738     MOVFF 0x738, POSTINC1
1C296  F4E6     NOP
1C298  C735     MOVFF abuf, POSTINC1
1C29A  F4E6     NOP
1C29C  C736     MOVFF 0x736, POSTINC1
1C29E  F4E6     NOP
1C2A0  5167     MOVF PMD7, W, BANKED
1C2A2  6E0B     MOVWF 0xB, ACCESS
1C2A4  5168     MOVF PMD8, W, BANKED
1C2A6  6E0C     MOVWF 0xC, ACCESS
1C2A8  4B67     INFSNZ PMD7, F, BANKED
1C2AA  2B68     INCF PMD8, F, BANKED
1C2AC  0061     MOVFFL wtemp5, POSTINC1
1C2AE  F42C     NOP
1C2B0  F4E6     NOP
1C2B2  0061     MOVFFL 0x50C, POSTINC1
1C2B4  F430     NOP
1C2B6  F4E6     NOP
1C2B8  0E30     MOVLW 0x30
1C2BA  6EE6     MOVWF 0xFE6, ACCESS
1C2BC  0EFC     MOVLW 0xFC
1C2BE  6EE6     MOVWF 0xFE6, ACCESS
1C2C0  0E0E     MOVLW 0xE
1C2C2  6EE6     MOVWF 0xFE6, ACCESS
1C2C4  ECD7     CALL 0xDAE, 0
1C2C6  F006     NOP
619:           		if (!B.FM80_online) { // try to guess battery energy by looking at battery voltage
1C2C8  516F     MOVF CMOUT, W, BANKED
1C2CA  A4D8     BTFSS 0xFD8, 2, ACCESS
1C2CC  D06B     BRA 0xC3A4
620:           			Soc = ((float) Volts_to_SOC(vw, vf) * 0.01f);
1C2CE  0E0A     MOVLW 0xA
1C2D0  6EE6     MOVWF 0xFE6, ACCESS
1C2D2  0ED7     MOVLW 0xD7
1C2D4  6EE6     MOVWF 0xFE6, ACCESS
1C2D6  0E23     MOVLW 0x23
1C2D8  6EE6     MOVWF 0xFE6, ACCESS
1C2DA  0E3C     MOVLW 0x3C
1C2DC  6EE6     MOVWF 0xFE6, ACCESS
1C2DE  C5D1     MOVFF vf, POSTINC1
1C2E0  F4E6     NOP
1C2E2  C5D2     MOVFF 0x5D2, POSTINC1
1C2E4  F4E6     NOP
1C2E6  C5CF     MOVFF vw, POSTINC1
1C2E8  F4E6     NOP
1C2EA  C5D0     MOVFF 0x5D0, POSTINC1
1C2EC  F4E6     NOP
1C2EE  EC6F     CALL 0x1E2DE, 0
1C2F0  F0F1     NOP
1C2F2  0061     MOVFFL ltemp0, wtemp5
1C2F4  F404     NOP
1C2F6  F50B     NOP
1C2F8  0061     MOVFFL ttemp5, 0x50C
1C2FA  F408     NOP
1C2FC  F50C     NOP
1C2FE  500B     MOVF 0xB, W, ACCESS
1C300  6E05     MOVWF 0x5, ACCESS
1C302  500C     MOVF 0xC, W, ACCESS
1C304  6E06     MOVWF 0x6, ACCESS
1C306  6A07     CLRF 0x7, ACCESS
1C308  6A08     CLRF 0x8, ACCESS
1C30A  0061     MOVFFL ltemp1, POSTINC1
1C30C  F414     NOP
1C30E  F4E6     NOP
1C310  0061     MOVFFL 0x506, POSTINC1
1C312  F418     NOP
1C314  F4E6     NOP
1C316  0061     MOVFFL ttemp2, POSTINC1
1C318  F41C     NOP
1C31A  F4E6     NOP
1C31C  0061     MOVFFL 0x508, POSTINC1
1C31E  F420     NOP
1C320  F4E6     NOP
1C322  0E00     MOVLW 0x0
1C324  6EE6     MOVWF 0xFE6, ACCESS
1C326  EC35     CALL 0x1BA6A, 0
1C328  F0DD     NOP
1C32A  0061     MOVFFL ltemp0, POSTINC1
1C32C  F404     NOP
1C32E  F4E6     NOP
1C330  0061     MOVFFL ttemp5, POSTINC1
1C332  F408     NOP
1C334  F4E6     NOP
1C336  0061     MOVFFL wtemp1, POSTINC1
1C338  F40C     NOP
1C33A  F4E6     NOP
1C33C  0061     MOVFFL ttemp1, POSTINC1
1C33E  F410     NOP
1C340  F4E6     NOP
1C342  EC2F     CALL 0x1705E, 0
1C344  F0B8     NOP
1C346  0EFC     MOVLW 0xFC
1C348  0061     MOVFFL ltemp0, PLUSW1
1C34A  F404     NOP
1C34C  F4E3     NOP
1C34E  0EFD     MOVLW 0xFD
1C350  0061     MOVFFL ttemp5, PLUSW1
1C352  F408     NOP
1C354  F4E3     NOP
1C356  0EFE     MOVLW 0xFE
1C358  0061     MOVFFL wtemp1, PLUSW1
1C35A  F40C     NOP
1C35C  F4E3     NOP
1C35E  0EFF     MOVLW 0xFF
1C360  0061     MOVFFL ttemp1, PLUSW1
1C362  F410     NOP
1C364  F4E3     NOP
621:           			EB->bat_energy = BAT_ENERGY*Soc;
1C366  0E00     MOVLW 0x0
1C368  6EE6     MOVWF 0xFE6, ACCESS
1C36A  0E00     MOVLW 0x0
1C36C  6EE6     MOVWF 0xFE6, ACCESS
1C36E  0EE1     MOVLW 0xE1
1C370  6EE6     MOVWF 0xFE6, ACCESS
1C372  0E49     MOVLW 0x49
1C374  6EE6     MOVWF 0xFE6, ACCESS
1C376  0EF8     MOVLW 0xF8
1C378  C4E3     MOVFF PLUSW1, POSTINC1
1C37A  F4E6     NOP
1C37C  C4E3     MOVFF PLUSW1, POSTINC1
1C37E  F4E6     NOP
1C380  C4E3     MOVFF PLUSW1, POSTINC1
1C382  F4E6     NOP
1C384  C4E3     MOVFF PLUSW1, POSTINC1
1C386  F4E6     NOP
1C388  EC2F     CALL 0x1705E, 0
1C38A  F0B8     NOP
1C38C  0061     MOVFFL ltemp0, 0x82C
1C38E  F404     NOP
1C390  F82C     NOP
1C392  0061     MOVFFL ttemp5, 0x82D
1C394  F408     NOP
1C396  F82D     NOP
1C398  0061     MOVFFL wtemp1, 0x82E
1C39A  F40C     NOP
1C39C  F82E     NOP
1C39E  0061     MOVFFL ttemp1, 0x82F
1C3A0  F410     NOP
1C3A2  F82F     NOP
622:           		}
623:           		B.FM80_online = true;
1C3A4  0E01     MOVLW 0x1
1C3A6  0105     MOVLB 0x5
1C3A8  6F6F     MOVWF CMOUT, BANKED
624:           		off_delay = 0;
1C3AA  6BDF     CLRF CLCnGLS3, BANKED
625:           		snprintf(buffer, MAX_B_BUF, "FM80 Online         ");
1C3AC  0EB8     MOVLW 0xB8
1C3AE  6EE6     MOVWF 0xFE6, ACCESS
1C3B0  0EFE     MOVLW 0xFE
1C3B2  6EE6     MOVWF 0xFE6, ACCESS
1C3B4  0EFF     MOVLW 0xFF
1C3B6  6EE6     MOVWF 0xFE6, ACCESS
1C3B8  0E00     MOVLW 0x0
1C3BA  6EE6     MOVWF 0xFE6, ACCESS
1C3BC  0E00     MOVLW 0x0
1C3BE  6EE6     MOVWF 0xFE6, ACCESS
1C3C0  0E0B     MOVLW 0xB
1C3C2  6EE6     MOVWF 0xFE6, ACCESS
1C3C4  0E06     MOVLW 0x6
1C3C6  6EE6     MOVWF 0xFE6, ACCESS
1C3C8  EC35     CALL 0x1C06A, 0
1C3CA  F0E0     NOP
626:           #ifndef LCD_MIRROR
627:           		eaDogM_WriteStringAtPos(3, 0, buffer);
1C3CC  0E00     MOVLW 0x0
1C3CE  6EE6     MOVWF 0xFE6, ACCESS
1C3D0  0E0B     MOVLW 0xB
1C3D2  6EE6     MOVWF 0xFE6, ACCESS
1C3D4  0E00     MOVLW 0x0
1C3D6  6EE6     MOVWF 0xFE6, ACCESS
1C3D8  0E03     MOVLW 0x3
1C3DA  6EE6     MOVWF 0xFE6, ACCESS
1C3DC  ECD9     CALL 0x1B2, 0
1C3DE  F000     NOP
628:           #endif
629:           	} else {
1C3E0  D026     BRA 0xC42E
630:           		snprintf(buffer, MAX_B_BUF, "FM80 Offline        ");
1C3E2  0E36     MOVLW 0x36
1C3E4  6EE6     MOVWF 0xFE6, ACCESS
1C3E6  0EFF     MOVLW 0xFF
1C3E8  6EE6     MOVWF 0xFE6, ACCESS
1C3EA  0EFF     MOVLW 0xFF
1C3EC  6EE6     MOVWF 0xFE6, ACCESS
1C3EE  0E00     MOVLW 0x0
1C3F0  6EE6     MOVWF 0xFE6, ACCESS
1C3F2  0E00     MOVLW 0x0
1C3F4  6EE6     MOVWF 0xFE6, ACCESS
1C3F6  0E0B     MOVLW 0xB
1C3F8  6EE6     MOVWF 0xFE6, ACCESS
1C3FA  0E06     MOVLW 0x6
1C3FC  6EE6     MOVWF 0xFE6, ACCESS
1C3FE  EC35     CALL 0x1C06A, 0
1C400  F0E0     NOP
631:           #ifndef LCD_MIRROR
632:           		eaDogM_WriteStringAtPos(3, 0, buffer);
1C402  0E00     MOVLW 0x0
1C404  6EE6     MOVWF 0xFE6, ACCESS
1C406  0E0B     MOVLW 0xB
1C408  6EE6     MOVWF 0xFE6, ACCESS
1C40A  0E00     MOVLW 0x0
1C40C  6EE6     MOVWF 0xFE6, ACCESS
1C40E  0E03     MOVLW 0x3
1C410  6EE6     MOVWF 0xFE6, ACCESS
1C412  ECD9     CALL 0x1B2, 0
1C414  F000     NOP
633:           #endif
634:           		if (off_delay++ > 3) {
1C416  0105     MOVLB 0x5
1C418  2BDF     INCF CLCnGLS3, F, BANKED
1C41A  05DF     DECF CLCnGLS3, W, BANKED
1C41C  6E0C     MOVWF 0xC, ACCESS
1C41E  0E03     MOVLW 0x3
1C420  640C     CPFSGT 0xC, ACCESS
1C422  D005     BRA 0xC42E
635:           			B.FM80_online = false;
1C424  6B6F     CLRF CMOUT, BANKED
636:           			cc_mode = STATUS_LAST;
1C426  0E00     MOVLW 0x0
1C428  6E4C     MOVWF ZCDCON, ACCESS
1C42A  0E05     MOVLW 0x5
1C42C  6E4B     MOVWF HLVDCON1, ACCESS
637:           		}
638:           	}
639:           	state = state_status;
1C42E  0E01     MOVLW 0x1
1C430  0105     MOVLB 0x5
1C432  6FE3     MOVWF 0xE3, BANKED
640:           }
1C434  52E5     MOVF 0xFE5, F, ACCESS
1C434  52E5     MOVF 0xFE5, F, ACCESS
1C434  52E5     MOVF 0xFE5, F, ACCESS
1C434  52E5     MOVF 0xFE5, F, ACCESS
1C434  52E5     MOVF 0xFE5, F, ACCESS
641:           
642:           void state_status_cb(void)
643:           {
644:           	static uint16_t day_clocks = 0;
645:           	static uint8_t status_prev = STATUS_SLEEPING;
646:           
647:           #ifdef debug_data
648:           	printf("%5d: %3x %3x %3x %3x %3x STATUS: FM80 %s mode\r\n", rx_count++, abuf[0], abuf[1], abuf[2], abuf[3], abuf[4], state_name[abuf[2]]);
649:           #endif
650:           
651:           	/*
652:           	 * check for the start and end of a solar production day
653:           	 * sets update flag if day state changes and has day change charge controllers
654:           	 * status in pv_prev variable
655:           	 */
656:           
657:           	/* clear event counter timer 10s ticks */
658:           	if (B.day_check++ > CHK_DAY_TIME) {
1FCC6  0105     MOVLB 0x5
1FCC8  516D     MOVF MD1CARL, W, BANKED
1FCCA  6E0B     MOVWF 0xB, ACCESS
1FCCC  516E     MOVF MD1CARH, W, BANKED
1FCCE  6E0C     MOVWF 0xC, ACCESS
1FCD0  4B6D     INFSNZ MD1CARL, F, BANKED
1FCD2  2B6E     INCF MD1CARH, F, BANKED
1FCD4  500C     MOVF 0xC, W, ACCESS
1FCD6  E104     BNZ 0xFCE0
1FCD8  0E79     MOVLW 0x79
1FCDA  5C0B     SUBWF 0xB, W, ACCESS
1FCDC  A0D8     BTFSS 0xFD8, 0, ACCESS
1FCDE  D005     BRA 0xFCEA
659:           		B.day_check = 0;
1FCE0  6B6D     CLRF MD1CARL, BANKED
1FCE2  6B6E     CLRF MD1CARH, BANKED
660:           		day_clocks = 0;
1FCE4  0106     MOVLB 0x6
1FCE6  6B58     CLRF 0x58, BANKED
1FCE8  6B59     CLRF 0x59, BANKED
661:           	}
662:           
663:           	if (FMxx_STATE != STATUS_SLEEPING) {
1FCEA  0107     MOVLB 0x7
1FCEC  5139     MOVF CLKRCON, W, BANKED
1FCEE  113A     IORWF CLKRCLK, W, BANKED
1FCF0  B4D8     BTFSC 0xFD8, 2, ACCESS
1FCF2  D01B     BRA 0xFD2A
664:           		if (++day_clocks > BAT_DAY_COUNT) {
1FCF4  0106     MOVLB 0x6
1FCF6  4B58     INFSNZ 0x58, F, BANKED
1FCF8  2B59     INCF 0x59, F, BANKED
1FCFA  5159     MOVF 0x59, W, BANKED
1FCFC  E104     BNZ 0xFD06
1FCFE  0E2E     MOVLW 0x2E
1FD00  5D58     SUBWF 0x58, W, BANKED
1FD02  A0D8     BTFSS 0xFD8, 0, ACCESS
1FD04  D02B     BRA 0xFD5C
665:           			day_clocks = 0;
1FD06  6B58     CLRF 0x58, BANKED
1FD08  6B59     CLRF 0x59, BANKED
666:           			B.day_check = 0;
1FD0A  0105     MOVLB 0x5
1FD0C  6B6D     CLRF MD1CARL, BANKED
1FD0E  6B6E     CLRF MD1CARH, BANKED
667:           			if (B.pv_prev == STATUS_SLEEPING) { // check sun on PV and trigger a daily energy update
1FD10  516B     MOVF MD1CON1, W, BANKED
1FD12  116C     IORWF MD1SRC, W, BANKED
1FD14  A4D8     BTFSS 0xFD8, 2, ACCESS
1FD16  D006     BRA 0xFD24
668:           				B.pv_update = true;
1FD18  0E01     MOVLW 0x1
1FD1A  6F64     MOVWF PMD4, BANKED
669:           				B.pv_prev = FMxx_STATE;
1FD1C  C739     MOVFF 0x739, 0x56B
1FD1E  F56B     NOP
1FD20  C73A     MOVFF 0x73A, 0x56C
1FD22  F56C     NOP
670:           			}
671:           			B.pv_high = true;
1FD24  0E01     MOVLW 0x1
1FD26  6F63     MOVWF PMD3, BANKED
1FD28  D019     BRA 0xFD5C
672:           		}
673:           	} else {
674:           		if (++day_clocks > BAT_DAY_COUNT) {
1FD2A  0106     MOVLB 0x6
1FD2C  4B58     INFSNZ 0x58, F, BANKED
1FD2E  2B59     INCF 0x59, F, BANKED
1FD30  5159     MOVF 0x59, W, BANKED
1FD32  E104     BNZ 0xFD3C
1FD34  0E2E     MOVLW 0x2E
1FD36  5D58     SUBWF 0x58, W, BANKED
1FD38  A0D8     BTFSS 0xFD8, 0, ACCESS
1FD3A  D010     BRA 0xFD5C
675:           			day_clocks = 0;
1FD3C  6B58     CLRF 0x58, BANKED
1FD3E  6B59     CLRF 0x59, BANKED
676:           			B.day_check = 0;
1FD40  0105     MOVLB 0x5
1FD42  6B6D     CLRF MD1CARL, BANKED
1FD44  6B6E     CLRF MD1CARH, BANKED
677:           			if (B.pv_prev != STATUS_SLEEPING) { // check for night and update day totals
1FD46  516B     MOVF MD1CON1, W, BANKED
1FD48  116C     IORWF MD1SRC, W, BANKED
1FD4A  B4D8     BTFSC 0xFD8, 2, ACCESS
1FD4C  D006     BRA 0xFD5A
678:           				B.pv_update = true;
1FD4E  0E01     MOVLW 0x1
1FD50  6F64     MOVWF PMD4, BANKED
679:           				B.pv_prev = FMxx_STATE;
1FD52  C739     MOVFF 0x739, 0x56B
1FD54  F56B     NOP
1FD56  C73A     MOVFF 0x73A, 0x56C
1FD58  F56C     NOP
680:           			}
681:           			B.pv_high = false;
1FD5A  6B63     CLRF PMD3, BANKED
682:           		}
683:           
684:           	}
685:           	if (B.FM80_online) { // don't update when offline
1FD5C  0105     MOVLB 0x5
1FD5E  516F     MOVF CMOUT, W, BANKED
1FD60  B4D8     BTFSC 0xFD8, 2, ACCESS
1FD62  D004     BRA 0xFD6C
686:           		cc_mode = FMxx_STATE;
1FD64  C739     MOVFF 0x739, cc_mode
1FD66  F54B     NOP
1FD68  C73A     MOVFF 0x73A, 0x54C
1FD6A  F54C     NOP
687:           	}
688:           	state = state_watts;
1FD6C  0E05     MOVLW 0x5
1FD6E  6FE3     MOVWF 0xE3, BANKED
689:           }
1FD70  0012     RETURN 0
690:           
691:           void state_panelv_cb(void)
692:           {
693:           #ifdef debug_data
694:           	printf("%5d: %3x %3x %3x %3x %3x   DATA: Panel Voltage %iVDC\r\n", rx_count++, abuf[0], abuf[1], abuf[2], abuf[3], abuf[4], (abuf[2] + (abuf[1] << 8)));
695:           #endif
696:           	state = state_batteryv;
2706  0E03     MOVLW 0x3
2708  0105     MOVLB 0x5
270A  6FE3     MOVWF 0xE3, BANKED
697:           }
270C  0012     RETURN 0
698:           
699:           void state_batteryv_cb(void)
1F44  0107     MOVLB 0x7
1F46  5137     MOVF 0x37, W, BANKED
1F48  6E0C     MOVWF 0xC, ACCESS
1F4A  6A0B     CLRF 0xB, ACCESS
1F4C  5139     MOVF CLKRCON, W, BANKED
1F4E  260B     ADDWF 0xB, F, ACCESS
1F50  513A     MOVF CLKRCLK, W, BANKED
1F52  220C     ADDWFC 0xC, F, ACCESS
700:           {
701:           	volt_f((abuf[2] + (abuf[1] << 8)));
1F54  0061     MOVFFL wtemp5, POSTINC1
1F56  F42C     NOP
1F58  F4E6     NOP
1F5A  0061     MOVFFL 0x50C, POSTINC1
1F5C  F430     NOP
1F5E  F4E6     NOP
1F60  EC92     CALL 0xF24, 0
1F62  F007     NOP
702:           #ifdef debug_data
703:           	printf("%5d: %3x %3x %3x %3x %3x   DATA: Battery Voltage %d.%01dVDC\r\n", rx_count++, abuf[0], abuf[1], abuf[2], abuf[3], abuf[4], volt_whole, volt_fract);
704:           #endif
705:           	state = state_batterya;
1F64  0E04     MOVLW 0x4
1F66  0105     MOVLB 0x5
1F68  6FE3     MOVWF 0xE3, BANKED
706:           }
1F6A  0012     RETURN 0
707:           
708:           void state_batterya_cb(void)
1F1C  0107     MOVLB 0x7
1F1E  5137     MOVF 0x37, W, BANKED
1F20  6E0C     MOVWF 0xC, ACCESS
1F22  6A0B     CLRF 0xB, ACCESS
1F24  5139     MOVF CLKRCON, W, BANKED
1F26  260B     ADDWF 0xB, F, ACCESS
1F28  513A     MOVF CLKRCLK, W, BANKED
1F2A  220C     ADDWFC 0xC, F, ACCESS
709:           {
710:           	volt_f((abuf[2] + (abuf[1] << 8)));
1F2C  0061     MOVFFL wtemp5, POSTINC1
1F2E  F42C     NOP
1F30  F4E6     NOP
1F32  0061     MOVFFL 0x50C, POSTINC1
1F34  F430     NOP
1F36  F4E6     NOP
1F38  EC92     CALL 0xF24, 0
1F3A  F007     NOP
711:           #ifdef debug_data
712:           	printf("%5d: %3x %3x %3x %3x %3x   DATA: Battery Amps %dADC\r\n", rx_count++, abuf[0], abuf[1], abuf[2], abuf[3], abuf[4], abuf[2] - 128);
713:           #endif
714:           	state = state_watts;
1F3C  0E05     MOVLW 0x5
1F3E  0105     MOVLB 0x5
1F40  6FE3     MOVWF 0xE3, BANKED
715:           }
1F42  0012     RETURN 0
716:           
717:           void state_watts_cb(void)
718:           {
719:           #ifdef debug_data
720:           	printf("%5d: %3x %3x %3x %3x %3x   DATA: Panel Watts %iW\r\n", rx_count++, abuf[0], abuf[1], abuf[2], abuf[3], abuf[4], (abuf[2] + (abuf[1] << 8)));
721:           #endif
722:           	panel_watts = (abuf[2] + (abuf[1] << 8));
1D6E  0107     MOVLB 0x7
1D70  5137     MOVF 0x37, W, BANKED
1D72  6E0C     MOVWF 0xC, ACCESS
1D74  6A0B     CLRF 0xB, ACCESS
1D76  5139     MOVF CLKRCON, W, BANKED
1D78  240B     ADDWF 0xB, W, ACCESS
1D7A  0105     MOVLB 0x5
1D7C  6FD5     MOVWF CLCSELECT, BANKED
1D7E  0107     MOVLB 0x7
1D80  513A     MOVF CLKRCLK, W, BANKED
1D82  200C     ADDWFC 0xC, W, ACCESS
1D84  0105     MOVLB 0x5
1D86  6FD6     MOVWF CLCnCON, BANKED
723:           	if (B.FM80_online) {
1D88  516F     MOVF CMOUT, W, BANKED
1D8A  B4D8     BTFSC 0xFD8, 2, ACCESS
1D8C  D003     BRA 0x1D94
724:           		state = state_mx_log; // only get log data once state_init_cb has run
1D8E  0E09     MOVLW 0x9
1D90  6FE3     MOVWF 0xE3, BANKED
725:           	} else {
1D92  0012     RETURN 0
726:           		state = state_mx_status;
1D94  0E0B     MOVLW 0xB
1D96  6FE3     MOVWF 0xE3, BANKED
727:           	}
728:           }
1D98  0012     RETURN 0
729:           
730:           void state_mx_log_cb(void)
731:           {
732:           	B.log.volts_peak = (int16_t) cbuf[5];
1B5C0  C98A     MOVFF 0x98A, 0x59C
1B5C2  F59C     NOP
1B5C4  C98B     MOVFF 0x98B, 0x59D
1B5C6  F59D     NOP
733:           	B.log.day = (int16_t) cbuf[14];
1B5C8  C99C     MOVFF 0x99C, 0x596
1B5CA  F596     NOP
1B5CC  C99D     MOVFF 0x99D, 0x597
1B5CE  F597     NOP
734:           	B.log.kilowatt_hours = (int16_t) (((uint16_t) (cbuf[3] & 0xF0) >> 4) | (uint16_t) (cbuf[4] << 4));
1B5D0  EE22     LFSR 2, 0x988
1B5D2  F188     NOP
1B5D4  0061     MOVFFL POSTINC2, wtemp5
1B5D6  F378     NOP
1B5D8  F50B     NOP
1B5DA  0061     MOVFFL POSTDEC2, 0x50C
1B5DC  F374     NOP
1B5DE  F50C     NOP
1B5E0  3A0B     SWAPF 0xB, F, ACCESS
1B5E2  3A0C     SWAPF 0xC, F, ACCESS
1B5E4  0EF0     MOVLW 0xF0
1B5E6  160C     ANDWF 0xC, F, ACCESS
1B5E8  500B     MOVF 0xB, W, ACCESS
1B5EA  0B0F     ANDLW 0xF
1B5EC  120C     IORWF 0xC, F, ACCESS
1B5EE  0EF0     MOVLW 0xF0
1B5F0  160B     ANDWF 0xB, F, ACCESS
1B5F2  EE22     LFSR 2, 0x986
1B5F4  F186     NOP
1B5F6  0061     MOVFFL POSTINC2, ltemp2
1B5F8  F378     NOP
1B5FA  F509     NOP
1B5FC  0061     MOVFFL POSTDEC2, ttemp3
1B5FE  F374     NOP
1B600  F50A     NOP
1B602  0E04     MOVLW 0x4
1B604  6E01     MOVWF __ptext283, ACCESS
1B606  90D8     BCF 0xFD8, 0, ACCESS
1B608  320A     RRCF 0xA, F, ACCESS
1B60A  3209     RRCF 0x9, F, ACCESS
1B60C  2E01     DECFSZ __ptext283, F, ACCESS
1B60E  D7FB     BRA 0xB606
1B610  0E0F     MOVLW 0xF
1B612  1609     ANDWF 0x9, F, ACCESS
1B614  0E00     MOVLW 0x0
1B616  160A     ANDWF 0xA, F, ACCESS
1B618  500B     MOVF 0xB, W, ACCESS
1B61A  1009     IORWF 0x9, W, ACCESS
1B61C  0105     MOVLB 0x5
1B61E  6F9A     MOVWF 0x9A, BANKED
1B620  500C     MOVF 0xC, W, ACCESS
1B622  100A     IORWF 0xA, W, ACCESS
1B624  6F9B     MOVWF 0x9B, BANKED
735:           	B.log.kilowatts_peak = (int16_t) (((uint16_t) (cbuf[13] & 0xFC) >> 2) | (uint16_t) (cbuf[12] << 6));
1B626  EE22     LFSR 2, 0x998
1B628  F198     NOP
1B62A  0061     MOVFFL POSTINC2, wtemp5
1B62C  F378     NOP
1B62E  F50B     NOP
1B630  0061     MOVFFL POSTDEC2, 0x50C
1B632  F374     NOP
1B634  F50C     NOP
1B636  0E06     MOVLW 0x6
1B638  90D8     BCF 0xFD8, 0, ACCESS
1B63A  360B     RLCF 0xB, F, ACCESS
1B63C  360C     RLCF 0xC, F, ACCESS
1B63E  2EE8     DECFSZ 0xFE8, F, ACCESS
1B640  D7FB     BRA 0xB638
1B642  EE22     LFSR 2, 0x99A
1B644  F19A     NOP
1B646  0061     MOVFFL POSTINC2, ltemp2
1B648  F378     NOP
1B64A  F509     NOP
1B64C  0061     MOVFFL POSTDEC2, ttemp3
1B64E  F374     NOP
1B650  F50A     NOP
1B652  90D8     BCF 0xFD8, 0, ACCESS
1B654  320A     RRCF 0xA, F, ACCESS
1B656  3209     RRCF 0x9, F, ACCESS
1B658  90D8     BCF 0xFD8, 0, ACCESS
1B65A  320A     RRCF 0xA, F, ACCESS
1B65C  3209     RRCF 0x9, F, ACCESS
1B65E  0E3F     MOVLW 0x3F
1B660  1609     ANDWF 0x9, F, ACCESS
1B662  0E00     MOVLW 0x0
1B664  160A     ANDWF 0xA, F, ACCESS
1B666  500B     MOVF 0xB, W, ACCESS
1B668  1009     IORWF 0x9, W, ACCESS
1B66A  6FA0     MOVWF 0xA0, BANKED
1B66C  500C     MOVF 0xC, W, ACCESS
1B66E  100A     IORWF 0xA, W, ACCESS
1B670  6FA1     MOVWF 0xA1, BANKED
736:           	B.log.bat_max = (int16_t) (((uint16_t) (cbuf[2] & 0xFC) >> 2) | (uint16_t) ((cbuf[3] & 0x0F) << 6));
1B672  0E0F     MOVLW 0xF
1B674  0109     MOVLB 0x9
1B676  1586     ANDWF SPI1CON2, W, BANKED
1B678  6E0B     MOVWF 0xB, ACCESS
1B67A  0E00     MOVLW 0x0
1B67C  1587     ANDWF SPI1STATUS, W, BANKED
1B67E  6E0C     MOVWF 0xC, ACCESS
1B680  0E06     MOVLW 0x6
1B682  90D8     BCF 0xFD8, 0, ACCESS
1B684  360B     RLCF 0xB, F, ACCESS
1B686  360C     RLCF 0xC, F, ACCESS
1B688  2EE8     DECFSZ 0xFE8, F, ACCESS
1B68A  D7FB     BRA 0xB682
1B68C  EE22     LFSR 2, 0x984
1B68E  F184     NOP
1B690  0061     MOVFFL POSTINC2, ltemp2
1B692  F378     NOP
1B694  F509     NOP
1B696  0061     MOVFFL POSTDEC2, ttemp3
1B698  F374     NOP
1B69A  F50A     NOP
1B69C  90D8     BCF 0xFD8, 0, ACCESS
1B69E  320A     RRCF 0xA, F, ACCESS
1B6A0  3209     RRCF 0x9, F, ACCESS
1B6A2  90D8     BCF 0xFD8, 0, ACCESS
1B6A4  320A     RRCF 0xA, F, ACCESS
1B6A6  3209     RRCF 0x9, F, ACCESS
1B6A8  0E3F     MOVLW 0x3F
1B6AA  1609     ANDWF 0x9, F, ACCESS
1B6AC  0E00     MOVLW 0x0
1B6AE  160A     ANDWF 0xA, F, ACCESS
1B6B0  500B     MOVF 0xB, W, ACCESS
1B6B2  1009     IORWF 0x9, W, ACCESS
1B6B4  0105     MOVLB 0x5
1B6B6  6FA4     MOVWF 0xA4, BANKED
1B6B8  500C     MOVF 0xC, W, ACCESS
1B6BA  100A     IORWF 0xA, W, ACCESS
1B6BC  6FA5     MOVWF 0xA5, BANKED
737:           	B.log.bat_min = (int16_t) (((uint16_t) (cbuf[10] & 0xC0) >> 6) | (uint16_t) ((cbuf[11] << 2) | ((cbuf[12] & 0x03) << 10)));
1B6BE  0E03     MOVLW 0x3
1B6C0  0109     MOVLB 0x9
1B6C2  1598     ANDWF SPI2INTE, W, BANKED
1B6C4  6E0B     MOVWF 0xB, ACCESS
1B6C6  0E00     MOVLW 0x0
1B6C8  1599     ANDWF SPI2CLK, W, BANKED
1B6CA  6E0C     MOVWF 0xC, ACCESS
1B6CC  0E0A     MOVLW 0xA
1B6CE  90D8     BCF 0xFD8, 0, ACCESS
1B6D0  360B     RLCF 0xB, F, ACCESS
1B6D2  360C     RLCF 0xC, F, ACCESS
1B6D4  2EE8     DECFSZ 0xFE8, F, ACCESS
1B6D6  D7FB     BRA 0xB6CE
1B6D8  EE22     LFSR 2, 0x996
1B6DA  F196     NOP
1B6DC  0061     MOVFFL POSTINC2, ltemp2
1B6DE  F378     NOP
1B6E0  F509     NOP
1B6E2  0061     MOVFFL POSTDEC2, ttemp3
1B6E4  F374     NOP
1B6E6  F50A     NOP
1B6E8  90D8     BCF 0xFD8, 0, ACCESS
1B6EA  3609     RLCF 0x9, F, ACCESS
1B6EC  360A     RLCF 0xA, F, ACCESS
1B6EE  90D8     BCF 0xFD8, 0, ACCESS
1B6F0  3609     RLCF 0x9, F, ACCESS
1B6F2  360A     RLCF 0xA, F, ACCESS
1B6F4  500B     MOVF 0xB, W, ACCESS
1B6F6  1009     IORWF 0x9, W, ACCESS
1B6F8  6E07     MOVWF 0x7, ACCESS
1B6FA  500C     MOVF 0xC, W, ACCESS
1B6FC  100A     IORWF 0xA, W, ACCESS
1B6FE  6E08     MOVWF 0x8, ACCESS
1B700  EE22     LFSR 2, 0x994
1B702  F194     NOP
1B704  0061     MOVFFL POSTINC2, wtemp5
1B706  F378     NOP
1B708  F50B     NOP
1B70A  0061     MOVFFL POSTDEC2, 0x50C
1B70C  F374     NOP
1B70E  F50C     NOP
1B710  0E06     MOVLW 0x6
1B712  6E01     MOVWF __ptext283, ACCESS
1B714  90D8     BCF 0xFD8, 0, ACCESS
1B716  320C     RRCF 0xC, F, ACCESS
1B718  320B     RRCF 0xB, F, ACCESS
1B71A  2E01     DECFSZ __ptext283, F, ACCESS
1B71C  D7FB     BRA 0xB714
1B71E  0E03     MOVLW 0x3
1B720  160B     ANDWF 0xB, F, ACCESS
1B722  0E00     MOVLW 0x0
1B724  160C     ANDWF 0xC, F, ACCESS
1B726  5007     MOVF 0x7, W, ACCESS
1B728  100B     IORWF 0xB, W, ACCESS
1B72A  0105     MOVLB 0x5
1B72C  6FA2     MOVWF 0xA2, BANKED
1B72E  5008     MOVF 0x8, W, ACCESS
1B730  100C     IORWF 0xC, W, ACCESS
1B732  6FA3     MOVWF 0xA3, BANKED
738:           	B.log.amps_peak = (int16_t) (cbuf[1] | ((cbuf[2] & 0x03) << 8));
1B734  0E03     MOVLW 0x3
1B736  0109     MOVLB 0x9
1B738  1584     ANDWF SPI1CON0, W, BANKED
1B73A  6E0B     MOVWF 0xB, ACCESS
1B73C  0E00     MOVLW 0x0
1B73E  1585     ANDWF SPI1CON1, W, BANKED
1B740  6E0C     MOVWF 0xC, ACCESS
1B742  0061     MOVFFL wtemp5, 0x50C
1B744  F42C     NOP
1B746  F50C     NOP
1B748  6A0B     CLRF 0xB, ACCESS
1B74A  5182     MOVF SPI1TCNT, W, BANKED
1B74C  100B     IORWF 0xB, W, ACCESS
1B74E  0105     MOVLB 0x5
1B750  6F9E     MOVWF 0x9E, BANKED
1B752  0109     MOVLB 0x9
1B754  5183     MOVF SPI1TCNTH, W, BANKED
1B756  100C     IORWF 0xC, W, ACCESS
1B758  0105     MOVLB 0x5
1B75A  6F9F     MOVWF 0x9F, BANKED
739:           	B.log.amp_hours = (int16_t) (cbuf[9] | ((cbuf[10] & 0x3F) << 8));
1B75C  0E3F     MOVLW 0x3F
1B75E  0109     MOVLB 0x9
1B760  1594     ANDWF SPI2STATUS, W, BANKED
1B762  6E0B     MOVWF 0xB, ACCESS
1B764  0E00     MOVLW 0x0
1B766  1595     ANDWF SPI2TWIDTH, W, BANKED
1B768  6E0C     MOVWF 0xC, ACCESS
1B76A  0061     MOVFFL wtemp5, 0x50C
1B76C  F42C     NOP
1B76E  F50C     NOP
1B770  6A0B     CLRF 0xB, ACCESS
1B772  5192     MOVF SPI2CON1, W, BANKED
1B774  100B     IORWF 0xB, W, ACCESS
1B776  0105     MOVLB 0x5
1B778  6F98     MOVWF SPI2INTE, BANKED
1B77A  0109     MOVLB 0x9
1B77C  5193     MOVF SPI2CON2, W, BANKED
1B77E  100C     IORWF 0xC, W, ACCESS
1B780  0105     MOVLB 0x5
1B782  6F99     MOVWF SPI2CLK, BANKED
740:           	B.log.absorb_time = (int16_t) (cbuf[6] | ((cbuf[7] & 0x0F) << 8));
1B784  0E0F     MOVLW 0xF
1B786  0109     MOVLB 0x9
1B788  158E     ANDWF SPI2TXB, W, BANKED
1B78A  6E0B     MOVWF 0xB, ACCESS
1B78C  0E00     MOVLW 0x0
1B78E  158F     ANDWF SPI2TCNT, W, BANKED
1B790  6E0C     MOVWF 0xC, ACCESS
1B792  0061     MOVFFL wtemp5, 0x50C
1B794  F42C     NOP
1B796  F50C     NOP
1B798  6A0B     CLRF 0xB, ACCESS
1B79A  518C     MOVF SPI1CLK, W, BANKED
1B79C  100B     IORWF 0xB, W, ACCESS
1B79E  0105     MOVLB 0x5
1B7A0  6FA6     MOVWF 0xA6, BANKED
1B7A2  0109     MOVLB 0x9
1B7A4  518D     MOVF SPI2RXB, W, BANKED
1B7A6  100C     IORWF 0xC, W, ACCESS
1B7A8  0105     MOVLB 0x5
1B7AA  6FA7     MOVWF 0xA7, BANKED
741:           	B.log.float_time = (int16_t) (((cbuf[7] & 0xF0) >> 4) | (cbuf[8] << 4));
1B7AC  EE22     LFSR 2, 0x990
1B7AE  F190     NOP
1B7B0  0061     MOVFFL POSTINC2, wtemp5
1B7B2  F378     NOP
1B7B4  F50B     NOP
1B7B6  0061     MOVFFL POSTDEC2, 0x50C
1B7B8  F374     NOP
1B7BA  F50C     NOP
1B7BC  3A0B     SWAPF 0xB, F, ACCESS
1B7BE  3A0C     SWAPF 0xC, F, ACCESS
1B7C0  0EF0     MOVLW 0xF0
1B7C2  160C     ANDWF 0xC, F, ACCESS
1B7C4  500B     MOVF 0xB, W, ACCESS
1B7C6  0B0F     ANDLW 0xF
1B7C8  120C     IORWF 0xC, F, ACCESS
1B7CA  0EF0     MOVLW 0xF0
1B7CC  160B     ANDWF 0xB, F, ACCESS
1B7CE  EE22     LFSR 2, 0x98E
1B7D0  F18E     NOP
1B7D2  0061     MOVFFL POSTINC2, ltemp2
1B7D4  F378     NOP
1B7D6  F509     NOP
1B7D8  0061     MOVFFL POSTDEC2, ttemp3
1B7DA  F374     NOP
1B7DC  F50A     NOP
1B7DE  0E04     MOVLW 0x4
1B7E0  6E01     MOVWF __ptext283, ACCESS
1B7E2  90D8     BCF 0xFD8, 0, ACCESS
1B7E4  320A     RRCF 0xA, F, ACCESS
1B7E6  3209     RRCF 0x9, F, ACCESS
1B7E8  2E01     DECFSZ __ptext283, F, ACCESS
1B7EA  D7FB     BRA 0xB7E2
1B7EC  0E0F     MOVLW 0xF
1B7EE  1609     ANDWF 0x9, F, ACCESS
1B7F0  0E00     MOVLW 0x0
1B7F2  160A     ANDWF 0xA, F, ACCESS
1B7F4  500B     MOVF 0xB, W, ACCESS
1B7F6  1009     IORWF 0x9, W, ACCESS
1B7F8  6FA8     MOVWF 0xA8, BANKED
1B7FA  500C     MOVF 0xC, W, ACCESS
1B7FC  100A     IORWF 0xA, W, ACCESS
1B7FE  6FA9     MOVWF 0xA9, BANKED
742:           
743:           	cmd_mx_log[5] = B.log.select;
1B800  C5AA     MOVFF 0x5AA, 0x87B
1B802  F87B     NOP
1B804  0108     MOVLB 0x8
1B806  6B7C     CLRF WDTTMR, BANKED
744:           	cmd_mx_log[7] = 0x16 + B.log.select; // update the checksum
1B808  0E16     MOVLW 0x16
1B80A  0105     MOVLB 0x5
1B80C  25AA     ADDWF 0xAA, W, BANKED
1B80E  0108     MOVLB 0x8
1B810  6F7F     MOVWF DAC1CON, BANKED
1B812  6B80     CLRF SPI1RXB, BANKED
1B814  0E00     MOVLW 0x0
1B816  2380     ADDWFC SPI1RXB, F, BANKED
745:           
746:           	state = state_mx_status;
1B818  0E0B     MOVLW 0xB
1B81A  0105     MOVLB 0x5
1B81C  6FE3     MOVWF 0xE3, BANKED
747:           }
1B81E  0012     RETURN 0
748:           
749:           void state_mx_status_cb(void)
167A6  0107     MOVLB 0x7
167A8  5149     MOVF BORCON, W, BANKED
167AA  6E0C     MOVWF 0xC, ACCESS
167AC  6A0B     CLRF 0xB, ACCESS
167AE  514B     MOVF HLVDCON1, W, BANKED
167B0  260B     ADDWF 0xB, F, ACCESS
167B2  514C     MOVF ZCDCON, W, BANKED
167B4  220C     ADDWFC 0xC, F, ACCESS
750:           {
751:           	volt_f((abuf[11] + (abuf[10] << 8))); // set battery voltage here in volt_whole and volt_frac
167B6  0061     MOVFFL wtemp5, POSTINC1
167B8  F42C     NOP
167BA  F4E6     NOP
167BC  0061     MOVFFL 0x50C, POSTINC1
167BE  F430     NOP
167C0  F4E6     NOP
167C2  EC92     CALL 0xF24, 0
167C4  F007     NOP
752:           	vw = volt_whole;
167C6  C5D9     MOVFF volt_whole, vw
167C8  F5CF     NOP
167CA  C5DA     MOVFF 0x5DA, 0x5D0
167CC  F5D0     NOP
753:           	vf = volt_fract;
167CE  C5D3     MOVFF volt_fract, vf
167D0  F5D1     NOP
167D2  C5D4     MOVFF 0x5D4, 0x5D2
167D4  F5D2     NOP
754:           	volt_f((abuf[13] + (abuf[12] << 8))); // set panel voltage here in volt_whole and volt_frac
167D6  0107     MOVLB 0x7
167D8  514D     MOVF 0x4D, W, BANKED
167DA  6E0C     MOVWF 0xC, ACCESS
167DC  6A0B     CLRF 0xB, ACCESS
167DE  514F     MOVF 0x4F, W, BANKED
167E0  260B     ADDWF 0xB, F, ACCESS
167E2  5150     MOVF 0x50, W, BANKED
167E4  220C     ADDWFC 0xC, F, ACCESS
167E6  0061     MOVFFL wtemp5, POSTINC1
167E8  F42C     NOP
167EA  F4E6     NOP
167EC  0061     MOVFFL 0x50C, POSTINC1
167EE  F430     NOP
167F0  F4E6     NOP
167F2  EC92     CALL 0xF24, 0
167F4  F007     NOP
755:           	if ((abuf[1] &0x0f) > 9) { // check for whole Amp
167F6  0061     MOVFFL 0x737, 0x50C
167F8  FCDC     NOP
167FA  F50C     NOP
167FC  0E0F     MOVLW 0xF
167FE  160C     ANDWF 0xC, F, ACCESS
16800  0E09     MOVLW 0x9
16802  640C     CPFSGT 0xC, ACCESS
16804  D00F     BRA 0x6824
756:           		abuf[2]++; // add extra Amp for fractional overflow.
16806  0107     MOVLB 0x7
16808  4B39     INFSNZ CLKRCON, F, BANKED
1680A  2B3A     INCF CLKRCLK, F, BANKED
757:           		abuf[1] = (abuf[1]&0x0f) - 10;
1680C  0E0F     MOVLW 0xF
1680E  1537     ANDWF 0x37, W, BANKED
16810  6E0B     MOVWF 0xB, ACCESS
16812  0E00     MOVLW 0x0
16814  1538     ANDWF BOOTREG, W, BANKED
16816  6E0C     MOVWF 0xC, ACCESS
16818  0EF6     MOVLW 0xF6
1681A  240B     ADDWF 0xB, W, ACCESS
1681C  6F37     MOVWF 0x37, BANKED
1681E  0EFF     MOVLW 0xFF
16820  200C     ADDWFC 0xC, W, ACCESS
16822  6F38     MOVWF BOOTREG, BANKED
758:           	}
759:           	if (B.FM80_online) { // don't update when offline
16824  0105     MOVLB 0x5
16826  516F     MOVF CMOUT, W, BANKED
16828  B4D8     BTFSC 0xFD8, 2, ACCESS
1682A  D00E     BRA 0x6848
760:           		bat_amp_whole = abuf[3] - 128;
1682C  EE21     LFSR 2, 0x73B
1682E  F33B     NOP
16830  0061     MOVFFL POSTINC2, wtemp5
16832  F378     NOP
16834  F50B     NOP
16836  0061     MOVFFL POSTDEC2, 0x50C
16838  F374     NOP
1683A  F50C     NOP
1683C  0E80     MOVLW 0x80
1683E  240B     ADDWF 0xB, W, ACCESS
16840  6FD7     MOVWF CLCnPOL, BANKED
16842  0EFF     MOVLW 0xFF
16844  200C     ADDWFC 0xC, W, ACCESS
16846  6FD8     MOVWF CLCnSEL0, BANKED
761:           	}
762:           #ifdef debug_data
763:           	printf("%5d: %3x %3x %3x %3x %3x  SDATA: FM80 Data mode %3x %3x %3x %3x %3x %3x %3x %3x %3x\r\n",
764:           		rx_count++, abuf[0], abuf[1], abuf[2], abuf[3], abuf[4], abuf[5], abuf[6], abuf[7], abuf[8], abuf[9], abuf[10], abuf[11], abuf[12], abuf[13]);
765:           #endif
766:           	if (B.ten_sec_flag) {
16848  5160     MOVF PMD0, W, BANKED
1684A  B4D8     BTFSC 0xFD8, 2, ACCESS
1684C  EF2B     GOTO 0x17056
1684E  F0B8     NOP
767:           		B.ten_sec_flag = false;
16850  6B60     CLRF PMD0, BANKED
768:           		if (B.FM80_online || B.modbus_online) { // log for MX80 and EM540
16852  516F     MOVF CMOUT, W, BANKED
16854  A4D8     BTFSS 0xFD8, 2, ACCESS
16856  D003     BRA 0x685E
16858  5172     MOVF CM1NCH, W, BANKED
1685A  B4D8     BTFSC 0xFD8, 2, ACCESS
1685C  D3FC     BRA 0x7056
769:           			MM_ERROR_C;
1685E  92BF     BCF 0xFBF, 1, ACCESS
770:           			/*
771:           			 * log CSV values to the comm ports for data storage and processing
772:           			 */
773:           			snprintf(buffer, 25, "%s", asctime(can_newtime)); // the log_buffer uses this string in LOG_VARS
16860  C5CD     MOVFF can_newtime, POSTINC1
16862  F4E6     NOP
16864  C5CE     MOVFF 0x5CE, POSTINC1
16866  F4E6     NOP
16868  EC8D     CALL 0x18D1A, 0
1686A  F0C6     NOP
1686C  0061     MOVFFL ltemp0, POSTINC1
1686E  F404     NOP
16870  F4E6     NOP
16872  0061     MOVFFL ttemp5, POSTINC1
16874  F408     NOP
16876  F4E6     NOP
16878  0EFB     MOVLW 0xFB
1687A  6EE6     MOVWF 0xFE6, ACCESS
1687C  0EFF     MOVLW 0xFF
1687E  6EE6     MOVWF 0xFE6, ACCESS
16880  0E19     MOVLW 0x19
16882  6EE6     MOVWF 0xFE6, ACCESS
16884  0E00     MOVLW 0x0
16886  6EE6     MOVWF 0xFE6, ACCESS
16888  0E00     MOVLW 0x0
1688A  6EE6     MOVWF 0xFE6, ACCESS
1688C  0E0B     MOVLW 0xB
1688E  6EE6     MOVWF 0xFE6, ACCESS
16890  0E08     MOVLW 0x8
16892  6EE6     MOVWF 0xFE6, ACCESS
16894  EC35     CALL 0x1C06A, 0
16896  F0E0     NOP
774:           			buffer[26] = 0; // remove newline
16898  010B     MOVLB 0xB
1689A  6B1A     CLRF 0x1A, BANKED
775:           			snprintf(log_buffer, MAX_B_BUF, log_format, LOG_VARS);
1689C  0E00     MOVLW 0x0
1689E  6EE6     MOVWF 0xFE6, ACCESS
168A0  0E0B     MOVLW 0xB
168A2  6EE6     MOVWF 0xFE6, ACCESS
168A4  0105     MOVLB 0x5
168A6  5167     MOVF PMD7, W, BANKED
168A8  6E0B     MOVWF 0xB, ACCESS
168AA  5168     MOVF PMD8, W, BANKED
168AC  6E0C     MOVWF 0xC, ACCESS
168AE  4B67     INFSNZ PMD7, F, BANKED
168B0  2B68     INCF PMD8, F, BANKED
168B2  0061     MOVFFL wtemp5, POSTINC1
168B4  F42C     NOP
168B6  F4E6     NOP
168B8  0061     MOVFFL 0x50C, POSTINC1
168BA  F430     NOP
168BC  F4E6     NOP
168BE  0E00     MOVLW 0x0
168C0  6EE6     MOVWF 0xFE6, ACCESS
168C2  0E00     MOVLW 0x0
168C4  6EE6     MOVWF 0xFE6, ACCESS
168C6  0E7A     MOVLW 0x7A
168C8  6EE6     MOVWF 0xFE6, ACCESS
168CA  0E44     MOVLW 0x44
168CC  6EE6     MOVWF 0xFE6, ACCESS
168CE  C978     MOVFF 0x978, POSTINC1
168D0  F4E6     NOP
168D2  C979     MOVFF 0x979, POSTINC1
168D4  F4E6     NOP
168D6  C97A     MOVFF 0x97A, POSTINC1
168D8  F4E6     NOP
168DA  C97B     MOVFF 0x97B, POSTINC1
168DC  F4E6     NOP
168DE  0E01     MOVLW 0x1
168E0  6EE6     MOVWF 0xFE6, ACCESS
168E2  EC35     CALL 0x1BA6A, 0
168E4  F0DD     NOP
168E6  0061     MOVFFL ltemp0, POSTINC1
168E8  F404     NOP
168EA  F4E6     NOP
168EC  0061     MOVFFL ttemp5, POSTINC1
168EE  F408     NOP
168F0  F4E6     NOP
168F2  0061     MOVFFL wtemp1, POSTINC1
168F4  F40C     NOP
168F6  F4E6     NOP
168F8  0061     MOVFFL ttemp1, POSTINC1
168FA  F410     NOP
168FC  F4E6     NOP
168FE  ECD2     CALL 0x187A4, 0
16900  F0C3     NOP
16902  0061     MOVFFL ltemp0, POSTINC1
16904  F404     NOP
16906  F4E6     NOP
16908  0061     MOVFFL ttemp5, POSTINC1
1690A  F408     NOP
1690C  F4E6     NOP
1690E  0061     MOVFFL wtemp1, POSTINC1
16910  F40C     NOP
16912  F4E6     NOP
16914  0061     MOVFFL ttemp1, POSTINC1
16916  F410     NOP
16918  F4E6     NOP
1691A  0E00     MOVLW 0x0
1691C  6EE6     MOVWF 0xFE6, ACCESS
1691E  0E00     MOVLW 0x0
16920  6EE6     MOVWF 0xFE6, ACCESS
16922  0E7A     MOVLW 0x7A
16924  6EE6     MOVWF 0xFE6, ACCESS
16926  0E44     MOVLW 0x44
16928  6EE6     MOVWF 0xFE6, ACCESS
1692A  0061     MOVFFL 0x6C3, ltemp2
1692C  FB0C     NOP
1692E  F509     NOP
16930  0061     MOVFFL 0x6C4, ttemp3
16932  FB10     NOP
16934  F50A     NOP
16936  0E00     MOVLW 0x0
16938  BE0A     BTFSC 0xA, 7, ACCESS
1693A  0EFF     MOVLW 0xFF
1693C  6E0B     MOVWF 0xB, ACCESS
1693E  6E0C     MOVWF 0xC, ACCESS
16940  0061     MOVFFL ltemp2, POSTINC1
16942  F424     NOP
16944  F4E6     NOP
16946  0061     MOVFFL ttemp3, POSTINC1
16948  F428     NOP
1694A  F4E6     NOP
1694C  0061     MOVFFL wtemp5, POSTINC1
1694E  F42C     NOP
16950  F4E6     NOP
16952  0061     MOVFFL 0x50C, POSTINC1
16954  F430     NOP
16956  F4E6     NOP
16958  0E01     MOVLW 0x1
1695A  6EE6     MOVWF 0xFE6, ACCESS
1695C  EC35     CALL 0x1BA6A, 0
1695E  F0DD     NOP
16960  0061     MOVFFL ltemp0, POSTINC1
16962  F404     NOP
16964  F4E6     NOP
16966  0061     MOVFFL ttemp5, POSTINC1
16968  F408     NOP
1696A  F4E6     NOP
1696C  0061     MOVFFL wtemp1, POSTINC1
1696E  F40C     NOP
16970  F4E6     NOP
16972  0061     MOVFFL ttemp1, POSTINC1
16974  F410     NOP
16976  F4E6     NOP
16978  ECD2     CALL 0x187A4, 0
1697A  F0C3     NOP
1697C  0061     MOVFFL ltemp0, POSTINC1
1697E  F404     NOP
16980  F4E6     NOP
16982  0061     MOVFFL ttemp5, POSTINC1
16984  F408     NOP
16986  F4E6     NOP
16988  0061     MOVFFL wtemp1, POSTINC1
1698A  F40C     NOP
1698C  F4E6     NOP
1698E  0061     MOVFFL ttemp1, POSTINC1
16990  F410     NOP
16992  F4E6     NOP
16994  C832     MOVFF 0x832, POSTINC1
16996  F4E6     NOP
16998  C833     MOVFF 0x833, POSTINC1
1699A  F4E6     NOP
1699C  0E00     MOVLW 0x0
1699E  6EE6     MOVWF 0xFE6, ACCESS
169A0  0E00     MOVLW 0x0
169A2  6EE6     MOVWF 0xFE6, ACCESS
169A4  0E61     MOVLW 0x61
169A6  6EE6     MOVWF 0xFE6, ACCESS
169A8  0E45     MOVLW 0x45
169AA  6EE6     MOVWF 0xFE6, ACCESS
169AC  C82C     MOVFF 0x82C, POSTINC1
169AE  F4E6     NOP
169B0  C82D     MOVFF 0x82D, POSTINC1
169B2  F4E6     NOP
169B4  C82E     MOVFF 0x82E, POSTINC1
169B6  F4E6     NOP
169B8  C82F     MOVFF 0x82F, POSTINC1
169BA  F4E6     NOP
169BC  ECD2     CALL 0x187A4, 0
169BE  F0C3     NOP
169C0  0061     MOVFFL ltemp0, POSTINC1
169C2  F404     NOP
169C4  F4E6     NOP
169C6  0061     MOVFFL ttemp5, POSTINC1
169C8  F408     NOP
169CA  F4E6     NOP
169CC  0061     MOVFFL wtemp1, POSTINC1
169CE  F40C     NOP
169D0  F4E6     NOP
169D2  0061     MOVFFL ttemp1, POSTINC1
169D4  F410     NOP
169D6  F4E6     NOP
169D8  0E00     MOVLW 0x0
169DA  6EE6     MOVWF 0xFE6, ACCESS
169DC  0E00     MOVLW 0x0
169DE  6EE6     MOVWF 0xFE6, ACCESS
169E0  0E20     MOVLW 0x20
169E2  6EE6     MOVWF 0xFE6, ACCESS
169E4  0E41     MOVLW 0x41
169E6  6EE6     MOVWF 0xFE6, ACCESS
169E8  C673     MOVFF 0x673, POSTINC1
169EA  F4E6     NOP
169EC  C674     MOVFF 0x674, POSTINC1
169EE  F4E6     NOP
169F0  C675     MOVFF 0x675, POSTINC1
169F2  F4E6     NOP
169F4  C676     MOVFF 0x676, POSTINC1
169F6  F4E6     NOP
169F8  0E01     MOVLW 0x1
169FA  6EE6     MOVWF 0xFE6, ACCESS
169FC  EC35     CALL 0x1BA6A, 0
169FE  F0DD     NOP
16A00  0061     MOVFFL ltemp0, POSTINC1
16A02  F404     NOP
16A04  F4E6     NOP
16A06  0061     MOVFFL ttemp5, POSTINC1
16A08  F408     NOP
16A0A  F4E6     NOP
16A0C  0061     MOVFFL wtemp1, POSTINC1
16A0E  F40C     NOP
16A10  F4E6     NOP
16A12  0061     MOVFFL ttemp1, POSTINC1
16A14  F410     NOP
16A16  F4E6     NOP
16A18  ECD2     CALL 0x187A4, 0
16A1A  F0C3     NOP
16A1C  0061     MOVFFL ltemp0, POSTINC1
16A1E  F404     NOP
16A20  F4E6     NOP
16A22  0061     MOVFFL ttemp5, POSTINC1
16A24  F408     NOP
16A26  F4E6     NOP
16A28  0061     MOVFFL wtemp1, POSTINC1
16A2A  F40C     NOP
16A2C  F4E6     NOP
16A2E  0061     MOVFFL ttemp1, POSTINC1
16A30  F410     NOP
16A32  F4E6     NOP
16A34  0E00     MOVLW 0x0
16A36  6EE6     MOVWF 0xFE6, ACCESS
16A38  0E00     MOVLW 0x0
16A3A  6EE6     MOVWF 0xFE6, ACCESS
16A3C  0E20     MOVLW 0x20
16A3E  6EE6     MOVWF 0xFE6, ACCESS
16A40  0E41     MOVLW 0x41
16A42  6EE6     MOVWF 0xFE6, ACCESS
16A44  C6A3     MOVFF 0x6A3, POSTINC1
16A46  F4E6     NOP
16A48  C6A4     MOVFF 0x6A4, POSTINC1
16A4A  F4E6     NOP
16A4C  C6A5     MOVFF 0x6A5, POSTINC1
16A4E  F4E6     NOP
16A50  C6A6     MOVFF 0x6A6, POSTINC1
16A52  F4E6     NOP
16A54  0E01     MOVLW 0x1
16A56  6EE6     MOVWF 0xFE6, ACCESS
16A58  EC35     CALL 0x1BA6A, 0
16A5A  F0DD     NOP
16A5C  0061     MOVFFL ltemp0, POSTINC1
16A5E  F404     NOP
16A60  F4E6     NOP
16A62  0061     MOVFFL ttemp5, POSTINC1
16A64  F408     NOP
16A66  F4E6     NOP
16A68  0061     MOVFFL wtemp1, POSTINC1
16A6A  F40C     NOP
16A6C  F4E6     NOP
16A6E  0061     MOVFFL ttemp1, POSTINC1
16A70  F410     NOP
16A72  F4E6     NOP
16A74  ECD2     CALL 0x187A4, 0
16A76  F0C3     NOP
16A78  0061     MOVFFL ltemp0, POSTINC1
16A7A  F404     NOP
16A7C  F4E6     NOP
16A7E  0061     MOVFFL ttemp5, POSTINC1
16A80  F408     NOP
16A82  F4E6     NOP
16A84  0061     MOVFFL wtemp1, POSTINC1
16A86  F40C     NOP
16A88  F4E6     NOP
16A8A  0061     MOVFFL ttemp1, POSTINC1
16A8C  F410     NOP
16A8E  F4E6     NOP
16A90  0E00     MOVLW 0x0
16A92  6EE6     MOVWF 0xFE6, ACCESS
16A94  0E00     MOVLW 0x0
16A96  6EE6     MOVWF 0xFE6, ACCESS
16A98  0E20     MOVLW 0x20
16A9A  6EE6     MOVWF 0xFE6, ACCESS
16A9C  0E41     MOVLW 0x41
16A9E  6EE6     MOVWF 0xFE6, ACCESS
16AA0  C697     MOVFF 0x697, POSTINC1
16AA2  F4E6     NOP
16AA4  C698     MOVFF 0x698, POSTINC1
16AA6  F4E6     NOP
16AA8  C699     MOVFF 0x699, POSTINC1
16AAA  F4E6     NOP
16AAC  C69A     MOVFF 0x69A, POSTINC1
16AAE  F4E6     NOP
16AB0  0E01     MOVLW 0x1
16AB2  6EE6     MOVWF 0xFE6, ACCESS
16AB4  EC35     CALL 0x1BA6A, 0
16AB6  F0DD     NOP
16AB8  0061     MOVFFL ltemp0, POSTINC1
16ABA  F404     NOP
16ABC  F4E6     NOP
16ABE  0061     MOVFFL ttemp5, POSTINC1
16AC0  F408     NOP
16AC2  F4E6     NOP
16AC4  0061     MOVFFL wtemp1, POSTINC1
16AC6  F40C     NOP
16AC8  F4E6     NOP
16ACA  0061     MOVFFL ttemp1, POSTINC1
16ACC  F410     NOP
16ACE  F4E6     NOP
16AD0  ECD2     CALL 0x187A4, 0
16AD2  F0C3     NOP
16AD4  0061     MOVFFL ltemp0, POSTINC1
16AD6  F404     NOP
16AD8  F4E6     NOP
16ADA  0061     MOVFFL ttemp5, POSTINC1
16ADC  F408     NOP
16ADE  F4E6     NOP
16AE0  0061     MOVFFL wtemp1, POSTINC1
16AE2  F40C     NOP
16AE4  F4E6     NOP
16AE6  0061     MOVFFL ttemp1, POSTINC1
16AE8  F410     NOP
16AEA  F4E6     NOP
16AEC  0E00     MOVLW 0x0
16AEE  6EE6     MOVWF 0xFE6, ACCESS
16AF0  0E00     MOVLW 0x0
16AF2  6EE6     MOVWF 0xFE6, ACCESS
16AF4  0E20     MOVLW 0x20
16AF6  6EE6     MOVWF 0xFE6, ACCESS
16AF8  0E41     MOVLW 0x41
16AFA  6EE6     MOVWF 0xFE6, ACCESS
16AFC  C68B     MOVFF 0x68B, POSTINC1
16AFE  F4E6     NOP
16B00  C68C     MOVFF 0x68C, POSTINC1
16B02  F4E6     NOP
16B04  C68D     MOVFF 0x68D, POSTINC1
16B06  F4E6     NOP
16B08  C68E     MOVFF 0x68E, POSTINC1
16B0A  F4E6     NOP
16B0C  0E01     MOVLW 0x1
16B0E  6EE6     MOVWF 0xFE6, ACCESS
16B10  EC35     CALL 0x1BA6A, 0
16B12  F0DD     NOP
16B14  0061     MOVFFL ltemp0, POSTINC1
16B16  F404     NOP
16B18  F4E6     NOP
16B1A  0061     MOVFFL ttemp5, POSTINC1
16B1C  F408     NOP
16B1E  F4E6     NOP
16B20  0061     MOVFFL wtemp1, POSTINC1
16B22  F40C     NOP
16B24  F4E6     NOP
16B26  0061     MOVFFL ttemp1, POSTINC1
16B28  F410     NOP
16B2A  F4E6     NOP
16B2C  ECD2     CALL 0x187A4, 0
16B2E  F0C3     NOP
16B30  0061     MOVFFL ltemp0, POSTINC1
16B32  F404     NOP
16B34  F4E6     NOP
16B36  0061     MOVFFL ttemp5, POSTINC1
16B38  F408     NOP
16B3A  F4E6     NOP
16B3C  0061     MOVFFL wtemp1, POSTINC1
16B3E  F40C     NOP
16B40  F4E6     NOP
16B42  0061     MOVFFL ttemp1, POSTINC1
16B44  F410     NOP
16B46  F4E6     NOP
16B48  C54B     MOVFF cc_mode, POSTINC1
16B4A  F4E6     NOP
16B4C  C54C     MOVFF 0x54C, POSTINC1
16B4E  F4E6     NOP
16B50  C578     MOVFF 0x578, POSTINC1
16B52  F4E6     NOP
16B54  C579     MOVFF 0x579, POSTINC1
16B56  F4E6     NOP
16B58  C57A     MOVFF 0x57A, POSTINC1
16B5A  F4E6     NOP
16B5C  C57B     MOVFF 0x57B, POSTINC1
16B5E  F4E6     NOP
16B60  C574     MOVFF 0x574, POSTINC1
16B62  F4E6     NOP
16B64  C575     MOVFF 0x575, POSTINC1
16B66  F4E6     NOP
16B68  C576     MOVFF 0x576, POSTINC1
16B6A  F4E6     NOP
16B6C  C577     MOVFF 0x577, POSTINC1
16B6E  F4E6     NOP
16B70  C635     MOVFF ac_Wh_daily, POSTINC1
16B72  F4E6     NOP
16B74  C636     MOVFF 0x636, POSTINC1
16B76  F4E6     NOP
16B78  C637     MOVFF 0x637, POSTINC1
16B7A  F4E6     NOP
16B7C  C638     MOVFF 0x638, POSTINC1
16B7E  F4E6     NOP
16B80  C639     MOVFF pv_Wh_daily, POSTINC1
16B82  F4E6     NOP
16B84  C63A     MOVFF 0x63A, POSTINC1
16B86  F4E6     NOP
16B88  C63B     MOVFF 0x63B, POSTINC1
16B8A  F4E6     NOP
16B8C  C63C     MOVFF 0x63C, POSTINC1
16B8E  F4E6     NOP
16B90  C5D5     MOVFF panel_watts, POSTINC1
16B92  F4E6     NOP
16B94  C5D6     MOVFF _UART5_Initialize, POSTINC1
16B96  F4E6     NOP
16B98  C5D3     MOVFF volt_fract, POSTINC1
16B9A  F4E6     NOP
16B9C  C5D4     MOVFF 0x5D4, POSTINC1
16B9E  F4E6     NOP
16BA0  C5D9     MOVFF volt_whole, POSTINC1
16BA2  F4E6     NOP
16BA4  C5DA     MOVFF 0x5DA, POSTINC1
16BA6  F4E6     NOP
16BA8  EE21     LFSR 2, 0x739
16BAA  F339     NOP
16BAC  0061     MOVFFL POSTINC2, wtemp5
16BAE  F378     NOP
16BB0  F50B     NOP
16BB2  0061     MOVFFL POSTDEC2, 0x50C
16BB4  F374     NOP
16BB6  F50C     NOP
16BB8  0E80     MOVLW 0x80
16BBA  240B     ADDWF 0xB, W, ACCESS
16BBC  6E09     MOVWF 0x9, ACCESS
16BBE  0EFF     MOVLW 0xFF
16BC0  200C     ADDWFC 0xC, W, ACCESS
16BC2  6E0A     MOVWF 0xA, ACCESS
16BC4  0061     MOVFFL ltemp2, POSTINC1
16BC6  F424     NOP
16BC8  F4E6     NOP
16BCA  0061     MOVFFL ttemp3, POSTINC1
16BCC  F428     NOP
16BCE  F4E6     NOP
16BD0  C5D1     MOVFF vf, POSTINC1
16BD2  F4E6     NOP
16BD4  C5D2     MOVFF 0x5D2, POSTINC1
16BD6  F4E6     NOP
16BD8  C5CF     MOVFF vw, POSTINC1
16BDA  F4E6     NOP
16BDC  C5D0     MOVFF 0x5D0, POSTINC1
16BDE  F4E6     NOP
16BE0  0E0F     MOVLW 0xF
16BE2  0107     MOVLB 0x7
16BE4  1537     ANDWF 0x37, W, BANKED
16BE6  6E0B     MOVWF 0xB, ACCESS
16BE8  0E00     MOVLW 0x0
16BEA  1538     ANDWF BOOTREG, W, BANKED
16BEC  6E0C     MOVWF 0xC, ACCESS
16BEE  0061     MOVFFL wtemp5, POSTINC1
16BF0  F42C     NOP
16BF2  F4E6     NOP
16BF4  0061     MOVFFL 0x50C, POSTINC1
16BF6  F430     NOP
16BF8  F4E6     NOP
16BFA  EE21     LFSR 2, 0x73B
16BFC  F33B     NOP
16BFE  0061     MOVFFL POSTINC2, wtemp5
16C00  F378     NOP
16C02  F50B     NOP
16C04  0061     MOVFFL POSTDEC2, 0x50C
16C06  F374     NOP
16C08  F50C     NOP
16C0A  0E80     MOVLW 0x80
16C0C  240B     ADDWF 0xB, W, ACCESS
16C0E  6E09     MOVWF 0x9, ACCESS
16C10  0EFF     MOVLW 0xFF
16C12  200C     ADDWFC 0xC, W, ACCESS
16C14  6E0A     MOVWF 0xA, ACCESS
16C16  0061     MOVFFL ltemp2, POSTINC1
16C18  F424     NOP
16C1A  F4E6     NOP
16C1C  0061     MOVFFL ttemp3, POSTINC1
16C1E  F428     NOP
16C20  F4E6     NOP
16C22  0ED7     MOVLW 0xD7
16C24  6EE6     MOVWF 0xFE6, ACCESS
16C26  0EFA     MOVLW 0xFA
16C28  6EE6     MOVWF 0xFE6, ACCESS
16C2A  0EFF     MOVLW 0xFF
16C2C  6EE6     MOVWF 0xFE6, ACCESS
16C2E  0E00     MOVLW 0x0
16C30  6EE6     MOVWF 0xFE6, ACCESS
16C32  0E00     MOVLW 0x0
16C34  6EE6     MOVWF 0xFE6, ACCESS
16C36  0E13     MOVLW 0x13
16C38  6EE6     MOVWF 0xFE6, ACCESS
16C3A  0E4A     MOVLW 0x4A
16C3C  6EE6     MOVWF 0xFE6, ACCESS
16C3E  EC35     CALL 0x1C06A, 0
16C40  F0E0     NOP
776:           			printf("%s", log_buffer); // log to USART
16C42  0E00     MOVLW 0x0
16C44  6EE6     MOVWF 0xFE6, ACCESS
16C46  0E13     MOVLW 0x13
16C48  6EE6     MOVWF 0xFE6, ACCESS
16C4A  0EFB     MOVLW 0xFB
16C4C  6EE6     MOVWF 0xFE6, ACCESS
16C4E  0EFF     MOVLW 0xFF
16C50  6EE6     MOVWF 0xFE6, ACCESS
16C52  0E04     MOVLW 0x4
16C54  6EE6     MOVWF 0xFE6, ACCESS
16C56  ECD7     CALL 0xDAE, 0
16C58  F006     NOP
777:           			if (B.FM80_online) {
16C5A  516F     MOVF CMOUT, W, BANKED
16C5C  B4D8     BTFSC 0xFD8, 2, ACCESS
16C5E  D197     BRA 0x6F8E
778:           				bat_amp_whole = abuf[3] - 128;
16C60  EE21     LFSR 2, 0x73B
16C62  F33B     NOP
16C64  0061     MOVFFL POSTINC2, wtemp5
16C66  F378     NOP
16C68  F50B     NOP
16C6A  0061     MOVFFL POSTDEC2, 0x50C
16C6C  F374     NOP
16C6E  F50C     NOP
16C70  0E80     MOVLW 0x80
16C72  240B     ADDWF 0xB, W, ACCESS
16C74  6FD7     MOVWF CLCnPOL, BANKED
16C76  0EFF     MOVLW 0xFF
16C78  200C     ADDWFC 0xC, W, ACCESS
16C7A  6FD8     MOVWF CLCnSEL0, BANKED
16C7C  D188     BRA 0x6F8E
779:           			}
780:           
781:           			switch (B.alt_display) {
782:           			case 3:
783:           				snprintf(buffer, MAX_B_BUF, "%4.2fHours              ", lp_filter(B.run_time, F_run, false));
16C7E  0E00     MOVLW 0x0
16C80  6EE6     MOVWF 0xFE6, ACCESS
16C82  0E04     MOVLW 0x4
16C84  6EE6     MOVWF 0xFE6, ACCESS
16C86  C574     MOVFF 0x574, POSTINC1
16C88  F4E6     NOP
16C8A  C575     MOVFF 0x575, POSTINC1
16C8C  F4E6     NOP
16C8E  C576     MOVFF 0x576, POSTINC1
16C90  F4E6     NOP
16C92  C577     MOVFF 0x577, POSTINC1
16C94  F4E6     NOP
16C96  EC91     CALL 0x1CF22, 0
16C98  F0E7     NOP
16C9A  0061     MOVFFL ltemp0, POSTINC1
16C9C  F404     NOP
16C9E  F4E6     NOP
16CA0  0061     MOVFFL ttemp5, POSTINC1
16CA2  F408     NOP
16CA4  F4E6     NOP
16CA6  0061     MOVFFL wtemp1, POSTINC1
16CA8  F40C     NOP
16CAA  F4E6     NOP
16CAC  0061     MOVFFL ttemp1, POSTINC1
16CAE  F410     NOP
16CB0  F4E6     NOP
16CB2  0EE2     MOVLW 0xE2
16CB4  6EE6     MOVWF 0xFE6, ACCESS
16CB6  0EFD     MOVLW 0xFD
16CB8  6EE6     MOVWF 0xFE6, ACCESS
16CBA  0EFF     MOVLW 0xFF
16CBC  6EE6     MOVWF 0xFE6, ACCESS
16CBE  0E00     MOVLW 0x0
16CC0  6EE6     MOVWF 0xFE6, ACCESS
16CC2  0E00     MOVLW 0x0
16CC4  6EE6     MOVWF 0xFE6, ACCESS
16CC6  0E0B     MOVLW 0xB
16CC8  6EE6     MOVWF 0xFE6, ACCESS
16CCA  0E0A     MOVLW 0xA
16CCC  6EE6     MOVWF 0xFE6, ACCESS
16CCE  EC35     CALL 0x1C06A, 0
16CD0  F0E0     NOP
784:           				eaDogM_WriteStringAtPos(2, 0, buffer);
16CD2  0E00     MOVLW 0x0
16CD4  6EE6     MOVWF 0xFE6, ACCESS
16CD6  0E0B     MOVLW 0xB
16CD8  6EE6     MOVWF 0xFE6, ACCESS
16CDA  0E00     MOVLW 0x0
16CDC  6EE6     MOVWF 0xFE6, ACCESS
16CDE  0E02     MOVLW 0x2
16CE0  6EE6     MOVWF 0xFE6, ACCESS
16CE2  ECD9     CALL 0x1B2, 0
16CE4  F000     NOP
785:           				snprintf(buffer, MAX_B_BUF, "ALT 3                   ");
16CE6  0EC9     MOVLW 0xC9
16CE8  6EE6     MOVWF 0xFE6, ACCESS
16CEA  0EFD     MOVLW 0xFD
16CEC  6EE6     MOVWF 0xFE6, ACCESS
16CEE  0EFF     MOVLW 0xFF
16CF0  6EE6     MOVWF 0xFE6, ACCESS
16CF2  0E00     MOVLW 0x0
16CF4  6EE6     MOVWF 0xFE6, ACCESS
16CF6  0E00     MOVLW 0x0
16CF8  6EE6     MOVWF 0xFE6, ACCESS
16CFA  0E0B     MOVLW 0xB
16CFC  6EE6     MOVWF 0xFE6, ACCESS
16CFE  0E06     MOVLW 0x6
16D00  6EE6     MOVWF 0xFE6, ACCESS
16D02  EC35     CALL 0x1C06A, 0
16D04  F0E0     NOP
786:           				eaDogM_WriteStringAtPos(3, 0, buffer);
16D06  0E00     MOVLW 0x0
16D08  6EE6     MOVWF 0xFE6, ACCESS
16D0A  0E0B     MOVLW 0xB
16D0C  6EE6     MOVWF 0xFE6, ACCESS
16D0E  0E00     MOVLW 0x0
16D10  6EE6     MOVWF 0xFE6, ACCESS
16D12  0E03     MOVLW 0x3
16D14  6EE6     MOVWF 0xFE6, ACCESS
16D16  ECD9     CALL 0x1B2, 0
16D18  F000     NOP
787:           				break;
16D1A  D14E     BRA 0x6FB8
788:           			case 2:
789:           				snprintf(buffer, MAX_B_BUF, "%4.2fBE %4.2fLW         ", EB->bat_energy / TEN_SEC_HOUR, (float) em.wl1 / 10.0f);
16D1C  0E00     MOVLW 0x0
16D1E  6EE6     MOVWF 0xFE6, ACCESS
16D20  0E00     MOVLW 0x0
16D22  6EE6     MOVWF 0xFE6, ACCESS
16D24  0E20     MOVLW 0x20
16D26  6EE6     MOVWF 0xFE6, ACCESS
16D28  0E41     MOVLW 0x41
16D2A  6EE6     MOVWF 0xFE6, ACCESS
16D2C  C68B     MOVFF 0x68B, POSTINC1
16D2E  F4E6     NOP
16D30  C68C     MOVFF 0x68C, POSTINC1
16D32  F4E6     NOP
16D34  C68D     MOVFF 0x68D, POSTINC1
16D36  F4E6     NOP
16D38  C68E     MOVFF 0x68E, POSTINC1
16D3A  F4E6     NOP
16D3C  0E01     MOVLW 0x1
16D3E  6EE6     MOVWF 0xFE6, ACCESS
16D40  EC35     CALL 0x1BA6A, 0
16D42  F0DD     NOP
16D44  0061     MOVFFL ltemp0, POSTINC1
16D46  F404     NOP
16D48  F4E6     NOP
16D4A  0061     MOVFFL ttemp5, POSTINC1
16D4C  F408     NOP
16D4E  F4E6     NOP
16D50  0061     MOVFFL wtemp1, POSTINC1
16D52  F40C     NOP
16D54  F4E6     NOP
16D56  0061     MOVFFL ttemp1, POSTINC1
16D58  F410     NOP
16D5A  F4E6     NOP
16D5C  ECD2     CALL 0x187A4, 0
16D5E  F0C3     NOP
16D60  0061     MOVFFL ltemp0, POSTINC1
16D62  F404     NOP
16D64  F4E6     NOP
16D66  0061     MOVFFL ttemp5, POSTINC1
16D68  F408     NOP
16D6A  F4E6     NOP
16D6C  0061     MOVFFL wtemp1, POSTINC1
16D6E  F40C     NOP
16D70  F4E6     NOP
16D72  0061     MOVFFL ttemp1, POSTINC1
16D74  F410     NOP
16D76  F4E6     NOP
16D78  0E00     MOVLW 0x0
16D7A  6EE6     MOVWF 0xFE6, ACCESS
16D7C  0E00     MOVLW 0x0
16D7E  6EE6     MOVWF 0xFE6, ACCESS
16D80  0EB4     MOVLW 0xB4
16D82  6EE6     MOVWF 0xFE6, ACCESS
16D84  0E43     MOVLW 0x43
16D86  6EE6     MOVWF 0xFE6, ACCESS
16D88  C82C     MOVFF 0x82C, POSTINC1
16D8A  F4E6     NOP
16D8C  C82D     MOVFF 0x82D, POSTINC1
16D8E  F4E6     NOP
16D90  C82E     MOVFF 0x82E, POSTINC1
16D92  F4E6     NOP
16D94  C82F     MOVFF 0x82F, POSTINC1
16D96  F4E6     NOP
16D98  ECD2     CALL 0x187A4, 0
16D9A  F0C3     NOP
16D9C  0061     MOVFFL ltemp0, POSTINC1
16D9E  F404     NOP
16DA0  F4E6     NOP
16DA2  0061     MOVFFL ttemp5, POSTINC1
16DA4  F408     NOP
16DA6  F4E6     NOP
16DA8  0061     MOVFFL wtemp1, POSTINC1
16DAA  F40C     NOP
16DAC  F4E6     NOP
16DAE  0061     MOVFFL ttemp1, POSTINC1
16DB0  F410     NOP
16DB2  F4E6     NOP
16DB4  0EFB     MOVLW 0xFB
16DB6  6EE6     MOVWF 0xFE6, ACCESS
16DB8  0EFD     MOVLW 0xFD
16DBA  6EE6     MOVWF 0xFE6, ACCESS
16DBC  0EFF     MOVLW 0xFF
16DBE  6EE6     MOVWF 0xFE6, ACCESS
16DC0  0E00     MOVLW 0x0
16DC2  6EE6     MOVWF 0xFE6, ACCESS
16DC4  0E00     MOVLW 0x0
16DC6  6EE6     MOVWF 0xFE6, ACCESS
16DC8  0E0B     MOVLW 0xB
16DCA  6EE6     MOVWF 0xFE6, ACCESS
16DCC  0E0E     MOVLW 0xE
16DCE  6EE6     MOVWF 0xFE6, ACCESS
16DD0  EC35     CALL 0x1C06A, 0
16DD2  F0E0     NOP
790:           				eaDogM_WriteStringAtPos(2, 0, buffer);
16DD4  0E00     MOVLW 0x0
16DD6  6EE6     MOVWF 0xFE6, ACCESS
16DD8  0E0B     MOVLW 0xB
16DDA  6EE6     MOVWF 0xFE6, ACCESS
16DDC  0E00     MOVLW 0x0
16DDE  6EE6     MOVWF 0xFE6, ACCESS
16DE0  0E02     MOVLW 0x2
16DE2  6EE6     MOVWF 0xFE6, ACCESS
16DE4  ECD9     CALL 0x1B2, 0
16DE6  F000     NOP
791:           				snprintf(buffer, MAX_B_BUF, "ALT 2                   ");
16DE8  0EB0     MOVLW 0xB0
16DEA  6EE6     MOVWF 0xFE6, ACCESS
16DEC  0EFD     MOVLW 0xFD
16DEE  6EE6     MOVWF 0xFE6, ACCESS
16DF0  0EFF     MOVLW 0xFF
16DF2  6EE6     MOVWF 0xFE6, ACCESS
16DF4  0E00     MOVLW 0x0
16DF6  6EE6     MOVWF 0xFE6, ACCESS
16DF8  0E00     MOVLW 0x0
16DFA  6EE6     MOVWF 0xFE6, ACCESS
16DFC  0E0B     MOVLW 0xB
16DFE  6EE6     MOVWF 0xFE6, ACCESS
16E00  0E06     MOVLW 0x6
16E02  6EE6     MOVWF 0xFE6, ACCESS
16E04  EC35     CALL 0x1C06A, 0
16E06  F0E0     NOP
792:           				eaDogM_WriteStringAtPos(3, 0, buffer);
16E08  0E00     MOVLW 0x0
16E0A  6EE6     MOVWF 0xFE6, ACCESS
16E0C  0E0B     MOVLW 0xB
16E0E  6EE6     MOVWF 0xFE6, ACCESS
16E10  0E00     MOVLW 0x0
16E12  6EE6     MOVWF 0xFE6, ACCESS
16E14  0E03     MOVLW 0x3
16E16  6EE6     MOVWF 0xFE6, ACCESS
16E18  ECD9     CALL 0x1B2, 0
16E1A  F000     NOP
793:           				break;
16E1C  D0CD     BRA 0x6FB8
794:           			case 1:
795:           				snprintf(buffer, MAX_B_BUF, "%4.2fHr %4.2fBW           ", B.run_time, B.net_balance);
16E1E  C578     MOVFF 0x578, POSTINC1
16E20  F4E6     NOP
16E22  C579     MOVFF 0x579, POSTINC1
16E24  F4E6     NOP
16E26  C57A     MOVFF 0x57A, POSTINC1
16E28  F4E6     NOP
16E2A  C57B     MOVFF 0x57B, POSTINC1
16E2C  F4E6     NOP
16E2E  C574     MOVFF 0x574, POSTINC1
16E30  F4E6     NOP
16E32  C575     MOVFF 0x575, POSTINC1
16E34  F4E6     NOP
16E36  C576     MOVFF 0x576, POSTINC1
16E38  F4E6     NOP
16E3A  C577     MOVFF 0x577, POSTINC1
16E3C  F4E6     NOP
16E3E  0E61     MOVLW 0x61
16E40  6EE6     MOVWF 0xFE6, ACCESS
16E42  0EFD     MOVLW 0xFD
16E44  6EE6     MOVWF 0xFE6, ACCESS
16E46  0EFF     MOVLW 0xFF
16E48  6EE6     MOVWF 0xFE6, ACCESS
16E4A  0E00     MOVLW 0x0
16E4C  6EE6     MOVWF 0xFE6, ACCESS
16E4E  0E00     MOVLW 0x0
16E50  6EE6     MOVWF 0xFE6, ACCESS
16E52  0E0B     MOVLW 0xB
16E54  6EE6     MOVWF 0xFE6, ACCESS
16E56  0E0E     MOVLW 0xE
16E58  6EE6     MOVWF 0xFE6, ACCESS
16E5A  EC35     CALL 0x1C06A, 0
16E5C  F0E0     NOP
796:           				eaDogM_WriteStringAtPos(2, 0, buffer);
16E5E  0E00     MOVLW 0x0
16E60  6EE6     MOVWF 0xFE6, ACCESS
16E62  0E0B     MOVLW 0xB
16E64  6EE6     MOVWF 0xFE6, ACCESS
16E66  0E00     MOVLW 0x0
16E68  6EE6     MOVWF 0xFE6, ACCESS
16E6A  0E02     MOVLW 0x2
16E6C  6EE6     MOVWF 0xFE6, ACCESS
16E6E  ECD9     CALL 0x1B2, 0
16E70  F000     NOP
797:           				snprintf(buffer, MAX_B_BUF, "%d.%01d Amps %d.%01d Volts   ", bat_amp_whole, abuf[1]&0x0f, vw, vf);
16E72  C5D1     MOVFF vf, POSTINC1
16E74  F4E6     NOP
16E76  C5D2     MOVFF 0x5D2, POSTINC1
16E78  F4E6     NOP
16E7A  C5CF     MOVFF vw, POSTINC1
16E7C  F4E6     NOP
16E7E  C5D0     MOVFF 0x5D0, POSTINC1
16E80  F4E6     NOP
16E82  0E0F     MOVLW 0xF
16E84  0107     MOVLB 0x7
16E86  1537     ANDWF 0x37, W, BANKED
16E88  6E0B     MOVWF 0xB, ACCESS
16E8A  0E00     MOVLW 0x0
16E8C  1538     ANDWF BOOTREG, W, BANKED
16E8E  6E0C     MOVWF 0xC, ACCESS
16E90  0061     MOVFFL wtemp5, POSTINC1
16E92  F42C     NOP
16E94  F4E6     NOP
16E96  0061     MOVFFL 0x50C, POSTINC1
16E98  F430     NOP
16E9A  F4E6     NOP
16E9C  C5D7     MOVFF bat_amp_whole, POSTINC1
16E9E  F4E6     NOP
16EA0  C5D8     MOVFF 0x5D8, POSTINC1
16EA2  F4E6     NOP
16EA4  0EEF     MOVLW 0xEF
16EA6  6EE6     MOVWF 0xFE6, ACCESS
16EA8  0EFC     MOVLW 0xFC
16EAA  6EE6     MOVWF 0xFE6, ACCESS
16EAC  0EFF     MOVLW 0xFF
16EAE  6EE6     MOVWF 0xFE6, ACCESS
16EB0  0E00     MOVLW 0x0
16EB2  6EE6     MOVWF 0xFE6, ACCESS
16EB4  0E00     MOVLW 0x0
16EB6  6EE6     MOVWF 0xFE6, ACCESS
16EB8  0E0B     MOVLW 0xB
16EBA  6EE6     MOVWF 0xFE6, ACCESS
16EBC  0E0E     MOVLW 0xE
16EBE  6EE6     MOVWF 0xFE6, ACCESS
16EC0  EC35     CALL 0x1C06A, 0
16EC2  F0E0     NOP
798:           				eaDogM_WriteStringAtPos(3, 0, buffer);
16EC4  0E00     MOVLW 0x0
16EC6  6EE6     MOVWF 0xFE6, ACCESS
16EC8  0E0B     MOVLW 0xB
16ECA  6EE6     MOVWF 0xFE6, ACCESS
16ECC  0E00     MOVLW 0x0
16ECE  6EE6     MOVWF 0xFE6, ACCESS
16ED0  0E03     MOVLW 0x3
16ED2  6EE6     MOVWF 0xFE6, ACCESS
16ED4  ECD9     CALL 0x1B2, 0
16ED6  F000     NOP
799:           				break;
16ED8  D06F     BRA 0x6FB8
800:           			case 0:
801:           			default:
802:           				snprintf(buffer, MAX_B_BUF, "%d Watts %d.%01d Volts   ", panel_watts, volt_whole, volt_fract);
16EDA  C5D3     MOVFF volt_fract, POSTINC1
16EDC  F4E6     NOP
16EDE  C5D4     MOVFF 0x5D4, POSTINC1
16EE0  F4E6     NOP
16EE2  C5D9     MOVFF volt_whole, POSTINC1
16EE4  F4E6     NOP
16EE6  C5DA     MOVFF 0x5DA, POSTINC1
16EE8  F4E6     NOP
16EEA  C5D5     MOVFF panel_watts, POSTINC1
16EEC  F4E6     NOP
16EEE  C5D6     MOVFF _UART5_Initialize, POSTINC1
16EF0  F4E6     NOP
16EF2  0E96     MOVLW 0x96
16EF4  6EE6     MOVWF 0xFE6, ACCESS
16EF6  0EFD     MOVLW 0xFD
16EF8  6EE6     MOVWF 0xFE6, ACCESS
16EFA  0EFF     MOVLW 0xFF
16EFC  6EE6     MOVWF 0xFE6, ACCESS
16EFE  0E00     MOVLW 0x0
16F00  6EE6     MOVWF 0xFE6, ACCESS
16F02  0E00     MOVLW 0x0
16F04  6EE6     MOVWF 0xFE6, ACCESS
16F06  0E0B     MOVLW 0xB
16F08  6EE6     MOVWF 0xFE6, ACCESS
16F0A  0E0C     MOVLW 0xC
16F0C  6EE6     MOVWF 0xFE6, ACCESS
16F0E  EC35     CALL 0x1C06A, 0
16F10  F0E0     NOP
803:           				eaDogM_WriteStringAtPos(2, 0, buffer);
16F12  0E00     MOVLW 0x0
16F14  6EE6     MOVWF 0xFE6, ACCESS
16F16  0E0B     MOVLW 0xB
16F18  6EE6     MOVWF 0xFE6, ACCESS
16F1A  0E00     MOVLW 0x0
16F1C  6EE6     MOVWF 0xFE6, ACCESS
16F1E  0E02     MOVLW 0x2
16F20  6EE6     MOVWF 0xFE6, ACCESS
16F22  ECD9     CALL 0x1B2, 0
16F24  F000     NOP
804:           				snprintf(buffer, MAX_B_BUF, "%d.%01d Amps %d.%01d Volts   ", bat_amp_whole, abuf[1]&0x0f, vw, vf);
16F26  C5D1     MOVFF vf, POSTINC1
16F28  F4E6     NOP
16F2A  C5D2     MOVFF 0x5D2, POSTINC1
16F2C  F4E6     NOP
16F2E  C5CF     MOVFF vw, POSTINC1
16F30  F4E6     NOP
16F32  C5D0     MOVFF 0x5D0, POSTINC1
16F34  F4E6     NOP
16F36  0E0F     MOVLW 0xF
16F38  0107     MOVLB 0x7
16F3A  1537     ANDWF 0x37, W, BANKED
16F3C  6E0B     MOVWF 0xB, ACCESS
16F3E  0E00     MOVLW 0x0
16F40  1538     ANDWF BOOTREG, W, BANKED
16F42  6E0C     MOVWF 0xC, ACCESS
16F44  0061     MOVFFL wtemp5, POSTINC1
16F46  F42C     NOP
16F48  F4E6     NOP
16F4A  0061     MOVFFL 0x50C, POSTINC1
16F4C  F430     NOP
16F4E  F4E6     NOP
16F50  C5D7     MOVFF bat_amp_whole, POSTINC1
16F52  F4E6     NOP
16F54  C5D8     MOVFF 0x5D8, POSTINC1
16F56  F4E6     NOP
16F58  0EEF     MOVLW 0xEF
16F5A  6EE6     MOVWF 0xFE6, ACCESS
16F5C  0EFC     MOVLW 0xFC
16F5E  6EE6     MOVWF 0xFE6, ACCESS
16F60  0EFF     MOVLW 0xFF
16F62  6EE6     MOVWF 0xFE6, ACCESS
16F64  0E00     MOVLW 0x0
16F66  6EE6     MOVWF 0xFE6, ACCESS
16F68  0E00     MOVLW 0x0
16F6A  6EE6     MOVWF 0xFE6, ACCESS
16F6C  0E0B     MOVLW 0xB
16F6E  6EE6     MOVWF 0xFE6, ACCESS
16F70  0E0E     MOVLW 0xE
16F72  6EE6     MOVWF 0xFE6, ACCESS
16F74  EC35     CALL 0x1C06A, 0
16F76  F0E0     NOP
805:           				eaDogM_WriteStringAtPos(3, 0, buffer);
16F78  0E00     MOVLW 0x0
16F7A  6EE6     MOVWF 0xFE6, ACCESS
16F7C  0E0B     MOVLW 0xB
16F7E  6EE6     MOVWF 0xFE6, ACCESS
16F80  0E00     MOVLW 0x0
16F82  6EE6     MOVWF 0xFE6, ACCESS
16F84  0E03     MOVLW 0x3
16F86  6EE6     MOVWF 0xFE6, ACCESS
16F88  ECD9     CALL 0x1B2, 0
16F8A  F000     NOP
806:           				break;
16F8C  D015     BRA 0x6FB8
807:           			}
16F8E  5173     MOVF CM1PCH, W, BANKED
16F90  6E0B     MOVWF 0xB, ACCESS
16F92  6A0C     CLRF 0xC, ACCESS
16F94  500C     MOVF 0xC, W, ACCESS
16F96  0A00     XORLW 0x0
16F98  A4D8     BTFSS 0xFD8, 2, ACCESS
16F9A  D79F     BRA 0x6EDA
16F9C  500B     MOVF 0xB, W, ACCESS
16F9E  0A00     XORLW 0x0
16FA0  B4D8     BTFSC 0xFD8, 2, ACCESS
16FA2  D79B     BRA 0x6EDA
16FA4  0A01     XORLW 0x1
16FA6  B4D8     BTFSC 0xFD8, 2, ACCESS
16FA8  D73A     BRA 0x6E1E
16FAA  0A03     XORLW 0x3
16FAC  B4D8     BTFSC 0xFD8, 2, ACCESS
16FAE  D6B6     BRA 0x6D1C
16FB0  0A01     XORLW 0x1
16FB2  B4D8     BTFSC 0xFD8, 2, ACCESS
16FB4  D664     BRA 0x6C7E
16FB6  D791     BRA 0x6EDA
808:           
809:           			can_fd_tx(); // send the logging packet via CANBUS
16FB8  EC10     CALL 0x1B820, 0
16FBA  F0DC     NOP
810:           			snprintf(info_buffer, MAX_B_BUF, " Data OK\r\n");
16FBC  0EB8     MOVLW 0xB8
16FBE  6EE6     MOVWF 0xFE6, ACCESS
16FC0  0EFF     MOVLW 0xFF
16FC2  6EE6     MOVWF 0xFE6, ACCESS
16FC4  0EFF     MOVLW 0xFF
16FC6  6EE6     MOVWF 0xFE6, ACCESS
16FC8  0E00     MOVLW 0x0
16FCA  6EE6     MOVWF 0xFE6, ACCESS
16FCC  0E00     MOVLW 0x0
16FCE  6EE6     MOVWF 0xFE6, ACCESS
16FD0  0E12     MOVLW 0x12
16FD2  6EE6     MOVWF 0xFE6, ACCESS
16FD4  0E06     MOVLW 0x6
16FD6  6EE6     MOVWF 0xFE6, ACCESS
16FD8  EC35     CALL 0x1C06A, 0
16FDA  F0E0     NOP
811:           			/*
812:           			 * update EEPROM energy history structure and check for serial commands on the logging port
813:           			 */
814:           			get_bm_data(EB);
16FDC  0E00     MOVLW 0x0
16FDE  6EE6     MOVWF 0xFE6, ACCESS
16FE0  0E08     MOVLW 0x8
16FE2  6EE6     MOVWF 0xFE6, ACCESS
16FE4  EC97     CALL 0x1372E, 0
16FE6  F09B     NOP
815:           			compute_bm_data(EB); // calculate battery energy at 10 second update rate
16FE8  0E00     MOVLW 0x0
16FEA  6EE6     MOVWF 0xFE6, ACCESS
16FEC  0E08     MOVLW 0x8
16FEE  6EE6     MOVWF 0xFE6, ACCESS
16FF0  EC06     CALL 0x1800C, 0
16FF2  F0C0     NOP
816:           			if (!EB->loaded) // save a copy to EEPROM if it wasn't loaded at boot
16FF4  0108     MOVLB 0x8
16FF6  5103     MOVF __activetblptr, W, BANKED
16FF8  A4D8     BTFSS 0xFD8, 2, ACCESS
16FFA  D009     BRA 0x700E
817:           			{
818:           				EB->loaded = true;
16FFC  0E01     MOVLW 0x1
16FFE  6F03     MOVWF __activetblptr, BANKED
819:           				wr_bm_data((void*) EB);
17000  0E00     MOVLW 0x0
17002  6EE6     MOVWF 0xFE6, ACCESS
17004  0E08     MOVLW 0x8
17006  6EE6     MOVWF 0xFE6, ACCESS
17008  ECB2     CALL 0x1CD64, 0
1700A  F0E6     NOP
820:           				MM_ERROR_S;
1700C  82BF     BSF 0xFBF, 1, ACCESS
821:           			}
822:           			if ((EBD_update++ >= BM_UPDATE) || ((EBD_update >= BM_UPDATE_RUN) && (cc_mode != STATUS_SLEEPING))) {
1700E  0106     MOVLB 0x6
17010  515C     MOVF 0x5C, W, BANKED
17012  6E0B     MOVWF 0xB, ACCESS
17014  515D     MOVF 0x5D, W, BANKED
17016  6E0C     MOVWF 0xC, ACCESS
17018  4B5C     INFSNZ 0x5C, F, BANKED
1701A  2B5D     INCF 0x5D, F, BANKED
1701C  0E10     MOVLW 0x10
1701E  5C0B     SUBWF 0xB, W, ACCESS
17020  0E0E     MOVLW 0xE
17022  580C     SUBWFB 0xC, W, ACCESS
17024  B0D8     BTFSC 0xFD8, 0, ACCESS
17026  D00A     BRA 0x703C
17028  0E08     MOVLW 0x8
1702A  5D5C     SUBWF 0x5C, W, BANKED
1702C  0E07     MOVLW 0x7
1702E  595D     SUBWFB 0x5D, W, BANKED
17030  A0D8     BTFSS 0xFD8, 0, ACCESS
17032  D011     BRA 0x7056
17034  504B     MOVF HLVDCON1, W, ACCESS
17036  104C     IORWF ZCDCON, W, ACCESS
17038  B4D8     BTFSC 0xFD8, 2, ACCESS
1703A  D00D     BRA 0x7056
823:           				EB->loaded = true;
1703C  0E01     MOVLW 0x1
1703E  0108     MOVLB 0x8
17040  6F03     MOVWF __activetblptr, BANKED
824:           				wr_bm_data((void*) EB);
17042  0E00     MOVLW 0x0
17044  6EE6     MOVWF 0xFE6, ACCESS
17046  0E08     MOVLW 0x8
17048  6EE6     MOVWF 0xFE6, ACCESS
1704A  ECB2     CALL 0x1CD64, 0
1704C  F0E6     NOP
825:           				EBD_update = 0;
1704E  0106     MOVLB 0x6
17050  6B5C     CLRF 0x5C, BANKED
17052  6B5D     CLRF 0x5D, BANKED
826:           				MM_ERROR_S;
17054  82BF     BSF 0xFBF, 1, ACCESS
827:           			}
828:           		}
829:           	}
830:           	state = state_fwrev;
17056  0E06     MOVLW 0x6
17058  0105     MOVLB 0x5
1705A  6FE3     MOVWF 0xE3, BANKED
831:           }
1705C  0012     RETURN 0
832:           
833:           static void state_fwrev_cb(void)
834:           {
835:           	B.fwrev[fw_state++] = abuf[2];
1B4A  0105     MOVLB 0x5
1B4C  51E2     MOVF 0xE2, W, BANKED
1B4E  0D02     MULLW 0x2
1B50  0E90     MOVLW 0x90
1B52  24F3     ADDWF 0xFF3, W, ACCESS
1B54  6ED9     MOVWF 0xFD9, ACCESS
1B56  0E05     MOVLW 0x5
1B58  20F4     ADDWFC 0xFF4, W, ACCESS
1B5A  6EDA     MOVWF __end_of_UART2_tx_vect_isr, ACCESS
1B5C  C739     MOVFF 0x739, POSTINC2
1B5E  F4DE     NOP
1B60  C73A     MOVFF 0x73A, POSTDEC2
1B62  F4DD     NOP
1B64  2BE2     INCF 0xE2, F, BANKED
836:           	if (!C.tm_ok) {
1B66  0108     MOVLB 0x8
1B68  5151     MOVF 0x51, W, BANKED
1B6A  A4D8     BTFSS 0xFD8, 2, ACCESS
1B6C  D004     BRA 0x1B76
837:           		state = state_misc;
1B6E  0E0A     MOVLW 0xA
1B70  0105     MOVLB 0x5
1B72  6FE3     MOVWF 0xE3, BANKED
838:           	} else {
1B74  0012     RETURN 0
839:           		C.tm_ok = false;
1B76  6B51     CLRF 0x51, BANKED
840:           		state = state_time;
1B78  0E07     MOVLW 0x7
1B7A  0105     MOVLB 0x5
1B7C  6FE3     MOVWF 0xE3, BANKED
841:           	}
842:           }
1B7E  0012     RETURN 0
843:           
844:           static void state_time_cb(void)
845:           {
846:           #ifdef SDEBUG
847:           	char s_buffer[22];
848:           	snprintf(s_buffer, 21, "Time CSum %X        ", calc_checksum((uint8_t *) & cmd_time[1], 10));
849:           	eaDogM_Scroll_String(s_buffer);
850:           #endif
851:           	state = state_date;
26FE  0E08     MOVLW 0x8
2700  0105     MOVLB 0x5
2702  6FE3     MOVWF 0xE3, BANKED
852:           }
2704  0012     RETURN 0
853:           
854:           static void state_date_cb(void)
855:           {
856:           #ifdef SDEBUG
857:           	char s_buffer[22];
858:           	snprintf(s_buffer, 21, "Date CSum %X        ", calc_checksum((uint8_t *) & cmd_date[1], 10));
859:           	eaDogM_Scroll_String(s_buffer);
860:           #endif
861:           	state = state_misc;
26F6  0E0A     MOVLW 0xA
26F8  0105     MOVLB 0x5
26FA  6FE3     MOVWF 0xE3, BANKED
862:           }
26FC  0012     RETURN 0
863:           
864:           /*
865:            * testing online status while waiting for 10 second flag callback
866:            */
867:           void state_misc_cb(void)
868:           {
869:           	if (mx_code == FM80_ID) { // only set FM80 offline here
1D42  0E03     MOVLW 0x3
1D44  0105     MOVLB 0x5
1D46  19DB     XORWF CLCnSEL3, W, BANKED
1D48  11DC     IORWF CLCnGLS0, W, BANKED
1D4A  B4D8     BTFSC 0xFD8, 2, ACCESS
1D4C  D007     BRA 0x1D5C
870:           	} else {
871:           		B.FM80_online = false;
1D4E  6B6F     CLRF CMOUT, BANKED
872:           		cc_mode = STATUS_LAST;
1D50  0E00     MOVLW 0x0
1D52  6E4C     MOVWF ZCDCON, ACCESS
1D54  0E05     MOVLW 0x5
1D56  6E4B     MOVWF HLVDCON1, ACCESS
873:           		state = state_init;
1D58  6BE3     CLRF 0xE3, BANKED
1D5A  0012     RETURN 0
874:           		return;
875:           	}
876:           	if (!B.ten_sec_flag) {
1D5C  5160     MOVF PMD0, W, BANKED
1D5E  A4D8     BTFSS 0xFD8, 2, ACCESS
1D60  D003     BRA 0x1D68
877:           		state = state_misc;
1D62  0E0A     MOVLW 0xA
1D64  6FE3     MOVWF 0xE3, BANKED
878:           	} else {
1D66  0012     RETURN 0
879:           		state = state_status;
1D68  0E01     MOVLW 0x1
1D6A  6FE3     MOVWF 0xE3, BANKED
880:           	}
881:           }
1D6C  0012     RETURN 0
882:           
883:           /* Misc ACSII spinner character generator, stores position for each shape */
884:           char spinners(uint8_t shape, const uint8_t reset)
1F318  52E6     MOVF 0xFE6, F, ACCESS
885:           {
886:           	static uint8_t s[MAX_SHAPES];
887:           	char c;
888:           
889:           	if (shape > (MAX_SHAPES - 1))
1F31A  0EFE     MOVLW 0xFE
1F31C  0061     MOVFFL PLUSW1, ltemp0
1F31E  F38C     NOP
1F320  F501     NOP
1F322  0E05     MOVLW 0x5
1F324  6401     CPFSGT __ptext283, ACCESS
1F326  D002     BRA 0xF32C
890:           		shape = 0;
1F328  0EFE     MOVLW 0xFE
1F32A  6AE3     CLRF 0xFE3, ACCESS
891:           	if (reset)
1F32C  0EFD     MOVLW 0xFD
1F32E  50E3     MOVF 0xFE3, W, ACCESS
1F330  B4D8     BTFSC 0xFD8, 2, ACCESS
1F332  D00B     BRA 0xF34A
892:           		s[shape] = 0;
1F334  0EFE     MOVLW 0xFE
1F336  50E3     MOVF 0xFE3, W, ACCESS
1F338  6E0B     MOVWF 0xB, ACCESS
1F33A  6A0C     CLRF 0xC, ACCESS
1F33C  0E1A     MOVLW 0x1A
1F33E  240B     ADDWF 0xB, W, ACCESS
1F340  6ED9     MOVWF 0xFD9, ACCESS
1F342  0E07     MOVLW 0x7
1F344  200C     ADDWFC 0xC, W, ACCESS
1F346  6EDA     MOVWF __end_of_UART2_tx_vect_isr, ACCESS
1F348  6ADF     CLRF 0xFDF, ACCESS
893:           	c = spin[shape][s[shape]];
1F34A  0EFE     MOVLW 0xFE
1F34C  50E3     MOVF 0xFE3, W, ACCESS
1F34E  0D14     MULLW 0x14
1F350  0E5F     MOVLW 0x5F
1F352  24F3     ADDWF 0xFF3, W, ACCESS
1F354  6E0B     MOVWF 0xB, ACCESS
1F356  0EFA     MOVLW 0xFA
1F358  20F4     ADDWFC 0xFF4, W, ACCESS
1F35A  6E0C     MOVWF 0xC, ACCESS
1F35C  0EFE     MOVLW 0xFE
1F35E  50E3     MOVF 0xFE3, W, ACCESS
1F360  6E09     MOVWF 0x9, ACCESS
1F362  6A0A     CLRF 0xA, ACCESS
1F364  0E1A     MOVLW 0x1A
1F366  2409     ADDWF 0x9, W, ACCESS
1F368  6ED9     MOVWF 0xFD9, ACCESS
1F36A  0E07     MOVLW 0x7
1F36C  200A     ADDWFC 0xA, W, ACCESS
1F36E  6EDA     MOVWF __end_of_UART2_tx_vect_isr, ACCESS
1F370  50DF     MOVF 0xFDF, W, ACCESS
1F372  260B     ADDWF 0xB, F, ACCESS
1F374  0E00     MOVLW 0x0
1F376  220C     ADDWFC 0xC, F, ACCESS
1F378  0061     MOVFFL wtemp5, TBLPTR
1F37A  F42C     NOP
1F37C  F4F6     NOP
1F37E  0061     MOVFFL 0x50C, TBLPTRH
1F380  F430     NOP
1F382  F4F7     NOP
1F384  0E00     MOVLW 0x0
1F386  6EF8     MOVWF 0xFF8, ACCESS
1F388  0008     TBLRD*
1F38A  0EFF     MOVLW 0xFF
1F38C  C4F5     MOVFF TABLAT, PLUSW1
1F38E  F4E3     NOP
894:           	if (++s[shape] >= strlen(spin[shape]))
1F390  0EFE     MOVLW 0xFE
1F392  50E3     MOVF 0xFE3, W, ACCESS
1F394  0D14     MULLW 0x14
1F396  0E5F     MOVLW 0x5F
1F398  24F3     ADDWF 0xFF3, W, ACCESS
1F39A  6E0B     MOVWF 0xB, ACCESS
1F39C  0EFA     MOVLW 0xFA
1F39E  20F4     ADDWFC 0xFF4, W, ACCESS
1F3A0  6E0C     MOVWF 0xC, ACCESS
1F3A2  0061     MOVFFL wtemp5, POSTINC1
1F3A4  F42C     NOP
1F3A6  F4E6     NOP
1F3A8  0061     MOVFFL 0x50C, POSTINC1
1F3AA  F430     NOP
1F3AC  F4E6     NOP
1F3AE  ECC2     CALL 0x384, 0
1F3B0  F001     NOP
1F3B2  0EFE     MOVLW 0xFE
1F3B4  50E3     MOVF 0xFE3, W, ACCESS
1F3B6  6E0B     MOVWF 0xB, ACCESS
1F3B8  6A0C     CLRF 0xC, ACCESS
1F3BA  0E1A     MOVLW 0x1A
1F3BC  240B     ADDWF 0xB, W, ACCESS
1F3BE  6ED9     MOVWF 0xFD9, ACCESS
1F3C0  0E07     MOVLW 0x7
1F3C2  200C     ADDWFC 0xC, W, ACCESS
1F3C4  6EDA     MOVWF __end_of_UART2_tx_vect_isr, ACCESS
1F3C6  2ADF     INCF 0xFDF, F, ACCESS
1F3C8  50DF     MOVF 0xFDF, W, ACCESS
1F3CA  6E0B     MOVWF 0xB, ACCESS
1F3CC  6A0C     CLRF 0xC, ACCESS
1F3CE  5001     MOVF __ptext283, W, ACCESS
1F3D0  5C0B     SUBWF 0xB, W, ACCESS
1F3D2  5002     MOVF ___rparam_used, W, ACCESS
1F3D4  580C     SUBWFB 0xC, W, ACCESS
1F3D6  A0D8     BTFSS 0xFD8, 0, ACCESS
1F3D8  D00B     BRA 0xF3F0
895:           		s[shape] = 0;
1F3DA  0EFE     MOVLW 0xFE
1F3DC  50E3     MOVF 0xFE3, W, ACCESS
1F3DE  6E0B     MOVWF 0xB, ACCESS
1F3E0  6A0C     CLRF 0xC, ACCESS
1F3E2  0E1A     MOVLW 0x1A
1F3E4  240B     ADDWF 0xB, W, ACCESS
1F3E6  6ED9     MOVWF 0xFD9, ACCESS
1F3E8  0E07     MOVLW 0x7
1F3EA  200C     ADDWFC 0xC, W, ACCESS
1F3EC  6EDA     MOVWF __end_of_UART2_tx_vect_isr, ACCESS
1F3EE  6ADF     CLRF 0xFDF, ACCESS
896:           	return c;
1F3F0  0EFF     MOVLW 0xFF
1F3F2  0061     MOVFFL PLUSW1, ltemp0
1F3F4  F38C     NOP
1F3F6  F501     NOP
897:           }
1F3F8  52E5     MOVF 0xFE5, F, ACCESS
1F3F8  52E5     MOVF 0xFE5, F, ACCESS
1F3F8  52E5     MOVF 0xFE5, F, ACCESS
1F3F8  52E5     MOVF 0xFE5, F, ACCESS
898:           
899:           void run_day_to_night(void)
1EC44  0E16     MOVLW 0x16
1EC46  26E1     ADDWF 0xFE1, F, ACCESS
1EC48  0E00     MOVLW 0x0
1EC4A  22E2     ADDWFC 0xFE2, F, ACCESS
900:           {
901:           	char s_buffer[22];
902:           
903:           	snprintf(s_buffer, 21, "DN %.1fWh PV        ", pv_Wh_daily);
1EC4C  C639     MOVFF pv_Wh_daily, POSTINC1
1EC4E  F4E6     NOP
1EC50  C63A     MOVFF 0x63A, POSTINC1
1EC52  F4E6     NOP
1EC54  C63B     MOVFF 0x63B, POSTINC1
1EC56  F4E6     NOP
1EC58  C63C     MOVFF 0x63C, POSTINC1
1EC5A  F4E6     NOP
1EC5C  0E21     MOVLW 0x21
1EC5E  6EE6     MOVWF 0xFE6, ACCESS
1EC60  0EFF     MOVLW 0xFF
1EC62  6EE6     MOVWF 0xFE6, ACCESS
1EC64  0E15     MOVLW 0x15
1EC66  6EE6     MOVWF 0xFE6, ACCESS
1EC68  0E00     MOVLW 0x0
1EC6A  6EE6     MOVWF 0xFE6, ACCESS
1EC6C  0EE2     MOVLW 0xE2
1EC6E  24E1     ADDWF 0xFE1, W, ACCESS
1EC70  6E01     MOVWF __ptext283, ACCESS
1EC72  0EFF     MOVLW 0xFF
1EC74  20E2     ADDWFC 0xFE2, W, ACCESS
1EC76  6E02     MOVWF ___rparam_used, ACCESS
1EC78  0061     MOVFFL ltemp0, POSTINC1
1EC7A  F404     NOP
1EC7C  F4E6     NOP
1EC7E  0061     MOVFFL ttemp5, POSTINC1
1EC80  F408     NOP
1EC82  F4E6     NOP
1EC84  0E0A     MOVLW 0xA
1EC86  6EE6     MOVWF 0xFE6, ACCESS
1EC88  EC35     CALL 0x1C06A, 0
1EC8A  F0E0     NOP
904:           	eaDogM_Scroll_String(s_buffer);
1EC8C  0EEA     MOVLW 0xEA
1EC8E  24E1     ADDWF 0xFE1, W, ACCESS
1EC90  6E01     MOVWF __ptext283, ACCESS
1EC92  0EFF     MOVLW 0xFF
1EC94  20E2     ADDWFC 0xFE2, W, ACCESS
1EC96  6E02     MOVWF ___rparam_used, ACCESS
1EC98  0061     MOVFFL ltemp0, POSTINC1
1EC9A  F404     NOP
1EC9C  F4E6     NOP
1EC9E  0061     MOVFFL ttemp5, POSTINC1
1ECA0  F408     NOP
1ECA2  F4E6     NOP
1ECA4  ECB1     CALL 0x1FF62, 0
1ECA6  F0FF     NOP
905:           	snprintf(s_buffer, 21, "DN %.1fWh AC        ", ac_Wh_daily);
1ECA8  C635     MOVFF ac_Wh_daily, POSTINC1
1ECAA  F4E6     NOP
1ECAC  C636     MOVFF 0x636, POSTINC1
1ECAE  F4E6     NOP
1ECB0  C637     MOVFF 0x637, POSTINC1
1ECB2  F4E6     NOP
1ECB4  C638     MOVFF 0x638, POSTINC1
1ECB6  F4E6     NOP
1ECB8  0EF7     MOVLW 0xF7
1ECBA  6EE6     MOVWF 0xFE6, ACCESS
1ECBC  0EFE     MOVLW 0xFE
1ECBE  6EE6     MOVWF 0xFE6, ACCESS
1ECC0  0E15     MOVLW 0x15
1ECC2  6EE6     MOVWF 0xFE6, ACCESS
1ECC4  0E00     MOVLW 0x0
1ECC6  6EE6     MOVWF 0xFE6, ACCESS
1ECC8  0EE2     MOVLW 0xE2
1ECCA  24E1     ADDWF 0xFE1, W, ACCESS
1ECCC  6E01     MOVWF __ptext283, ACCESS
1ECCE  0EFF     MOVLW 0xFF
1ECD0  20E2     ADDWFC 0xFE2, W, ACCESS
1ECD2  6E02     MOVWF ___rparam_used, ACCESS
1ECD4  0061     MOVFFL ltemp0, POSTINC1
1ECD6  F404     NOP
1ECD8  F4E6     NOP
1ECDA  0061     MOVFFL ttemp5, POSTINC1
1ECDC  F408     NOP
1ECDE  F4E6     NOP
1ECE0  0E0A     MOVLW 0xA
1ECE2  6EE6     MOVWF 0xFE6, ACCESS
1ECE4  EC35     CALL 0x1C06A, 0
1ECE6  F0E0     NOP
906:           	eaDogM_Scroll_String(s_buffer);
1ECE8  0EEA     MOVLW 0xEA
1ECEA  24E1     ADDWF 0xFE1, W, ACCESS
1ECEC  6E01     MOVWF __ptext283, ACCESS
1ECEE  0EFF     MOVLW 0xFF
1ECF0  20E2     ADDWFC 0xFE2, W, ACCESS
1ECF2  6E02     MOVWF ___rparam_used, ACCESS
1ECF4  0061     MOVFFL ltemp0, POSTINC1
1ECF6  F404     NOP
1ECF8  F4E6     NOP
1ECFA  0061     MOVFFL ttemp5, POSTINC1
1ECFC  F408     NOP
1ECFE  F4E6     NOP
1ED00  ECB1     CALL 0x1FF62, 0
1ED02  F0FF     NOP
907:           	eaDogM_Scroll_String(s_buffer);
1ED04  0EEA     MOVLW 0xEA
1ED06  24E1     ADDWF 0xFE1, W, ACCESS
1ED08  6E01     MOVWF __ptext283, ACCESS
1ED0A  0EFF     MOVLW 0xFF
1ED0C  20E2     ADDWFC 0xFE2, W, ACCESS
1ED0E  6E02     MOVWF ___rparam_used, ACCESS
1ED10  0061     MOVFFL ltemp0, POSTINC1
1ED12  F404     NOP
1ED14  F4E6     NOP
1ED16  0061     MOVFFL ttemp5, POSTINC1
1ED18  F408     NOP
1ED1A  F4E6     NOP
1ED1C  ECB1     CALL 0x1FF62, 0
1ED1E  F0FF     NOP
908:           	eaDogM_Scroll_String(s_buffer);
1ED20  0EEA     MOVLW 0xEA
1ED22  24E1     ADDWF 0xFE1, W, ACCESS
1ED24  6E01     MOVWF __ptext283, ACCESS
1ED26  0EFF     MOVLW 0xFF
1ED28  20E2     ADDWFC 0xFE2, W, ACCESS
1ED2A  6E02     MOVWF ___rparam_used, ACCESS
1ED2C  0061     MOVFFL ltemp0, POSTINC1
1ED2E  F404     NOP
1ED30  F4E6     NOP
1ED32  0061     MOVFFL ttemp5, POSTINC1
1ED34  F408     NOP
1ED36  F4E6     NOP
1ED38  ECB1     CALL 0x1FF62, 0
1ED3A  F0FF     NOP
909:           }
1ED3C  0EEA     MOVLW 0xEA
1ED3C  0EEA     MOVLW 0xEA
1ED3C  0EEA     MOVLW 0xEA
1ED3C  0EEA     MOVLW 0xEA
1ED3C  0EEA     MOVLW 0xEA
910:           
911:           void run_night_to_day(void)
1EB42  0E16     MOVLW 0x16
1EB44  26E1     ADDWF 0xFE1, F, ACCESS
1EB46  0E00     MOVLW 0x0
1EB48  22E2     ADDWFC 0xFE2, F, ACCESS
912:           {
913:           	char s_buffer[22];
914:           
915:           	snprintf(s_buffer, 21, "ND %.1fWh PV        ", pv_Wh_daily_prev);
1EB4A  C631     MOVFF pv_Wh_daily_prev, POSTINC1
1EB4C  F4E6     NOP
1EB4E  C632     MOVFF 0x632, POSTINC1
1EB50  F4E6     NOP
1EB52  C633     MOVFF 0x633, POSTINC1
1EB54  F4E6     NOP
1EB56  C634     MOVFF 0x634, POSTINC1
1EB58  F4E6     NOP
1EB5A  0E0C     MOVLW 0xC
1EB5C  6EE6     MOVWF 0xFE6, ACCESS
1EB5E  0EFF     MOVLW 0xFF
1EB60  6EE6     MOVWF 0xFE6, ACCESS
1EB62  0E15     MOVLW 0x15
1EB64  6EE6     MOVWF 0xFE6, ACCESS
1EB66  0E00     MOVLW 0x0
1EB68  6EE6     MOVWF 0xFE6, ACCESS
1EB6A  0EE2     MOVLW 0xE2
1EB6C  24E1     ADDWF 0xFE1, W, ACCESS
1EB6E  6E01     MOVWF __ptext283, ACCESS
1EB70  0EFF     MOVLW 0xFF
1EB72  20E2     ADDWFC 0xFE2, W, ACCESS
1EB74  6E02     MOVWF ___rparam_used, ACCESS
1EB76  0061     MOVFFL ltemp0, POSTINC1
1EB78  F404     NOP
1EB7A  F4E6     NOP
1EB7C  0061     MOVFFL ttemp5, POSTINC1
1EB7E  F408     NOP
1EB80  F4E6     NOP
1EB82  0E0A     MOVLW 0xA
1EB84  6EE6     MOVWF 0xFE6, ACCESS
1EB86  EC35     CALL 0x1C06A, 0
1EB88  F0E0     NOP
916:           	eaDogM_Scroll_String(s_buffer);
1EB8A  0EEA     MOVLW 0xEA
1EB8C  24E1     ADDWF 0xFE1, W, ACCESS
1EB8E  6E01     MOVWF __ptext283, ACCESS
1EB90  0EFF     MOVLW 0xFF
1EB92  20E2     ADDWFC 0xFE2, W, ACCESS
1EB94  6E02     MOVWF ___rparam_used, ACCESS
1EB96  0061     MOVFFL ltemp0, POSTINC1
1EB98  F404     NOP
1EB9A  F4E6     NOP
1EB9C  0061     MOVFFL ttemp5, POSTINC1
1EB9E  F408     NOP
1EBA0  F4E6     NOP
1EBA2  ECB1     CALL 0x1FF62, 0
1EBA4  F0FF     NOP
917:           	snprintf(s_buffer, 21, "ND %.1fWh AC        ", ac_Wh_daily_prev);
1EBA6  C62D     MOVFF ac_Wh_daily_prev, POSTINC1
1EBA8  F4E6     NOP
1EBAA  C62E     MOVFF 0x62E, POSTINC1
1EBAC  F4E6     NOP
1EBAE  C62F     MOVFF 0x62F, POSTINC1
1EBB0  F4E6     NOP
1EBB2  C630     MOVFF 0x630, POSTINC1
1EBB4  F4E6     NOP
1EBB6  0EE2     MOVLW 0xE2
1EBB8  6EE6     MOVWF 0xFE6, ACCESS
1EBBA  0EFE     MOVLW 0xFE
1EBBC  6EE6     MOVWF 0xFE6, ACCESS
1EBBE  0E15     MOVLW 0x15
1EBC0  6EE6     MOVWF 0xFE6, ACCESS
1EBC2  0E00     MOVLW 0x0
1EBC4  6EE6     MOVWF 0xFE6, ACCESS
1EBC6  0EE2     MOVLW 0xE2
1EBC8  24E1     ADDWF 0xFE1, W, ACCESS
1EBCA  6E01     MOVWF __ptext283, ACCESS
1EBCC  0EFF     MOVLW 0xFF
1EBCE  20E2     ADDWFC 0xFE2, W, ACCESS
1EBD0  6E02     MOVWF ___rparam_used, ACCESS
1EBD2  0061     MOVFFL ltemp0, POSTINC1
1EBD4  F404     NOP
1EBD6  F4E6     NOP
1EBD8  0061     MOVFFL ttemp5, POSTINC1
1EBDA  F408     NOP
1EBDC  F4E6     NOP
1EBDE  0E0A     MOVLW 0xA
1EBE0  6EE6     MOVWF 0xFE6, ACCESS
1EBE2  EC35     CALL 0x1C06A, 0
1EBE4  F0E0     NOP
918:           	eaDogM_Scroll_String(s_buffer);
1EBE6  0EEA     MOVLW 0xEA
1EBE8  24E1     ADDWF 0xFE1, W, ACCESS
1EBEA  6E01     MOVWF __ptext283, ACCESS
1EBEC  0EFF     MOVLW 0xFF
1EBEE  20E2     ADDWFC 0xFE2, W, ACCESS
1EBF0  6E02     MOVWF ___rparam_used, ACCESS
1EBF2  0061     MOVFFL ltemp0, POSTINC1
1EBF4  F404     NOP
1EBF6  F4E6     NOP
1EBF8  0061     MOVFFL ttemp5, POSTINC1
1EBFA  F408     NOP
1EBFC  F4E6     NOP
1EBFE  ECB1     CALL 0x1FF62, 0
1EC00  F0FF     NOP
919:           	eaDogM_Scroll_String(s_buffer);
1EC02  0EEA     MOVLW 0xEA
1EC04  24E1     ADDWF 0xFE1, W, ACCESS
1EC06  6E01     MOVWF __ptext283, ACCESS
1EC08  0EFF     MOVLW 0xFF
1EC0A  20E2     ADDWFC 0xFE2, W, ACCESS
1EC0C  6E02     MOVWF ___rparam_used, ACCESS
1EC0E  0061     MOVFFL ltemp0, POSTINC1
1EC10  F404     NOP
1EC12  F4E6     NOP
1EC14  0061     MOVFFL ttemp5, POSTINC1
1EC16  F408     NOP
1EC18  F4E6     NOP
1EC1A  ECB1     CALL 0x1FF62, 0
1EC1C  F0FF     NOP
920:           	eaDogM_Scroll_String(s_buffer);
1EC1E  0EEA     MOVLW 0xEA
1EC20  24E1     ADDWF 0xFE1, W, ACCESS
1EC22  6E01     MOVWF __ptext283, ACCESS
1EC24  0EFF     MOVLW 0xFF
1EC26  20E2     ADDWFC 0xFE2, W, ACCESS
1EC28  6E02     MOVWF ___rparam_used, ACCESS
1EC2A  0061     MOVFFL ltemp0, POSTINC1
1EC2C  F404     NOP
1EC2E  F4E6     NOP
1EC30  0061     MOVFFL ttemp5, POSTINC1
1EC32  F408     NOP
1EC34  F4E6     NOP
1EC36  ECB1     CALL 0x1FF62, 0
1EC38  F0FF     NOP
921:           }
1EC3A  0EEA     MOVLW 0xEA
1EC3A  0EEA     MOVLW 0xEA
1EC3A  0EEA     MOVLW 0xEA
1EC3A  0EEA     MOVLW 0xEA
1EC3A  0EEA     MOVLW 0xEA
922:           /**
923:            End of File
924:            */
---  /public/Q84vtouch/eadog.c  -------------------------------------------------------------------------
1:             #include <string.h>
2:             #include "qconfig.h"
3:             #include "eadog.h"
4:             #include "mateQ84.X/mcc_generated_files/mcc.h"
5:             
6:             volatile struct spi_link_type spi_link = {
7:                 .LCD_DATA = false,
8:             };
9:             
10:            static const spi1_configuration_t spi1_configuration[] = {
11:                {0x83, 0x20, 0x3, 0x4, 0}
12:            };
13:            
14:            static char Sstr[NSB][LSB];
15:            static volatile bool scroll_lock = false, powerup = true;
16:            static volatile uint8_t scroll_line_pos = 4;
17:            
18:            static void send_lcd_cmd_long(const uint8_t); // for display init only
19:            static void send_lcd_data(const uint8_t);
20:            static void send_lcd_cmd(const uint8_t);
21:            static void spi_byte(void);
22:            
23:            /*
24:             * Init the NHD-0420D3Z-NSW-BBW-V3 in 8-bit serial mode
25:             * channel 1 DMA if configured
26:             */
27:            bool init_display(void) {
28:                spi_link.txbuf = lcd_dma_buf; // use MCC DMA buffer variable
1F22C  0EC4     MOVLW 0xC4
1F22E  0106     MOVLB 0x6
1F230  6F13     MOVWF 0x13, BANKED
1F232  0E0A     MOVLW 0xA
1F234  6F14     MOVWF 0x14, BANKED
29:                memset(Sstr, ' ', NSB * LSB); // clear scroll buffer of junk
1F236  0E69     MOVLW 0x69
1F238  6EE6     MOVWF 0xFE6, ACCESS
1F23A  0E00     MOVLW 0x0
1F23C  6EE6     MOVWF 0xFE6, ACCESS
1F23E  0E20     MOVLW 0x20
1F240  6EE6     MOVWF 0xFE6, ACCESS
1F242  0E00     MOVLW 0x0
1F244  6EE6     MOVWF 0xFE6, ACCESS
1F246  0E40     MOVLW 0x40
1F248  6EE6     MOVWF 0xFE6, ACCESS
1F24A  0E0D     MOVLW 0xD
1F24C  6EE6     MOVWF 0xFE6, ACCESS
1F24E  EC29     CALL 0x1B052, 0
1F250  F0D8     NOP
30:            
31:            #ifdef USE_LCD_DMA
32:                DMA1_SetSCNTIInterruptHandler(clear_lcd_done);
1F252  0E2C     MOVLW 0x2C
1F254  6EE6     MOVWF 0xFE6, ACCESS
1F256  0E20     MOVLW 0x20
1F258  6EE6     MOVWF 0xFE6, ACCESS
1F25A  0E00     MOVLW 0x0
1F25C  6EE6     MOVWF 0xFE6, ACCESS
1F25E  EC27     CALL 0x224E, 0
1F260  F011     NOP
33:                DMA1_SetORIInterruptHandler(spi_byte);
1F262  0E30     MOVLW 0x30
1F264  6EE6     MOVWF 0xFE6, ACCESS
1F266  0E1A     MOVLW 0x1A
1F268  6EE6     MOVWF 0xFE6, ACCESS
1F26A  0E00     MOVLW 0x0
1F26C  6EE6     MOVWF 0xFE6, ACCESS
1F26E  EC38     CALL 0x2270, 0
1F270  F011     NOP
34:                DMA1_SetDMAPriority(2);
1F272  0E02     MOVLW 0x2
1F274  6EE6     MOVWF 0xFE6, ACCESS
1F276  EC37     CALL 0x246E, 0
1F278  F012     NOP
35:            #endif
36:            #ifdef NHD  // uses MODE 3 on the Q84, https://newhavendisplay.com/content/specs/NHD-0420D3Z-NSW-BBW-V3.pdf
37:            #ifdef USEMCC_SPI
38:            #else
39:                SPI1CON0bits.EN = 0;
40:                // mode 3
41:                SPI1CON1 = 0x20;
42:                // SSET disabled; RXR suspended if the RxFIFO is full; TXR required for a transfer; 
43:                SPI1CON2 = 0x03;
44:                // BAUD 0; 
45:                SPI1BAUD = 0x04; // 50kHz SCK
46:                // CLKSEL MFINTOSC; 
47:                SPI1CLK = 0x02;
48:                // BMODE every byte; LSBF MSb first; EN enabled; MST bus master; 
49:                SPI1CON0 = 0x83;
50:                SPI1CON0bits.EN = 1;
51:            #endif
52:                if (powerup) {
1F27A  0105     MOVLB 0x5
1F27C  51AF     MOVF OSCCON3, W, BANKED
1F27E  B4D8     BTFSC 0xFD8, 2, ACCESS
1F280  D00A     BRA 0xF296
53:                    wdtdelay(350000); // > 400ms power up delay
1F282  0E30     MOVLW 0x30
1F284  6EE6     MOVWF 0xFE6, ACCESS
1F286  0E57     MOVLW 0x57
1F288  6EE6     MOVWF 0xFE6, ACCESS
1F28A  0E05     MOVLW 0x5
1F28C  6EE6     MOVWF 0xFE6, ACCESS
1F28E  0E00     MOVLW 0x0
1F290  6EE6     MOVWF 0xFE6, ACCESS
1F292  EC0F     CALL 0xC1E, 0
1F294  F006     NOP
54:                }
55:            
56:            #ifdef USE_LCD_DMA
57:                SPI1INTFbits.SPI1TXUIF = 0;
1F296  0100     MOVLB 0x0
1F298  938A     BCF SPI1INTF, 1, BANKED
58:                DMASELECT = 0; // use DMA1
1F29A  6BE8     CLRF DMASELECT, BANKED
59:                DMAnCON0bits.EN = 0;
1F29C  9FFC     BCF DMAnCON0, 7, BANKED
60:                SPI1CON0bits.EN = 0;
1F29E  9F84     BCF SPI1CON0, 7, BANKED
61:                SPI1CON2 = 0x02; //  Received data is not stored in the FIFO
1F2A0  0E02     MOVLW 0x2
1F2A2  6F86     MOVWF SPI1CON2, BANKED
62:                SPI1CON0bits.EN = 1;
1F2A4  8F84     BSF SPI1CON0, 7, BANKED
63:                DMAnCON1bits.DMODE = 0;
1F2A6  0E3F     MOVLW 0x3F
1F2A8  17FD     ANDWF DMAnCON1, F, BANKED
64:                DMAnCON1bits.DSTP = 0;
1F2AA  9BFD     BCF DMAnCON1, 5, BANKED
65:                DMAnCON1bits.SMODE = 1;
1F2AC  51FD     MOVF DMAnCON1, W, BANKED
1F2AE  0BF9     ANDLW 0xF9
1F2B0  0902     IORLW 0x2
1F2B2  6FFD     MOVWF DMAnCON1, BANKED
66:                DMAnCON1bits.SMR = 0;
1F2B4  0EE7     MOVLW 0xE7
1F2B6  17FD     ANDWF DMAnCON1, F, BANKED
67:                DMAnCON1bits.SSTP = 1;
1F2B8  81FD     BSF DMAnCON1, 0, BANKED
68:                DMAnSSA = (uint24_t) spi_link.txbuf;
1F2BA  C613     MOVFF 0x613, DMAnSSA
1F2BC  F0F9     NOP
1F2BE  C614     MOVFF 0x614, DMAnSSAH
1F2C0  F0FA     NOP
1F2C2  6BFB     CLRF DMAnSSAU, BANKED
69:                DMAnCON0bits.DGO = 0;
1F2C4  9BFC     BCF DMAnCON0, 5, BANKED
70:                DMAnCON0bits.EN = 1; /* enable DMA */
1F2C6  8FFC     BSF DMAnCON0, 7, BANKED
71:                SPI1INTFbits.SPI1TXUIF = 1;
1F2C8  838A     BSF SPI1INTF, 1, BANKED
72:                send_lcd_cmd_dma(LCD_CMD_BRI); // set back-light level
1F2CA  0E53     MOVLW 0x53
1F2CC  6EE6     MOVWF 0xFE6, ACCESS
1F2CE  ECE8     CALL 0x25D0, 0
1F2D0  F012     NOP
73:                send_lcd_data_dma(NHD_BL_LOW);
1F2D2  0E02     MOVLW 0x2
1F2D4  6EE6     MOVWF 0xFE6, ACCESS
1F2D6  EC27     CALL 0x184E, 0
1F2D8  F00C     NOP
74:                send_lcd_cmd_dma(LCD_CMD_CONT); // set display contrast
1F2DA  0E52     MOVLW 0x52
1F2DC  6EE6     MOVWF 0xFE6, ACCESS
1F2DE  ECE8     CALL 0x25D0, 0
1F2E0  F012     NOP
75:                send_lcd_data_dma(NHD_CONT);
1F2E2  0E2B     MOVLW 0x2B
1F2E4  6EE6     MOVWF 0xFE6, ACCESS
1F2E6  EC27     CALL 0x184E, 0
1F2E8  F00C     NOP
76:                send_lcd_cmd_dma(LCD_CMD_ON); // display on
1F2EA  0E41     MOVLW 0x41
1F2EC  6EE6     MOVWF 0xFE6, ACCESS
1F2EE  ECE8     CALL 0x25D0, 0
1F2F0  F012     NOP
77:                send_lcd_cmd_dma(LCD_CMD_CLR); // clear screen
1F2F2  0E51     MOVLW 0x51
1F2F4  6EE6     MOVWF 0xFE6, ACCESS
1F2F6  ECE8     CALL 0x25D0, 0
1F2F8  F012     NOP
78:                wdtdelay(800);
1F2FA  0E20     MOVLW 0x20
1F2FC  6EE6     MOVWF 0xFE6, ACCESS
1F2FE  0E03     MOVLW 0x3
1F300  6EE6     MOVWF 0xFE6, ACCESS
1F302  0E00     MOVLW 0x0
1F304  6EE6     MOVWF 0xFE6, ACCESS
1F306  0E00     MOVLW 0x0
1F308  6EE6     MOVWF 0xFE6, ACCESS
1F30A  EC0F     CALL 0xC1E, 0
1F30C  F006     NOP
79:                DMA1_StopTransfer();
1F30E  EC76     CALL 0x26EC, 0
1F310  F013     NOP
80:            #else
81:                send_lcd_cmd_long(LCD_CMD_HOME); // home cursor
82:                send_lcd_cmd(LCD_CMD_ON); // display on
83:                wdtdelay(80);
84:                send_lcd_cmd(NHD_BL_MED); // set back-light level
85:                send_lcd_data(NHD_BL_LOW);
86:                wdtdelay(80);
87:                send_lcd_cmd_long(LCD_CMD_CLR); // clear screen
88:            #endif
89:            #endif
90:                powerup = false; // only of the first display init call
1F312  0105     MOVLB 0x5
1F314  6BAF     CLRF OSCCON3, BANKED
91:                return true;
92:            }
1F316  0012     RETURN 0
93:            
94:            #ifdef NHD
95:            
96:            /*
97:             * R2 short on LCD NHD-0420D3Z-NSW-BBW-V3 board
98:             */
99:            
100:           static void send_lcd_data(const uint8_t data) {
101:               CS_SetLow();
102:               SPI1_ExchangeByte(data);
103:               wdtdelay(8);
104:           }
105:           
106:           static void send_lcd_cmd(const uint8_t cmd) {
107:               CS_SetLow();
108:               SPI1_ExchangeByte(NHD_CMD);
109:               wdtdelay(8);
110:               SPI1_ExchangeByte(cmd);
111:               wdtdelay(8);
112:           }
113:           
114:           static void send_lcd_cmd_long(const uint8_t cmd) {
115:               CS_SetLow();
116:               SPI1_ExchangeByte(NHD_CMD);
117:               wdtdelay(8);
118:               SPI1_ExchangeByte(cmd);
119:               wdtdelay(800);
120:           }
121:           
122:           /*
123:            * CAN use DMA channel 1 for transfers
124:            */
125:           void eaDogM_WriteString(char *strPtr) {
06E6  52E6     MOVF 0xFE6, F, ACCESS
126:               uint8_t len = (uint8_t) strlen(strPtr);
06E8  0EFD     MOVLW 0xFD
06EA  C4E3     MOVFF PLUSW1, POSTINC1
06EC  F4E6     NOP
06EE  C4E3     MOVFF PLUSW1, POSTINC1
06F0  F4E6     NOP
06F2  ECC2     CALL 0x384, 0
06F4  F001     NOP
06F6  0EFF     MOVLW 0xFF
06F8  0061     MOVFFL ltemp0, PLUSW1
06FA  F404     NOP
06FC  F4E3     NOP
127:           
128:               wait_lcd_done();
06FE  EC41     CALL 0x2682, 0
0700  F013     NOP
129:               wait_lcd_set();
0702  ECA3     CALL 0x2746, 0
0704  F013     NOP
130:               CS_SetLow(); /* SPI select display */
0706  96C1     BCF 0xFC1, 3, ACCESS
131:               if (len > (uint8_t) max_strlen) {
0708  0EFF     MOVLW 0xFF
070A  0061     MOVFFL PLUSW1, ltemp0
070C  F38C     NOP
070E  F501     NOP
0710  0E14     MOVLW 0x14
0712  6401     CPFSGT __ptext283, ACCESS
0714  D004     BRA 0x71E
132:                   len = max_strlen;
0716  0EFF     MOVLW 0xFF
0718  6AE3     CLRF 0xFE3, ACCESS
071A  84E3     BSF 0xFE3, 2, ACCESS
071C  88E3     BSF 0xFE3, 4, ACCESS
133:               }
134:               memcpy(spi_link.txbuf, strPtr, len);
071E  0EFF     MOVLW 0xFF
0720  50E3     MOVF 0xFE3, W, ACCESS
0722  6EE6     MOVWF 0xFE6, ACCESS
0724  0E00     MOVLW 0x0
0726  6EE6     MOVWF 0xFE6, ACCESS
0728  0EFB     MOVLW 0xFB
072A  C4E3     MOVFF PLUSW1, POSTINC1
072C  F4E6     NOP
072E  C4E3     MOVFF PLUSW1, POSTINC1
0730  F4E6     NOP
0732  C613     MOVFF 0x613, POSTINC1
0734  F4E6     NOP
0736  C614     MOVFF 0x614, POSTINC1
0738  F4E6     NOP
073A  EC81     CALL 0x1E502, 0
073C  F0F2     NOP
135:           #ifdef USE_LCD_DMA
136:               DMAnCON0bits.EN = 0; /* disable DMA to change source count */
073E  0100     MOVLB 0x0
0740  9FFC     BCF DMAnCON0, 7, BANKED
137:               DMA1_SetSourceSize(len);
0742  0EFF     MOVLW 0xFF
0744  50E3     MOVF 0xFE3, W, ACCESS
0746  6EE6     MOVWF 0xFE6, ACCESS
0748  0E00     MOVLW 0x0
074A  6EE6     MOVWF 0xFE6, ACCESS
074C  ECF3     CALL 0x25E6, 0
074E  F012     NOP
138:               DMA1_SetDestinationSize(1);
0750  0E01     MOVLW 0x1
0752  6EE6     MOVWF 0xFE6, ACCESS
0754  0E00     MOVLW 0x0
0756  6EE6     MOVWF 0xFE6, ACCESS
0758  ECFE     CALL 0x25FC, 0
075A  F012     NOP
139:               DMAnCON0bits.EN = 1; /* enable DMA */
075C  8FFC     BSF DMAnCON0, 7, BANKED
140:           #else
141:               SPI1_ExchangeBlock(spi_link.txbuf, len);
142:           #endif
143:               start_lcd(); // start DMA transfer
075E  ECA6     CALL 0x274C, 0
0760  F013     NOP
144:           }
0762  52E5     MOVF 0xFE5, F, ACCESS
0762  52E5     MOVF 0xFE5, F, ACCESS
0762  52E5     MOVF 0xFE5, F, ACCESS
0762  52E5     MOVF 0xFE5, F, ACCESS
145:           
146:           /*
147:            * uses DMA channel 1 for transfers
148:            */
149:           void send_lcd_cmd_dma(const uint8_t strPtr) {
150:               send_lcd_data_dma(NHD_CMD); //prefix
25D0  0EFE     MOVLW 0xFE
25D2  6EE6     MOVWF 0xFE6, ACCESS
25D4  EC27     CALL 0x184E, 0
25D6  F00C     NOP
151:               send_lcd_data_dma(strPtr); // cmd code
25D8  0EFF     MOVLW 0xFF
25DA  50E3     MOVF 0xFE3, W, ACCESS
25DC  6EE6     MOVWF 0xFE6, ACCESS
25DE  EC27     CALL 0x184E, 0
25E0  F00C     NOP
152:           }
25E2  52E5     MOVF 0xFE5, F, ACCESS
25E2  52E5     MOVF 0xFE5, F, ACCESS
153:           
154:           /*
155:            * uses DMA channel 1 for transfers
156:            */
157:           void send_lcd_data_dma(const uint8_t strPtr) {
158:               wait_lcd_done();
184E  EC41     CALL 0x2682, 0
1850  F013     NOP
159:               wait_lcd_set();
1852  ECA3     CALL 0x2746, 0
1854  F013     NOP
160:               CS_SetLow(); /* SPI select display */
1856  96C1     BCF 0xFC1, 3, ACCESS
161:               spi_link.txbuf[0] = strPtr;
1858  C613     MOVFF 0x613, FSR2
185A  F4D9     NOP
185C  C614     MOVFF 0x614, FSR2H
185E  F4DA     NOP
1860  0EFF     MOVLW 0xFF
1862  C4E3     MOVFF PLUSW1, INDF2
1864  F4DF     NOP
162:               DMAnCON0bits.EN = 0; /* disable DMA to change source count */
1866  0100     MOVLB 0x0
1868  9FFC     BCF DMAnCON0, 7, BANKED
163:               DMA1_SetSourceSize(1);
186A  0E01     MOVLW 0x1
186C  6EE6     MOVWF 0xFE6, ACCESS
186E  0E00     MOVLW 0x0
1870  6EE6     MOVWF 0xFE6, ACCESS
1872  ECF3     CALL 0x25E6, 0
1874  F012     NOP
164:               DMA1_SetDestinationSize(1);
1876  0E01     MOVLW 0x1
1878  6EE6     MOVWF 0xFE6, ACCESS
187A  0E00     MOVLW 0x0
187C  6EE6     MOVWF 0xFE6, ACCESS
187E  ECFE     CALL 0x25FC, 0
1880  F012     NOP
165:               DMAnCON0bits.EN = 1; /* enable DMA */
1882  8FFC     BSF DMAnCON0, 7, BANKED
166:               start_lcd(); // start DMA transfer
1884  ECA6     CALL 0x274C, 0
1886  F013     NOP
167:           }
1888  52E5     MOVF 0xFE5, F, ACCESS
1888  52E5     MOVF 0xFE5, F, ACCESS
168:           
169:           /*
170:            * send three byte command string via DMA
171:            */
172:           void send_lcd_pos_dma(const uint8_t strPtr) {
173:               wait_lcd_done();
0E0C  EC41     CALL 0x2682, 0
0E0E  F013     NOP
174:               wait_lcd_set();
0E10  ECA3     CALL 0x2746, 0
0E12  F013     NOP
175:               CS_SetLow(); /* SPI select display */
0E14  96C1     BCF 0xFC1, 3, ACCESS
176:               spi_link.txbuf[0] = NHD_CMD;
0E16  C613     MOVFF 0x613, FSR2
0E18  F4D9     NOP
0E1A  C614     MOVFF 0x614, FSR2H
0E1C  F4DA     NOP
0E1E  0EFE     MOVLW 0xFE
0E20  6EDF     MOVWF 0xFDF, ACCESS
177:               spi_link.txbuf[1] = NHD_POS;
0E22  EE20     LFSR 2, 0x1
0E24  F001     NOP
0E26  5113     MOVF 0x13, W, BANKED
0E28  26D9     ADDWF 0xFD9, F, ACCESS
0E2A  5114     MOVF 0x14, W, BANKED
0E2C  22DA     ADDWFC __end_of_UART2_tx_vect_isr, F, ACCESS
0E2E  0E45     MOVLW 0x45
0E30  6EDF     MOVWF 0xFDF, ACCESS
178:               spi_link.txbuf[2] = strPtr;
0E32  EE20     LFSR 2, 0x2
0E34  F002     NOP
0E36  5113     MOVF 0x13, W, BANKED
0E38  26D9     ADDWF 0xFD9, F, ACCESS
0E3A  5114     MOVF 0x14, W, BANKED
0E3C  22DA     ADDWFC __end_of_UART2_tx_vect_isr, F, ACCESS
0E3E  0EFF     MOVLW 0xFF
0E40  C4E3     MOVFF PLUSW1, INDF2
0E42  F4DF     NOP
179:               DMAnCON0bits.EN = 0; /* disable DMA to change source count */
0E44  0100     MOVLB 0x0
0E46  9FFC     BCF DMAnCON0, 7, BANKED
180:               DMA1_SetSourceSize(3);
0E48  0E03     MOVLW 0x3
0E4A  6EE6     MOVWF 0xFE6, ACCESS
0E4C  0E00     MOVLW 0x0
0E4E  6EE6     MOVWF 0xFE6, ACCESS
0E50  ECF3     CALL 0x25E6, 0
0E52  F012     NOP
181:               DMA1_SetDestinationSize(1);
0E54  0E01     MOVLW 0x1
0E56  6EE6     MOVWF 0xFE6, ACCESS
0E58  0E00     MOVLW 0x0
0E5A  6EE6     MOVWF 0xFE6, ACCESS
0E5C  ECFE     CALL 0x25FC, 0
0E5E  F012     NOP
182:               DMAnCON0bits.EN = 1; /* enable DMA */
0E60  8FFC     BSF DMAnCON0, 7, BANKED
183:               start_lcd(); // start DMA transfer
0E62  ECA6     CALL 0x274C, 0
0E64  F013     NOP
184:           }
0E66  52E5     MOVF 0xFE5, F, ACCESS
0E66  52E5     MOVF 0xFE5, F, ACCESS
185:           
186:           void eaDogM_WriteStringAtPos(const uint8_t r, const uint8_t c, char *strPtr) {
01B2  52E6     MOVF 0xFE6, F, ACCESS
187:               uint8_t row;
188:           
189:               if (scroll_lock) { // don't update LCD text when in scroll mode
01B4  5029     MOVF 0x29, W, ACCESS
01B6  A4D8     BTFSS 0xFD8, 2, ACCESS
01B8  D045     BRA 0x244
01BA  D013     BRA 0x1E2
190:                   return;
191:               }
192:           
193:               switch (r) {
194:                   case LCD1:
195:                       row = 0x40;
01BC  0EFF     MOVLW 0xFF
01BE  6AE3     CLRF 0xFE3, ACCESS
01C0  8CE3     BSF 0xFE3, 6, ACCESS
196:                       break;
01C2  D025     BRA 0x20E
197:                   case LCD2:
198:                       row = 0x14;
01C4  0EFF     MOVLW 0xFF
01C6  6AE3     CLRF 0xFE3, ACCESS
01C8  84E3     BSF 0xFE3, 2, ACCESS
01CA  88E3     BSF 0xFE3, 4, ACCESS
199:                       break;
01CC  D020     BRA 0x20E
200:                   case LCD3:
201:                       row = 0x54;
01CE  0E54     MOVLW 0x54
01D0  6E0C     MOVWF 0xC, ACCESS
01D2  0EFF     MOVLW 0xFF
01D4  0061     MOVFFL 0x50C, PLUSW1
01D6  F430     NOP
01D8  F4E3     NOP
202:                       break;
01DA  D019     BRA 0x20E
203:                   case LCD0:
204:                       row = 0x00;
01DC  0EFF     MOVLW 0xFF
01DE  6AE3     CLRF 0xFE3, ACCESS
205:                       break;
01E0  D016     BRA 0x20E
206:                   default:
207:                       row = 0x00;
208:                       break;
209:               }
01E2  0EFE     MOVLW 0xFE
01E4  50E3     MOVF 0xFE3, W, ACCESS
01E6  6E0B     MOVWF 0xB, ACCESS
01E8  6A0C     CLRF 0xC, ACCESS
01EA  500C     MOVF 0xC, W, ACCESS
01EC  0A00     XORLW 0x0
01EE  A4D8     BTFSS 0xFD8, 2, ACCESS
01F0  D7F5     BRA 0x1DC
01F2  500B     MOVF 0xB, W, ACCESS
01F4  0A00     XORLW 0x0
01F6  B4D8     BTFSC 0xFD8, 2, ACCESS
01F8  D7F1     BRA 0x1DC
01FA  0A01     XORLW 0x1
01FC  B4D8     BTFSC 0xFD8, 2, ACCESS
01FE  D7DE     BRA 0x1BC
0200  0A03     XORLW 0x3
0202  B4D8     BTFSC 0xFD8, 2, ACCESS
0204  D7DF     BRA 0x1C4
0206  0A01     XORLW 0x1
0208  B4D8     BTFSC 0xFD8, 2, ACCESS
020A  D7E1     BRA 0x1CE
020C  D7E7     BRA 0x1DC
210:           
211:           #ifdef USE_LCD_DMA
212:               send_lcd_pos_dma(row + c);
020E  0EFD     MOVLW 0xFD
0210  0061     MOVFFL PLUSW1, 0x50C
0212  F38C     NOP
0214  F50C     NOP
0216  0EFF     MOVLW 0xFF
0218  50E3     MOVF 0xFE3, W, ACCESS
021A  240C     ADDWF 0xC, W, ACCESS
021C  6EE6     MOVWF 0xFE6, ACCESS
021E  EC06     CALL 0xE0C, 0
0220  F007     NOP
213:           #else
214:               send_lcd_cmd(0x45);
215:               send_lcd_data(row + c);
216:           #endif
217:               can_fd_lcd_mirror(r, strPtr);
0222  0EFB     MOVLW 0xFB
0224  C4E3     MOVFF PLUSW1, POSTINC1
0226  F4E6     NOP
0228  C4E3     MOVFF PLUSW1, POSTINC1
022A  F4E6     NOP
022C  0EFC     MOVLW 0xFC
022E  50E3     MOVF 0xFE3, W, ACCESS
0230  6EE6     MOVWF 0xFE6, ACCESS
0232  EC00     CALL 0x1F400, 0
0234  F0FA     NOP
218:               eaDogM_WriteString(strPtr);
0236  0EFB     MOVLW 0xFB
0238  C4E3     MOVFF PLUSW1, POSTINC1
023A  F4E6     NOP
023C  C4E3     MOVFF PLUSW1, POSTINC1
023E  F4E6     NOP
0240  EC73     CALL 0x6E6, 0
0242  F003     NOP
219:           }
0244  0EFB     MOVLW 0xFB
0244  0EFB     MOVLW 0xFB
0244  0EFB     MOVLW 0xFB
0244  0EFB     MOVLW 0xFB
0244  0EFB     MOVLW 0xFB
220:           
221:           void eaDogM_WriteIntAtPos(const uint8_t r, const uint8_t c, const uint8_t i) {
222:           
223:           }
224:           
225:           void eaDogM_SetPos(const uint8_t r, const uint8_t c) {
226:           
227:           }
228:           
229:           void eaDogM_ClearRow(const uint8_t r) {
230:           
231:           }
232:           
233:           void eaDogM_WriteByteToCGRAM(const uint8_t ndx, const uint8_t data) {
234:           
235:           }
236:           
237:           #else
238:           #endif
239:           
240:           void eaDogM_WriteCommand(const uint8_t cmd) {
241:           #ifdef USE_LCD_DMA
242:               send_lcd_cmd_dma(cmd);
243:           #else
244:               send_lcd_cmd(cmd);
245:           #endif
246:           }
247:           
248:           void eaDogM_WriteChr(const int8_t value) {
249:           #ifdef USE_LCD_DMA
250:               send_lcd_data_dma((uint8_t) value);
251:           #else
252:               send_lcd_data((uint8_t) value);
253:           #endif
254:           }
255:           
256:           /*
257:            * Trigger the SPI DMA transfer to the LCD display
258:            */
259:           void start_lcd(void) {
260:           #ifdef USE_LCD_DMA
261:               DMA1_StartTransferWithTrigger();
274C  EC87     CALL 0x270E, 0
274E  F013     NOP
262:           #endif
263:           }
2750  0012     RETURN 0
264:           
265:           void wait_lcd_set(void) {
266:               spi_link.LCD_DATA = true;
2746  0106     MOVLB 0x6
2748  870F     BSF 0xF, 3, BANKED
267:           }
274A  0012     RETURN 0
268:           
269:           bool wait_lcd_check(void) {
270:               return spi_link.LCD_DATA;
271:           }
272:           
273:           void wait_lcd_done(void) {
274:           #ifdef USE_LCD_DMA
275:               while (spi_link.LCD_DATA);
2682  0106     MOVLB 0x6
2684  B70F     BTFSC 0xF, 3, BANKED
2686  D7FD     BRA wait_lcd_done
276:               while (!SPI1STATUSbits.TXBE);
2688  0100     MOVLB 0x0
268A  AB87     BTFSS SPI1STATUS, 5, BANKED
268C  D7FD     BRA 0x2688
277:               MLED_SetLow();
268E  92BF     BCF 0xFBF, 1, ACCESS
278:           #endif
279:           }
2690  0012     RETURN 0
280:           
281:           /*
282:            * in DMA mode this is a ISR that runs when the source count is complete
283:            */
284:           void clear_lcd_done(void) {
285:               INT_TRACE; // GPIO interrupt scope trace
202C  ACBF     BTFSS 0xFBF, 6, ACCESS
202E  D002     BRA 0x2034
2030  0E01     MOVLW 0x1
2032  D001     BRA 0x2036
2034  0E00     MOVLW 0x0
2036  0AFF     XORLW 0xFF
2038  6E0C     MOVWF 0xC, ACCESS
203A  3A0C     SWAPF 0xC, F, ACCESS
203C  460C     RLNCF 0xC, F, ACCESS
203E  460C     RLNCF 0xC, F, ACCESS
2040  50BF     MOVF 0xFBF, W, ACCESS
2042  180C     XORWF 0xC, W, ACCESS
2044  0BBF     ANDLW 0xBF
2046  180C     XORWF 0xC, W, ACCESS
2048  6EBF     MOVWF 0xFBF, ACCESS
286:               spi_link.LCD_DATA = false;
204A  0106     MOVLB 0x6
204C  970F     BCF 0xF, 3, BANKED
287:           }
1980  C4FA     MOVFF PCLATH, __pcstackBANK9
204E  0012     RETURN 0
288:           
289:           void spi_rec_done(void) {
290:           #ifdef USE_LCD_DMA
291:           #endif
292:           }
293:           
294:           /*
295:            * SPI buffer overrun ISR
296:            */
297:           static void spi_byte(void) {
298:               INT_TRACE; // GPIO interrupt scope trace
1A30  ACBF     BTFSS 0xFBF, 6, ACCESS
1A32  D002     BRA 0x1A38
1A34  0E01     MOVLW 0x1
1A36  D001     BRA 0x1A3A
1A38  0E00     MOVLW 0x0
1A3A  0AFF     XORLW 0xFF
1A3C  6E0C     MOVWF 0xC, ACCESS
1A3E  3A0C     SWAPF 0xC, F, ACCESS
1A40  460C     RLNCF 0xC, F, ACCESS
1A42  460C     RLNCF 0xC, F, ACCESS
1A44  50BF     MOVF 0xFBF, W, ACCESS
1A46  180C     XORWF 0xC, W, ACCESS
1A48  0BBF     ANDLW 0xBF
1A4A  180C     XORWF 0xC, W, ACCESS
1A4C  6EBF     MOVWF 0xFBF, ACCESS
299:               MLED_Toggle();
1A4E  A2BF     BTFSS 0xFBF, 1, ACCESS
1A50  D002     BRA 0x1A56
1A52  0E01     MOVLW 0x1
1A54  D001     BRA 0x1A58
1A56  0E00     MOVLW 0x0
1A58  0AFF     XORLW 0xFF
1A5A  6E0C     MOVWF 0xC, ACCESS
1A5C  460C     RLNCF 0xC, F, ACCESS
1A5E  50BF     MOVF 0xFBF, W, ACCESS
1A60  180C     XORWF 0xC, W, ACCESS
1A62  0BFD     ANDLW 0xFD
1A64  180C     XORWF 0xC, W, ACCESS
1A66  6EBF     MOVWF 0xFBF, ACCESS
300:           }
1A68  0012     RETURN 0
301:           
302:           /*
303:            * auto scrolls up the string on the display
304:            */
305:           char * eaDogM_Scroll_String(char *strPtr) {
306:               scroll_lock = true;
1FF62  0E01     MOVLW 0x1
1FF64  6E29     MOVWF 0x29, ACCESS
307:               memcpy((void *) &Sstr[4][0], &Sstr[0][0], 20); // move top line to old line buffer
1FF66  0E14     MOVLW 0x14
1FF68  6EE6     MOVWF 0xFE6, ACCESS
1FF6A  0E00     MOVLW 0x0
1FF6C  6EE6     MOVWF 0xFE6, ACCESS
1FF6E  0E40     MOVLW 0x40
1FF70  6EE6     MOVWF 0xFE6, ACCESS
1FF72  0E0D     MOVLW 0xD
1FF74  6EE6     MOVWF 0xFE6, ACCESS
1FF76  0E94     MOVLW 0x94
1FF78  6EE6     MOVWF 0xFE6, ACCESS
1FF7A  0E0D     MOVLW 0xD
1FF7C  6EE6     MOVWF 0xFE6, ACCESS
1FF7E  EC81     CALL 0x1E502, 0
1FF80  F0F2     NOP
308:               memcpy((void *) &Sstr[0][0], &Sstr[1][0], 20);
1FF82  0E14     MOVLW 0x14
1FF84  6EE6     MOVWF 0xFE6, ACCESS
1FF86  0E00     MOVLW 0x0
1FF88  6EE6     MOVWF 0xFE6, ACCESS
1FF8A  0E55     MOVLW 0x55
1FF8C  6EE6     MOVWF 0xFE6, ACCESS
1FF8E  0E0D     MOVLW 0xD
1FF90  6EE6     MOVWF 0xFE6, ACCESS
1FF92  0E40     MOVLW 0x40
1FF94  6EE6     MOVWF 0xFE6, ACCESS
1FF96  0E0D     MOVLW 0xD
1FF98  6EE6     MOVWF 0xFE6, ACCESS
1FF9A  EC81     CALL 0x1E502, 0
1FF9C  F0F2     NOP
309:               memcpy((void *) &Sstr[1][0], &Sstr[2][0], 20);
1FF9E  0E14     MOVLW 0x14
1FFA0  6EE6     MOVWF 0xFE6, ACCESS
1FFA2  0E00     MOVLW 0x0
1FFA4  6EE6     MOVWF 0xFE6, ACCESS
1FFA6  0E6A     MOVLW 0x6A
1FFA8  6EE6     MOVWF 0xFE6, ACCESS
1FFAA  0E0D     MOVLW 0xD
1FFAC  6EE6     MOVWF 0xFE6, ACCESS
1FFAE  0E55     MOVLW 0x55
1FFB0  6EE6     MOVWF 0xFE6, ACCESS
1FFB2  0E0D     MOVLW 0xD
1FFB4  6EE6     MOVWF 0xFE6, ACCESS
1FFB6  EC81     CALL 0x1E502, 0
1FFB8  F0F2     NOP
310:               memcpy((void *) &Sstr[2][0], &Sstr[3][0], 20);
1FFBA  0E14     MOVLW 0x14
1FFBC  6EE6     MOVWF 0xFE6, ACCESS
1FFBE  0E00     MOVLW 0x0
1FFC0  6EE6     MOVWF 0xFE6, ACCESS
1FFC2  0E7F     MOVLW 0x7F
1FFC4  6EE6     MOVWF 0xFE6, ACCESS
1FFC6  0E0D     MOVLW 0xD
1FFC8  6EE6     MOVWF 0xFE6, ACCESS
1FFCA  0E6A     MOVLW 0x6A
1FFCC  6EE6     MOVWF 0xFE6, ACCESS
1FFCE  0E0D     MOVLW 0xD
1FFD0  6EE6     MOVWF 0xFE6, ACCESS
1FFD2  EC81     CALL 0x1E502, 0
1FFD4  F0F2     NOP
311:               memcpy((void *) &Sstr[3][0], strPtr, 20); // place new text on the bottom line
1FFD6  0E14     MOVLW 0x14
1FFD8  6EE6     MOVWF 0xFE6, ACCESS
1FFDA  0E00     MOVLW 0x0
1FFDC  6EE6     MOVWF 0xFE6, ACCESS
1FFDE  0EFC     MOVLW 0xFC
1FFE0  C4E3     MOVFF PLUSW1, POSTINC1
1FFE2  F4E6     NOP
1FFE4  C4E3     MOVFF PLUSW1, POSTINC1
1FFE6  F4E6     NOP
1FFE8  0E7F     MOVLW 0x7F
1FFEA  6EE6     MOVWF 0xFE6, ACCESS
1FFEC  0E0D     MOVLW 0xD
1FFEE  6EE6     MOVWF 0xFE6, ACCESS
1FFF0  EC81     CALL 0x1E502, 0
1FFF2  F0F2     NOP
312:               scroll_line_pos = 4;
1FFF4  0E04     MOVLW 0x4
1FFF6  6E4D     MOVWF 0x4D, ACCESS
313:               return &Sstr[4][0];
314:           }
1FFF8  52E5     MOVF 0xFE5, F, ACCESS
1FFFA  52E5     MOVF 0xFE5, F, ACCESS
1FFFA  52E5     MOVF 0xFE5, F, ACCESS
315:           
316:           /*
317:            * mainline info scroll updater, should run a ~1 second ticks
318:            */
319:           void eaDogM_Scroll_Task(void) {
320:               if (!scroll_lock) {
15B2  5029     MOVF 0x29, W, ACCESS
15B4  B4D8     BTFSC 0xFD8, 2, ACCESS
15B6  0012     RETURN 0
321:                   return;
322:               }
323:           
324:               if (scroll_line_pos == 0) { // wait for last line display time period
15B8  504D     MOVF 0x4D, W, ACCESS
15BA  A4D8     BTFSS 0xFD8, 2, ACCESS
15BC  D004     BRA 0x15C6
325:                   scroll_lock = false;
15BE  6A29     CLRF 0x29, ACCESS
326:                   scroll_line_pos = 4;
15C0  0E04     MOVLW 0x4
15C2  6E4D     MOVWF 0x4D, ACCESS
15C4  0012     RETURN 0
327:                   return;
328:               }
329:           
330:               scroll_lock = false;
15C6  6A29     CLRF 0x29, ACCESS
331:               --scroll_line_pos;
15C8  064D     DECF 0x4D, F, ACCESS
332:               eaDogM_WriteStringAtPos(scroll_line_pos, 0, &Sstr[scroll_line_pos][0]);
15CA  504D     MOVF 0x4D, W, ACCESS
15CC  0D15     MULLW 0x15
15CE  0E40     MOVLW 0x40
15D0  24F3     ADDWF 0xFF3, W, ACCESS
15D2  6E0B     MOVWF 0xB, ACCESS
15D4  0E0D     MOVLW 0xD
15D6  20F4     ADDWFC 0xFF4, W, ACCESS
15D8  6E0C     MOVWF 0xC, ACCESS
15DA  0061     MOVFFL wtemp5, POSTINC1
15DC  F42C     NOP
15DE  F4E6     NOP
15E0  0061     MOVFFL 0x50C, POSTINC1
15E2  F430     NOP
15E4  F4E6     NOP
15E6  0E00     MOVLW 0x0
15E8  6EE6     MOVWF 0xFE6, ACCESS
15EA  504D     MOVF 0x4D, W, ACCESS
15EC  6EE6     MOVWF 0xFE6, ACCESS
15EE  ECD9     CALL 0x1B2, 0
15F0  F000     NOP
333:               scroll_lock = true;
15F2  0E01     MOVLW 0x1
15F4  6E29     MOVWF 0x29, ACCESS
334:           
335:           }
15F6  0012     RETURN 0
---  /public/Q84vtouch/canfd.c  -------------------------------------------------------------------------
1:             #include "canfd.h"
2:             
3:             CAN_MSG_OBJ msg[CANFD_NBUF];
4:             volatile uint8_t rxMsgData[CAN_REC_BUFFERS][CANFD_BYTES] = {
5:             	"     no data        ",
6:             	" no_data            ",
7:             	" no info1           ",
8:             	" no info2           ",
9:             };
10:            
11:            volatile can_rec_count_t can_rec_count = {
12:            	.rec_count = 0,
13:            	.rec_flag = false,
14:            };
15:            
16:            /*
17:             * 16-bit word to 2 bytes
18:             */
19:            union {
20:            	uint16_t Word;
21:            
22:            	struct {
23:            		uint8_t Byte1 : 8;
24:            		uint8_t Byte2 : 8;
25:            	} structBytes;
26:            } myVar;
27:            
28:            static EB_data *EB = &EBD;
29:            
30:            /*
31:             * process the FIFO data into msg structure
32:             */
33:            void Can1FIFO1NotEmptyHandler(void)
19DD6  52E6     MOVF 0xFE6, F, ACCESS
34:            {
35:            	uint8_t tries = 0;
19DD8  0EFF     MOVLW 0xFF
19DDA  6AE3     CLRF 0xFE3, ACCESS
36:            	static uint8_t half = CAN_LOW_BUF;
37:            
38:            	INT_TRACE; // GPIO interrupt scope trace
19DDC  ACBF     BTFSS 0xFBF, 6, ACCESS
19DDE  D002     BRA 0x9DE4
19DE0  0E01     MOVLW 0x1
19DE2  D001     BRA 0x9DE6
19DE4  0E00     MOVLW 0x0
19DE6  0AFF     XORLW 0xFF
19DE8  6E0C     MOVWF 0xC, ACCESS
19DEA  3A0C     SWAPF 0xC, F, ACCESS
19DEC  460C     RLNCF 0xC, F, ACCESS
19DEE  460C     RLNCF 0xC, F, ACCESS
19DF0  50BF     MOVF 0xFBF, W, ACCESS
19DF2  180C     XORWF 0xC, W, ACCESS
19DF4  0BBF     ANDLW 0xBF
19DF6  180C     XORWF 0xC, W, ACCESS
19DF8  6EBF     MOVWF 0xFBF, ACCESS
39:            #ifdef CAN_REMOTE	
40:            	char s_buffer[LCD_BUF_SIZ];
41:            #endif
42:            
43:            	while (true) {
44:            		can_rec_count.rec_count++;
19DFA  0E01     MOVLW 0x1
19DFC  0107     MOVLB 0x7
19DFE  2720     ADDWF 0x20, F, BANKED
19E00  0E00     MOVLW 0x0
19E02  2321     ADDWFC 0x21, F, BANKED
19E04  2322     ADDWFC 0x22, F, BANKED
19E06  2323     ADDWFC 0x23, F, BANKED
45:            		if (CAN1_ReceiveFrom(FIFO1, &msg[half])) //receive the message
19E08  5028     MOVF 0x28, W, ACCESS
19E0A  0D07     MULLW 0x7
19E0C  0E75     MOVLW 0x75
19E0E  24F3     ADDWF 0xFF3, W, ACCESS
19E10  6E0B     MOVWF 0xB, ACCESS
19E12  0E07     MOVLW 0x7
19E14  20F4     ADDWFC 0xFF4, W, ACCESS
19E16  6E0C     MOVWF 0xC, ACCESS
19E18  0061     MOVFFL wtemp5, POSTINC1
19E1A  F42C     NOP
19E1C  F4E6     NOP
19E1E  0061     MOVFFL 0x50C, POSTINC1
19E20  F430     NOP
19E22  F4E6     NOP
19E24  0E01     MOVLW 0x1
19E26  6EE6     MOVWF 0xFE6, ACCESS
19E28  ECA6     CALL 0xB4C, 0
19E2A  F005     NOP
19E2C  5001     MOVF __ptext283, W, ACCESS
19E2E  B4D8     BTFSC 0xFD8, 2, ACCESS
19E30  D17D     BRA 0xA12C
46:            		{
47:            			memcpy(&msg[MIRR0R_BUF], &msg[half], sizeof(CAN_MSG_OBJ));
19E32  0E07     MOVLW 0x7
19E34  6EE6     MOVWF 0xFE6, ACCESS
19E36  0E00     MOVLW 0x0
19E38  6EE6     MOVWF 0xFE6, ACCESS
19E3A  5028     MOVF 0x28, W, ACCESS
19E3C  0D07     MULLW 0x7
19E3E  0E75     MOVLW 0x75
19E40  24F3     ADDWF 0xFF3, W, ACCESS
19E42  6E0B     MOVWF 0xB, ACCESS
19E44  0E07     MOVLW 0x7
19E46  20F4     ADDWFC 0xFF4, W, ACCESS
19E48  6E0C     MOVWF 0xC, ACCESS
19E4A  0061     MOVFFL wtemp5, POSTINC1
19E4C  F42C     NOP
19E4E  F4E6     NOP
19E50  0061     MOVFFL 0x50C, POSTINC1
19E52  F430     NOP
19E54  F4E6     NOP
19E56  0E83     MOVLW 0x83
19E58  6EE6     MOVWF 0xFE6, ACCESS
19E5A  0E07     MOVLW 0x7
19E5C  6EE6     MOVWF 0xFE6, ACCESS
19E5E  EC81     CALL 0x1E502, 0
19E60  F0F2     NOP
48:            			if ((msg[half].msgId & 0xf) == EMON_SL || (msg[half].msgId & 0xf) == EMON_SU) {
19E62  5028     MOVF 0x28, W, ACCESS
19E64  0D07     MULLW 0x7
19E66  0E75     MOVLW 0x75
19E68  24F3     ADDWF 0xFF3, W, ACCESS
19E6A  6ED9     MOVWF 0xFD9, ACCESS
19E6C  0E07     MOVLW 0x7
19E6E  20F4     ADDWFC 0xFF4, W, ACCESS
19E70  6EDA     MOVWF __end_of_UART2_tx_vect_isr, ACCESS
19E72  50DF     MOVF 0xFDF, W, ACCESS
19E74  0B0F     ANDLW 0xF
19E76  0A02     XORLW 0x2
19E78  B4D8     BTFSC 0xFD8, 2, ACCESS
19E7A  D00D     BRA 0x9E96
19E7C  5028     MOVF 0x28, W, ACCESS
19E7E  0D07     MULLW 0x7
19E80  0E75     MOVLW 0x75
19E82  24F3     ADDWF 0xFF3, W, ACCESS
19E84  6ED9     MOVWF 0xFD9, ACCESS
19E86  0E07     MOVLW 0x7
19E88  20F4     ADDWFC 0xFF4, W, ACCESS
19E8A  6EDA     MOVWF __end_of_UART2_tx_vect_isr, ACCESS
19E8C  50DF     MOVF 0xFDF, W, ACCESS
19E8E  0B0F     ANDLW 0xF
19E90  0A03     XORLW 0x3
19E92  A4D8     BTFSS 0xFD8, 2, ACCESS
19E94  D04A     BRA 0x9F2A
49:            				memcpy((void *) &rxMsgData[half][0], msg[half].data, CANFD_BYTES);
19E96  0E40     MOVLW 0x40
19E98  6EE6     MOVWF 0xFE6, ACCESS
19E9A  0E00     MOVLW 0x0
19E9C  6EE6     MOVWF 0xFE6, ACCESS
19E9E  5028     MOVF 0x28, W, ACCESS
19EA0  0D07     MULLW 0x7
19EA2  0E7A     MOVLW 0x7A
19EA4  24F3     ADDWF 0xFF3, W, ACCESS
19EA6  6ED9     MOVWF 0xFD9, ACCESS
19EA8  0E07     MOVLW 0x7
19EAA  20F4     ADDWFC 0xFF4, W, ACCESS
19EAC  6EDA     MOVWF __end_of_UART2_tx_vect_isr, ACCESS
19EAE  0061     MOVFFL POSTINC2, wtemp5
19EB0  F378     NOP
19EB2  F50B     NOP
19EB4  0061     MOVFFL POSTDEC2, 0x50C
19EB6  F374     NOP
19EB8  F50C     NOP
19EBA  0061     MOVFFL wtemp5, POSTINC1
19EBC  F42C     NOP
19EBE  F4E6     NOP
19EC0  0061     MOVFFL 0x50C, POSTINC1
19EC2  F430     NOP
19EC4  F4E6     NOP
19EC6  5028     MOVF 0x28, W, ACCESS
19EC8  0D40     MULLW 0x40
19ECA  0E00     MOVLW 0x0
19ECC  24F3     ADDWF 0xFF3, W, ACCESS
19ECE  6E0B     MOVWF 0xB, ACCESS
19ED0  0E11     MOVLW 0x11
19ED2  20F4     ADDWFC 0xFF4, W, ACCESS
19ED4  6E0C     MOVWF 0xC, ACCESS
19ED6  0061     MOVFFL wtemp5, POSTINC1
19ED8  F42C     NOP
19EDA  F4E6     NOP
19EDC  0061     MOVFFL 0x50C, POSTINC1
19EDE  F430     NOP
19EE0  F4E6     NOP
19EE2  EC81     CALL 0x1E502, 0
19EE4  F0F2     NOP
50:            				if ((msg[half].msgId & 0xf) == EMON_SL) {
19EE6  5028     MOVF 0x28, W, ACCESS
19EE8  0D07     MULLW 0x7
19EEA  0E75     MOVLW 0x75
19EEC  24F3     ADDWF 0xFF3, W, ACCESS
19EEE  6ED9     MOVWF 0xFD9, ACCESS
19EF0  0E07     MOVLW 0x7
19EF2  20F4     ADDWFC 0xFF4, W, ACCESS
19EF4  6EDA     MOVWF __end_of_UART2_tx_vect_isr, ACCESS
19EF6  50DF     MOVF 0xFDF, W, ACCESS
19EF8  0B0F     ANDLW 0xF
19EFA  0A02     XORLW 0x2
19EFC  A4D8     BTFSS 0xFD8, 2, ACCESS
19EFE  D003     BRA 0x9F06
51:            					half = CAN_HIGH_BUF;
19F00  0E01     MOVLW 0x1
19F02  6E28     MOVWF 0x28, ACCESS
52:            					break;
19F04  D11C     BRA 0xA13E
53:            				}
54:            				if ((msg[half].msgId & 0xf) == EMON_SU) {
19F06  5028     MOVF 0x28, W, ACCESS
19F08  0D07     MULLW 0x7
19F0A  0E75     MOVLW 0x75
19F0C  24F3     ADDWF 0xFF3, W, ACCESS
19F0E  6ED9     MOVWF 0xFD9, ACCESS
19F10  0E07     MOVLW 0x7
19F12  20F4     ADDWFC 0xFF4, W, ACCESS
19F14  6EDA     MOVWF __end_of_UART2_tx_vect_isr, ACCESS
19F16  50DF     MOVF 0xFDF, W, ACCESS
19F18  0B0F     ANDLW 0xF
19F1A  0A03     XORLW 0x3
19F1C  A4D8     BTFSS 0xFD8, 2, ACCESS
19F1E  D005     BRA 0x9F2A
55:            					half = CAN_LOW_BUF;
19F20  6A28     CLRF 0x28, ACCESS
56:            					can_rec_count.rec_flag = true;
19F22  0E01     MOVLW 0x1
19F24  0107     MOVLB 0x7
19F26  6F24     MOVWF 0x24, BANKED
57:            					break;
19F28  D10A     BRA 0xA13E
58:            				}
59:            			}
60:            			if ((msg[half].msgId & 0xf) == EMON_CO) {
19F2A  5028     MOVF 0x28, W, ACCESS
19F2C  0D07     MULLW 0x7
19F2E  0E75     MOVLW 0x75
19F30  24F3     ADDWF 0xFF3, W, ACCESS
19F32  6ED9     MOVWF 0xFD9, ACCESS
19F34  0E07     MOVLW 0x7
19F36  20F4     ADDWFC 0xFF4, W, ACCESS
19F38  6EDA     MOVWF __end_of_UART2_tx_vect_isr, ACCESS
19F3A  50DF     MOVF 0xFDF, W, ACCESS
19F3C  0B0F     ANDLW 0xF
19F3E  0A0C     XORLW 0xC
19F40  A4D8     BTFSS 0xFD8, 2, ACCESS
19F42  D01F     BRA 0x9F82
61:            				memcpy((void *) &rxMsgData[CAN_INFO_BUF][0], msg[half].data, CANFD_BYTES);
19F44  0E40     MOVLW 0x40
19F46  6EE6     MOVWF 0xFE6, ACCESS
19F48  0E00     MOVLW 0x0
19F4A  6EE6     MOVWF 0xFE6, ACCESS
19F4C  5028     MOVF 0x28, W, ACCESS
19F4E  0D07     MULLW 0x7
19F50  0E7A     MOVLW 0x7A
19F52  24F3     ADDWF 0xFF3, W, ACCESS
19F54  6ED9     MOVWF 0xFD9, ACCESS
19F56  0E07     MOVLW 0x7
19F58  20F4     ADDWFC 0xFF4, W, ACCESS
19F5A  6EDA     MOVWF __end_of_UART2_tx_vect_isr, ACCESS
19F5C  0061     MOVFFL POSTINC2, wtemp5
19F5E  F378     NOP
19F60  F50B     NOP
19F62  0061     MOVFFL POSTDEC2, 0x50C
19F64  F374     NOP
19F66  F50C     NOP
19F68  0061     MOVFFL wtemp5, POSTINC1
19F6A  F42C     NOP
19F6C  F4E6     NOP
19F6E  0061     MOVFFL 0x50C, POSTINC1
19F70  F430     NOP
19F72  F4E6     NOP
19F74  0E80     MOVLW 0x80
19F76  6EE6     MOVWF 0xFE6, ACCESS
19F78  0E11     MOVLW 0x11
19F7A  6EE6     MOVWF 0xFE6, ACCESS
19F7C  EC81     CALL 0x1E502, 0
19F7E  F0F2     NOP
62:            				break;
19F80  D0DE     BRA 0xA13E
63:            			}
64:            			if ((msg[half].msgId & 0xf) == EMON_ER) {
19F82  5028     MOVF 0x28, W, ACCESS
19F84  0D07     MULLW 0x7
19F86  0E75     MOVLW 0x75
19F88  24F3     ADDWF 0xFF3, W, ACCESS
19F8A  6ED9     MOVWF 0xFD9, ACCESS
19F8C  0E07     MOVLW 0x7
19F8E  20F4     ADDWFC 0xFF4, W, ACCESS
19F90  6EDA     MOVWF __end_of_UART2_tx_vect_isr, ACCESS
19F92  50DF     MOVF 0xFDF, W, ACCESS
19F94  0B0F     ANDLW 0xF
19F96  0A0F     XORLW 0xF
19F98  A4D8     BTFSS 0xFD8, 2, ACCESS
19F9A  D01F     BRA 0x9FDA
65:            				memcpy((void *) &rxMsgData[CAN_ERROR_BUF][0], msg[half].data, CANFD_BYTES);
19F9C  0E40     MOVLW 0x40
19F9E  6EE6     MOVWF 0xFE6, ACCESS
19FA0  0E00     MOVLW 0x0
19FA2  6EE6     MOVWF 0xFE6, ACCESS
19FA4  5028     MOVF 0x28, W, ACCESS
19FA6  0D07     MULLW 0x7
19FA8  0E7A     MOVLW 0x7A
19FAA  24F3     ADDWF 0xFF3, W, ACCESS
19FAC  6ED9     MOVWF 0xFD9, ACCESS
19FAE  0E07     MOVLW 0x7
19FB0  20F4     ADDWFC 0xFF4, W, ACCESS
19FB2  6EDA     MOVWF __end_of_UART2_tx_vect_isr, ACCESS
19FB4  0061     MOVFFL POSTINC2, wtemp5
19FB6  F378     NOP
19FB8  F50B     NOP
19FBA  0061     MOVFFL POSTDEC2, 0x50C
19FBC  F374     NOP
19FBE  F50C     NOP
19FC0  0061     MOVFFL wtemp5, POSTINC1
19FC2  F42C     NOP
19FC4  F4E6     NOP
19FC6  0061     MOVFFL 0x50C, POSTINC1
19FC8  F430     NOP
19FCA  F4E6     NOP
19FCC  0EC0     MOVLW 0xC0
19FCE  6EE6     MOVWF 0xFE6, ACCESS
19FD0  0E11     MOVLW 0x11
19FD2  6EE6     MOVWF 0xFE6, ACCESS
19FD4  EC81     CALL 0x1E502, 0
19FD6  F0F2     NOP
66:            				break;
19FD8  D0B2     BRA 0xA13E
67:            			}
68:            			if ((msg[half].msgId & 0xf) == EMON_TM) {
19FDA  5028     MOVF 0x28, W, ACCESS
19FDC  0D07     MULLW 0x7
19FDE  0E75     MOVLW 0x75
19FE0  24F3     ADDWF 0xFF3, W, ACCESS
19FE2  6ED9     MOVWF 0xFD9, ACCESS
19FE4  0E07     MOVLW 0x7
19FE6  20F4     ADDWFC 0xFF4, W, ACCESS
19FE8  6EDA     MOVWF __end_of_UART2_tx_vect_isr, ACCESS
19FEA  50DF     MOVF 0xFDF, W, ACCESS
19FEC  0B0F     ANDLW 0xF
19FEE  0A0A     XORLW 0xA
19FF0  A4D8     BTFSS 0xFD8, 2, ACCESS
19FF2  D09C     BRA 0xA12C
69:            				memcpy((void *) &can_timer, msg[half].data, sizeof(time_t)); // load 32-bit linux time from canbus packet
19FF4  0E04     MOVLW 0x4
19FF6  6EE6     MOVWF 0xFE6, ACCESS
19FF8  0E00     MOVLW 0x0
19FFA  6EE6     MOVWF 0xFE6, ACCESS
19FFC  5028     MOVF 0x28, W, ACCESS
19FFE  0D07     MULLW 0x7
1A000  0E7A     MOVLW 0x7A
1A002  24F3     ADDWF 0xFF3, W, ACCESS
1A004  6ED9     MOVWF 0xFD9, ACCESS
1A006  0E07     MOVLW 0x7
1A008  20F4     ADDWFC 0xFF4, W, ACCESS
1A00A  6EDA     MOVWF __end_of_UART2_tx_vect_isr, ACCESS
1A00C  0061     MOVFFL POSTINC2, wtemp5
1A00E  F378     NOP
1A010  F50B     NOP
1A012  0061     MOVFFL POSTDEC2, 0x50C
1A014  F374     NOP
1A016  F50C     NOP
1A018  0061     MOVFFL wtemp5, POSTINC1
1A01A  F42C     NOP
1A01C  F4E6     NOP
1A01E  0061     MOVFFL 0x50C, POSTINC1
1A020  F430     NOP
1A022  F4E6     NOP
1A024  0EFA     MOVLW 0xFA
1A026  6EE6     MOVWF 0xFE6, ACCESS
1A028  0E06     MOVLW 0x6
1A02A  6EE6     MOVWF 0xFE6, ACCESS
1A02C  EC81     CALL 0x1E502, 0
1A02E  F0F2     NOP
70:            				EB->fm80_time = can_timer; // save remote Unix time from canbus packets
1A030  0105     MOVLB 0x5
1A032  EE20     LFSR 2, 0x3E
1A034  F03E     NOP
1A036  51AB     MOVF 0xAB, W, BANKED
1A038  26D9     ADDWF 0xFD9, F, ACCESS
1A03A  51AC     MOVF ACTCON, W, BANKED
1A03C  22DA     ADDWFC __end_of_UART2_tx_vect_isr, F, ACCESS
1A03E  C6FA     MOVFF can_timer, POSTINC2
1A040  F4DE     NOP
1A042  C6FB     MOVFF 0x6FB, POSTINC2
1A044  F4DE     NOP
1A046  C6FC     MOVFF 0x6FC, POSTINC2
1A048  F4DE     NOP
1A04A  C6FD     MOVFF 0x6FD, POSTINC2
1A04C  F4DE     NOP
71:            				can_newtime = localtime(&can_timer);
1A04E  0EFA     MOVLW 0xFA
1A050  6EE6     MOVWF 0xFE6, ACCESS
1A052  0E06     MOVLW 0x6
1A054  6EE6     MOVWF 0xFE6, ACCESS
1A056  ECC1     CALL 0x2582, 0
1A058  F012     NOP
1A05A  0061     MOVFFL ltemp0, can_newtime
1A05C  F404     NOP
1A05E  F5CD     NOP
1A060  0061     MOVFFL ttemp5, 0x5CE
1A062  F408     NOP
1A064  F5CE     NOP
72:            				update_time(can_newtime, EB);
1A066  C5AB     MOVFF EB, POSTINC1
1A068  F4E6     NOP
1A06A  C5AC     MOVFF 0x5AC, POSTINC1
1A06C  F4E6     NOP
1A06E  C5CD     MOVFF can_newtime, POSTINC1
1A070  F4E6     NOP
1A072  C5CE     MOVFF 0x5CE, POSTINC1
1A074  F4E6     NOP
1A076  EC11     CALL 0x1C622, 0
1A078  F0E3     NOP
73:            				/*
74:            				 * update the FM80 time and data message values with a proper checksum
75:            				 * this is sent to the FM80 but am unsure if it changes anything on the device
76:            				 */
77:            				myVar.Word = EB->time;
1A07A  0105     MOVLB 0x5
1A07C  EE20     LFSR 2, 0x36
1A07E  F036     NOP
1A080  51AB     MOVF 0xAB, W, BANKED
1A082  26D9     ADDWF 0xFD9, F, ACCESS
1A084  51AC     MOVF ACTCON, W, BANKED
1A086  22DA     ADDWFC __end_of_UART2_tx_vect_isr, F, ACCESS
1A088  C4DE     MOVFF POSTINC2, myVar
1A08A  F525     NOP
1A08C  C4DD     MOVFF POSTDEC2, 0x526
1A08E  F526     NOP
78:            				cmd_time[5] = myVar.structBytes.Byte1; // store time
1A090  C525     MOVFF myVar, _ADC_Initialize
1A092  F7EE     NOP
1A094  0107     MOVLB 0x7
1A096  6BEF     CLRF DMAnDSZH, BANKED
79:            				cmd_time[4] = myVar.structBytes.Byte2;
1A098  C526     MOVFF 0x526, 0x7EC
1A09A  F7EC     NOP
1A09C  6BED     CLRF DMAnDPTRH, BANKED
80:            				myVar.Word = calc_checksum((uint8_t *) & cmd_time[1], CMD_CRC_LEN);
1A09E  0E0A     MOVLW 0xA
1A0A0  6EE6     MOVWF 0xFE6, ACCESS
1A0A2  0EE6     MOVLW 0xE6
1A0A4  6EE6     MOVWF 0xFE6, ACCESS
1A0A6  0E07     MOVLW 0x7
1A0A8  6EE6     MOVWF 0xFE6, ACCESS
1A0AA  EC2C     CALL 0x1F858, 0
1A0AC  F0FC     NOP
1A0AE  0061     MOVFFL ltemp0, myVar
1A0B0  F404     NOP
1A0B2  F525     NOP
1A0B4  0061     MOVFFL ttemp5, 0x526
1A0B6  F408     NOP
1A0B8  F526     NOP
81:            				cmd_time[7] = myVar.structBytes.Byte1; // store crc
1A0BA  C525     MOVFF myVar, 0x7F2
1A0BC  F7F2     NOP
1A0BE  0107     MOVLB 0x7
1A0C0  6BF3     CLRF DMAnSCNTH, BANKED
82:            				cmd_time[6] = myVar.structBytes.Byte2;
1A0C2  C526     MOVFF 0x526, 0x7F0
1A0C4  F7F0     NOP
1A0C6  6BF1     CLRF DMAnDSAH, BANKED
83:            				myVar.Word = EB->date;
1A0C8  0105     MOVLB 0x5
1A0CA  EE20     LFSR 2, 0x38
1A0CC  F038     NOP
1A0CE  51AB     MOVF 0xAB, W, BANKED
1A0D0  26D9     ADDWF 0xFD9, F, ACCESS
1A0D2  51AC     MOVF ACTCON, W, BANKED
1A0D4  22DA     ADDWFC __end_of_UART2_tx_vect_isr, F, ACCESS
1A0D6  C4DE     MOVFF POSTINC2, myVar
1A0D8  F525     NOP
1A0DA  C4DD     MOVFF POSTDEC2, 0x526
1A0DC  F526     NOP
84:            				cmd_date[5] = myVar.structBytes.Byte1;
1A0DE  C525     MOVFF myVar, 0x7DE
1A0E0  F7DE     NOP
1A0E2  0107     MOVLB 0x7
1A0E4  6BDF     CLRF CLCnGLS3, BANKED
85:            				cmd_date[4] = myVar.structBytes.Byte2;
1A0E6  C526     MOVFF 0x526, 0x7DC
1A0E8  F7DC     NOP
1A0EA  6BDD     CLRF CLCnGLS1, BANKED
86:            				myVar.Word = calc_checksum((uint8_t *) & cmd_date[1], CMD_CRC_LEN);
1A0EC  0E0A     MOVLW 0xA
1A0EE  6EE6     MOVWF 0xFE6, ACCESS
1A0F0  0ED6     MOVLW 0xD6
1A0F2  6EE6     MOVWF 0xFE6, ACCESS
1A0F4  0E07     MOVLW 0x7
1A0F6  6EE6     MOVWF 0xFE6, ACCESS
1A0F8  EC2C     CALL 0x1F858, 0
1A0FA  F0FC     NOP
1A0FC  0061     MOVFFL ltemp0, myVar
1A0FE  F404     NOP
1A100  F525     NOP
1A102  0061     MOVFFL ttemp5, 0x526
1A104  F408     NOP
1A106  F526     NOP
87:            				cmd_date[7] = myVar.structBytes.Byte1;
1A108  C525     MOVFF myVar, 0x7E2
1A10A  F7E2     NOP
1A10C  0107     MOVLB 0x7
1A10E  6BE3     CLRF 0xE3, BANKED
88:            				cmd_date[6] = myVar.structBytes.Byte2;
1A110  C526     MOVFF 0x526, 0x7E0
1A112  F7E0     NOP
1A114  6BE1     CLRF 0xE1, BANKED
89:            				if (B.canbus_online && B.FM80_online) {
1A116  0105     MOVLB 0x5
1A118  5171     MOVF CM1CON1, W, BANKED
1A11A  B4D8     BTFSC 0xFD8, 2, ACCESS
1A11C  D010     BRA 0xA13E
1A11E  516F     MOVF CMOUT, W, BANKED
1A120  B4D8     BTFSC 0xFD8, 2, ACCESS
1A122  D00D     BRA 0xA13E
90:            					C.tm_ok = true; // FM80 time date data valid to send flag
1A124  0E01     MOVLW 0x1
1A126  0108     MOVLB 0x8
1A128  6F51     MOVWF 0x51, BANKED
1A12A  D009     BRA 0xA13E
91:            				}
92:            				break;
93:            			}
94:            #ifdef CAN_REMOTE
95:            			if ((msg[MIRR0R_BUF].msgId & 0xf) == EMON_MR + LCD0) {
96:            				memcpy((void *) s_buffer, msg[MIRR0R_BUF].data, LCD_BUF_SIZ); // load LCD mirror packet
97:            				eaDogM_WriteStringAtPos(LCD0, 0, s_buffer);
98:            				break;
99:            			}
100:           			if ((msg[MIRR0R_BUF].msgId & 0xf) == EMON_MR + LCD1) {
101:           				memcpy((void *) s_buffer, msg[MIRR0R_BUF].data, LCD_BUF_SIZ); // load LCD mirror packet
102:           				eaDogM_WriteStringAtPos(LCD1, 0, s_buffer);
103:           				break;
104:           			}
105:           			if ((msg[MIRR0R_BUF].msgId & 0xf) == EMON_MR + LCD2) {
106:           				memcpy((void *) s_buffer, msg[MIRR0R_BUF].data, LCD_BUF_SIZ); // load LCD mirror packet
107:           				eaDogM_WriteStringAtPos(LCD2, 0, s_buffer);
108:           				break;
109:           			}
110:           			if ((msg[MIRR0R_BUF].msgId & 0xf) == EMON_MR + LCD3) {
111:           				memcpy((void *) s_buffer, msg[MIRR0R_BUF].data, LCD_BUF_SIZ); // load LCD mirror packet
112:           				eaDogM_WriteStringAtPos(LCD3, 0, s_buffer);
113:           				break;
114:           			}
115:           #endif
116:           		}
117:           		if (++tries >= CAN_RX_TRIES) {
1A12C  0EFF     MOVLW 0xFF
1A12E  2AE3     INCF 0xFE3, F, ACCESS
1A130  0EFF     MOVLW 0xFF
1A132  0061     MOVFFL PLUSW1, ltemp0
1A134  F38C     NOP
1A136  F501     NOP
1A138  0E07     MOVLW 0x7
1A13A  6401     CPFSGT __ptext283, ACCESS
1A13C  D65E     BRA 0x9DFA
118:           			break;
119:           		}
120:           	}
121:           }
1A13E  52E5     MOVF 0xFE5, F, ACCESS
1A13E  52E5     MOVF 0xFE5, F, ACCESS
122:           
123:           /*
124:            * send 64 byte CAN packets with the ASCII battery data in CSV format
125:            * EMON_SL [0..63], EMON_SU [64..127] bytes of data
126:            * ^ for ASCII start of string, ~ for end of data string
127:            * also send aux error and config packets if flagged
128:            */
129:           void can_fd_tx(void)
1B820  0E07     MOVLW 0x7
1B822  26E1     ADDWF 0xFE1, F, ACCESS
1B824  0E00     MOVLW 0x0
1B826  22E2     ADDWFC 0xFE2, F, ACCESS
130:           {
131:           	CAN_MSG_OBJ Transmission; //create the CAN message object
132:           	Transmission.field.brs = CAN_BRS_MODE; //Transmit the data bytes at data bit rate
1B828  0EFD     MOVLW 0xFD
1B82A  24E1     ADDWF 0xFE1, W, ACCESS
1B82C  6ED9     MOVWF 0xFD9, ACCESS
1B82E  0EFF     MOVLW 0xFF
1B830  20E2     ADDWFC 0xFE2, W, ACCESS
1B832  6EDA     MOVWF __end_of_UART2_tx_vect_isr, ACCESS
1B834  8EDF     BSF 0xFDF, 7, ACCESS
133:           	Transmission.field.dlc = DLC_64; // 64 data bytes
1B836  0EFD     MOVLW 0xFD
1B838  24E1     ADDWF 0xFE1, W, ACCESS
1B83A  6ED9     MOVWF 0xFD9, ACCESS
1B83C  0EFF     MOVLW 0xFF
1B83E  20E2     ADDWFC 0xFE2, W, ACCESS
1B840  6EDA     MOVWF __end_of_UART2_tx_vect_isr, ACCESS
1B842  0E3C     MOVLW 0x3C
1B844  12DF     IORWF 0xFDF, F, ACCESS
134:           	Transmission.field.formatType = CAN_FD_FORMAT; //CAN FD frames
1B846  0EFD     MOVLW 0xFD
1B848  24E1     ADDWF 0xFE1, W, ACCESS
1B84A  6ED9     MOVWF 0xFD9, ACCESS
1B84C  0EFF     MOVLW 0xFF
1B84E  20E2     ADDWFC 0xFE2, W, ACCESS
1B850  6EDA     MOVWF __end_of_UART2_tx_vect_isr, ACCESS
1B852  8CDF     BSF 0xFDF, 6, ACCESS
135:           	Transmission.field.frameType = CAN_FRAME_DATA; //Data frame
1B854  0EFD     MOVLW 0xFD
1B856  24E1     ADDWF 0xFE1, W, ACCESS
1B858  6ED9     MOVWF 0xFD9, ACCESS
1B85A  0EFF     MOVLW 0xFF
1B85C  20E2     ADDWFC 0xFE2, W, ACCESS
1B85E  6EDA     MOVWF __end_of_UART2_tx_vect_isr, ACCESS
1B860  92DF     BCF 0xFDF, 1, ACCESS
136:           	Transmission.field.idType = CAN_FRAME_EXT; //Standard ID
1B862  0EFD     MOVLW 0xFD
1B864  24E1     ADDWF 0xFE1, W, ACCESS
1B866  6ED9     MOVWF 0xFD9, ACCESS
1B868  0EFF     MOVLW 0xFF
1B86A  20E2     ADDWFC 0xFE2, W, ACCESS
1B86C  6EDA     MOVWF __end_of_UART2_tx_vect_isr, ACCESS
1B86E  80DF     BSF 0xFDF, 0, ACCESS
137:           	Transmission.msgId = EMON_SL; // packet type ID of client
1B870  0E02     MOVLW 0x2
1B872  6E09     MOVWF 0x9, ACCESS
1B874  6A0A     CLRF 0xA, ACCESS
1B876  6A0B     CLRF 0xB, ACCESS
1B878  6A0C     CLRF 0xC, ACCESS
1B87A  0EF9     MOVLW 0xF9
1B87C  0061     MOVFFL ltemp2, PLUSW1
1B87E  F424     NOP
1B880  F4E3     NOP
1B882  0EFA     MOVLW 0xFA
1B884  0061     MOVFFL ttemp3, PLUSW1
1B886  F428     NOP
1B888  F4E3     NOP
1B88A  0EFB     MOVLW 0xFB
1B88C  0061     MOVFFL wtemp5, PLUSW1
1B88E  F42C     NOP
1B890  F4E3     NOP
1B892  0EFC     MOVLW 0xFC
1B894  0061     MOVFFL 0x50C, PLUSW1
1B896  F430     NOP
1B898  F4E3     NOP
138:           	Transmission.data = (uint8_t*) can_buffer; //transmit the data from the data bytes
1B89A  0EFE     MOVLW 0xFE
1B89C  24E1     ADDWF 0xFE1, W, ACCESS
1B89E  6ED9     MOVWF 0xFD9, ACCESS
1B8A0  0EFF     MOVLW 0xFF
1B8A2  20E2     ADDWFC 0xFE2, W, ACCESS
1B8A4  6EDA     MOVWF __end_of_UART2_tx_vect_isr, ACCESS
1B8A6  0E00     MOVLW 0x0
1B8A8  6EDE     MOVWF 0xFDE, ACCESS
1B8AA  0E10     MOVLW 0x10
1B8AC  6EDD     MOVWF 0xFDD, ACCESS
139:           	if (CAN_TX_FIFO_AVAILABLE == (CAN1_TransmitFIFOStatusGet(FIFO2) & CAN_TX_FIFO_AVAILABLE))//ensure that the FIFO has space for a message
1B8AE  0E02     MOVLW 0x2
1B8B0  6EE6     MOVWF 0xFE6, ACCESS
1B8B2  ECF6     CALL 0x1BEC, 0
1B8B4  F00D     NOP
1B8B6  A001     BTFSS __ptext283, 0, ACCESS
1B8B8  D010     BRA 0xB8DA
140:           	{
141:           		CAN1_Transmit(FIFO2, &Transmission); //transmit frame
1B8BA  0EF9     MOVLW 0xF9
1B8BC  24E1     ADDWF 0xFE1, W, ACCESS
1B8BE  6E01     MOVWF __ptext283, ACCESS
1B8C0  0EFF     MOVLW 0xFF
1B8C2  20E2     ADDWFC 0xFE2, W, ACCESS
1B8C4  6E02     MOVWF ___rparam_used, ACCESS
1B8C6  0061     MOVFFL ltemp0, POSTINC1
1B8C8  F404     NOP
1B8CA  F4E6     NOP
1B8CC  0061     MOVFFL ttemp5, POSTINC1
1B8CE  F408     NOP
1B8D0  F4E6     NOP
1B8D2  0E02     MOVLW 0x2
1B8D4  6EE6     MOVWF 0xFE6, ACCESS
1B8D6  ECB3     CALL 0x1FB66, 0
1B8D8  F0FD     NOP
142:           	}
143:           	Transmission.msgId = (EMON_SU);
1B8DA  0E03     MOVLW 0x3
1B8DC  6E09     MOVWF 0x9, ACCESS
1B8DE  6A0A     CLRF 0xA, ACCESS
1B8E0  6A0B     CLRF 0xB, ACCESS
1B8E2  6A0C     CLRF 0xC, ACCESS
1B8E4  0EF9     MOVLW 0xF9
1B8E6  0061     MOVFFL ltemp2, PLUSW1
1B8E8  F424     NOP
1B8EA  F4E3     NOP
1B8EC  0EFA     MOVLW 0xFA
1B8EE  0061     MOVFFL ttemp3, PLUSW1
1B8F0  F428     NOP
1B8F2  F4E3     NOP
1B8F4  0EFB     MOVLW 0xFB
1B8F6  0061     MOVFFL wtemp5, PLUSW1
1B8F8  F42C     NOP
1B8FA  F4E3     NOP
1B8FC  0EFC     MOVLW 0xFC
1B8FE  0061     MOVFFL 0x50C, PLUSW1
1B900  F430     NOP
1B902  F4E3     NOP
144:           	Transmission.data = (uint8_t*) can_buffer + CANFD_BYTES; //transmit the data from the data bytes
1B904  0EFE     MOVLW 0xFE
1B906  24E1     ADDWF 0xFE1, W, ACCESS
1B908  6ED9     MOVWF 0xFD9, ACCESS
1B90A  0EFF     MOVLW 0xFF
1B90C  20E2     ADDWFC 0xFE2, W, ACCESS
1B90E  6EDA     MOVWF __end_of_UART2_tx_vect_isr, ACCESS
1B910  0E40     MOVLW 0x40
1B912  6EDE     MOVWF 0xFDE, ACCESS
1B914  0E10     MOVLW 0x10
1B916  6EDD     MOVWF 0xFDD, ACCESS
145:           	if (CAN_TX_FIFO_AVAILABLE == (CAN1_TransmitFIFOStatusGet(FIFO2) & CAN_TX_FIFO_AVAILABLE))//ensure that the FIFO has space for a message
1B918  0E02     MOVLW 0x2
1B91A  6EE6     MOVWF 0xFE6, ACCESS
1B91C  ECF6     CALL 0x1BEC, 0
1B91E  F00D     NOP
1B920  A001     BTFSS __ptext283, 0, ACCESS
1B922  D010     BRA 0xB944
146:           	{
147:           		CAN1_Transmit(FIFO2, &Transmission); //transmit frame
1B924  0EF9     MOVLW 0xF9
1B926  24E1     ADDWF 0xFE1, W, ACCESS
1B928  6E01     MOVWF __ptext283, ACCESS
1B92A  0EFF     MOVLW 0xFF
1B92C  20E2     ADDWFC 0xFE2, W, ACCESS
1B92E  6E02     MOVWF ___rparam_used, ACCESS
1B930  0061     MOVFFL ltemp0, POSTINC1
1B932  F404     NOP
1B934  F4E6     NOP
1B936  0061     MOVFFL ttemp5, POSTINC1
1B938  F408     NOP
1B93A  F4E6     NOP
1B93C  0E02     MOVLW 0x2
1B93E  6EE6     MOVWF 0xFE6, ACCESS
1B940  ECB3     CALL 0x1FB66, 0
1B942  F0FD     NOP
148:           	}
149:           
150:           	Transmission.msgId = (EMON_ER); // error packet type ID
1B944  0E0F     MOVLW 0xF
1B946  6E09     MOVWF 0x9, ACCESS
1B948  6A0A     CLRF 0xA, ACCESS
1B94A  6A0B     CLRF 0xB, ACCESS
1B94C  6A0C     CLRF 0xC, ACCESS
1B94E  0EF9     MOVLW 0xF9
1B950  0061     MOVFFL ltemp2, PLUSW1
1B952  F424     NOP
1B954  F4E3     NOP
1B956  0EFA     MOVLW 0xFA
1B958  0061     MOVFFL ttemp3, PLUSW1
1B95A  F428     NOP
1B95C  F4E3     NOP
1B95E  0EFB     MOVLW 0xFB
1B960  0061     MOVFFL wtemp5, PLUSW1
1B962  F42C     NOP
1B964  F4E3     NOP
1B966  0EFC     MOVLW 0xFC
1B968  0061     MOVFFL 0x50C, PLUSW1
1B96A  F430     NOP
1B96C  F4E3     NOP
151:           	Transmission.data = (uint8_t*) info_buffer; //transmit the data from the data bytes
1B96E  0EFE     MOVLW 0xFE
1B970  24E1     ADDWF 0xFE1, W, ACCESS
1B972  6ED9     MOVWF 0xFD9, ACCESS
1B974  0EFF     MOVLW 0xFF
1B976  20E2     ADDWFC 0xFE2, W, ACCESS
1B978  6EDA     MOVWF __end_of_UART2_tx_vect_isr, ACCESS
1B97A  0E00     MOVLW 0x0
1B97C  6EDE     MOVWF 0xFDE, ACCESS
1B97E  0E12     MOVLW 0x12
1B980  6EDD     MOVWF 0xFDD, ACCESS
152:           	if (CAN_TX_FIFO_AVAILABLE == (CAN1_TransmitFIFOStatusGet(FIFO3) & CAN_TX_FIFO_AVAILABLE))//ensure that the FIFO has space for a message
1B982  0E03     MOVLW 0x3
1B984  6EE6     MOVWF 0xFE6, ACCESS
1B986  ECF6     CALL 0x1BEC, 0
1B988  F00D     NOP
1B98A  A001     BTFSS __ptext283, 0, ACCESS
1B98C  D010     BRA 0xB9AE
153:           	{
154:           		CAN1_Transmit(FIFO3, &Transmission); //transmit frame
1B98E  0EF9     MOVLW 0xF9
1B990  24E1     ADDWF 0xFE1, W, ACCESS
1B992  6E01     MOVWF __ptext283, ACCESS
1B994  0EFF     MOVLW 0xFF
1B996  20E2     ADDWFC 0xFE2, W, ACCESS
1B998  6E02     MOVWF ___rparam_used, ACCESS
1B99A  0061     MOVFFL ltemp0, POSTINC1
1B99C  F404     NOP
1B99E  F4E6     NOP
1B9A0  0061     MOVFFL ttemp5, POSTINC1
1B9A2  F408     NOP
1B9A4  F4E6     NOP
1B9A6  0E03     MOVLW 0x3
1B9A8  6EE6     MOVWF 0xFE6, ACCESS
1B9AA  ECB3     CALL 0x1FB66, 0
1B9AC  F0FD     NOP
155:           	}
156:           
157:           	if (C.serial_ok && C.version_ok) {
1B9AE  0108     MOVLB 0x8
1B9B0  514F     MOVF 0x4F, W, BANKED
1B9B2  B4D8     BTFSC 0xFD8, 2, ACCESS
1B9B4  D054     BRA 0xBA5E
1B9B6  5150     MOVF 0x50, W, BANKED
1B9B8  B4D8     BTFSC 0xFD8, 2, ACCESS
1B9BA  D051     BRA 0xBA5E
158:           		Transmission.msgId = (EMON_CO); // config packet type ID
1B9BC  0E0C     MOVLW 0xC
1B9BE  6E09     MOVWF 0x9, ACCESS
1B9C0  6A0A     CLRF 0xA, ACCESS
1B9C2  6A0B     CLRF 0xB, ACCESS
1B9C4  6A0C     CLRF 0xC, ACCESS
1B9C6  0EF9     MOVLW 0xF9
1B9C8  0061     MOVFFL ltemp2, PLUSW1
1B9CA  F424     NOP
1B9CC  F4E3     NOP
1B9CE  0EFA     MOVLW 0xFA
1B9D0  0061     MOVFFL ttemp3, PLUSW1
1B9D2  F428     NOP
1B9D4  F4E3     NOP
1B9D6  0EFB     MOVLW 0xFB
1B9D8  0061     MOVFFL wtemp5, PLUSW1
1B9DA  F42C     NOP
1B9DC  F4E3     NOP
1B9DE  0EFC     MOVLW 0xFC
1B9E0  0061     MOVFFL 0x50C, PLUSW1
1B9E2  F430     NOP
1B9E4  F4E3     NOP
159:           		snprintf(info_buffer, MAX_B_BUF, "SN: %s %u FW: 0X%X", ems.serial, ems.year, emv.firmware);
1B9E6  C537     MOVFF emv, POSTINC1
1B9E8  F4E6     NOP
1B9EA  C538     MOVFF 0x538, POSTINC1
1B9EC  F4E6     NOP
1B9EE  C6DD     MOVFF 0x6DD, POSTINC1
1B9F0  F4E6     NOP
1B9F2  C6DE     MOVFF 0x6DE, POSTINC1
1B9F4  F4E6     NOP
1B9F6  0ECF     MOVLW 0xCF
1B9F8  6EE6     MOVWF 0xFE6, ACCESS
1B9FA  0E06     MOVLW 0x6
1B9FC  6EE6     MOVWF 0xFE6, ACCESS
1B9FE  0E4B     MOVLW 0x4B
1BA00  6EE6     MOVWF 0xFE6, ACCESS
1BA02  0EFF     MOVLW 0xFF
1BA04  6EE6     MOVWF 0xFE6, ACCESS
1BA06  0EFF     MOVLW 0xFF
1BA08  6EE6     MOVWF 0xFE6, ACCESS
1BA0A  0E00     MOVLW 0x0
1BA0C  6EE6     MOVWF 0xFE6, ACCESS
1BA0E  0E00     MOVLW 0x0
1BA10  6EE6     MOVWF 0xFE6, ACCESS
1BA12  0E12     MOVLW 0x12
1BA14  6EE6     MOVWF 0xFE6, ACCESS
1BA16  0E0C     MOVLW 0xC
1BA18  6EE6     MOVWF 0xFE6, ACCESS
1BA1A  EC35     CALL 0x1C06A, 0
1BA1C  F0E0     NOP
160:           		Transmission.data = (uint8_t*) info_buffer; //transmit the data from the data bytes
1BA1E  0EFE     MOVLW 0xFE
1BA20  24E1     ADDWF 0xFE1, W, ACCESS
1BA22  6ED9     MOVWF 0xFD9, ACCESS
1BA24  0EFF     MOVLW 0xFF
1BA26  20E2     ADDWFC 0xFE2, W, ACCESS
1BA28  6EDA     MOVWF __end_of_UART2_tx_vect_isr, ACCESS
1BA2A  0E00     MOVLW 0x0
1BA2C  6EDE     MOVWF 0xFDE, ACCESS
1BA2E  0E12     MOVLW 0x12
1BA30  6EDD     MOVWF 0xFDD, ACCESS
161:           		if (CAN_TX_FIFO_AVAILABLE == (CAN1_TransmitFIFOStatusGet(FIFO3) & CAN_TX_FIFO_AVAILABLE))//ensure that the FIFO has space for a message
1BA32  0E03     MOVLW 0x3
1BA34  6EE6     MOVWF 0xFE6, ACCESS
1BA36  ECF6     CALL 0x1BEC, 0
1BA38  F00D     NOP
1BA3A  A001     BTFSS __ptext283, 0, ACCESS
1BA3C  D010     BRA 0xBA5E
162:           		{
163:           			CAN1_Transmit(FIFO3, &Transmission); //transmit frame
1BA3E  0EF9     MOVLW 0xF9
1BA40  24E1     ADDWF 0xFE1, W, ACCESS
1BA42  6E01     MOVWF __ptext283, ACCESS
1BA44  0EFF     MOVLW 0xFF
1BA46  20E2     ADDWFC 0xFE2, W, ACCESS
1BA48  6E02     MOVWF ___rparam_used, ACCESS
1BA4A  0061     MOVFFL ltemp0, POSTINC1
1BA4C  F404     NOP
1BA4E  F4E6     NOP
1BA50  0061     MOVFFL ttemp5, POSTINC1
1BA52  F408     NOP
1BA54  F4E6     NOP
1BA56  0E03     MOVLW 0x3
1BA58  6EE6     MOVWF 0xFE6, ACCESS
1BA5A  ECB3     CALL 0x1FB66, 0
1BA5C  F0FD     NOP
164:           		}
165:           	}
166:           #ifdef CAN_REMOTE
167:           	if (CAN1_IsRxErrorActive()) {
168:           	}
169:           #endif
170:           	IO_RB5_SetLow();
1BA5E  9ABF     BCF 0xFBF, 5, ACCESS
171:           }
1BA60  0EF9     MOVLW 0xF9
1BA60  0EF9     MOVLW 0xF9
1BA60  0EF9     MOVLW 0xF9
1BA60  0EF9     MOVLW 0xF9
1BA60  0EF9     MOVLW 0xF9
172:           
173:           /*
174:            * complete and correct the MCC CANBUS configuration
175:            */
176:           void can_setup(void)
177:           {
178:           	/*
179:           	 * don't trust MCC for nothing
180:           	 */
181:           	CAN1_OperationModeSet(CAN_CONFIGURATION_MODE);
0CEA  0E04     MOVLW 0x4
0CEC  6EE6     MOVWF 0xFE6, ACCESS
0CEE  EC30     CALL 0x660, 0
0CF0  F003     NOP
182:           	/*
183:           	 * interrupt handlers, both receive data from the FIFO
184:           	 */
185:           	CAN1_SetFIFO1NotEmptyHandler(Can1FIFO1NotEmptyHandler);
0CF2  0ED6     MOVLW 0xD6
0CF4  6EE6     MOVWF 0xFE6, ACCESS
0CF6  0E9D     MOVLW 0x9D
0CF8  6EE6     MOVWF 0xFE6, ACCESS
0CFA  0E01     MOVLW 0x1
0CFC  6EE6     MOVWF 0xFE6, ACCESS
0CFE  EC6B     CALL 0x22D6, 0
0D00  F011     NOP
186:           	CAN1_SetRxBufferOverFlowInterruptHandler(Can1FIFO1NotEmptyHandler);
0D02  0ED6     MOVLW 0xD6
0D04  6EE6     MOVWF 0xFE6, ACCESS
0D06  0E9D     MOVLW 0x9D
0D08  6EE6     MOVWF 0xFE6, ACCESS
0D0A  0E01     MOVLW 0x1
0D0C  6EE6     MOVWF 0xFE6, ACCESS
0D0E  EC9E     CALL 0x233C, 0
0D10  F011     NOP
187:           	CAN1_SetTXQNotFullHandler(TXQNotFullHandler);
0D12  0E08     MOVLW 0x8
0D14  6EE6     MOVWF 0xFE6, ACCESS
0D16  0E20     MOVLW 0x20
0D18  6EE6     MOVWF 0xFE6, ACCESS
0D1A  0E00     MOVLW 0x0
0D1C  6EE6     MOVWF 0xFE6, ACCESS
0D1E  EC5A     CALL 0x22B4, 0
0D20  F011     NOP
188:           
189:           	/*
190:           	 * user mod filter and masking
191:           	 * SID to allow all system id's to pass
192:           	 */
193:           	C1FLTOBJ0L = 0x00;
0D22  0101     MOVLB 0x1
0D24  6B8C     CLRF SPI1CLK, BANKED
194:           	C1FLTOBJ0H = 0x00;
0D26  6B8D     CLRF SPI2RXB, BANKED
195:           	C1FLTOBJ0U = 0x00;
0D28  6B8E     CLRF SPI2TXB, BANKED
196:           	C1FLTOBJ0T = 0x40;
0D2A  0E40     MOVLW 0x40
0D2C  6F8F     MOVWF SPI2TCNT, BANKED
197:           	/*
198:           	 * user MASK mod
199:           	 */
200:           	C1MASK0L = 0xFF;
0D2E  6990     SETF SPI2TCNTH, BANKED
201:           	C1MASK0H = 0x00;
0D30  6B91     CLRF SPI2CON0, BANKED
202:           	C1MASK0U = 0xFF;
0D32  6992     SETF SPI2CON1, BANKED
203:           	C1MASK0T = 0x5F;
0D34  0E5F     MOVLW 0x5F
0D36  6F93     MOVWF SPI2CON2, BANKED
204:           	C1FLTCON0L = 0x81;
0D38  0E81     MOVLW 0x81
0D3A  6F80     MOVWF SPI1RXB, BANKED
205:           
206:           	C1FIFOCON1Lbits.TFNRFNIE = 1; // not empty FIFO interrupt
0D3C  815C     BSF 0x5C, 0, BANKED
207:           	/*
208:           	 * enable CAN receiver interrupts, again, to fix one of the many MCC bugs
209:           	 */
210:           	C1INTUbits.RXIE = 1; // The stupid MCC sets this back to off when setting the error interrupts
0D3E  831E     BSF 0x1E, 1, BANKED
211:           	PIR4bits.CANRXIF = 0; // clear flags and set interrupt controller again, just to be sure
0D40  98B2     BCF 0xFB2, 4, ACCESS
212:           	PIE4bits.CANRXIE = 1;
0D42  88A2     BSF 0xFA2, 4, ACCESS
213:           	CAN1_OperationModeSet(CAN_NORMAL_FD_MODE);
0D44  0E00     MOVLW 0x0
0D46  6EE6     MOVWF 0xFE6, ACCESS
0D48  EC30     CALL 0x660, 0
0D4A  F003     NOP
214:           }
0D4C  0012     RETURN 0
215:           
216:           /*
217:            * send LCD line buffer data via CANBUS to remote displays
218:            */
219:           void can_fd_lcd_mirror(const uint8_t r, char *strPtr)
1F400  0E07     MOVLW 0x7
1F402  26E1     ADDWF 0xFE1, F, ACCESS
1F404  0E00     MOVLW 0x0
1F406  22E2     ADDWFC 0xFE2, F, ACCESS
220:           {
221:           	if (!B.FM80_io) {
1F408  0105     MOVLB 0x5
1F40A  5170     MOVF CM1CON0, W, BANKED
1F40C  A4D8     BTFSS 0xFD8, 2, ACCESS
1F40E  D066     BRA 0xF4DC
222:           		CAN_MSG_OBJ Transmission; //create the CAN message object
223:           		Transmission.field.brs = CAN_BRS_MODE; //Transmit the data bytes at data bit rate
1F410  0EFD     MOVLW 0xFD
1F412  24E1     ADDWF 0xFE1, W, ACCESS
1F414  6ED9     MOVWF 0xFD9, ACCESS
1F416  0EFF     MOVLW 0xFF
1F418  20E2     ADDWFC 0xFE2, W, ACCESS
1F41A  6EDA     MOVWF __end_of_UART2_tx_vect_isr, ACCESS
1F41C  8EDF     BSF 0xFDF, 7, ACCESS
224:           		Transmission.field.dlc = DLC_64; // 64 data bytes
1F41E  0EFD     MOVLW 0xFD
1F420  24E1     ADDWF 0xFE1, W, ACCESS
1F422  6ED9     MOVWF 0xFD9, ACCESS
1F424  0EFF     MOVLW 0xFF
1F426  20E2     ADDWFC 0xFE2, W, ACCESS
1F428  6EDA     MOVWF __end_of_UART2_tx_vect_isr, ACCESS
1F42A  0E3C     MOVLW 0x3C
1F42C  12DF     IORWF 0xFDF, F, ACCESS
225:           		Transmission.field.formatType = CAN_FD_FORMAT; // CAN FD frames
1F42E  0EFD     MOVLW 0xFD
1F430  24E1     ADDWF 0xFE1, W, ACCESS
1F432  6ED9     MOVWF 0xFD9, ACCESS
1F434  0EFF     MOVLW 0xFF
1F436  20E2     ADDWFC 0xFE2, W, ACCESS
1F438  6EDA     MOVWF __end_of_UART2_tx_vect_isr, ACCESS
1F43A  8CDF     BSF 0xFDF, 6, ACCESS
226:           		Transmission.field.frameType = CAN_FRAME_DATA; // Data frame
1F43C  0EFD     MOVLW 0xFD
1F43E  24E1     ADDWF 0xFE1, W, ACCESS
1F440  6ED9     MOVWF 0xFD9, ACCESS
1F442  0EFF     MOVLW 0xFF
1F444  20E2     ADDWFC 0xFE2, W, ACCESS
1F446  6EDA     MOVWF __end_of_UART2_tx_vect_isr, ACCESS
1F448  92DF     BCF 0xFDF, 1, ACCESS
227:           		Transmission.field.idType = CAN_FRAME_EXT; // EXT ID
1F44A  0EFD     MOVLW 0xFD
1F44C  24E1     ADDWF 0xFE1, W, ACCESS
1F44E  6ED9     MOVWF 0xFD9, ACCESS
1F450  0EFF     MOVLW 0xFF
1F452  20E2     ADDWFC 0xFE2, W, ACCESS
1F454  6EDA     MOVWF __end_of_UART2_tx_vect_isr, ACCESS
1F456  80DF     BSF 0xFDF, 0, ACCESS
228:           		Transmission.msgId = EMON_MR + r; // packet type ID of client
1F458  0EF8     MOVLW 0xF8
1F45A  50E3     MOVF 0xFE3, W, ACCESS
1F45C  6E0B     MOVWF 0xB, ACCESS
1F45E  6A0C     CLRF 0xC, ACCESS
1F460  0E04     MOVLW 0x4
1F462  260B     ADDWF 0xB, F, ACCESS
1F464  0E00     MOVLW 0x0
1F466  220C     ADDWFC 0xC, F, ACCESS
1F468  0EF9     MOVLW 0xF9
1F46A  0061     MOVFFL wtemp5, PLUSW1
1F46C  F42C     NOP
1F46E  F4E3     NOP
1F470  0EFA     MOVLW 0xFA
1F472  0061     MOVFFL 0x50C, PLUSW1
1F474  F430     NOP
1F476  F4E3     NOP
1F478  6A01     CLRF __ptext283, ACCESS
1F47A  BEE3     BTFSC 0xFE3, 7, ACCESS
1F47C  6801     SETF __ptext283, ACCESS
1F47E  0EFB     MOVLW 0xFB
1F480  0061     MOVFFL ltemp0, PLUSW1
1F482  F404     NOP
1F484  F4E3     NOP
1F486  0EFC     MOVLW 0xFC
1F488  0061     MOVFFL ltemp0, PLUSW1
1F48A  F404     NOP
1F48C  F4E3     NOP
229:           		Transmission.data = (uint8_t*) strPtr; //transmit the data from the data bytes
1F48E  50E1     MOVF 0xFE1, W, ACCESS
1F490  0FF6     ADDLW 0xF6
1F492  6ED9     MOVWF 0xFD9, ACCESS
1F494  50E2     MOVF 0xFE2, W, ACCESS
1F496  6EDA     MOVWF __end_of_UART2_tx_vect_isr, ACCESS
1F498  0EFF     MOVLW 0xFF
1F49A  22DA     ADDWFC __end_of_UART2_tx_vect_isr, F, ACCESS
1F49C  0EFE     MOVLW 0xFE
1F49E  24E1     ADDWF 0xFE1, W, ACCESS
1F4A0  6EE9     MOVWF 0xFE9, ACCESS
1F4A2  0EFF     MOVLW 0xFF
1F4A4  20E2     ADDWFC 0xFE2, W, ACCESS
1F4A6  6EEA     MOVWF 0xFEA, ACCESS
1F4A8  C4DE     MOVFF POSTINC2, POSTINC0
1F4AA  F4EE     NOP
1F4AC  C4DD     MOVFF POSTDEC2, POSTDEC0
1F4AE  F4ED     NOP
230:           		if (CAN_TX_FIFO_AVAILABLE == (CAN1_TransmitFIFOStatusGet(TXQ) & CAN_TX_FIFO_AVAILABLE))//ensure that the FIFO has space for a message
1F4B0  0E00     MOVLW 0x0
1F4B2  6EE6     MOVWF 0xFE6, ACCESS
1F4B4  ECF6     CALL 0x1BEC, 0
1F4B6  F00D     NOP
1F4B8  A001     BTFSS __ptext283, 0, ACCESS
1F4BA  D010     BRA 0xF4DC
231:           		{
232:           			CAN1_Transmit(TXQ, &Transmission); //transmit frame
1F4BC  0EF9     MOVLW 0xF9
1F4BE  24E1     ADDWF 0xFE1, W, ACCESS
1F4C0  6E01     MOVWF __ptext283, ACCESS
1F4C2  0EFF     MOVLW 0xFF
1F4C4  20E2     ADDWFC 0xFE2, W, ACCESS
1F4C6  6E02     MOVWF ___rparam_used, ACCESS
1F4C8  0061     MOVFFL ltemp0, POSTINC1
1F4CA  F404     NOP
1F4CC  F4E6     NOP
1F4CE  0061     MOVFFL ttemp5, POSTINC1
1F4D0  F408     NOP
1F4D2  F4E6     NOP
1F4D4  0E00     MOVLW 0x0
1F4D6  6EE6     MOVWF 0xFE6, ACCESS
1F4D8  ECB3     CALL 0x1FB66, 0
1F4DA  F0FD     NOP
233:           		}
234:           	}
235:           #ifdef CAN_REMOTE
236:           	if (CAN1_IsRxErrorActive()) {
237:           	}
238:           #endif
239:           	IO_RB5_SetLow();
1F4DC  9ABF     BCF 0xFBF, 5, ACCESS
240:           }
1F4DE  0EF6     MOVLW 0xF6
1F4E0  26E1     ADDWF 0xFE1, F, ACCESS
1F4E2  0EFF     MOVLW 0xFF
1F4E4  22E2     ADDWFC 0xFE2, F, ACCESS
1F4E4  22E2     ADDWFC 0xFE2, F, ACCESS
241:           
242:           void TXQNotFullHandler(void)
243:           {
244:           	INT_TRACE; // GPIO interrupt scope trace
2008  ACBF     BTFSS 0xFBF, 6, ACCESS
200A  D002     BRA 0x2010
200C  0E01     MOVLW 0x1
200E  D001     BRA 0x2012
2010  0E00     MOVLW 0x0
2012  0AFF     XORLW 0xFF
2014  6E0C     MOVWF 0xC, ACCESS
2016  3A0C     SWAPF 0xC, F, ACCESS
2018  460C     RLNCF 0xC, F, ACCESS
201A  460C     RLNCF 0xC, F, ACCESS
201C  50BF     MOVF 0xFBF, W, ACCESS
201E  180C     XORWF 0xC, W, ACCESS
2020  0BBF     ANDLW 0xBF
2022  180C     XORWF 0xC, W, ACCESS
2024  6EBF     MOVWF 0xFBF, ACCESS
245:           	C1INTUbits.TXIE = 0;
2026  0101     MOVLB 0x1
2028  911E     BCF 0x1E, 0, BANKED
246:           }
202A  0012     RETURN 0
2770  EE17     LFSR 1, 0x1FAA
---  /public/Q84vtouch/batmon.c  ------------------------------------------------------------------------
1:             #include "batmon.h"
2:             
3:             EB_data EBD = {
4:             	.checkmark = BM_CM,
5:             	.version = BM_EEPROM_VER,
6:             	.loaded = false,
7:             	.bat_cycles = 0,
8:             	.bat_energy = BAT_ENERGY,
9:             	.bat_mode = 0,
10:            	.bat_time = 0,
11:            	.crc = 0,
12:            	.alt_display = 0,
13:            };
14:            
15:            uint16_t EBD_update = 0; // EEPROM write counter for BM_UPDATE
16:            float pv_Wh_daily = 0.0f, pv_Wh_daily_prev = 0.0f, ac_Wh_daily = 0.0f, ac_Wh_daily_prev = 0.0f;
17:            
18:            /*
19:             * get the pointer to the system EEPROM save data
20:             */
21:            EB_data *get_EEPROM(void)
22:            {
23:            	return &EBD;
24:            }
25:            
26:            /*
27:             * load EEPROM data to energy if correctly formatted
28:             */
29:            bool initbm_data(uint8_t * EB)
1E82A  52E6     MOVF 0xFE6, F, ACCESS
1E82C  52E6     MOVF 0xFE6, F, ACCESS
1E82E  52E6     MOVF 0xFE6, F, ACCESS
1E830  52E6     MOVF 0xFE6, F, ACCESS
30:            {
31:            	EB_data *ebd = (EB_data*) EB;
1E832  0EFA     MOVLW 0xFA
1E834  0061     MOVFFL PLUSW1, wtemp5
1E836  F38C     NOP
1E838  F50B     NOP
1E83A  0EFB     MOVLW 0xFB
1E83C  0061     MOVFFL PLUSW1, 0x50C
1E83E  F38C     NOP
1E840  F50C     NOP
1E842  0EFF     MOVLW 0xFF
1E844  0061     MOVFFL 0x50C, PLUSW1
1E846  F430     NOP
1E848  F4E3     NOP
1E84A  0EFE     MOVLW 0xFE
1E84C  0061     MOVFFL wtemp5, PLUSW1
1E84E  F42C     NOP
1E850  F4E3     NOP
32:            
33:            	if (DATAEE_ReadByte(0) != BM_CM) {
1E852  0E00     MOVLW 0x0
1E854  6EE6     MOVWF 0xFE6, ACCESS
1E856  0E00     MOVLW 0x0
1E858  6EE6     MOVWF 0xFE6, ACCESS
1E85A  EC8A     CALL 0x1D14, 0
1E85C  F00E     NOP
1E85E  0E58     MOVLW 0x58
1E860  1801     XORWF __ptext283, W, ACCESS
1E862  B4D8     BTFSC 0xFD8, 2, ACCESS
1E864  D011     BRA 0xE888
34:            		ebd->loaded = false;
1E866  0EFE     MOVLW 0xFE
1E868  0061     MOVFFL PLUSW1, wtemp5
1E86A  F38C     NOP
1E86C  F50B     NOP
1E86E  0EFF     MOVLW 0xFF
1E870  0061     MOVFFL PLUSW1, 0x50C
1E872  F38C     NOP
1E874  F50C     NOP
1E876  0E03     MOVLW 0x3
1E878  240B     ADDWF 0xB, W, ACCESS
1E87A  6ED9     MOVWF 0xFD9, ACCESS
1E87C  0E00     MOVLW 0x0
1E87E  200C     ADDWFC 0xC, W, ACCESS
1E880  6EDA     MOVWF __end_of_UART2_tx_vect_isr, ACCESS
1E882  6ADF     CLRF 0xFDF, ACCESS
35:            		return false;
1E884  0E00     MOVLW 0x0
1E886  D051     BRA 0xE92A
36:            	} else {
37:            		for (uint16_t i = 0; i < sizeof(EB_data); i++) {
1E888  0EFC     MOVLW 0xFC
1E88A  6AE3     CLRF 0xFE3, ACCESS
1E88C  0EFD     MOVLW 0xFD
1E88E  6AE3     CLRF 0xFE3, ACCESS
38:            			EB[i] = DATAEE_ReadByte(i);
1E890  0EFC     MOVLW 0xFC
1E892  C4E3     MOVFF PLUSW1, POSTINC1
1E894  F4E6     NOP
1E896  C4E3     MOVFF PLUSW1, POSTINC1
1E898  F4E6     NOP
1E89A  EC8A     CALL 0x1D14, 0
1E89C  F00E     NOP
1E89E  0EFC     MOVLW 0xFC
1E8A0  0061     MOVFFL PLUSW1, wtemp5
1E8A2  F38C     NOP
1E8A4  F50B     NOP
1E8A6  0EFD     MOVLW 0xFD
1E8A8  0061     MOVFFL PLUSW1, 0x50C
1E8AA  F38C     NOP
1E8AC  F50C     NOP
1E8AE  0EFA     MOVLW 0xFA
1E8B0  0061     MOVFFL PLUSW1, ltemp2
1E8B2  F38C     NOP
1E8B4  F509     NOP
1E8B6  0EFB     MOVLW 0xFB
1E8B8  0061     MOVFFL PLUSW1, ttemp3
1E8BA  F38C     NOP
1E8BC  F50A     NOP
1E8BE  500B     MOVF 0xB, W, ACCESS
1E8C0  2409     ADDWF 0x9, W, ACCESS
1E8C2  6ED9     MOVWF 0xFD9, ACCESS
1E8C4  500C     MOVF 0xC, W, ACCESS
1E8C6  200A     ADDWFC 0xA, W, ACCESS
1E8C8  6EDA     MOVWF __end_of_UART2_tx_vect_isr, ACCESS
1E8CA  0061     MOVFFL ltemp0, INDF2
1E8CC  F404     NOP
1E8CE  F4DF     NOP
39:            		}
1E8D0  0EFC     MOVLW 0xFC
1E8D2  50E3     MOVF 0xFE3, W, ACCESS
1E8D4  0F01     ADDLW 0x1
1E8D6  6E01     MOVWF __ptext283, ACCESS
1E8D8  0EFC     MOVLW 0xFC
1E8DA  0061     MOVFFL ltemp0, PLUSW1
1E8DC  F404     NOP
1E8DE  F4E3     NOP
1E8E0  6A01     CLRF __ptext283, ACCESS
1E8E2  0EFD     MOVLW 0xFD
1E8E4  50E3     MOVF 0xFE3, W, ACCESS
1E8E6  2001     ADDWFC __ptext283, W, ACCESS
1E8E8  6E01     MOVWF __ptext283, ACCESS
1E8EA  0EFD     MOVLW 0xFD
1E8EC  0061     MOVFFL ltemp0, PLUSW1
1E8EE  F404     NOP
1E8F0  F4E3     NOP
1E8F2  0EFD     MOVLW 0xFD
1E8F4  50E3     MOVF 0xFE3, W, ACCESS
1E8F6  E108     BNZ 0xE908
1E8F8  0EFC     MOVLW 0xFC
1E8FA  0061     MOVFFL PLUSW1, ltemp0
1E8FC  F38C     NOP
1E8FE  F501     NOP
1E900  0E44     MOVLW 0x44
1E902  5E01     SUBWF __ptext283, F, ACCESS
1E904  A0D8     BTFSS 0xFD8, 0, ACCESS
1E906  D7C4     BRA 0xE890
40:            		ebd->loaded = true;
1E908  0EFE     MOVLW 0xFE
1E90A  0061     MOVFFL PLUSW1, wtemp5
1E90C  F38C     NOP
1E90E  F50B     NOP
1E910  0EFF     MOVLW 0xFF
1E912  0061     MOVFFL PLUSW1, 0x50C
1E914  F38C     NOP
1E916  F50C     NOP
1E918  0E03     MOVLW 0x3
1E91A  240B     ADDWF 0xB, W, ACCESS
1E91C  6ED9     MOVWF 0xFD9, ACCESS
1E91E  0E00     MOVLW 0x0
1E920  200C     ADDWFC 0xC, W, ACCESS
1E922  6EDA     MOVWF __end_of_UART2_tx_vect_isr, ACCESS
1E924  0E01     MOVLW 0x1
1E926  6EDF     MOVWF 0xFDF, ACCESS
41:            	}
42:            	return true;
1E928  0E01     MOVLW 0x1
1E92A  6E01     MOVWF __ptext283, ACCESS
43:            }
1E92C  0EFA     MOVLW 0xFA
1E92E  26E1     ADDWF 0xFE1, F, ACCESS
1E930  0EFF     MOVLW 0xFF
1E932  22E2     ADDWFC 0xFE2, F, ACCESS
1E932  22E2     ADDWFC 0xFE2, F, ACCESS
44:            
45:            /*
46:             * write energy array to EEPROM
47:             */
48:            void wr_bm_data(uint8_t * EB)
1CD64  52E6     MOVF 0xFE6, F, ACCESS
1CD66  52E6     MOVF 0xFE6, F, ACCESS
1CD68  52E6     MOVF 0xFE6, F, ACCESS
1CD6A  52E6     MOVF 0xFE6, F, ACCESS
49:            {
50:            	EB_data *ebd = (EB_data*) EB;
1CD6C  0EFA     MOVLW 0xFA
1CD6E  0061     MOVFFL PLUSW1, wtemp5
1CD70  F38C     NOP
1CD72  F50B     NOP
1CD74  0EFB     MOVLW 0xFB
1CD76  0061     MOVFFL PLUSW1, 0x50C
1CD78  F38C     NOP
1CD7A  F50C     NOP
1CD7C  0EFF     MOVLW 0xFF
1CD7E  0061     MOVFFL 0x50C, PLUSW1
1CD80  F430     NOP
1CD82  F4E3     NOP
1CD84  0EFE     MOVLW 0xFE
1CD86  0061     MOVFFL wtemp5, PLUSW1
1CD88  F42C     NOP
1CD8A  F4E3     NOP
51:            
52:            	EB[0] = BM_CM;
1CD8C  0EFA     MOVLW 0xFA
1CD8E  C4E3     MOVFF PLUSW1, FSR2
1CD90  F4D9     NOP
1CD92  0EFB     MOVLW 0xFB
1CD94  C4E3     MOVFF PLUSW1, FSR2H
1CD96  F4DA     NOP
1CD98  0E58     MOVLW 0x58
1CD9A  6EDF     MOVWF 0xFDF, ACCESS
53:            	ebd->crc = 0;
1CD9C  0EFE     MOVLW 0xFE
1CD9E  0061     MOVFFL PLUSW1, wtemp5
1CDA0  F38C     NOP
1CDA2  F50B     NOP
1CDA4  0EFF     MOVLW 0xFF
1CDA6  0061     MOVFFL PLUSW1, 0x50C
1CDA8  F38C     NOP
1CDAA  F50C     NOP
1CDAC  0E42     MOVLW 0x42
1CDAE  240B     ADDWF 0xB, W, ACCESS
1CDB0  6ED9     MOVWF 0xFD9, ACCESS
1CDB2  0E00     MOVLW 0x0
1CDB4  200C     ADDWFC 0xC, W, ACCESS
1CDB6  6EDA     MOVWF __end_of_UART2_tx_vect_isr, ACCESS
1CDB8  6ADE     CLRF 0xFDE, ACCESS
1CDBA  6ADD     CLRF 0xFDD, ACCESS
54:            	ebd->crc = crc16(EB, sizeof(EB_data) - 2); // exclude crc bytes
1CDBC  0E42     MOVLW 0x42
1CDBE  6EE6     MOVWF 0xFE6, ACCESS
1CDC0  0E00     MOVLW 0x0
1CDC2  6EE6     MOVWF 0xFE6, ACCESS
1CDC4  0EF8     MOVLW 0xF8
1CDC6  C4E3     MOVFF PLUSW1, POSTINC1
1CDC8  F4E6     NOP
1CDCA  C4E3     MOVFF PLUSW1, POSTINC1
1CDCC  F4E6     NOP
1CDCE  EC35     CALL 0x1DE6A, 0
1CDD0  F0EF     NOP
1CDD2  0EFE     MOVLW 0xFE
1CDD4  0061     MOVFFL PLUSW1, wtemp5
1CDD6  F38C     NOP
1CDD8  F50B     NOP
1CDDA  0EFF     MOVLW 0xFF
1CDDC  0061     MOVFFL PLUSW1, 0x50C
1CDDE  F38C     NOP
1CDE0  F50C     NOP
1CDE2  0E42     MOVLW 0x42
1CDE4  240B     ADDWF 0xB, W, ACCESS
1CDE6  6ED9     MOVWF 0xFD9, ACCESS
1CDE8  0E00     MOVLW 0x0
1CDEA  200C     ADDWFC 0xC, W, ACCESS
1CDEC  6EDA     MOVWF __end_of_UART2_tx_vect_isr, ACCESS
1CDEE  0061     MOVFFL ltemp0, POSTINC2
1CDF0  F404     NOP
1CDF2  F4DE     NOP
1CDF4  0061     MOVFFL ttemp5, POSTDEC2
1CDF6  F408     NOP
1CDF8  F4DD     NOP
55:            	ebd->bat_time = ++ebd->bat_time;
1CDFA  0EFE     MOVLW 0xFE
1CDFC  0061     MOVFFL PLUSW1, wtemp5
1CDFE  F38C     NOP
1CE00  F50B     NOP
1CE02  0EFF     MOVLW 0xFF
1CE04  0061     MOVFFL PLUSW1, 0x50C
1CE06  F38C     NOP
1CE08  F50C     NOP
1CE0A  0E3A     MOVLW 0x3A
1CE0C  240B     ADDWF 0xB, W, ACCESS
1CE0E  6ED9     MOVWF 0xFD9, ACCESS
1CE10  0E00     MOVLW 0x0
1CE12  200C     ADDWFC 0xC, W, ACCESS
1CE14  6EDA     MOVWF __end_of_UART2_tx_vect_isr, ACCESS
1CE16  2ADE     INCF 0xFDE, F, ACCESS
1CE18  0E00     MOVLW 0x0
1CE1A  22DE     ADDWFC 0xFDE, F, ACCESS
1CE1C  22DE     ADDWFC 0xFDE, F, ACCESS
1CE1E  22DD     ADDWFC 0xFDD, F, ACCESS
1CE20  52DD     MOVF 0xFDD, F, ACCESS
1CE22  52DD     MOVF 0xFDD, F, ACCESS
1CE24  0EFE     MOVLW 0xFE
1CE26  0061     MOVFFL PLUSW1, wtemp5
1CE28  F38C     NOP
1CE2A  F50B     NOP
1CE2C  0EFF     MOVLW 0xFF
1CE2E  0061     MOVFFL PLUSW1, 0x50C
1CE30  F38C     NOP
1CE32  F50C     NOP
1CE34  0E3A     MOVLW 0x3A
1CE36  240B     ADDWF 0xB, W, ACCESS
1CE38  6EE9     MOVWF 0xFE9, ACCESS
1CE3A  0E00     MOVLW 0x0
1CE3C  200C     ADDWFC 0xC, W, ACCESS
1CE3E  6EEA     MOVWF 0xFEA, ACCESS
1CE40  C4DE     MOVFF POSTINC2, POSTINC0
1CE42  F4EE     NOP
1CE44  C4DE     MOVFF POSTINC2, POSTINC0
1CE46  F4EE     NOP
1CE48  C4DE     MOVFF POSTINC2, POSTINC0
1CE4A  F4EE     NOP
1CE4C  C4DE     MOVFF POSTINC2, POSTINC0
1CE4E  F4EE     NOP
56:            
57:            	if ((ebd->bat_time) % BAT_CYCLES == 0) {
1CE50  0EFE     MOVLW 0xFE
1CE52  0061     MOVFFL PLUSW1, wtemp5
1CE54  F38C     NOP
1CE56  F50B     NOP
1CE58  0EFF     MOVLW 0xFF
1CE5A  0061     MOVFFL PLUSW1, 0x50C
1CE5C  F38C     NOP
1CE5E  F50C     NOP
1CE60  0E3A     MOVLW 0x3A
1CE62  240B     ADDWF 0xB, W, ACCESS
1CE64  6ED9     MOVWF 0xFD9, ACCESS
1CE66  0E00     MOVLW 0x0
1CE68  200C     ADDWFC 0xC, W, ACCESS
1CE6A  6EDA     MOVWF __end_of_UART2_tx_vect_isr, ACCESS
1CE6C  50DF     MOVF 0xFDF, W, ACCESS
1CE6E  6E0C     MOVWF 0xC, ACCESS
1CE70  0E07     MOVLW 0x7
1CE72  160C     ANDWF 0xC, F, ACCESS
1CE74  A4D8     BTFSS 0xFD8, 2, ACCESS
1CE76  D011     BRA 0xCE9A
58:            		ebd->bat_cycles++;
1CE78  0EFE     MOVLW 0xFE
1CE7A  0061     MOVFFL PLUSW1, wtemp5
1CE7C  F38C     NOP
1CE7E  F50B     NOP
1CE80  0EFF     MOVLW 0xFF
1CE82  0061     MOVFFL PLUSW1, 0x50C
1CE84  F38C     NOP
1CE86  F50C     NOP
1CE88  0E32     MOVLW 0x32
1CE8A  240B     ADDWF 0xB, W, ACCESS
1CE8C  6ED9     MOVWF 0xFD9, ACCESS
1CE8E  0E00     MOVLW 0x0
1CE90  200C     ADDWFC 0xC, W, ACCESS
1CE92  6EDA     MOVWF __end_of_UART2_tx_vect_isr, ACCESS
1CE94  2ADE     INCF 0xFDE, F, ACCESS
1CE96  0E00     MOVLW 0x0
1CE98  22DD     ADDWFC 0xFDD, F, ACCESS
59:            	}
60:            
61:            	for (uint16_t i = 0; i < sizeof(EB_data); i++) {
1CE9A  0EFC     MOVLW 0xFC
1CE9C  6AE3     CLRF 0xFE3, ACCESS
1CE9E  0EFD     MOVLW 0xFD
1CEA0  6AE3     CLRF 0xFE3, ACCESS
62:            		DATAEE_WriteByte(i, EB[i]);
1CEA2  0EFC     MOVLW 0xFC
1CEA4  0061     MOVFFL PLUSW1, wtemp5
1CEA6  F38C     NOP
1CEA8  F50B     NOP
1CEAA  0EFD     MOVLW 0xFD
1CEAC  0061     MOVFFL PLUSW1, 0x50C
1CEAE  F38C     NOP
1CEB0  F50C     NOP
1CEB2  0EFA     MOVLW 0xFA
1CEB4  0061     MOVFFL PLUSW1, ltemp2
1CEB6  F38C     NOP
1CEB8  F509     NOP
1CEBA  0EFB     MOVLW 0xFB
1CEBC  0061     MOVFFL PLUSW1, ttemp3
1CEBE  F38C     NOP
1CEC0  F50A     NOP
1CEC2  500B     MOVF 0xB, W, ACCESS
1CEC4  2409     ADDWF 0x9, W, ACCESS
1CEC6  6ED9     MOVWF 0xFD9, ACCESS
1CEC8  500C     MOVF 0xC, W, ACCESS
1CECA  200A     ADDWFC 0xA, W, ACCESS
1CECC  6EDA     MOVWF __end_of_UART2_tx_vect_isr, ACCESS
1CECE  50DF     MOVF 0xFDF, W, ACCESS
1CED0  6EE6     MOVWF 0xFE6, ACCESS
1CED2  0EFB     MOVLW 0xFB
1CED4  C4E3     MOVFF PLUSW1, POSTINC1
1CED6  F4E6     NOP
1CED8  C4E3     MOVFF PLUSW1, POSTINC1
1CEDA  F4E6     NOP
1CEDC  EC70     CALL 0xAE0, 0
1CEDE  F005     NOP
63:            	}
1CEE0  0EFC     MOVLW 0xFC
1CEE2  50E3     MOVF 0xFE3, W, ACCESS
1CEE4  0F01     ADDLW 0x1
1CEE6  6E01     MOVWF __ptext283, ACCESS
1CEE8  0EFC     MOVLW 0xFC
1CEEA  0061     MOVFFL ltemp0, PLUSW1
1CEEC  F404     NOP
1CEEE  F4E3     NOP
1CEF0  6A01     CLRF __ptext283, ACCESS
1CEF2  0EFD     MOVLW 0xFD
1CEF4  50E3     MOVF 0xFE3, W, ACCESS
1CEF6  2001     ADDWFC __ptext283, W, ACCESS
1CEF8  6E01     MOVWF __ptext283, ACCESS
1CEFA  0EFD     MOVLW 0xFD
1CEFC  0061     MOVFFL ltemp0, PLUSW1
1CEFE  F404     NOP
1CF00  F4E3     NOP
1CF02  0EFD     MOVLW 0xFD
1CF04  50E3     MOVF 0xFE3, W, ACCESS
1CF06  E108     BNZ 0xCF18
1CF08  0EFC     MOVLW 0xFC
1CF0A  0061     MOVFFL PLUSW1, ltemp0
1CF0C  F38C     NOP
1CF0E  F501     NOP
1CF10  0E44     MOVLW 0x44
1CF12  5E01     SUBWF __ptext283, F, ACCESS
1CF14  A0D8     BTFSS 0xFD8, 0, ACCESS
1CF16  D7C5     BRA 0xCEA2
64:            }
1CF18  0EFA     MOVLW 0xFA
1CF18  0EFA     MOVLW 0xFA
1CF18  0EFA     MOVLW 0xFA
1CF18  0EFA     MOVLW 0xFA
1CF18  0EFA     MOVLW 0xFA
65:            
66:            /*
67:             * update energy values and
68:             * READ commands from the logging serial port
69:             * F top-off bank energy to MAX
70:             */
71:            void get_bm_data(EB_data * EB)
1372E  0E17     MOVLW 0x17
13730  26E1     ADDWF 0xFE1, F, ACCESS
13732  0E00     MOVLW 0x0
13734  22E2     ADDWFC 0xFE2, F, ACCESS
72:            {
73:            	uint8_t rxData = 0;
74:            	char s_buffer[22];
75:            
76:            	EB->ENac = (float) em.vl1l2 / 10.0f;
13736  0E00     MOVLW 0x0
13738  6EE6     MOVWF 0xFE6, ACCESS
1373A  0E00     MOVLW 0x0
1373C  6EE6     MOVWF 0xFE6, ACCESS
1373E  0E20     MOVLW 0x20
13740  6EE6     MOVWF 0xFE6, ACCESS
13742  0E41     MOVLW 0x41
13744  6EE6     MOVWF 0xFE6, ACCESS
13746  C673     MOVFF 0x673, POSTINC1
13748  F4E6     NOP
1374A  C674     MOVFF 0x674, POSTINC1
1374C  F4E6     NOP
1374E  C675     MOVFF 0x675, POSTINC1
13750  F4E6     NOP
13752  C676     MOVFF 0x676, POSTINC1
13754  F4E6     NOP
13756  0E01     MOVLW 0x1
13758  6EE6     MOVWF 0xFE6, ACCESS
1375A  EC35     CALL 0x1BA6A, 0
1375C  F0DD     NOP
1375E  0061     MOVFFL ltemp0, POSTINC1
13760  F404     NOP
13762  F4E6     NOP
13764  0061     MOVFFL ttemp5, POSTINC1
13766  F408     NOP
13768  F4E6     NOP
1376A  0061     MOVFFL wtemp1, POSTINC1
1376C  F40C     NOP
1376E  F4E6     NOP
13770  0061     MOVFFL ttemp1, POSTINC1
13772  F410     NOP
13774  F4E6     NOP
13776  ECD2     CALL 0x187A4, 0
13778  F0C3     NOP
1377A  0EE7     MOVLW 0xE7
1377C  0061     MOVFFL PLUSW1, wtemp5
1377E  F38C     NOP
13780  F50B     NOP
13782  0EE8     MOVLW 0xE8
13784  0061     MOVFFL PLUSW1, 0x50C
13786  F38C     NOP
13788  F50C     NOP
1378A  0E20     MOVLW 0x20
1378C  240B     ADDWF 0xB, W, ACCESS
1378E  6ED9     MOVWF 0xFD9, ACCESS
13790  0E00     MOVLW 0x0
13792  200C     ADDWFC 0xC, W, ACCESS
13794  6EDA     MOVWF __end_of_UART2_tx_vect_isr, ACCESS
13796  0061     MOVFFL ltemp0, POSTINC2
13798  F404     NOP
1379A  F4DE     NOP
1379C  0061     MOVFFL ttemp5, POSTINC2
1379E  F408     NOP
137A0  F4DE     NOP
137A2  0061     MOVFFL wtemp1, POSTINC2
137A4  F40C     NOP
137A6  F4DE     NOP
137A8  0061     MOVFFL ttemp1, POSTINC2
137AA  F410     NOP
137AC  F4DE     NOP
77:            	EB->ENva = (float) em.val1 / 10.0f;
137AE  0E00     MOVLW 0x0
137B0  6EE6     MOVWF 0xFE6, ACCESS
137B2  0E00     MOVLW 0x0
137B4  6EE6     MOVWF 0xFE6, ACCESS
137B6  0E20     MOVLW 0x20
137B8  6EE6     MOVWF 0xFE6, ACCESS
137BA  0E41     MOVLW 0x41
137BC  6EE6     MOVWF 0xFE6, ACCESS
137BE  C697     MOVFF 0x697, POSTINC1
137C0  F4E6     NOP
137C2  C698     MOVFF 0x698, POSTINC1
137C4  F4E6     NOP
137C6  C699     MOVFF 0x699, POSTINC1
137C8  F4E6     NOP
137CA  C69A     MOVFF 0x69A, POSTINC1
137CC  F4E6     NOP
137CE  0E01     MOVLW 0x1
137D0  6EE6     MOVWF 0xFE6, ACCESS
137D2  EC35     CALL 0x1BA6A, 0
137D4  F0DD     NOP
137D6  0061     MOVFFL ltemp0, POSTINC1
137D8  F404     NOP
137DA  F4E6     NOP
137DC  0061     MOVFFL ttemp5, POSTINC1
137DE  F408     NOP
137E0  F4E6     NOP
137E2  0061     MOVFFL wtemp1, POSTINC1
137E4  F40C     NOP
137E6  F4E6     NOP
137E8  0061     MOVFFL ttemp1, POSTINC1
137EA  F410     NOP
137EC  F4E6     NOP
137EE  ECD2     CALL 0x187A4, 0
137F0  F0C3     NOP
137F2  0EE7     MOVLW 0xE7
137F4  0061     MOVFFL PLUSW1, wtemp5
137F6  F38C     NOP
137F8  F50B     NOP
137FA  0EE8     MOVLW 0xE8
137FC  0061     MOVFFL PLUSW1, 0x50C
137FE  F38C     NOP
13800  F50C     NOP
13802  0E18     MOVLW 0x18
13804  240B     ADDWF 0xB, W, ACCESS
13806  6ED9     MOVWF 0xFD9, ACCESS
13808  0E00     MOVLW 0x0
1380A  200C     ADDWFC 0xC, W, ACCESS
1380C  6EDA     MOVWF __end_of_UART2_tx_vect_isr, ACCESS
1380E  0061     MOVFFL ltemp0, POSTINC2
13810  F404     NOP
13812  F4DE     NOP
13814  0061     MOVFFL ttemp5, POSTINC2
13816  F408     NOP
13818  F4DE     NOP
1381A  0061     MOVFFL wtemp1, POSTINC2
1381C  F40C     NOP
1381E  F4DE     NOP
13820  0061     MOVFFL ttemp1, POSTINC2
13822  F410     NOP
13824  F4DE     NOP
78:            	EB->ENw = (float) em.wl1 / 10.0f;
13826  0E00     MOVLW 0x0
13828  6EE6     MOVWF 0xFE6, ACCESS
1382A  0E00     MOVLW 0x0
1382C  6EE6     MOVWF 0xFE6, ACCESS
1382E  0E20     MOVLW 0x20
13830  6EE6     MOVWF 0xFE6, ACCESS
13832  0E41     MOVLW 0x41
13834  6EE6     MOVWF 0xFE6, ACCESS
13836  C68B     MOVFF 0x68B, POSTINC1
13838  F4E6     NOP
1383A  C68C     MOVFF 0x68C, POSTINC1
1383C  F4E6     NOP
1383E  C68D     MOVFF 0x68D, POSTINC1
13840  F4E6     NOP
13842  C68E     MOVFF 0x68E, POSTINC1
13844  F4E6     NOP
13846  0E01     MOVLW 0x1
13848  6EE6     MOVWF 0xFE6, ACCESS
1384A  EC35     CALL 0x1BA6A, 0
1384C  F0DD     NOP
1384E  0061     MOVFFL ltemp0, POSTINC1
13850  F404     NOP
13852  F4E6     NOP
13854  0061     MOVFFL ttemp5, POSTINC1
13856  F408     NOP
13858  F4E6     NOP
1385A  0061     MOVFFL wtemp1, POSTINC1
1385C  F40C     NOP
1385E  F4E6     NOP
13860  0061     MOVFFL ttemp1, POSTINC1
13862  F410     NOP
13864  F4E6     NOP
13866  ECD2     CALL 0x187A4, 0
13868  F0C3     NOP
1386A  0EE7     MOVLW 0xE7
1386C  0061     MOVFFL PLUSW1, wtemp5
1386E  F38C     NOP
13870  F50B     NOP
13872  0EE8     MOVLW 0xE8
13874  0061     MOVFFL PLUSW1, 0x50C
13876  F38C     NOP
13878  F50C     NOP
1387A  0E14     MOVLW 0x14
1387C  240B     ADDWF 0xB, W, ACCESS
1387E  6ED9     MOVWF 0xFD9, ACCESS
13880  0E00     MOVLW 0x0
13882  200C     ADDWFC 0xC, W, ACCESS
13884  6EDA     MOVWF __end_of_UART2_tx_vect_isr, ACCESS
13886  0061     MOVFFL ltemp0, POSTINC2
13888  F404     NOP
1388A  F4DE     NOP
1388C  0061     MOVFFL ttemp5, POSTINC2
1388E  F408     NOP
13890  F4DE     NOP
13892  0061     MOVFFL wtemp1, POSTINC2
13894  F40C     NOP
13896  F4DE     NOP
13898  0061     MOVFFL ttemp1, POSTINC2
1389A  F410     NOP
1389C  F4DE     NOP
79:            	EB->ENvar = (float) em.varl1 / 10.0f;
1389E  0E00     MOVLW 0x0
138A0  6EE6     MOVWF 0xFE6, ACCESS
138A2  0E00     MOVLW 0x0
138A4  6EE6     MOVWF 0xFE6, ACCESS
138A6  0E20     MOVLW 0x20
138A8  6EE6     MOVWF 0xFE6, ACCESS
138AA  0E41     MOVLW 0x41
138AC  6EE6     MOVWF 0xFE6, ACCESS
138AE  C6A3     MOVFF 0x6A3, POSTINC1
138B0  F4E6     NOP
138B2  C6A4     MOVFF 0x6A4, POSTINC1
138B4  F4E6     NOP
138B6  C6A5     MOVFF 0x6A5, POSTINC1
138B8  F4E6     NOP
138BA  C6A6     MOVFF 0x6A6, POSTINC1
138BC  F4E6     NOP
138BE  0E01     MOVLW 0x1
138C0  6EE6     MOVWF 0xFE6, ACCESS
138C2  EC35     CALL 0x1BA6A, 0
138C4  F0DD     NOP
138C6  0061     MOVFFL ltemp0, POSTINC1
138C8  F404     NOP
138CA  F4E6     NOP
138CC  0061     MOVFFL ttemp5, POSTINC1
138CE  F408     NOP
138D0  F4E6     NOP
138D2  0061     MOVFFL wtemp1, POSTINC1
138D4  F40C     NOP
138D6  F4E6     NOP
138D8  0061     MOVFFL ttemp1, POSTINC1
138DA  F410     NOP
138DC  F4E6     NOP
138DE  ECD2     CALL 0x187A4, 0
138E0  F0C3     NOP
138E2  0EE7     MOVLW 0xE7
138E4  0061     MOVFFL PLUSW1, wtemp5
138E6  F38C     NOP
138E8  F50B     NOP
138EA  0EE8     MOVLW 0xE8
138EC  0061     MOVFFL PLUSW1, 0x50C
138EE  F38C     NOP
138F0  F50C     NOP
138F2  0E1C     MOVLW 0x1C
138F4  240B     ADDWF 0xB, W, ACCESS
138F6  6ED9     MOVWF 0xFD9, ACCESS
138F8  0E00     MOVLW 0x0
138FA  200C     ADDWFC 0xC, W, ACCESS
138FC  6EDA     MOVWF __end_of_UART2_tx_vect_isr, ACCESS
138FE  0061     MOVFFL ltemp0, POSTINC2
13900  F404     NOP
13902  F4DE     NOP
13904  0061     MOVFFL ttemp5, POSTINC2
13906  F408     NOP
13908  F4DE     NOP
1390A  0061     MOVFFL wtemp1, POSTINC2
1390C  F40C     NOP
1390E  F4DE     NOP
13910  0061     MOVFFL ttemp1, POSTINC2
13912  F410     NOP
13914  F4DE     NOP
80:            	EB->FMw = (float) panel_watts;
13916  0105     MOVLB 0x5
13918  51D5     MOVF CLCSELECT, W, BANKED
1391A  6E09     MOVWF 0x9, ACCESS
1391C  51D6     MOVF CLCnCON, W, BANKED
1391E  6E0A     MOVWF 0xA, ACCESS
13920  6A0B     CLRF 0xB, ACCESS
13922  6A0C     CLRF 0xC, ACCESS
13924  0061     MOVFFL ltemp2, POSTINC1
13926  F424     NOP
13928  F4E6     NOP
1392A  0061     MOVFFL ttemp3, POSTINC1
1392C  F428     NOP
1392E  F4E6     NOP
13930  0061     MOVFFL wtemp5, POSTINC1
13932  F42C     NOP
13934  F4E6     NOP
13936  0061     MOVFFL 0x50C, POSTINC1
13938  F430     NOP
1393A  F4E6     NOP
1393C  0E00     MOVLW 0x0
1393E  6EE6     MOVWF 0xFE6, ACCESS
13940  EC35     CALL 0x1BA6A, 0
13942  F0DD     NOP
13944  0EE7     MOVLW 0xE7
13946  0061     MOVFFL PLUSW1, wtemp5
13948  F38C     NOP
1394A  F50B     NOP
1394C  0EE8     MOVLW 0xE8
1394E  0061     MOVFFL PLUSW1, 0x50C
13950  F38C     NOP
13952  F50C     NOP
13954  0E04     MOVLW 0x4
13956  240B     ADDWF 0xB, W, ACCESS
13958  6ED9     MOVWF 0xFD9, ACCESS
1395A  0E00     MOVLW 0x0
1395C  200C     ADDWFC 0xC, W, ACCESS
1395E  6EDA     MOVWF __end_of_UART2_tx_vect_isr, ACCESS
13960  0061     MOVFFL ltemp0, POSTINC2
13962  F404     NOP
13964  F4DE     NOP
13966  0061     MOVFFL ttemp5, POSTINC2
13968  F408     NOP
1396A  F4DE     NOP
1396C  0061     MOVFFL wtemp1, POSTINC2
1396E  F40C     NOP
13970  F4DE     NOP
13972  0061     MOVFFL ttemp1, POSTINC2
13974  F410     NOP
13976  F4DE     NOP
81:            	EB->FMpv = (float) volt_whole;
13978  0105     MOVLB 0x5
1397A  51D9     MOVF CLCnSEL1, W, BANKED
1397C  6E09     MOVWF 0x9, ACCESS
1397E  51DA     MOVF CLCnSEL2, W, BANKED
13980  6E0A     MOVWF 0xA, ACCESS
13982  6A0B     CLRF 0xB, ACCESS
13984  6A0C     CLRF 0xC, ACCESS
13986  0061     MOVFFL ltemp2, POSTINC1
13988  F424     NOP
1398A  F4E6     NOP
1398C  0061     MOVFFL ttemp3, POSTINC1
1398E  F428     NOP
13990  F4E6     NOP
13992  0061     MOVFFL wtemp5, POSTINC1
13994  F42C     NOP
13996  F4E6     NOP
13998  0061     MOVFFL 0x50C, POSTINC1
1399A  F430     NOP
1399C  F4E6     NOP
1399E  0E00     MOVLW 0x0
139A0  6EE6     MOVWF 0xFE6, ACCESS
139A2  EC35     CALL 0x1BA6A, 0
139A4  F0DD     NOP
139A6  0EE7     MOVLW 0xE7
139A8  0061     MOVFFL PLUSW1, wtemp5
139AA  F38C     NOP
139AC  F50B     NOP
139AE  0EE8     MOVLW 0xE8
139B0  0061     MOVFFL PLUSW1, 0x50C
139B2  F38C     NOP
139B4  F50C     NOP
139B6  0E08     MOVLW 0x8
139B8  240B     ADDWF 0xB, W, ACCESS
139BA  6ED9     MOVWF 0xFD9, ACCESS
139BC  0E00     MOVLW 0x0
139BE  200C     ADDWFC 0xC, W, ACCESS
139C0  6EDA     MOVWF __end_of_UART2_tx_vect_isr, ACCESS
139C2  0061     MOVFFL ltemp0, POSTINC2
139C4  F404     NOP
139C6  F4DE     NOP
139C8  0061     MOVFFL ttemp5, POSTINC2
139CA  F408     NOP
139CC  F4DE     NOP
139CE  0061     MOVFFL wtemp1, POSTINC2
139D0  F40C     NOP
139D2  F4DE     NOP
139D4  0061     MOVFFL ttemp1, POSTINC2
139D6  F410     NOP
139D8  F4DE     NOP
82:            	EB->cc_mode = cc_mode;
139DA  0EE7     MOVLW 0xE7
139DC  0061     MOVFFL PLUSW1, wtemp5
139DE  F38C     NOP
139E0  F50B     NOP
139E2  0EE8     MOVLW 0xE8
139E4  0061     MOVFFL PLUSW1, 0x50C
139E6  F38C     NOP
139E8  F50C     NOP
139EA  0E30     MOVLW 0x30
139EC  240B     ADDWF 0xB, W, ACCESS
139EE  6ED9     MOVWF 0xFD9, ACCESS
139F0  0E00     MOVLW 0x0
139F2  200C     ADDWFC 0xC, W, ACCESS
139F4  6EDA     MOVWF __end_of_UART2_tx_vect_isr, ACCESS
139F6  C54B     MOVFF cc_mode, POSTINC2
139F8  F4DE     NOP
139FA  C54C     MOVFF 0x54C, POSTDEC2
139FC  F4DD     NOP
83:            	EB->bat_amp_whole = (float) bat_amp_whole;
139FE  0105     MOVLB 0x5
13A00  51D7     MOVF CLCnPOL, W, BANKED
13A02  6E09     MOVWF 0x9, ACCESS
13A04  51D8     MOVF CLCnSEL0, W, BANKED
13A06  6E0A     MOVWF 0xA, ACCESS
13A08  6A0B     CLRF 0xB, ACCESS
13A0A  6A0C     CLRF 0xC, ACCESS
13A0C  0061     MOVFFL ltemp2, POSTINC1
13A0E  F424     NOP
13A10  F4E6     NOP
13A12  0061     MOVFFL ttemp3, POSTINC1
13A14  F428     NOP
13A16  F4E6     NOP
13A18  0061     MOVFFL wtemp5, POSTINC1
13A1A  F42C     NOP
13A1C  F4E6     NOP
13A1E  0061     MOVFFL 0x50C, POSTINC1
13A20  F430     NOP
13A22  F4E6     NOP
13A24  0E00     MOVLW 0x0
13A26  6EE6     MOVWF 0xFE6, ACCESS
13A28  EC35     CALL 0x1BA6A, 0
13A2A  F0DD     NOP
13A2C  0EE7     MOVLW 0xE7
13A2E  0061     MOVFFL PLUSW1, wtemp5
13A30  F38C     NOP
13A32  F50B     NOP
13A34  0EE8     MOVLW 0xE8
13A36  0061     MOVFFL PLUSW1, 0x50C
13A38  F38C     NOP
13A3A  F50C     NOP
13A3C  0E28     MOVLW 0x28
13A3E  240B     ADDWF 0xB, W, ACCESS
13A40  6ED9     MOVWF 0xFD9, ACCESS
13A42  0E00     MOVLW 0x0
13A44  200C     ADDWFC 0xC, W, ACCESS
13A46  6EDA     MOVWF __end_of_UART2_tx_vect_isr, ACCESS
13A48  0061     MOVFFL ltemp0, POSTINC2
13A4A  F404     NOP
13A4C  F4DE     NOP
13A4E  0061     MOVFFL ttemp5, POSTINC2
13A50  F408     NOP
13A52  F4DE     NOP
13A54  0061     MOVFFL wtemp1, POSTINC2
13A56  F40C     NOP
13A58  F4DE     NOP
13A5A  0061     MOVFFL ttemp1, POSTINC2
13A5C  F410     NOP
13A5E  F4DE     NOP
84:            	EB->volt_whole = (float) vw;
13A60  0105     MOVLB 0x5
13A62  51CF     MOVF 0xCF, W, BANKED
13A64  6E09     MOVWF 0x9, ACCESS
13A66  51D0     MOVF 0xD0, W, BANKED
13A68  6E0A     MOVWF 0xA, ACCESS
13A6A  6A0B     CLRF 0xB, ACCESS
13A6C  6A0C     CLRF 0xC, ACCESS
13A6E  0061     MOVFFL ltemp2, POSTINC1
13A70  F424     NOP
13A72  F4E6     NOP
13A74  0061     MOVFFL ttemp3, POSTINC1
13A76  F428     NOP
13A78  F4E6     NOP
13A7A  0061     MOVFFL wtemp5, POSTINC1
13A7C  F42C     NOP
13A7E  F4E6     NOP
13A80  0061     MOVFFL 0x50C, POSTINC1
13A82  F430     NOP
13A84  F4E6     NOP
13A86  0E00     MOVLW 0x0
13A88  6EE6     MOVWF 0xFE6, ACCESS
13A8A  EC35     CALL 0x1BA6A, 0
13A8C  F0DD     NOP
13A8E  0EE7     MOVLW 0xE7
13A90  0061     MOVFFL PLUSW1, wtemp5
13A92  F38C     NOP
13A94  F50B     NOP
13A96  0EE8     MOVLW 0xE8
13A98  0061     MOVFFL PLUSW1, 0x50C
13A9A  F38C     NOP
13A9C  F50C     NOP
13A9E  0E24     MOVLW 0x24
13AA0  240B     ADDWF 0xB, W, ACCESS
13AA2  6ED9     MOVWF 0xFD9, ACCESS
13AA4  0E00     MOVLW 0x0
13AA6  200C     ADDWFC 0xC, W, ACCESS
13AA8  6EDA     MOVWF __end_of_UART2_tx_vect_isr, ACCESS
13AAA  0061     MOVFFL ltemp0, POSTINC2
13AAC  F404     NOP
13AAE  F4DE     NOP
13AB0  0061     MOVFFL ttemp5, POSTINC2
13AB2  F408     NOP
13AB4  F4DE     NOP
13AB6  0061     MOVFFL wtemp1, POSTINC2
13AB8  F40C     NOP
13ABA  F4DE     NOP
13ABC  0061     MOVFFL ttemp1, POSTINC2
13ABE  F410     NOP
13AC0  F4DE     NOP
85:            	/*
86:            	 * check for commands using the logging serial port
87:            	 * 'F' FULL,	reset battery energy to max and increase one battery charge cycle
88:            	 */
89:            	if (UART2_is_rx_ready()) {
13AC2  EC39     CALL 0x2672, 0
13AC4  F013     NOP
13AC6  5001     MOVF __ptext283, W, ACCESS
13AC8  B4D8     BTFSC 0xFD8, 2, ACCESS
13ACA  EF07     GOTO 0x1460E
13ACC  F0A3     NOP
90:            		rxData = UART2_Read();
13ACE  EC8E     CALL 0x131C, 0
13AD0  F009     NOP
13AD2  0EFF     MOVLW 0xFF
13AD4  0061     MOVFFL ltemp0, PLUSW1
13AD6  F404     NOP
13AD8  F4E3     NOP
91:            		switch (rxData) {
13ADA  EFC0     GOTO 0x14580
13ADC  F0A2     NOP
92:            		case 'A': // alternative data display for rows 2 and 3
93:            			B.alt_display = MAX_ALT_DIS;
13ADE  0E03     MOVLW 0x3
13AE0  0105     MOVLB 0x5
13AE2  6F73     MOVWF CM1PCH, BANKED
94:            		case 'a':
95:            			B.alt_display++;
13AE4  0105     MOVLB 0x5
13AE6  2B73     INCF CM1PCH, F, BANKED
96:            			if (B.alt_display > MAX_ALT_DIS) {
13AE8  0E03     MOVLW 0x3
13AEA  6573     CPFSGT CM1PCH, BANKED
13AEC  D001     BRA 0x3AF0
97:            				B.alt_display = 0;
13AEE  6B73     CLRF CM1PCH, BANKED
98:            			}
99:            			EB->alt_display = B.alt_display;
13AF0  0EE7     MOVLW 0xE7
13AF2  0061     MOVFFL PLUSW1, wtemp5
13AF4  F38C     NOP
13AF6  F50B     NOP
13AF8  0EE8     MOVLW 0xE8
13AFA  0061     MOVFFL PLUSW1, 0x50C
13AFC  F38C     NOP
13AFE  F50C     NOP
13B00  0E02     MOVLW 0x2
13B02  240B     ADDWF 0xB, W, ACCESS
13B04  6ED9     MOVWF 0xFD9, ACCESS
13B06  0E00     MOVLW 0x0
13B08  200C     ADDWFC 0xC, W, ACCESS
13B0A  6EDA     MOVWF __end_of_UART2_tx_vect_isr, ACCESS
13B0C  C573     MOVFF 0x573, INDF2
13B0E  F4DF     NOP
100:           			break;
13B10  EF07     GOTO 0x1460E
13B12  F0A3     NOP
101:           		case 'D': // display time
102:           		case 'd':
103:           			snprintf(s_buffer, 21, "%s", asctime(can_newtime));
13B14  C5CD     MOVFF can_newtime, POSTINC1
13B16  F4E6     NOP
13B18  C5CE     MOVFF 0x5CE, POSTINC1
13B1A  F4E6     NOP
13B1C  EC8D     CALL 0x18D1A, 0
13B1E  F0C6     NOP
13B20  0061     MOVFFL ltemp0, POSTINC1
13B22  F404     NOP
13B24  F4E6     NOP
13B26  0061     MOVFFL ttemp5, POSTINC1
13B28  F408     NOP
13B2A  F4E6     NOP
13B2C  0EFB     MOVLW 0xFB
13B2E  6EE6     MOVWF 0xFE6, ACCESS
13B30  0EFF     MOVLW 0xFF
13B32  6EE6     MOVWF 0xFE6, ACCESS
13B34  0E15     MOVLW 0x15
13B36  6EE6     MOVWF 0xFE6, ACCESS
13B38  0E00     MOVLW 0x0
13B3A  6EE6     MOVWF 0xFE6, ACCESS
13B3C  0EE3     MOVLW 0xE3
13B3E  24E1     ADDWF 0xFE1, W, ACCESS
13B40  6E01     MOVWF __ptext283, ACCESS
13B42  0EFF     MOVLW 0xFF
13B44  20E2     ADDWFC 0xFE2, W, ACCESS
13B46  6E02     MOVWF ___rparam_used, ACCESS
13B48  0061     MOVFFL ltemp0, POSTINC1
13B4A  F404     NOP
13B4C  F4E6     NOP
13B4E  0061     MOVFFL ttemp5, POSTINC1
13B50  F408     NOP
13B52  F4E6     NOP
13B54  0E08     MOVLW 0x8
13B56  6EE6     MOVWF 0xFE6, ACCESS
13B58  EC35     CALL 0x1C06A, 0
13B5A  F0E0     NOP
104:           			eaDogM_Scroll_String(s_buffer);
13B5C  0EE9     MOVLW 0xE9
13B5E  24E1     ADDWF 0xFE1, W, ACCESS
13B60  6E01     MOVWF __ptext283, ACCESS
13B62  0EFF     MOVLW 0xFF
13B64  20E2     ADDWFC 0xFE2, W, ACCESS
13B66  6E02     MOVWF ___rparam_used, ACCESS
13B68  0061     MOVFFL ltemp0, POSTINC1
13B6A  F404     NOP
13B6C  F4E6     NOP
13B6E  0061     MOVFFL ttemp5, POSTINC1
13B70  F408     NOP
13B72  F4E6     NOP
13B74  ECB1     CALL 0x1FF62, 0
13B76  F0FF     NOP
105:           			break;
13B78  EF07     GOTO 0x1460E
13B7A  F0A3     NOP
106:           		case 'f': // set energy to Full
107:           		case 'F':
108:           			EB->bat_energy = BAT_ENERGY;
13B7C  0EE7     MOVLW 0xE7
13B7E  0061     MOVFFL PLUSW1, wtemp5
13B80  F38C     NOP
13B82  F50B     NOP
13B84  0EE8     MOVLW 0xE8
13B86  0061     MOVFFL PLUSW1, 0x50C
13B88  F38C     NOP
13B8A  F50C     NOP
13B8C  0E2C     MOVLW 0x2C
13B8E  240B     ADDWF 0xB, W, ACCESS
13B90  6ED9     MOVWF 0xFD9, ACCESS
13B92  0E00     MOVLW 0x0
13B94  200C     ADDWFC 0xC, W, ACCESS
13B96  6EDA     MOVWF __end_of_UART2_tx_vect_isr, ACCESS
13B98  0E00     MOVLW 0x0
13B9A  6EDE     MOVWF 0xFDE, ACCESS
13B9C  0E00     MOVLW 0x0
13B9E  6EDE     MOVWF 0xFDE, ACCESS
13BA0  0EE1     MOVLW 0xE1
13BA2  6EDE     MOVWF 0xFDE, ACCESS
13BA4  0E49     MOVLW 0x49
13BA6  D015     BRA 0x3BD2
109:           			EB->bat_cycles++;
110:           			break;
111:           		case 'e': // set energy to Empty
112:           		case 'E':
113:           			EB->bat_energy = 1;
13BA8  0EE7     MOVLW 0xE7
13BAA  0061     MOVFFL PLUSW1, wtemp5
13BAC  F38C     NOP
13BAE  F50B     NOP
13BB0  0EE8     MOVLW 0xE8
13BB2  0061     MOVFFL PLUSW1, 0x50C
13BB4  F38C     NOP
13BB6  F50C     NOP
13BB8  0E2C     MOVLW 0x2C
13BBA  240B     ADDWF 0xB, W, ACCESS
13BBC  6ED9     MOVWF 0xFD9, ACCESS
13BBE  0E00     MOVLW 0x0
13BC0  200C     ADDWFC 0xC, W, ACCESS
13BC2  6EDA     MOVWF __end_of_UART2_tx_vect_isr, ACCESS
13BC4  0E00     MOVLW 0x0
13BC6  6EDE     MOVWF 0xFDE, ACCESS
13BC8  0E00     MOVLW 0x0
13BCA  6EDE     MOVWF 0xFDE, ACCESS
13BCC  0E80     MOVLW 0x80
13BCE  6EDE     MOVWF 0xFDE, ACCESS
13BD0  0E3F     MOVLW 0x3F
13BD2  6EDD     MOVWF 0xFDD, ACCESS
114:           			EB->bat_cycles++;
13BD4  0EE7     MOVLW 0xE7
13BD6  0061     MOVFFL PLUSW1, wtemp5
13BD8  F38C     NOP
13BDA  F50B     NOP
13BDC  0EE8     MOVLW 0xE8
13BDE  0061     MOVFFL PLUSW1, 0x50C
13BE0  F38C     NOP
13BE2  F50C     NOP
13BE4  0E32     MOVLW 0x32
13BE6  240B     ADDWF 0xB, W, ACCESS
13BE8  6ED9     MOVWF 0xFD9, ACCESS
13BEA  0E00     MOVLW 0x0
13BEC  200C     ADDWFC 0xC, W, ACCESS
13BEE  6EDA     MOVWF __end_of_UART2_tx_vect_isr, ACCESS
13BF0  2ADE     INCF 0xFDE, F, ACCESS
13BF2  0E00     MOVLW 0x0
13BF4  22DD     ADDWFC 0xFDD, F, ACCESS
115:           			break;
13BF6  EF07     GOTO 0x1460E
13BF8  F0A3     NOP
116:           		case 'i': // start Info scroll on display
117:           		case 'I':
118:           			snprintf(s_buffer, 21, "%s %u                  ", ems.serial, ems.year);
13BFA  C6DD     MOVFF 0x6DD, POSTINC1
13BFC  F4E6     NOP
13BFE  C6DE     MOVFF 0x6DE, POSTINC1
13C00  F4E6     NOP
13C02  0ECF     MOVLW 0xCF
13C04  6EE6     MOVWF 0xFE6, ACCESS
13C06  0E06     MOVLW 0x6
13C08  6EE6     MOVWF 0xFE6, ACCESS
13C0A  0E5E     MOVLW 0x5E
13C0C  6EE6     MOVWF 0xFE6, ACCESS
13C0E  0EFE     MOVLW 0xFE
13C10  6EE6     MOVWF 0xFE6, ACCESS
13C12  0E15     MOVLW 0x15
13C14  6EE6     MOVWF 0xFE6, ACCESS
13C16  0E00     MOVLW 0x0
13C18  6EE6     MOVWF 0xFE6, ACCESS
13C1A  0EE1     MOVLW 0xE1
13C1C  24E1     ADDWF 0xFE1, W, ACCESS
13C1E  6E01     MOVWF __ptext283, ACCESS
13C20  0EFF     MOVLW 0xFF
13C22  20E2     ADDWFC 0xFE2, W, ACCESS
13C24  6E02     MOVWF ___rparam_used, ACCESS
13C26  0061     MOVFFL ltemp0, POSTINC1
13C28  F404     NOP
13C2A  F4E6     NOP
13C2C  0061     MOVFFL ttemp5, POSTINC1
13C2E  F408     NOP
13C30  F4E6     NOP
13C32  0E0A     MOVLW 0xA
13C34  6EE6     MOVWF 0xFE6, ACCESS
13C36  EC35     CALL 0x1C06A, 0
13C38  F0E0     NOP
119:           			eaDogM_Scroll_String(s_buffer);
13C3A  0EE9     MOVLW 0xE9
13C3C  24E1     ADDWF 0xFE1, W, ACCESS
13C3E  6E01     MOVWF __ptext283, ACCESS
13C40  0EFF     MOVLW 0xFF
13C42  20E2     ADDWFC 0xFE2, W, ACCESS
13C44  6E02     MOVWF ___rparam_used, ACCESS
13C46  0061     MOVFFL ltemp0, POSTINC1
13C48  F404     NOP
13C4A  F4E6     NOP
13C4C  0061     MOVFFL ttemp5, POSTINC1
13C4E  F408     NOP
13C50  F4E6     NOP
13C52  ECB1     CALL 0x1FF62, 0
13C54  F0FF     NOP
120:           			snprintf(s_buffer, 21, "0X%X                   ", emv.firmware);
13C56  C537     MOVFF emv, POSTINC1
13C58  F4E6     NOP
13C5A  C538     MOVFF 0x538, POSTINC1
13C5C  F4E6     NOP
13C5E  0E46     MOVLW 0x46
13C60  6EE6     MOVWF 0xFE6, ACCESS
13C62  0EFE     MOVLW 0xFE
13C64  6EE6     MOVWF 0xFE6, ACCESS
13C66  0E15     MOVLW 0x15
13C68  6EE6     MOVWF 0xFE6, ACCESS
13C6A  0E00     MOVLW 0x0
13C6C  6EE6     MOVWF 0xFE6, ACCESS
13C6E  0EE3     MOVLW 0xE3
13C70  24E1     ADDWF 0xFE1, W, ACCESS
13C72  6E01     MOVWF __ptext283, ACCESS
13C74  0EFF     MOVLW 0xFF
13C76  20E2     ADDWFC 0xFE2, W, ACCESS
13C78  6E02     MOVWF ___rparam_used, ACCESS
13C7A  0061     MOVFFL ltemp0, POSTINC1
13C7C  F404     NOP
13C7E  F4E6     NOP
13C80  0061     MOVFFL ttemp5, POSTINC1
13C82  F408     NOP
13C84  F4E6     NOP
13C86  0E08     MOVLW 0x8
13C88  6EE6     MOVWF 0xFE6, ACCESS
13C8A  EC35     CALL 0x1C06A, 0
13C8C  F0E0     NOP
121:           			eaDogM_Scroll_String(s_buffer);
13C8E  0EE9     MOVLW 0xE9
13C90  24E1     ADDWF 0xFE1, W, ACCESS
13C92  6E01     MOVWF __ptext283, ACCESS
13C94  0EFF     MOVLW 0xFF
13C96  20E2     ADDWFC 0xFE2, W, ACCESS
13C98  6E02     MOVWF ___rparam_used, ACCESS
13C9A  0061     MOVFFL ltemp0, POSTINC1
13C9C  F404     NOP
13C9E  F4E6     NOP
13CA0  0061     MOVFFL ttemp5, POSTINC1
13CA2  F408     NOP
13CA4  F4E6     NOP
13CA6  ECB1     CALL 0x1FF62, 0
13CA8  F0FF     NOP
122:           			snprintf(s_buffer, 21, "0X%X%X%X%X%X%X%X%X         ", B.mui[0], B.mui[1], B.mui[2], B.mui[3], B.mui[4], B.mui[5], B.mui[6], B.mui[7]);
13CAA  C58A     MOVFF 0x58A, POSTINC1
13CAC  F4E6     NOP
13CAE  C58B     MOVFF 0x58B, POSTINC1
13CB0  F4E6     NOP
13CB2  C588     MOVFF 0x588, POSTINC1
13CB4  F4E6     NOP
13CB6  C589     MOVFF 0x589, POSTINC1
13CB8  F4E6     NOP
13CBA  C586     MOVFF 0x586, POSTINC1
13CBC  F4E6     NOP
13CBE  C587     MOVFF 0x587, POSTINC1
13CC0  F4E6     NOP
13CC2  C584     MOVFF 0x584, POSTINC1
13CC4  F4E6     NOP
13CC6  C585     MOVFF 0x585, POSTINC1
13CC8  F4E6     NOP
13CCA  C582     MOVFF 0x582, POSTINC1
13CCC  F4E6     NOP
13CCE  C583     MOVFF 0x583, POSTINC1
13CD0  F4E6     NOP
13CD2  C580     MOVFF 0x580, POSTINC1
13CD4  F4E6     NOP
13CD6  C581     MOVFF 0x581, POSTINC1
13CD8  F4E6     NOP
13CDA  C57E     MOVFF 0x57E, POSTINC1
13CDC  F4E6     NOP
13CDE  C57F     MOVFF 0x57F, POSTINC1
13CE0  F4E6     NOP
13CE2  C57C     MOVFF 0x57C, POSTINC1
13CE4  F4E6     NOP
13CE6  C57D     MOVFF 0x57D, POSTINC1
13CE8  F4E6     NOP
13CEA  0E2A     MOVLW 0x2A
13CEC  6EE6     MOVWF 0xFE6, ACCESS
13CEE  0EFD     MOVLW 0xFD
13CF0  6EE6     MOVWF 0xFE6, ACCESS
13CF2  0E15     MOVLW 0x15
13CF4  6EE6     MOVWF 0xFE6, ACCESS
13CF6  0E00     MOVLW 0x0
13CF8  6EE6     MOVWF 0xFE6, ACCESS
13CFA  0ED5     MOVLW 0xD5
13CFC  24E1     ADDWF 0xFE1, W, ACCESS
13CFE  6E01     MOVWF __ptext283, ACCESS
13D00  0EFF     MOVLW 0xFF
13D02  20E2     ADDWFC 0xFE2, W, ACCESS
13D04  6E02     MOVWF ___rparam_used, ACCESS
13D06  0061     MOVFFL ltemp0, POSTINC1
13D08  F404     NOP
13D0A  F4E6     NOP
13D0C  0061     MOVFFL ttemp5, POSTINC1
13D0E  F408     NOP
13D10  F4E6     NOP
13D12  0E16     MOVLW 0x16
13D14  6EE6     MOVWF 0xFE6, ACCESS
13D16  EC35     CALL 0x1C06A, 0
13D18  F0E0     NOP
123:           			eaDogM_Scroll_String(s_buffer);
13D1A  0EE9     MOVLW 0xE9
13D1C  24E1     ADDWF 0xFE1, W, ACCESS
13D1E  6E01     MOVWF __ptext283, ACCESS
13D20  0EFF     MOVLW 0xFF
13D22  20E2     ADDWFC 0xFE2, W, ACCESS
13D24  6E02     MOVWF ___rparam_used, ACCESS
13D26  0061     MOVFFL ltemp0, POSTINC1
13D28  F404     NOP
13D2A  F4E6     NOP
13D2C  0061     MOVFFL ttemp5, POSTINC1
13D2E  F408     NOP
13D30  F4E6     NOP
13D32  ECB1     CALL 0x1FF62, 0
13D34  F0FF     NOP
124:           			snprintf(s_buffer, 21, "FM80 FW %X.%X.%X                ", B.fwrev[0], B.fwrev[1], B.fwrev[2]);
13D36  C594     MOVFF 0x594, POSTINC1
13D38  F4E6     NOP
13D3A  C595     MOVFF 0x595, POSTINC1
13D3C  F4E6     NOP
13D3E  C592     MOVFF 0x592, POSTINC1
13D40  F4E6     NOP
13D42  C593     MOVFF 0x593, POSTINC1
13D44  F4E6     NOP
13D46  C590     MOVFF 0x590, POSTINC1
13D48  F4E6     NOP
13D4A  C591     MOVFF 0x591, POSTINC1
13D4C  F4E6     NOP
13D4E  0ECE     MOVLW 0xCE
13D50  6EE6     MOVWF 0xFE6, ACCESS
13D52  0EFC     MOVLW 0xFC
13D54  6EE6     MOVWF 0xFE6, ACCESS
13D56  0E15     MOVLW 0x15
13D58  6EE6     MOVWF 0xFE6, ACCESS
13D5A  0E00     MOVLW 0x0
13D5C  6EE6     MOVWF 0xFE6, ACCESS
13D5E  0EDF     MOVLW 0xDF
13D60  24E1     ADDWF 0xFE1, W, ACCESS
13D62  6E01     MOVWF __ptext283, ACCESS
13D64  0EFF     MOVLW 0xFF
13D66  20E2     ADDWFC 0xFE2, W, ACCESS
13D68  6E02     MOVWF ___rparam_used, ACCESS
13D6A  0061     MOVFFL ltemp0, POSTINC1
13D6C  F404     NOP
13D6E  F4E6     NOP
13D70  0061     MOVFFL ttemp5, POSTINC1
13D72  F408     NOP
13D74  F4E6     NOP
13D76  0E0C     MOVLW 0xC
13D78  6EE6     MOVWF 0xFE6, ACCESS
13D7A  EC35     CALL 0x1C06A, 0
13D7C  F0E0     NOP
13D7E  D6EE     BRA 0x3B5C
125:           			eaDogM_Scroll_String(s_buffer);
126:           			break;
127:           		case 'R': // reset log data command state
128:           		case 'r':
129:           			B.log.select = 0;
13D80  0105     MOVLB 0x5
13D82  6BAA     CLRF 0xAA, BANKED
130:           		case 'L':// send day log date t logging serial port
131:           		case 'l':
132:           			B.log.select++; // pull the next days log data
13D84  0105     MOVLB 0x5
13D86  2BAA     INCF 0xAA, F, BANKED
133:           			snprintf(s_buffer, 21, "Pwr %5.2fkWpk %5.2fkWh              ", (float) B.log.kilowatts_peak / 1000.0, (float) B.log.kilowatt_hours / 10.0);
13D88  0E00     MOVLW 0x0
13D8A  6EE6     MOVWF 0xFE6, ACCESS
13D8C  0E00     MOVLW 0x0
13D8E  6EE6     MOVWF 0xFE6, ACCESS
13D90  0E20     MOVLW 0x20
13D92  6EE6     MOVWF 0xFE6, ACCESS
13D94  0E41     MOVLW 0x41
13D96  6EE6     MOVWF 0xFE6, ACCESS
13D98  0061     MOVFFL 0x59A, ltemp2
13D9A  F668     NOP
13D9C  F509     NOP
13D9E  0061     MOVFFL 0x59B, ttemp3
13DA0  F66C     NOP
13DA2  F50A     NOP
13DA4  0E00     MOVLW 0x0
13DA6  BE0A     BTFSC 0xA, 7, ACCESS
13DA8  0EFF     MOVLW 0xFF
13DAA  6E0B     MOVWF 0xB, ACCESS
13DAC  6E0C     MOVWF 0xC, ACCESS
13DAE  0061     MOVFFL ltemp2, POSTINC1
13DB0  F424     NOP
13DB2  F4E6     NOP
13DB4  0061     MOVFFL ttemp3, POSTINC1
13DB6  F428     NOP
13DB8  F4E6     NOP
13DBA  0061     MOVFFL wtemp5, POSTINC1
13DBC  F42C     NOP
13DBE  F4E6     NOP
13DC0  0061     MOVFFL 0x50C, POSTINC1
13DC2  F430     NOP
13DC4  F4E6     NOP
13DC6  0E01     MOVLW 0x1
13DC8  6EE6     MOVWF 0xFE6, ACCESS
13DCA  EC35     CALL 0x1BA6A, 0
13DCC  F0DD     NOP
13DCE  0061     MOVFFL ltemp0, POSTINC1
13DD0  F404     NOP
13DD2  F4E6     NOP
13DD4  0061     MOVFFL ttemp5, POSTINC1
13DD6  F408     NOP
13DD8  F4E6     NOP
13DDA  0061     MOVFFL wtemp1, POSTINC1
13DDC  F40C     NOP
13DDE  F4E6     NOP
13DE0  0061     MOVFFL ttemp1, POSTINC1
13DE2  F410     NOP
13DE4  F4E6     NOP
13DE6  ECD2     CALL 0x187A4, 0
13DE8  F0C3     NOP
13DEA  0061     MOVFFL ltemp0, POSTINC1
13DEC  F404     NOP
13DEE  F4E6     NOP
13DF0  0061     MOVFFL ttemp5, POSTINC1
13DF2  F408     NOP
13DF4  F4E6     NOP
13DF6  0061     MOVFFL wtemp1, POSTINC1
13DF8  F40C     NOP
13DFA  F4E6     NOP
13DFC  0061     MOVFFL ttemp1, POSTINC1
13DFE  F410     NOP
13E00  F4E6     NOP
13E02  0E00     MOVLW 0x0
13E04  6EE6     MOVWF 0xFE6, ACCESS
13E06  0E00     MOVLW 0x0
13E08  6EE6     MOVWF 0xFE6, ACCESS
13E0A  0E7A     MOVLW 0x7A
13E0C  6EE6     MOVWF 0xFE6, ACCESS
13E0E  0E44     MOVLW 0x44
13E10  6EE6     MOVWF 0xFE6, ACCESS
13E12  0061     MOVFFL 0x5A0, ltemp2
13E14  F680     NOP
13E16  F509     NOP
13E18  0061     MOVFFL 0x5A1, ttemp3
13E1A  F684     NOP
13E1C  F50A     NOP
13E1E  0E00     MOVLW 0x0
13E20  BE0A     BTFSC 0xA, 7, ACCESS
13E22  0EFF     MOVLW 0xFF
13E24  6E0B     MOVWF 0xB, ACCESS
13E26  6E0C     MOVWF 0xC, ACCESS
13E28  0061     MOVFFL ltemp2, POSTINC1
13E2A  F424     NOP
13E2C  F4E6     NOP
13E2E  0061     MOVFFL ttemp3, POSTINC1
13E30  F428     NOP
13E32  F4E6     NOP
13E34  0061     MOVFFL wtemp5, POSTINC1
13E36  F42C     NOP
13E38  F4E6     NOP
13E3A  0061     MOVFFL 0x50C, POSTINC1
13E3C  F430     NOP
13E3E  F4E6     NOP
13E40  0E01     MOVLW 0x1
13E42  6EE6     MOVWF 0xFE6, ACCESS
13E44  EC35     CALL 0x1BA6A, 0
13E46  F0DD     NOP
13E48  0061     MOVFFL ltemp0, POSTINC1
13E4A  F404     NOP
13E4C  F4E6     NOP
13E4E  0061     MOVFFL ttemp5, POSTINC1
13E50  F408     NOP
13E52  F4E6     NOP
13E54  0061     MOVFFL wtemp1, POSTINC1
13E56  F40C     NOP
13E58  F4E6     NOP
13E5A  0061     MOVFFL ttemp1, POSTINC1
13E5C  F410     NOP
13E5E  F4E6     NOP
13E60  ECD2     CALL 0x187A4, 0
13E62  F0C3     NOP
13E64  0061     MOVFFL ltemp0, POSTINC1
13E66  F404     NOP
13E68  F4E6     NOP
13E6A  0061     MOVFFL ttemp5, POSTINC1
13E6C  F408     NOP
13E6E  F4E6     NOP
13E70  0061     MOVFFL wtemp1, POSTINC1
13E72  F40C     NOP
13E74  F4E6     NOP
13E76  0061     MOVFFL ttemp1, POSTINC1
13E78  F410     NOP
13E7A  F4E6     NOP
13E7C  0E87     MOVLW 0x87
13E7E  6EE6     MOVWF 0xFE6, ACCESS
13E80  0EFC     MOVLW 0xFC
13E82  6EE6     MOVWF 0xFE6, ACCESS
13E84  0E15     MOVLW 0x15
13E86  6EE6     MOVWF 0xFE6, ACCESS
13E88  0E00     MOVLW 0x0
13E8A  6EE6     MOVWF 0xFE6, ACCESS
13E8C  0EDD     MOVLW 0xDD
13E8E  24E1     ADDWF 0xFE1, W, ACCESS
13E90  6E01     MOVWF __ptext283, ACCESS
13E92  0EFF     MOVLW 0xFF
13E94  20E2     ADDWFC 0xFE2, W, ACCESS
13E96  6E02     MOVWF ___rparam_used, ACCESS
13E98  0061     MOVFFL ltemp0, POSTINC1
13E9A  F404     NOP
13E9C  F4E6     NOP
13E9E  0061     MOVFFL ttemp5, POSTINC1
13EA0  F408     NOP
13EA2  F4E6     NOP
13EA4  0E0E     MOVLW 0xE
13EA6  6EE6     MOVWF 0xFE6, ACCESS
13EA8  EC35     CALL 0x1C06A, 0
13EAA  F0E0     NOP
134:           			eaDogM_Scroll_String(s_buffer);
13EAC  0EE9     MOVLW 0xE9
13EAE  24E1     ADDWF 0xFE1, W, ACCESS
13EB0  6E01     MOVWF __ptext283, ACCESS
13EB2  0EFF     MOVLW 0xFF
13EB4  20E2     ADDWFC 0xFE2, W, ACCESS
13EB6  6E02     MOVWF ___rparam_used, ACCESS
13EB8  0061     MOVFFL ltemp0, POSTINC1
13EBA  F404     NOP
13EBC  F4E6     NOP
13EBE  0061     MOVFFL ttemp5, POSTINC1
13EC0  F408     NOP
13EC2  F4E6     NOP
13EC4  ECB1     CALL 0x1FF62, 0
13EC6  F0FF     NOP
135:           			if (rxData == 'L') {
13EC8  0EFF     MOVLW 0xFF
13ECA  0061     MOVFFL PLUSW1, ltemp0
13ECC  F38C     NOP
13ECE  F501     NOP
13ED0  0E4C     MOVLW 0x4C
13ED2  1801     XORWF __ptext283, W, ACCESS
13ED4  A4D8     BTFSS 0xFD8, 2, ACCESS
13ED6  D0A6     BRA 0x4024
136:           				snprintf(s_buffer, 21, "#,%5.2f,%5.2f,", (float) B.log.kilowatts_peak / 1000.0, (float) B.log.kilowatt_hours / 10.0);
13ED8  0E00     MOVLW 0x0
13EDA  6EE6     MOVWF 0xFE6, ACCESS
13EDC  0E00     MOVLW 0x0
13EDE  6EE6     MOVWF 0xFE6, ACCESS
13EE0  0E20     MOVLW 0x20
13EE2  6EE6     MOVWF 0xFE6, ACCESS
13EE4  0E41     MOVLW 0x41
13EE6  6EE6     MOVWF 0xFE6, ACCESS
13EE8  0061     MOVFFL 0x59A, ltemp2
13EEA  F668     NOP
13EEC  F509     NOP
13EEE  0061     MOVFFL 0x59B, ttemp3
13EF0  F66C     NOP
13EF2  F50A     NOP
13EF4  0E00     MOVLW 0x0
13EF6  BE0A     BTFSC 0xA, 7, ACCESS
13EF8  0EFF     MOVLW 0xFF
13EFA  6E0B     MOVWF 0xB, ACCESS
13EFC  6E0C     MOVWF 0xC, ACCESS
13EFE  0061     MOVFFL ltemp2, POSTINC1
13F00  F424     NOP
13F02  F4E6     NOP
13F04  0061     MOVFFL ttemp3, POSTINC1
13F06  F428     NOP
13F08  F4E6     NOP
13F0A  0061     MOVFFL wtemp5, POSTINC1
13F0C  F42C     NOP
13F0E  F4E6     NOP
13F10  0061     MOVFFL 0x50C, POSTINC1
13F12  F430     NOP
13F14  F4E6     NOP
13F16  0E01     MOVLW 0x1
13F18  6EE6     MOVWF 0xFE6, ACCESS
13F1A  EC35     CALL 0x1BA6A, 0
13F1C  F0DD     NOP
13F1E  0061     MOVFFL ltemp0, POSTINC1
13F20  F404     NOP
13F22  F4E6     NOP
13F24  0061     MOVFFL ttemp5, POSTINC1
13F26  F408     NOP
13F28  F4E6     NOP
13F2A  0061     MOVFFL wtemp1, POSTINC1
13F2C  F40C     NOP
13F2E  F4E6     NOP
13F30  0061     MOVFFL ttemp1, POSTINC1
13F32  F410     NOP
13F34  F4E6     NOP
13F36  ECD2     CALL 0x187A4, 0
13F38  F0C3     NOP
13F3A  0061     MOVFFL ltemp0, POSTINC1
13F3C  F404     NOP
13F3E  F4E6     NOP
13F40  0061     MOVFFL ttemp5, POSTINC1
13F42  F408     NOP
13F44  F4E6     NOP
13F46  0061     MOVFFL wtemp1, POSTINC1
13F48  F40C     NOP
13F4A  F4E6     NOP
13F4C  0061     MOVFFL ttemp1, POSTINC1
13F4E  F410     NOP
13F50  F4E6     NOP
13F52  0E00     MOVLW 0x0
13F54  6EE6     MOVWF 0xFE6, ACCESS
13F56  0E00     MOVLW 0x0
13F58  6EE6     MOVWF 0xFE6, ACCESS
13F5A  0E7A     MOVLW 0x7A
13F5C  6EE6     MOVWF 0xFE6, ACCESS
13F5E  0E44     MOVLW 0x44
13F60  6EE6     MOVWF 0xFE6, ACCESS
13F62  0061     MOVFFL 0x5A0, ltemp2
13F64  F680     NOP
13F66  F509     NOP
13F68  0061     MOVFFL 0x5A1, ttemp3
13F6A  F684     NOP
13F6C  F50A     NOP
13F6E  0E00     MOVLW 0x0
13F70  BE0A     BTFSC 0xA, 7, ACCESS
13F72  0EFF     MOVLW 0xFF
13F74  6E0B     MOVWF 0xB, ACCESS
13F76  6E0C     MOVWF 0xC, ACCESS
13F78  0061     MOVFFL ltemp2, POSTINC1
13F7A  F424     NOP
13F7C  F4E6     NOP
13F7E  0061     MOVFFL ttemp3, POSTINC1
13F80  F428     NOP
13F82  F4E6     NOP
13F84  0061     MOVFFL wtemp5, POSTINC1
13F86  F42C     NOP
13F88  F4E6     NOP
13F8A  0061     MOVFFL 0x50C, POSTINC1
13F8C  F430     NOP
13F8E  F4E6     NOP
13F90  0E01     MOVLW 0x1
13F92  6EE6     MOVWF 0xFE6, ACCESS
13F94  EC35     CALL 0x1BA6A, 0
13F96  F0DD     NOP
13F98  0061     MOVFFL ltemp0, POSTINC1
13F9A  F404     NOP
13F9C  F4E6     NOP
13F9E  0061     MOVFFL ttemp5, POSTINC1
13FA0  F408     NOP
13FA2  F4E6     NOP
13FA4  0061     MOVFFL wtemp1, POSTINC1
13FA6  F40C     NOP
13FA8  F4E6     NOP
13FAA  0061     MOVFFL ttemp1, POSTINC1
13FAC  F410     NOP
13FAE  F4E6     NOP
13FB0  ECD2     CALL 0x187A4, 0
13FB2  F0C3     NOP
13FB4  0061     MOVFFL ltemp0, POSTINC1
13FB6  F404     NOP
13FB8  F4E6     NOP
13FBA  0061     MOVFFL ttemp5, POSTINC1
13FBC  F408     NOP
13FBE  F4E6     NOP
13FC0  0061     MOVFFL wtemp1, POSTINC1
13FC2  F40C     NOP
13FC4  F4E6     NOP
13FC6  0061     MOVFFL ttemp1, POSTINC1
13FC8  F410     NOP
13FCA  F4E6     NOP
13FCC  0E90     MOVLW 0x90
13FCE  6EE6     MOVWF 0xFE6, ACCESS
13FD0  0EFF     MOVLW 0xFF
13FD2  6EE6     MOVWF 0xFE6, ACCESS
13FD4  0E15     MOVLW 0x15
13FD6  6EE6     MOVWF 0xFE6, ACCESS
13FD8  0E00     MOVLW 0x0
13FDA  6EE6     MOVWF 0xFE6, ACCESS
13FDC  0EDD     MOVLW 0xDD
13FDE  24E1     ADDWF 0xFE1, W, ACCESS
13FE0  6E01     MOVWF __ptext283, ACCESS
13FE2  0EFF     MOVLW 0xFF
13FE4  20E2     ADDWFC 0xFE2, W, ACCESS
13FE6  6E02     MOVWF ___rparam_used, ACCESS
13FE8  0061     MOVFFL ltemp0, POSTINC1
13FEA  F404     NOP
13FEC  F4E6     NOP
13FEE  0061     MOVFFL ttemp5, POSTINC1
13FF0  F408     NOP
13FF2  F4E6     NOP
13FF4  0E0E     MOVLW 0xE
13FF6  6EE6     MOVWF 0xFE6, ACCESS
13FF8  EC35     CALL 0x1C06A, 0
13FFA  F0E0     NOP
137:           				printf("%s", s_buffer);
13FFC  0EE9     MOVLW 0xE9
13FFE  24E1     ADDWF 0xFE1, W, ACCESS
14000  6E01     MOVWF __ptext283, ACCESS
14002  0EFF     MOVLW 0xFF
14004  20E2     ADDWFC 0xFE2, W, ACCESS
14006  6E02     MOVWF ___rparam_used, ACCESS
14008  0061     MOVFFL ltemp0, POSTINC1
1400A  F404     NOP
1400C  F4E6     NOP
1400E  0061     MOVFFL ttemp5, POSTINC1
14010  F408     NOP
14012  F4E6     NOP
14014  0EFB     MOVLW 0xFB
14016  6EE6     MOVWF 0xFE6, ACCESS
14018  0EFF     MOVLW 0xFF
1401A  6EE6     MOVWF 0xFE6, ACCESS
1401C  0E04     MOVLW 0x4
1401E  6EE6     MOVWF 0xFE6, ACCESS
14020  ECD7     CALL 0xDAE, 0
14022  F006     NOP
138:           			}
14024  C5A6     MOVFF 0x5A6, POSTINC1
14026  F4E6     NOP
139:           			snprintf(s_buffer, 21, "Chg F%imin A%imin                ", B.log.float_time, B.log.absorb_time);
14028  C5A7     MOVFF 0x5A7, POSTINC1
1402A  F4E6     NOP
1402C  C5A8     MOVFF 0x5A8, POSTINC1
1402E  F4E6     NOP
14030  C5A9     MOVFF 0x5A9, POSTINC1
14032  F4E6     NOP
14034  0EAC     MOVLW 0xAC
14036  6EE6     MOVWF 0xFE6, ACCESS
14038  0EFC     MOVLW 0xFC
1403A  6EE6     MOVWF 0xFE6, ACCESS
1403C  0E15     MOVLW 0x15
1403E  6EE6     MOVWF 0xFE6, ACCESS
14040  0E00     MOVLW 0x0
14042  6EE6     MOVWF 0xFE6, ACCESS
14044  0EE1     MOVLW 0xE1
14046  24E1     ADDWF 0xFE1, W, ACCESS
14048  6E01     MOVWF __ptext283, ACCESS
1404A  0EFF     MOVLW 0xFF
1404C  20E2     ADDWFC 0xFE2, W, ACCESS
1404E  6E02     MOVWF ___rparam_used, ACCESS
14050  0061     MOVFFL ltemp0, POSTINC1
14052  F404     NOP
14054  F4E6     NOP
14056  0061     MOVFFL ttemp5, POSTINC1
14058  F408     NOP
1405A  F4E6     NOP
1405C  0E0A     MOVLW 0xA
1405E  6EE6     MOVWF 0xFE6, ACCESS
14060  EC35     CALL 0x1C06A, 0
14062  F0E0     NOP
140:           			eaDogM_Scroll_String(s_buffer);
14064  0EE9     MOVLW 0xE9
14066  24E1     ADDWF 0xFE1, W, ACCESS
14068  6E01     MOVWF __ptext283, ACCESS
1406A  0EFF     MOVLW 0xFF
1406C  20E2     ADDWFC 0xFE2, W, ACCESS
1406E  6E02     MOVWF ___rparam_used, ACCESS
14070  0061     MOVFFL ltemp0, POSTINC1
14072  F404     NOP
14074  F4E6     NOP
14076  0061     MOVFFL ttemp5, POSTINC1
14078  F408     NOP
1407A  F4E6     NOP
1407C  ECB1     CALL 0x1FF62, 0
1407E  F0FF     NOP
141:           			if (rxData == 'L') {
14080  0EFF     MOVLW 0xFF
14082  0061     MOVFFL PLUSW1, ltemp0
14084  F38C     NOP
14086  F501     NOP
14088  0E4C     MOVLW 0x4C
1408A  1801     XORWF __ptext283, W, ACCESS
1408C  A4D8     BTFSS 0xFD8, 2, ACCESS
1408E  D034     BRA 0x40F8
142:           				snprintf(s_buffer, 21, "%i,%i,", B.log.float_time, B.log.absorb_time);
14090  C5A6     MOVFF 0x5A6, POSTINC1
14092  F4E6     NOP
14094  C5A7     MOVFF 0x5A7, POSTINC1
14096  F4E6     NOP
14098  C5A8     MOVFF 0x5A8, POSTINC1
1409A  F4E6     NOP
1409C  C5A9     MOVFF 0x5A9, POSTINC1
1409E  F4E6     NOP
140A0  0ECC     MOVLW 0xCC
140A2  6EE6     MOVWF 0xFE6, ACCESS
140A4  0EFF     MOVLW 0xFF
140A6  6EE6     MOVWF 0xFE6, ACCESS
140A8  0E15     MOVLW 0x15
140AA  6EE6     MOVWF 0xFE6, ACCESS
140AC  0E00     MOVLW 0x0
140AE  6EE6     MOVWF 0xFE6, ACCESS
140B0  0EE1     MOVLW 0xE1
140B2  24E1     ADDWF 0xFE1, W, ACCESS
140B4  6E01     MOVWF __ptext283, ACCESS
140B6  0EFF     MOVLW 0xFF
140B8  20E2     ADDWFC 0xFE2, W, ACCESS
140BA  6E02     MOVWF ___rparam_used, ACCESS
140BC  0061     MOVFFL ltemp0, POSTINC1
140BE  F404     NOP
140C0  F4E6     NOP
140C2  0061     MOVFFL ttemp5, POSTINC1
140C4  F408     NOP
140C6  F4E6     NOP
140C8  0E0A     MOVLW 0xA
140CA  6EE6     MOVWF 0xFE6, ACCESS
140CC  EC35     CALL 0x1C06A, 0
140CE  F0E0     NOP
143:           				printf("%s", s_buffer);
140D0  0EE9     MOVLW 0xE9
140D2  24E1     ADDWF 0xFE1, W, ACCESS
140D4  6E01     MOVWF __ptext283, ACCESS
140D6  0EFF     MOVLW 0xFF
140D8  20E2     ADDWFC 0xFE2, W, ACCESS
140DA  6E02     MOVWF ___rparam_used, ACCESS
140DC  0061     MOVFFL ltemp0, POSTINC1
140DE  F404     NOP
140E0  F4E6     NOP
140E2  0061     MOVFFL ttemp5, POSTINC1
140E4  F408     NOP
140E6  F4E6     NOP
140E8  0EFB     MOVLW 0xFB
140EA  6EE6     MOVWF 0xFE6, ACCESS
140EC  0EFF     MOVLW 0xFF
140EE  6EE6     MOVWF 0xFE6, ACCESS
140F0  0E04     MOVLW 0x4
140F2  6EE6     MOVWF 0xFE6, ACCESS
140F4  ECD7     CALL 0xDAE, 0
140F6  F006     NOP
144:           			}
140F8  C598     MOVFF 0x598, POSTINC1
140FA  F4E6     NOP
145:           			snprintf(s_buffer, 21, "%iVpk %4.1fApk %iAh       ", B.log.volts_peak, (float) B.log.amps_peak / 10.0, B.log.amp_hours);
140FC  C599     MOVFF 0x599, POSTINC1
140FE  F4E6     NOP
14100  0E00     MOVLW 0x0
14102  6EE6     MOVWF 0xFE6, ACCESS
14104  0E00     MOVLW 0x0
14106  6EE6     MOVWF 0xFE6, ACCESS
14108  0E20     MOVLW 0x20
1410A  6EE6     MOVWF 0xFE6, ACCESS
1410C  0E41     MOVLW 0x41
1410E  6EE6     MOVWF 0xFE6, ACCESS
14110  0061     MOVFFL 0x59E, ltemp2
14112  F678     NOP
14114  F509     NOP
14116  0061     MOVFFL 0x59F, ttemp3
14118  F67C     NOP
1411A  F50A     NOP
1411C  0E00     MOVLW 0x0
1411E  BE0A     BTFSC 0xA, 7, ACCESS
14120  0EFF     MOVLW 0xFF
14122  6E0B     MOVWF 0xB, ACCESS
14124  6E0C     MOVWF 0xC, ACCESS
14126  0061     MOVFFL ltemp2, POSTINC1
14128  F424     NOP
1412A  F4E6     NOP
1412C  0061     MOVFFL ttemp3, POSTINC1
1412E  F428     NOP
14130  F4E6     NOP
14132  0061     MOVFFL wtemp5, POSTINC1
14134  F42C     NOP
14136  F4E6     NOP
14138  0061     MOVFFL 0x50C, POSTINC1
1413A  F430     NOP
1413C  F4E6     NOP
1413E  0E01     MOVLW 0x1
14140  6EE6     MOVWF 0xFE6, ACCESS
14142  EC35     CALL 0x1BA6A, 0
14144  F0DD     NOP
14146  0061     MOVFFL ltemp0, POSTINC1
14148  F404     NOP
1414A  F4E6     NOP
1414C  0061     MOVFFL ttemp5, POSTINC1
1414E  F408     NOP
14150  F4E6     NOP
14152  0061     MOVFFL wtemp1, POSTINC1
14154  F40C     NOP
14156  F4E6     NOP
14158  0061     MOVFFL ttemp1, POSTINC1
1415A  F410     NOP
1415C  F4E6     NOP
1415E  ECD2     CALL 0x187A4, 0
14160  F0C3     NOP
14162  0061     MOVFFL ltemp0, POSTINC1
14164  F404     NOP
14166  F4E6     NOP
14168  0061     MOVFFL ttemp5, POSTINC1
1416A  F408     NOP
1416C  F4E6     NOP
1416E  0061     MOVFFL wtemp1, POSTINC1
14170  F40C     NOP
14172  F4E6     NOP
14174  0061     MOVFFL ttemp1, POSTINC1
14176  F410     NOP
14178  F4E6     NOP
1417A  C59C     MOVFF 0x59C, POSTINC1
1417C  F4E6     NOP
1417E  C59D     MOVFF 0x59D, POSTINC1
14180  F4E6     NOP
14182  0E46     MOVLW 0x46
14184  6EE6     MOVWF 0xFE6, ACCESS
14186  0EFD     MOVLW 0xFD
14188  6EE6     MOVWF 0xFE6, ACCESS
1418A  0E15     MOVLW 0x15
1418C  6EE6     MOVWF 0xFE6, ACCESS
1418E  0E00     MOVLW 0x0
14190  6EE6     MOVWF 0xFE6, ACCESS
14192  0EDD     MOVLW 0xDD
14194  24E1     ADDWF 0xFE1, W, ACCESS
14196  6E01     MOVWF __ptext283, ACCESS
14198  0EFF     MOVLW 0xFF
1419A  20E2     ADDWFC 0xFE2, W, ACCESS
1419C  6E02     MOVWF ___rparam_used, ACCESS
1419E  0061     MOVFFL ltemp0, POSTINC1
141A0  F404     NOP
141A2  F4E6     NOP
141A4  0061     MOVFFL ttemp5, POSTINC1
141A6  F408     NOP
141A8  F4E6     NOP
141AA  0E0E     MOVLW 0xE
141AC  6EE6     MOVWF 0xFE6, ACCESS
141AE  EC35     CALL 0x1C06A, 0
141B0  F0E0     NOP
146:           			eaDogM_Scroll_String(s_buffer);
141B2  0EE9     MOVLW 0xE9
141B4  24E1     ADDWF 0xFE1, W, ACCESS
141B6  6E01     MOVWF __ptext283, ACCESS
141B8  0EFF     MOVLW 0xFF
141BA  20E2     ADDWFC 0xFE2, W, ACCESS
141BC  6E02     MOVWF ___rparam_used, ACCESS
141BE  0061     MOVFFL ltemp0, POSTINC1
141C0  F404     NOP
141C2  F4E6     NOP
141C4  0061     MOVFFL ttemp5, POSTINC1
141C6  F408     NOP
141C8  F4E6     NOP
141CA  ECB1     CALL 0x1FF62, 0
141CC  F0FF     NOP
147:           			if (rxData == 'L') {
141CE  0EFF     MOVLW 0xFF
141D0  0061     MOVFFL PLUSW1, ltemp0
141D2  F38C     NOP
141D4  F501     NOP
141D6  0E4C     MOVLW 0x4C
141D8  1801     XORWF __ptext283, W, ACCESS
141DA  A4D8     BTFSS 0xFD8, 2, ACCESS
141DC  D071     BRA 0x42C0
148:           				snprintf(s_buffer, 21, "%i,%4.1f,%i,", B.log.volts_peak, (float) B.log.amps_peak / 10.0, B.log.amp_hours);
141DE  C598     MOVFF 0x598, POSTINC1
141E0  F4E6     NOP
141E2  C599     MOVFF 0x599, POSTINC1
141E4  F4E6     NOP
141E6  0E00     MOVLW 0x0
141E8  6EE6     MOVWF 0xFE6, ACCESS
141EA  0E00     MOVLW 0x0
141EC  6EE6     MOVWF 0xFE6, ACCESS
141EE  0E20     MOVLW 0x20
141F0  6EE6     MOVWF 0xFE6, ACCESS
141F2  0E41     MOVLW 0x41
141F4  6EE6     MOVWF 0xFE6, ACCESS
141F6  0061     MOVFFL 0x59E, ltemp2
141F8  F678     NOP
141FA  F509     NOP
141FC  0061     MOVFFL 0x59F, ttemp3
141FE  F67C     NOP
14200  F50A     NOP
14202  0E00     MOVLW 0x0
14204  BE0A     BTFSC 0xA, 7, ACCESS
14206  0EFF     MOVLW 0xFF
14208  6E0B     MOVWF 0xB, ACCESS
1420A  6E0C     MOVWF 0xC, ACCESS
1420C  0061     MOVFFL ltemp2, POSTINC1
1420E  F424     NOP
14210  F4E6     NOP
14212  0061     MOVFFL ttemp3, POSTINC1
14214  F428     NOP
14216  F4E6     NOP
14218  0061     MOVFFL wtemp5, POSTINC1
1421A  F42C     NOP
1421C  F4E6     NOP
1421E  0061     MOVFFL 0x50C, POSTINC1
14220  F430     NOP
14222  F4E6     NOP
14224  0E01     MOVLW 0x1
14226  6EE6     MOVWF 0xFE6, ACCESS
14228  EC35     CALL 0x1BA6A, 0
1422A  F0DD     NOP
1422C  0061     MOVFFL ltemp0, POSTINC1
1422E  F404     NOP
14230  F4E6     NOP
14232  0061     MOVFFL ttemp5, POSTINC1
14234  F408     NOP
14236  F4E6     NOP
14238  0061     MOVFFL wtemp1, POSTINC1
1423A  F40C     NOP
1423C  F4E6     NOP
1423E  0061     MOVFFL ttemp1, POSTINC1
14240  F410     NOP
14242  F4E6     NOP
14244  ECD2     CALL 0x187A4, 0
14246  F0C3     NOP
14248  0061     MOVFFL ltemp0, POSTINC1
1424A  F404     NOP
1424C  F4E6     NOP
1424E  0061     MOVFFL ttemp5, POSTINC1
14250  F408     NOP
14252  F4E6     NOP
14254  0061     MOVFFL wtemp1, POSTINC1
14256  F40C     NOP
14258  F4E6     NOP
1425A  0061     MOVFFL ttemp1, POSTINC1
1425C  F410     NOP
1425E  F4E6     NOP
14260  C59C     MOVFF 0x59C, POSTINC1
14262  F4E6     NOP
14264  C59D     MOVFF 0x59D, POSTINC1
14266  F4E6     NOP
14268  0E9F     MOVLW 0x9F
1426A  6EE6     MOVWF 0xFE6, ACCESS
1426C  0EFF     MOVLW 0xFF
1426E  6EE6     MOVWF 0xFE6, ACCESS
14270  0E15     MOVLW 0x15
14272  6EE6     MOVWF 0xFE6, ACCESS
14274  0E00     MOVLW 0x0
14276  6EE6     MOVWF 0xFE6, ACCESS
14278  0EDD     MOVLW 0xDD
1427A  24E1     ADDWF 0xFE1, W, ACCESS
1427C  6E01     MOVWF __ptext283, ACCESS
1427E  0EFF     MOVLW 0xFF
14280  20E2     ADDWFC 0xFE2, W, ACCESS
14282  6E02     MOVWF ___rparam_used, ACCESS
14284  0061     MOVFFL ltemp0, POSTINC1
14286  F404     NOP
14288  F4E6     NOP
1428A  0061     MOVFFL ttemp5, POSTINC1
1428C  F408     NOP
1428E  F4E6     NOP
14290  0E0E     MOVLW 0xE
14292  6EE6     MOVWF 0xFE6, ACCESS
14294  EC35     CALL 0x1C06A, 0
14296  F0E0     NOP
149:           				printf("%s", s_buffer);
14298  0EE9     MOVLW 0xE9
1429A  24E1     ADDWF 0xFE1, W, ACCESS
1429C  6E01     MOVWF __ptext283, ACCESS
1429E  0EFF     MOVLW 0xFF
142A0  20E2     ADDWFC 0xFE2, W, ACCESS
142A2  6E02     MOVWF ___rparam_used, ACCESS
142A4  0061     MOVFFL ltemp0, POSTINC1
142A6  F404     NOP
142A8  F4E6     NOP
142AA  0061     MOVFFL ttemp5, POSTINC1
142AC  F408     NOP
142AE  F4E6     NOP
142B0  0EFB     MOVLW 0xFB
142B2  6EE6     MOVWF 0xFE6, ACCESS
142B4  0EFF     MOVLW 0xFF
142B6  6EE6     MOVWF 0xFE6, ACCESS
142B8  0E04     MOVLW 0x4
142BA  6EE6     MOVWF 0xFE6, ACCESS
142BC  ECD7     CALL 0xDAE, 0
142BE  F006     NOP
150:           			}
142C0  C596     MOVFF 0x596, POSTINC1
142C2  F4E6     NOP
151:           			snprintf(s_buffer, 21, "%4.1fV %4.1fV :Day %i       ", (float) B.log.bat_max / 10.0, (float) B.log.bat_min / 10.0, B.log.day);
142C4  C597     MOVFF 0x597, POSTINC1
142C6  F4E6     NOP
142C8  0E00     MOVLW 0x0
142CA  6EE6     MOVWF 0xFE6, ACCESS
142CC  0E00     MOVLW 0x0
142CE  6EE6     MOVWF 0xFE6, ACCESS
142D0  0E20     MOVLW 0x20
142D2  6EE6     MOVWF 0xFE6, ACCESS
142D4  0E41     MOVLW 0x41
142D6  6EE6     MOVWF 0xFE6, ACCESS
142D8  0061     MOVFFL 0x5A2, ltemp2
142DA  F688     NOP
142DC  F509     NOP
142DE  0061     MOVFFL 0x5A3, ttemp3
142E0  F68C     NOP
142E2  F50A     NOP
142E4  0E00     MOVLW 0x0
142E6  BE0A     BTFSC 0xA, 7, ACCESS
142E8  0EFF     MOVLW 0xFF
142EA  6E0B     MOVWF 0xB, ACCESS
142EC  6E0C     MOVWF 0xC, ACCESS
142EE  0061     MOVFFL ltemp2, POSTINC1
142F0  F424     NOP
142F2  F4E6     NOP
142F4  0061     MOVFFL ttemp3, POSTINC1
142F6  F428     NOP
142F8  F4E6     NOP
142FA  0061     MOVFFL wtemp5, POSTINC1
142FC  F42C     NOP
142FE  F4E6     NOP
14300  0061     MOVFFL 0x50C, POSTINC1
14302  F430     NOP
14304  F4E6     NOP
14306  0E01     MOVLW 0x1
14308  6EE6     MOVWF 0xFE6, ACCESS
1430A  EC35     CALL 0x1BA6A, 0
1430C  F0DD     NOP
1430E  0061     MOVFFL ltemp0, POSTINC1
14310  F404     NOP
14312  F4E6     NOP
14314  0061     MOVFFL ttemp5, POSTINC1
14316  F408     NOP
14318  F4E6     NOP
1431A  0061     MOVFFL wtemp1, POSTINC1
1431C  F40C     NOP
1431E  F4E6     NOP
14320  0061     MOVFFL ttemp1, POSTINC1
14322  F410     NOP
14324  F4E6     NOP
14326  ECD2     CALL 0x187A4, 0
14328  F0C3     NOP
1432A  0061     MOVFFL ltemp0, POSTINC1
1432C  F404     NOP
1432E  F4E6     NOP
14330  0061     MOVFFL ttemp5, POSTINC1
14332  F408     NOP
14334  F4E6     NOP
14336  0061     MOVFFL wtemp1, POSTINC1
14338  F40C     NOP
1433A  F4E6     NOP
1433C  0061     MOVFFL ttemp1, POSTINC1
1433E  F410     NOP
14340  F4E6     NOP
14342  0E00     MOVLW 0x0
14344  6EE6     MOVWF 0xFE6, ACCESS
14346  0E00     MOVLW 0x0
14348  6EE6     MOVWF 0xFE6, ACCESS
1434A  0E20     MOVLW 0x20
1434C  6EE6     MOVWF 0xFE6, ACCESS
1434E  0E41     MOVLW 0x41
14350  6EE6     MOVWF 0xFE6, ACCESS
14352  0061     MOVFFL 0x5A4, ltemp2
14354  F690     NOP
14356  F509     NOP
14358  0061     MOVFFL 0x5A5, ttemp3
1435A  F694     NOP
1435C  F50A     NOP
1435E  0E00     MOVLW 0x0
14360  BE0A     BTFSC 0xA, 7, ACCESS
14362  0EFF     MOVLW 0xFF
14364  6E0B     MOVWF 0xB, ACCESS
14366  6E0C     MOVWF 0xC, ACCESS
14368  0061     MOVFFL ltemp2, POSTINC1
1436A  F424     NOP
1436C  F4E6     NOP
1436E  0061     MOVFFL ttemp3, POSTINC1
14370  F428     NOP
14372  F4E6     NOP
14374  0061     MOVFFL wtemp5, POSTINC1
14376  F42C     NOP
14378  F4E6     NOP
1437A  0061     MOVFFL 0x50C, POSTINC1
1437C  F430     NOP
1437E  F4E6     NOP
14380  0E01     MOVLW 0x1
14382  6EE6     MOVWF 0xFE6, ACCESS
14384  EC35     CALL 0x1BA6A, 0
14386  F0DD     NOP
14388  0061     MOVFFL ltemp0, POSTINC1
1438A  F404     NOP
1438C  F4E6     NOP
1438E  0061     MOVFFL ttemp5, POSTINC1
14390  F408     NOP
14392  F4E6     NOP
14394  0061     MOVFFL wtemp1, POSTINC1
14396  F40C     NOP
14398  F4E6     NOP
1439A  0061     MOVFFL ttemp1, POSTINC1
1439C  F410     NOP
1439E  F4E6     NOP
143A0  ECD2     CALL 0x187A4, 0
143A2  F0C3     NOP
143A4  0061     MOVFFL ltemp0, POSTINC1
143A6  F404     NOP
143A8  F4E6     NOP
143AA  0061     MOVFFL ttemp5, POSTINC1
143AC  F408     NOP
143AE  F4E6     NOP
143B0  0061     MOVFFL wtemp1, POSTINC1
143B2  F40C     NOP
143B4  F4E6     NOP
143B6  0061     MOVFFL ttemp1, POSTINC1
143B8  F410     NOP
143BA  F4E6     NOP
143BC  0E0D     MOVLW 0xD
143BE  6EE6     MOVWF 0xFE6, ACCESS
143C0  0EFD     MOVLW 0xFD
143C2  6EE6     MOVWF 0xFE6, ACCESS
143C4  0E15     MOVLW 0x15
143C6  6EE6     MOVWF 0xFE6, ACCESS
143C8  0E00     MOVLW 0x0
143CA  6EE6     MOVWF 0xFE6, ACCESS
143CC  0EDB     MOVLW 0xDB
143CE  24E1     ADDWF 0xFE1, W, ACCESS
143D0  6E01     MOVWF __ptext283, ACCESS
143D2  0EFF     MOVLW 0xFF
143D4  20E2     ADDWFC 0xFE2, W, ACCESS
143D6  6E02     MOVWF ___rparam_used, ACCESS
143D8  0061     MOVFFL ltemp0, POSTINC1
143DA  F404     NOP
143DC  F4E6     NOP
143DE  0061     MOVFFL ttemp5, POSTINC1
143E0  F408     NOP
143E2  F4E6     NOP
143E4  0E10     MOVLW 0x10
143E6  6EE6     MOVWF 0xFE6, ACCESS
143E8  EC35     CALL 0x1C06A, 0
143EA  F0E0     NOP
152:           			eaDogM_Scroll_String(s_buffer);
143EC  0EE9     MOVLW 0xE9
143EE  24E1     ADDWF 0xFE1, W, ACCESS
143F0  6E01     MOVWF __ptext283, ACCESS
143F2  0EFF     MOVLW 0xFF
143F4  20E2     ADDWFC 0xFE2, W, ACCESS
143F6  6E02     MOVWF ___rparam_used, ACCESS
143F8  0061     MOVFFL ltemp0, POSTINC1
143FA  F404     NOP
143FC  F4E6     NOP
143FE  0061     MOVFFL ttemp5, POSTINC1
14400  F408     NOP
14402  F4E6     NOP
14404  ECB1     CALL 0x1FF62, 0
14406  F0FF     NOP
153:           			if (rxData == 'L') {
14408  0EFF     MOVLW 0xFF
1440A  0061     MOVFFL PLUSW1, ltemp0
1440C  F38C     NOP
1440E  F501     NOP
14410  0E4C     MOVLW 0x4C
14412  1801     XORWF __ptext283, W, ACCESS
14414  A4D8     BTFSS 0xFD8, 2, ACCESS
14416  D0FB     BRA 0x460E
154:           				snprintf(s_buffer, 21, "%4.1f,%4.1f,%i,", (float) B.log.bat_max / 10.0, (float) B.log.bat_min / 10.0, B.log.day);
14418  C596     MOVFF 0x596, POSTINC1
1441A  F4E6     NOP
1441C  C597     MOVFF 0x597, POSTINC1
1441E  F4E6     NOP
14420  0E00     MOVLW 0x0
14422  6EE6     MOVWF 0xFE6, ACCESS
14424  0E00     MOVLW 0x0
14426  6EE6     MOVWF 0xFE6, ACCESS
14428  0E20     MOVLW 0x20
1442A  6EE6     MOVWF 0xFE6, ACCESS
1442C  0E41     MOVLW 0x41
1442E  6EE6     MOVWF 0xFE6, ACCESS
14430  0061     MOVFFL 0x5A2, ltemp2
14432  F688     NOP
14434  F509     NOP
14436  0061     MOVFFL 0x5A3, ttemp3
14438  F68C     NOP
1443A  F50A     NOP
1443C  0E00     MOVLW 0x0
1443E  BE0A     BTFSC 0xA, 7, ACCESS
14440  0EFF     MOVLW 0xFF
14442  6E0B     MOVWF 0xB, ACCESS
14444  6E0C     MOVWF 0xC, ACCESS
14446  0061     MOVFFL ltemp2, POSTINC1
14448  F424     NOP
1444A  F4E6     NOP
1444C  0061     MOVFFL ttemp3, POSTINC1
1444E  F428     NOP
14450  F4E6     NOP
14452  0061     MOVFFL wtemp5, POSTINC1
14454  F42C     NOP
14456  F4E6     NOP
14458  0061     MOVFFL 0x50C, POSTINC1
1445A  F430     NOP
1445C  F4E6     NOP
1445E  0E01     MOVLW 0x1
14460  6EE6     MOVWF 0xFE6, ACCESS
14462  EC35     CALL 0x1BA6A, 0
14464  F0DD     NOP
14466  0061     MOVFFL ltemp0, POSTINC1
14468  F404     NOP
1446A  F4E6     NOP
1446C  0061     MOVFFL ttemp5, POSTINC1
1446E  F408     NOP
14470  F4E6     NOP
14472  0061     MOVFFL wtemp1, POSTINC1
14474  F40C     NOP
14476  F4E6     NOP
14478  0061     MOVFFL ttemp1, POSTINC1
1447A  F410     NOP
1447C  F4E6     NOP
1447E  ECD2     CALL 0x187A4, 0
14480  F0C3     NOP
14482  0061     MOVFFL ltemp0, POSTINC1
14484  F404     NOP
14486  F4E6     NOP
14488  0061     MOVFFL ttemp5, POSTINC1
1448A  F408     NOP
1448C  F4E6     NOP
1448E  0061     MOVFFL wtemp1, POSTINC1
14490  F40C     NOP
14492  F4E6     NOP
14494  0061     MOVFFL ttemp1, POSTINC1
14496  F410     NOP
14498  F4E6     NOP
1449A  0E00     MOVLW 0x0
1449C  6EE6     MOVWF 0xFE6, ACCESS
1449E  0E00     MOVLW 0x0
144A0  6EE6     MOVWF 0xFE6, ACCESS
144A2  0E20     MOVLW 0x20
144A4  6EE6     MOVWF 0xFE6, ACCESS
144A6  0E41     MOVLW 0x41
144A8  6EE6     MOVWF 0xFE6, ACCESS
144AA  0061     MOVFFL 0x5A4, ltemp2
144AC  F690     NOP
144AE  F509     NOP
144B0  0061     MOVFFL 0x5A5, ttemp3
144B2  F694     NOP
144B4  F50A     NOP
144B6  0E00     MOVLW 0x0
144B8  BE0A     BTFSC 0xA, 7, ACCESS
144BA  0EFF     MOVLW 0xFF
144BC  6E0B     MOVWF 0xB, ACCESS
144BE  6E0C     MOVWF 0xC, ACCESS
144C0  0061     MOVFFL ltemp2, POSTINC1
144C2  F424     NOP
144C4  F4E6     NOP
144C6  0061     MOVFFL ttemp3, POSTINC1
144C8  F428     NOP
144CA  F4E6     NOP
144CC  0061     MOVFFL wtemp5, POSTINC1
144CE  F42C     NOP
144D0  F4E6     NOP
144D2  0061     MOVFFL 0x50C, POSTINC1
144D4  F430     NOP
144D6  F4E6     NOP
144D8  0E01     MOVLW 0x1
144DA  6EE6     MOVWF 0xFE6, ACCESS
144DC  EC35     CALL 0x1BA6A, 0
144DE  F0DD     NOP
144E0  0061     MOVFFL ltemp0, POSTINC1
144E2  F404     NOP
144E4  F4E6     NOP
144E6  0061     MOVFFL ttemp5, POSTINC1
144E8  F408     NOP
144EA  F4E6     NOP
144EC  0061     MOVFFL wtemp1, POSTINC1
144EE  F40C     NOP
144F0  F4E6     NOP
144F2  0061     MOVFFL ttemp1, POSTINC1
144F4  F410     NOP
144F6  F4E6     NOP
144F8  ECD2     CALL 0x187A4, 0
144FA  F0C3     NOP
144FC  0061     MOVFFL ltemp0, POSTINC1
144FE  F404     NOP
14500  F4E6     NOP
14502  0061     MOVFFL ttemp5, POSTINC1
14504  F408     NOP
14506  F4E6     NOP
14508  0061     MOVFFL wtemp1, POSTINC1
1450A  F40C     NOP
1450C  F4E6     NOP
1450E  0061     MOVFFL ttemp1, POSTINC1
14510  F410     NOP
14512  F4E6     NOP
14514  0E80     MOVLW 0x80
14516  6EE6     MOVWF 0xFE6, ACCESS
14518  0EFF     MOVLW 0xFF
1451A  6EE6     MOVWF 0xFE6, ACCESS
1451C  0E15     MOVLW 0x15
1451E  6EE6     MOVWF 0xFE6, ACCESS
14520  0E00     MOVLW 0x0
14522  6EE6     MOVWF 0xFE6, ACCESS
14524  0EDB     MOVLW 0xDB
14526  24E1     ADDWF 0xFE1, W, ACCESS
14528  6E01     MOVWF __ptext283, ACCESS
1452A  0EFF     MOVLW 0xFF
1452C  20E2     ADDWFC 0xFE2, W, ACCESS
1452E  6E02     MOVWF ___rparam_used, ACCESS
14530  0061     MOVFFL ltemp0, POSTINC1
14532  F404     NOP
14534  F4E6     NOP
14536  0061     MOVFFL ttemp5, POSTINC1
14538  F408     NOP
1453A  F4E6     NOP
1453C  0E10     MOVLW 0x10
1453E  6EE6     MOVWF 0xFE6, ACCESS
14540  EC35     CALL 0x1C06A, 0
14542  F0E0     NOP
155:           				printf("%s^\r\n", s_buffer);
14544  0EE9     MOVLW 0xE9
14546  24E1     ADDWF 0xFE1, W, ACCESS
14548  6E01     MOVWF __ptext283, ACCESS
1454A  0EFF     MOVLW 0xFF
1454C  20E2     ADDWFC 0xFE2, W, ACCESS
1454E  6E02     MOVWF ___rparam_used, ACCESS
14550  0061     MOVFFL ltemp0, POSTINC1
14552  F404     NOP
14554  F4E6     NOP
14556  0061     MOVFFL ttemp5, POSTINC1
14558  F408     NOP
1455A  F4E6     NOP
1455C  0ED3     MOVLW 0xD3
1455E  6EE6     MOVWF 0xFE6, ACCESS
14560  0EFF     MOVLW 0xFF
14562  6EE6     MOVWF 0xFE6, ACCESS
14564  0E04     MOVLW 0x4
14566  6EE6     MOVWF 0xFE6, ACCESS
14568  ECD7     CALL 0xDAE, 0
1456A  F006     NOP
1456C  D050     BRA 0x460E
156:           			}
157:           			break;
158:           		case 'W': // Write current state to EEPROM data
159:           		case 'w':
160:           			wr_bm_data((void*) EB);
1456E  0EE7     MOVLW 0xE7
14570  C4E3     MOVFF PLUSW1, POSTINC1
14572  F4E6     NOP
14574  C4E3     MOVFF PLUSW1, POSTINC1
14576  F4E6     NOP
14578  ECB2     CALL 0x1CD64, 0
1457A  F0E6     NOP
161:           			MM_ERROR_S;
1457C  82BF     BSF 0xFBF, 1, ACCESS
1457E  D047     BRA 0x460E
162:           			break;
163:           		default:
164:           			break;
165:           		}
14580  0EFF     MOVLW 0xFF
14582  50E3     MOVF 0xFE3, W, ACCESS
14584  6E0B     MOVWF 0xB, ACCESS
14586  6A0C     CLRF 0xC, ACCESS
14588  500C     MOVF 0xC, W, ACCESS
1458A  0A00     XORLW 0x0
1458C  A4D8     BTFSS 0xFD8, 2, ACCESS
1458E  D03F     BRA 0x460E
14590  500B     MOVF 0xB, W, ACCESS
14592  0A41     XORLW 0x41
14594  B4D8     BTFSC 0xFD8, 2, ACCESS
14596  EF6F     GOTO 0x13ADE
14598  F09D     NOP
1459A  0A05     XORLW 0x5
1459C  B4D8     BTFSC 0xFD8, 2, ACCESS
1459E  EF8A     GOTO 0x13B14
145A0  F09D     NOP
145A2  0A01     XORLW 0x1
145A4  B4D8     BTFSC 0xFD8, 2, ACCESS
145A6  EFD4     GOTO 0x13BA8
145A8  F09D     NOP
145AA  0A03     XORLW 0x3
145AC  B4D8     BTFSC 0xFD8, 2, ACCESS
145AE  EFBE     GOTO 0x13B7C
145B0  F09D     NOP
145B2  0A0F     XORLW 0xF
145B4  B4D8     BTFSC 0xFD8, 2, ACCESS
145B6  EFFD     GOTO 0x13BFA
145B8  F09D     NOP
145BA  0A05     XORLW 0x5
145BC  B4D8     BTFSC 0xFD8, 2, ACCESS
145BE  EFC2     GOTO 0x13D84
145C0  F09E     NOP
145C2  0A1E     XORLW 0x1E
145C4  B4D8     BTFSC 0xFD8, 2, ACCESS
145C6  EFC0     GOTO 0x13D80
145C8  F09E     NOP
145CA  0A05     XORLW 0x5
145CC  B4D8     BTFSC 0xFD8, 2, ACCESS
145CE  D7CF     BRA 0x456E
145D0  0A36     XORLW 0x36
145D2  B4D8     BTFSC 0xFD8, 2, ACCESS
145D4  EF72     GOTO 0x13AE4
145D6  F09D     NOP
145D8  0A05     XORLW 0x5
145DA  B4D8     BTFSC 0xFD8, 2, ACCESS
145DC  EF8A     GOTO 0x13B14
145DE  F09D     NOP
145E0  0A01     XORLW 0x1
145E2  B4D8     BTFSC 0xFD8, 2, ACCESS
145E4  EFD4     GOTO 0x13BA8
145E6  F09D     NOP
145E8  0A03     XORLW 0x3
145EA  B4D8     BTFSC 0xFD8, 2, ACCESS
145EC  EFBE     GOTO 0x13B7C
145EE  F09D     NOP
145F0  0A0F     XORLW 0xF
145F2  B4D8     BTFSC 0xFD8, 2, ACCESS
145F4  EFFD     GOTO 0x13BFA
145F6  F09D     NOP
145F8  0A05     XORLW 0x5
145FA  B4D8     BTFSC 0xFD8, 2, ACCESS
145FC  EFC2     GOTO 0x13D84
145FE  F09E     NOP
14600  0A1E     XORLW 0x1E
14602  B4D8     BTFSC 0xFD8, 2, ACCESS
14604  EFC0     GOTO 0x13D80
14606  F09E     NOP
14608  0A05     XORLW 0x5
1460A  B4D8     BTFSC 0xFD8, 2, ACCESS
1460C  D7B0     BRA 0x456E
166:           	}
167:           }
1460E  0EE7     MOVLW 0xE7
1460E  0EE7     MOVLW 0xE7
1460E  0EE7     MOVLW 0xE7
1460E  0EE7     MOVLW 0xE7
1460E  0EE7     MOVLW 0xE7
168:           
169:           /*
170:            * track energy usage and storage of the system
171:            * with LiFePO4 battery chem this is simple, direct with no major secondary effects over the discharge/charge curve
172:            * 
173:            */
174:           void compute_bm_data(EB_data * EB)
1800C  0E08     MOVLW 0x8
1800E  26E1     ADDWF 0xFE1, F, ACCESS
18010  0E00     MOVLW 0x0
18012  22E2     ADDWFC 0xFE2, F, ACCESS
175:           {
176:           	float net_energy, net_balance;
177:           
178:           	pv_Wh_daily += (EB->FMw / TEN_SEC_HOUR); // integrate Wh for 10 second updates 
18014  0E00     MOVLW 0x0
18016  6EE6     MOVWF 0xFE6, ACCESS
18018  0E00     MOVLW 0x0
1801A  6EE6     MOVWF 0xFE6, ACCESS
1801C  0EB4     MOVLW 0xB4
1801E  6EE6     MOVWF 0xFE6, ACCESS
18020  0E43     MOVLW 0x43
18022  6EE6     MOVWF 0xFE6, ACCESS
18024  0EF2     MOVLW 0xF2
18026  0061     MOVFFL PLUSW1, wtemp5
18028  F38C     NOP
1802A  F50B     NOP
1802C  0EF3     MOVLW 0xF3
1802E  0061     MOVFFL PLUSW1, 0x50C
18030  F38C     NOP
18032  F50C     NOP
18034  0E04     MOVLW 0x4
18036  240B     ADDWF 0xB, W, ACCESS
18038  6ED9     MOVWF 0xFD9, ACCESS
1803A  0E00     MOVLW 0x0
1803C  200C     ADDWFC 0xC, W, ACCESS
1803E  6EDA     MOVWF __end_of_UART2_tx_vect_isr, ACCESS
18040  C4DE     MOVFF POSTINC2, POSTINC1
18042  F4E6     NOP
18044  C4DE     MOVFF POSTINC2, POSTINC1
18046  F4E6     NOP
18048  C4DE     MOVFF POSTINC2, POSTINC1
1804A  F4E6     NOP
1804C  C4DE     MOVFF POSTINC2, POSTINC1
1804E  F4E6     NOP
18050  ECD2     CALL 0x187A4, 0
18052  F0C3     NOP
18054  0061     MOVFFL ltemp0, POSTINC1
18056  F404     NOP
18058  F4E6     NOP
1805A  0061     MOVFFL ttemp5, POSTINC1
1805C  F408     NOP
1805E  F4E6     NOP
18060  0061     MOVFFL wtemp1, POSTINC1
18062  F40C     NOP
18064  F4E6     NOP
18066  0061     MOVFFL ttemp1, POSTINC1
18068  F410     NOP
1806A  F4E6     NOP
1806C  C639     MOVFF pv_Wh_daily, POSTINC1
1806E  F4E6     NOP
18070  C63A     MOVFF 0x63A, POSTINC1
18072  F4E6     NOP
18074  C63B     MOVFF 0x63B, POSTINC1
18076  F4E6     NOP
18078  C63C     MOVFF 0x63C, POSTINC1
1807A  F4E6     NOP
1807C  EC30     CALL 0x17860, 0
1807E  F0BC     NOP
18080  0061     MOVFFL ltemp0, pv_Wh_daily
18082  F404     NOP
18084  F639     NOP
18086  0061     MOVFFL ttemp5, 0x63A
18088  F408     NOP
1808A  F63A     NOP
1808C  0061     MOVFFL wtemp1, 0x63B
1808E  F40C     NOP
18090  F63B     NOP
18092  0061     MOVFFL ttemp1, 0x63C
18094  F410     NOP
18096  F63C     NOP
179:           	ac_Wh_daily += (EB->ENw / TEN_SEC_HOUR);
18098  0E00     MOVLW 0x0
1809A  6EE6     MOVWF 0xFE6, ACCESS
1809C  0E00     MOVLW 0x0
1809E  6EE6     MOVWF 0xFE6, ACCESS
180A0  0EB4     MOVLW 0xB4
180A2  6EE6     MOVWF 0xFE6, ACCESS
180A4  0E43     MOVLW 0x43
180A6  6EE6     MOVWF 0xFE6, ACCESS
180A8  0EF2     MOVLW 0xF2
180AA  0061     MOVFFL PLUSW1, wtemp5
180AC  F38C     NOP
180AE  F50B     NOP
180B0  0EF3     MOVLW 0xF3
180B2  0061     MOVFFL PLUSW1, 0x50C
180B4  F38C     NOP
180B6  F50C     NOP
180B8  0E14     MOVLW 0x14
180BA  240B     ADDWF 0xB, W, ACCESS
180BC  6ED9     MOVWF 0xFD9, ACCESS
180BE  0E00     MOVLW 0x0
180C0  200C     ADDWFC 0xC, W, ACCESS
180C2  6EDA     MOVWF __end_of_UART2_tx_vect_isr, ACCESS
180C4  C4DE     MOVFF POSTINC2, POSTINC1
180C6  F4E6     NOP
180C8  C4DE     MOVFF POSTINC2, POSTINC1
180CA  F4E6     NOP
180CC  C4DE     MOVFF POSTINC2, POSTINC1
180CE  F4E6     NOP
180D0  C4DE     MOVFF POSTINC2, POSTINC1
180D2  F4E6     NOP
180D4  ECD2     CALL 0x187A4, 0
180D6  F0C3     NOP
180D8  0061     MOVFFL ltemp0, POSTINC1
180DA  F404     NOP
180DC  F4E6     NOP
180DE  0061     MOVFFL ttemp5, POSTINC1
180E0  F408     NOP
180E2  F4E6     NOP
180E4  0061     MOVFFL wtemp1, POSTINC1
180E6  F40C     NOP
180E8  F4E6     NOP
180EA  0061     MOVFFL ttemp1, POSTINC1
180EC  F410     NOP
180EE  F4E6     NOP
180F0  C635     MOVFF ac_Wh_daily, POSTINC1
180F2  F4E6     NOP
180F4  C636     MOVFF 0x636, POSTINC1
180F6  F4E6     NOP
180F8  C637     MOVFF 0x637, POSTINC1
180FA  F4E6     NOP
180FC  C638     MOVFF 0x638, POSTINC1
180FE  F4E6     NOP
18100  EC30     CALL 0x17860, 0
18102  F0BC     NOP
18104  0061     MOVFFL ltemp0, ac_Wh_daily
18106  F404     NOP
18108  F635     NOP
1810A  0061     MOVFFL ttemp5, 0x636
1810C  F408     NOP
1810E  F636     NOP
18110  0061     MOVFFL wtemp1, 0x637
18112  F40C     NOP
18114  F637     NOP
18116  0061     MOVFFL ttemp1, 0x638
18118  F410     NOP
1811A  F638     NOP
180:           
181:           	net_balance = EB->FMw - (EB->ENw * INV_EFF_VAL); // make the energy comparison AC -> DC watts equal using inverter losses
1811C  0E14     MOVLW 0x14
1811E  6EE6     MOVWF 0xFE6, ACCESS
18120  0EAE     MOVLW 0xAE
18122  6EE6     MOVWF 0xFE6, ACCESS
18124  0E87     MOVLW 0x87
18126  6EE6     MOVWF 0xFE6, ACCESS
18128  0E3F     MOVLW 0x3F
1812A  6EE6     MOVWF 0xFE6, ACCESS
1812C  0EF2     MOVLW 0xF2
1812E  0061     MOVFFL PLUSW1, wtemp5
18130  F38C     NOP
18132  F50B     NOP
18134  0EF3     MOVLW 0xF3
18136  0061     MOVFFL PLUSW1, 0x50C
18138  F38C     NOP
1813A  F50C     NOP
1813C  0E14     MOVLW 0x14
1813E  240B     ADDWF 0xB, W, ACCESS
18140  6ED9     MOVWF 0xFD9, ACCESS
18142  0E00     MOVLW 0x0
18144  200C     ADDWFC 0xC, W, ACCESS
18146  6EDA     MOVWF __end_of_UART2_tx_vect_isr, ACCESS
18148  C4DE     MOVFF POSTINC2, POSTINC1
1814A  F4E6     NOP
1814C  C4DE     MOVFF POSTINC2, POSTINC1
1814E  F4E6     NOP
18150  C4DE     MOVFF POSTINC2, POSTINC1
18152  F4E6     NOP
18154  C4DE     MOVFF POSTINC2, POSTINC1
18156  F4E6     NOP
18158  EC2F     CALL 0x1705E, 0
1815A  F0B8     NOP
1815C  0061     MOVFFL ltemp0, POSTINC1
1815E  F404     NOP
18160  F4E6     NOP
18162  0061     MOVFFL ttemp5, POSTINC1
18164  F408     NOP
18166  F4E6     NOP
18168  0061     MOVFFL wtemp1, POSTINC1
1816A  F40C     NOP
1816C  F4E6     NOP
1816E  0061     MOVFFL ttemp1, POSTINC1
18170  F410     NOP
18172  F4E6     NOP
18174  0EF2     MOVLW 0xF2
18176  0061     MOVFFL PLUSW1, wtemp5
18178  F38C     NOP
1817A  F50B     NOP
1817C  0EF3     MOVLW 0xF3
1817E  0061     MOVFFL PLUSW1, 0x50C
18180  F38C     NOP
18182  F50C     NOP
18184  0E04     MOVLW 0x4
18186  240B     ADDWF 0xB, W, ACCESS
18188  6ED9     MOVWF 0xFD9, ACCESS
1818A  0E00     MOVLW 0x0
1818C  200C     ADDWFC 0xC, W, ACCESS
1818E  6EDA     MOVWF __end_of_UART2_tx_vect_isr, ACCESS
18190  C4DE     MOVFF POSTINC2, POSTINC1
18192  F4E6     NOP
18194  C4DE     MOVFF POSTINC2, POSTINC1
18196  F4E6     NOP
18198  C4DE     MOVFF POSTINC2, POSTINC1
1819A  F4E6     NOP
1819C  C4DE     MOVFF POSTINC2, POSTINC1
1819E  F4E6     NOP
181A0  ECC0     CALL 0x1B80, 0
181A2  F00D     NOP
181A4  0EF8     MOVLW 0xF8
181A6  0061     MOVFFL ltemp0, PLUSW1
181A8  F404     NOP
181AA  F4E3     NOP
181AC  0EF9     MOVLW 0xF9
181AE  0061     MOVFFL ttemp5, PLUSW1
181B0  F408     NOP
181B2  F4E3     NOP
181B4  0EFA     MOVLW 0xFA
181B6  0061     MOVFFL wtemp1, PLUSW1
181B8  F40C     NOP
181BA  F4E3     NOP
181BC  0EFB     MOVLW 0xFB
181BE  0061     MOVFFL ttemp1, PLUSW1
181C0  F410     NOP
181C2  F4E3     NOP
182:           	if (net_balance > 0.0001f) { // more energy from panels than current load usage
181C4  0EF8     MOVLW 0xF8
181C6  C4E3     MOVFF PLUSW1, POSTINC1
181C8  F4E6     NOP
181CA  C4E3     MOVFF PLUSW1, POSTINC1
181CC  F4E6     NOP
181CE  C4E3     MOVFF PLUSW1, POSTINC1
181D0  F4E6     NOP
181D2  C4E3     MOVFF PLUSW1, POSTINC1
181D4  F4E6     NOP
181D6  0E17     MOVLW 0x17
181D8  6EE6     MOVWF 0xFE6, ACCESS
181DA  0EB7     MOVLW 0xB7
181DC  6EE6     MOVWF 0xFE6, ACCESS
181DE  0ED1     MOVLW 0xD1
181E0  6EE6     MOVWF 0xFE6, ACCESS
181E2  0E38     MOVLW 0x38
181E4  6EE6     MOVWF 0xFE6, ACCESS
181E6  EC60     CALL 0x1D6C0, 0
181E8  F0EB     NOP
181EA  B001     BTFSC __ptext283, 0, ACCESS
181EC  D113     BRA 0x8414
183:           		net_balance = net_balance * BAT_EFF_VAL; // actual battery energy storage correction, energy in vs energy out losses
181EE  0EF6     MOVLW 0xF6
181F0  6EE6     MOVWF 0xFE6, ACCESS
181F2  0E28     MOVLW 0x28
181F4  6EE6     MOVWF 0xFE6, ACCESS
181F6  0E7C     MOVLW 0x7C
181F8  6EE6     MOVWF 0xFE6, ACCESS
181FA  0E3F     MOVLW 0x3F
181FC  6EE6     MOVWF 0xFE6, ACCESS
181FE  0EF4     MOVLW 0xF4
18200  C4E3     MOVFF PLUSW1, POSTINC1
18202  F4E6     NOP
18204  C4E3     MOVFF PLUSW1, POSTINC1
18206  F4E6     NOP
18208  C4E3     MOVFF PLUSW1, POSTINC1
1820A  F4E6     NOP
1820C  C4E3     MOVFF PLUSW1, POSTINC1
1820E  F4E6     NOP
18210  EC2F     CALL 0x1705E, 0
18212  F0B8     NOP
18214  0EF8     MOVLW 0xF8
18216  0061     MOVFFL ltemp0, PLUSW1
18218  F404     NOP
1821A  F4E3     NOP
1821C  0EF9     MOVLW 0xF9
1821E  0061     MOVFFL ttemp5, PLUSW1
18220  F408     NOP
18222  F4E3     NOP
18224  0EFA     MOVLW 0xFA
18226  0061     MOVFFL wtemp1, PLUSW1
18228  F40C     NOP
1822A  F4E3     NOP
1822C  0EFB     MOVLW 0xFB
1822E  0061     MOVFFL ttemp1, PLUSW1
18230  F410     NOP
18232  F4E3     NOP
184:           		B.net_balance = net_balance;
18234  50E1     MOVF 0xFE1, W, ACCESS
18236  0FF8     ADDLW 0xF8
18238  6ED9     MOVWF 0xFD9, ACCESS
1823A  50E2     MOVF 0xFE2, W, ACCESS
1823C  6EDA     MOVWF __end_of_UART2_tx_vect_isr, ACCESS
1823E  0EFF     MOVLW 0xFF
18240  22DA     ADDWFC __end_of_UART2_tx_vect_isr, F, ACCESS
18242  C4DE     MOVFF POSTINC2, 0x578
18244  F578     NOP
18246  C4DE     MOVFF POSTINC2, 0x579
18248  F579     NOP
1824A  C4DE     MOVFF POSTINC2, 0x57A
1824C  F57A     NOP
1824E  C4DE     MOVFF POSTINC2, 0x57B
18250  F57B     NOP
185:           		B.run_time = (EB->bat_energy / TEN_SEC_HOUR) / IDLE_DRAIN;
18252  0E00     MOVLW 0x0
18254  6EE6     MOVWF 0xFE6, ACCESS
18256  0E00     MOVLW 0x0
18258  6EE6     MOVWF 0xFE6, ACCESS
1825A  0E20     MOVLW 0x20
1825C  6EE6     MOVWF 0xFE6, ACCESS
1825E  0E41     MOVLW 0x41
18260  6EE6     MOVWF 0xFE6, ACCESS
18262  0E00     MOVLW 0x0
18264  6EE6     MOVWF 0xFE6, ACCESS
18266  0E00     MOVLW 0x0
18268  6EE6     MOVWF 0xFE6, ACCESS
1826A  0EB4     MOVLW 0xB4
1826C  6EE6     MOVWF 0xFE6, ACCESS
1826E  0E43     MOVLW 0x43
18270  6EE6     MOVWF 0xFE6, ACCESS
18272  0EEE     MOVLW 0xEE
18274  0061     MOVFFL PLUSW1, wtemp5
18276  F38C     NOP
18278  F50B     NOP
1827A  0EEF     MOVLW 0xEF
1827C  0061     MOVFFL PLUSW1, 0x50C
1827E  F38C     NOP
18280  F50C     NOP
18282  0E2C     MOVLW 0x2C
18284  240B     ADDWF 0xB, W, ACCESS
18286  6ED9     MOVWF 0xFD9, ACCESS
18288  0E00     MOVLW 0x0
1828A  200C     ADDWFC 0xC, W, ACCESS
1828C  6EDA     MOVWF __end_of_UART2_tx_vect_isr, ACCESS
1828E  C4DE     MOVFF POSTINC2, POSTINC1
18290  F4E6     NOP
18292  C4DE     MOVFF POSTINC2, POSTINC1
18294  F4E6     NOP
18296  C4DE     MOVFF POSTINC2, POSTINC1
18298  F4E6     NOP
1829A  C4DE     MOVFF POSTINC2, POSTINC1
1829C  F4E6     NOP
1829E  ECD2     CALL 0x187A4, 0
182A0  F0C3     NOP
182A2  0061     MOVFFL ltemp0, POSTINC1
182A4  F404     NOP
182A6  F4E6     NOP
182A8  0061     MOVFFL ttemp5, POSTINC1
182AA  F408     NOP
182AC  F4E6     NOP
182AE  0061     MOVFFL wtemp1, POSTINC1
182B0  F40C     NOP
182B2  F4E6     NOP
182B4  0061     MOVFFL ttemp1, POSTINC1
182B6  F410     NOP
182B8  F4E6     NOP
182BA  ECD2     CALL 0x187A4, 0
182BC  F0C3     NOP
182BE  0061     MOVFFL ltemp0, 0x574
182C0  F404     NOP
182C2  F574     NOP
182C4  0061     MOVFFL ttemp5, 0x575
182C6  F408     NOP
182C8  F575     NOP
182CA  0061     MOVFFL wtemp1, 0x576
182CC  F40C     NOP
182CE  F576     NOP
182D0  0061     MOVFFL ttemp1, 0x577
182D2  F410     NOP
182D4  F577     NOP
186:           		if (B.run_time > BAT_RUN_MAX) {
182D6  C574     MOVFF 0x574, POSTINC1
182D8  F4E6     NOP
182DA  C575     MOVFF 0x575, POSTINC1
182DC  F4E6     NOP
182DE  C576     MOVFF 0x576, POSTINC1
182E0  F4E6     NOP
182E2  C577     MOVFF 0x577, POSTINC1
182E4  F4E6     NOP
182E6  0E00     MOVLW 0x0
182E8  6EE6     MOVWF 0xFE6, ACCESS
182EA  0E00     MOVLW 0x0
182EC  6EE6     MOVWF 0xFE6, ACCESS
182EE  0E8C     MOVLW 0x8C
182F0  6EE6     MOVWF 0xFE6, ACCESS
182F2  0E43     MOVLW 0x43
182F4  6EE6     MOVWF 0xFE6, ACCESS
182F6  EC60     CALL 0x1D6C0, 0
182F8  F0EB     NOP
182FA  B001     BTFSC __ptext283, 0, ACCESS
182FC  D009     BRA 0x8310
187:           			B.run_time = BAT_RUN_MAX;
182FE  0E00     MOVLW 0x0
18300  0105     MOVLB 0x5
18302  6F74     MOVWF CM2CON0, BANKED
18304  0E00     MOVLW 0x0
18306  6F75     MOVWF CM2CON1, BANKED
18308  0E8C     MOVLW 0x8C
1830A  6F76     MOVWF CM2NCH, BANKED
1830C  0E43     MOVLW 0x43
1830E  6F77     MOVWF CM2PCH, BANKED
188:           		}
189:           		if (B.run_time < 0.0001f) {
18310  0E17     MOVLW 0x17
18312  6EE6     MOVWF 0xFE6, ACCESS
18314  0EB7     MOVLW 0xB7
18316  6EE6     MOVWF 0xFE6, ACCESS
18318  0ED1     MOVLW 0xD1
1831A  6EE6     MOVWF 0xFE6, ACCESS
1831C  0E38     MOVLW 0x38
1831E  6EE6     MOVWF 0xFE6, ACCESS
18320  C574     MOVFF 0x574, POSTINC1
18322  F4E6     NOP
18324  C575     MOVFF 0x575, POSTINC1
18326  F4E6     NOP
18328  C576     MOVFF 0x576, POSTINC1
1832A  F4E6     NOP
1832C  C577     MOVFF 0x577, POSTINC1
1832E  F4E6     NOP
18330  EC60     CALL 0x1D6C0, 0
18332  F0EB     NOP
18334  B001     BTFSC __ptext283, 0, ACCESS
18336  D009     BRA 0x834A
190:           			B.run_time = 0.0001f;
18338  0E17     MOVLW 0x17
1833A  0105     MOVLB 0x5
1833C  6F74     MOVWF CM2CON0, BANKED
1833E  0EB7     MOVLW 0xB7
18340  6F75     MOVWF CM2CON1, BANKED
18342  0ED1     MOVLW 0xD1
18344  6F76     MOVWF CM2NCH, BANKED
18346  0E38     MOVLW 0x38
18348  6F77     MOVWF CM2PCH, BANKED
191:           		}
192:           		/*
193:           		 * try to sync BMS charged condition to monitor charged condition and set full energy levels
194:           		 */
195:           		if ((cc_mode == STATUS_FLOATING) && (EB->FMw > BAT_CHARGED_W) && (EB->ENw > BAT_CHARGED_W)) {
1834A  044B     DECF HLVDCON1, W, ACCESS
1834C  104C     IORWF ZCDCON, W, ACCESS
1834E  A4D8     BTFSS 0xFD8, 2, ACCESS
18350  D127     BRA 0x85A0
18352  0EF6     MOVLW 0xF6
18354  0061     MOVFFL PLUSW1, wtemp5
18356  F38C     NOP
18358  F50B     NOP
1835A  0EF7     MOVLW 0xF7
1835C  0061     MOVFFL PLUSW1, 0x50C
1835E  F38C     NOP
18360  F50C     NOP
18362  0E04     MOVLW 0x4
18364  240B     ADDWF 0xB, W, ACCESS
18366  6ED9     MOVWF 0xFD9, ACCESS
18368  0E00     MOVLW 0x0
1836A  200C     ADDWFC 0xC, W, ACCESS
1836C  6EDA     MOVWF __end_of_UART2_tx_vect_isr, ACCESS
1836E  C4DE     MOVFF POSTINC2, POSTINC1
18370  F4E6     NOP
18372  C4DE     MOVFF POSTINC2, POSTINC1
18374  F4E6     NOP
18376  C4DE     MOVFF POSTINC2, POSTINC1
18378  F4E6     NOP
1837A  C4DE     MOVFF POSTINC2, POSTINC1
1837C  F4E6     NOP
1837E  0E00     MOVLW 0x0
18380  6EE6     MOVWF 0xFE6, ACCESS
18382  0E00     MOVLW 0x0
18384  6EE6     MOVWF 0xFE6, ACCESS
18386  0E48     MOVLW 0x48
18388  6EE6     MOVWF 0xFE6, ACCESS
1838A  0E43     MOVLW 0x43
1838C  6EE6     MOVWF 0xFE6, ACCESS
1838E  EC60     CALL 0x1D6C0, 0
18390  F0EB     NOP
18392  B001     BTFSC __ptext283, 0, ACCESS
18394  D105     BRA 0x85A0
18396  0EF6     MOVLW 0xF6
18398  0061     MOVFFL PLUSW1, wtemp5
1839A  F38C     NOP
1839C  F50B     NOP
1839E  0EF7     MOVLW 0xF7
183A0  0061     MOVFFL PLUSW1, 0x50C
183A2  F38C     NOP
183A4  F50C     NOP
183A6  0E14     MOVLW 0x14
183A8  240B     ADDWF 0xB, W, ACCESS
183AA  6ED9     MOVWF 0xFD9, ACCESS
183AC  0E00     MOVLW 0x0
183AE  200C     ADDWFC 0xC, W, ACCESS
183B0  6EDA     MOVWF __end_of_UART2_tx_vect_isr, ACCESS
183B2  C4DE     MOVFF POSTINC2, POSTINC1
183B4  F4E6     NOP
183B6  C4DE     MOVFF POSTINC2, POSTINC1
183B8  F4E6     NOP
183BA  C4DE     MOVFF POSTINC2, POSTINC1
183BC  F4E6     NOP
183BE  C4DE     MOVFF POSTINC2, POSTINC1
183C0  F4E6     NOP
183C2  0E00     MOVLW 0x0
183C4  6EE6     MOVWF 0xFE6, ACCESS
183C6  0E00     MOVLW 0x0
183C8  6EE6     MOVWF 0xFE6, ACCESS
183CA  0E48     MOVLW 0x48
183CC  6EE6     MOVWF 0xFE6, ACCESS
183CE  0E43     MOVLW 0x43
183D0  6EE6     MOVWF 0xFE6, ACCESS
183D2  EC60     CALL 0x1D6C0, 0
183D4  F0EB     NOP
183D6  B001     BTFSC __ptext283, 0, ACCESS
183D8  D0E3     BRA 0x85A0
196:           			if (!B.FM80_charged) {
183DA  0105     MOVLB 0x5
183DC  5162     MOVF PMD2, W, BANKED
183DE  A4D8     BTFSS 0xFD8, 2, ACCESS
183E0  D0DF     BRA 0x85A0
197:           				B.FM80_charged = true;
183E2  0E01     MOVLW 0x1
183E4  6F62     MOVWF PMD2, BANKED
198:           				EB->bat_energy = BAT_ENERGY;
183E6  0EF6     MOVLW 0xF6
183E8  0061     MOVFFL PLUSW1, wtemp5
183EA  F38C     NOP
183EC  F50B     NOP
183EE  0EF7     MOVLW 0xF7
183F0  0061     MOVFFL PLUSW1, 0x50C
183F2  F38C     NOP
183F4  F50C     NOP
183F6  0E2C     MOVLW 0x2C
183F8  240B     ADDWF 0xB, W, ACCESS
183FA  6ED9     MOVWF 0xFD9, ACCESS
183FC  0E00     MOVLW 0x0
183FE  200C     ADDWFC 0xC, W, ACCESS
18400  6EDA     MOVWF __end_of_UART2_tx_vect_isr, ACCESS
18402  0E00     MOVLW 0x0
18404  6EDE     MOVWF 0xFDE, ACCESS
18406  0E00     MOVLW 0x0
18408  6EDE     MOVWF 0xFDE, ACCESS
1840A  0EE1     MOVLW 0xE1
1840C  6EDE     MOVWF 0xFDE, ACCESS
1840E  0E49     MOVLW 0x49
18410  6EDD     MOVWF 0xFDD, ACCESS
18412  D0C6     BRA 0x85A0
199:           			}
200:           		}
201:           	} else {
202:           		net_balance = net_balance; // net drain, inverter correction already applied: possible future second order corrections here
203:           		B.net_balance = net_balance;
18414  50E1     MOVF 0xFE1, W, ACCESS
18416  0FF8     ADDLW 0xF8
18418  6ED9     MOVWF 0xFD9, ACCESS
1841A  50E2     MOVF 0xFE2, W, ACCESS
1841C  6EDA     MOVWF __end_of_UART2_tx_vect_isr, ACCESS
1841E  0EFF     MOVLW 0xFF
18420  22DA     ADDWFC __end_of_UART2_tx_vect_isr, F, ACCESS
18422  C4DE     MOVFF POSTINC2, 0x578
18424  F578     NOP
18426  C4DE     MOVFF POSTINC2, 0x579
18428  F579     NOP
1842A  C4DE     MOVFF POSTINC2, 0x57A
1842C  F57A     NOP
1842E  C4DE     MOVFF POSTINC2, 0x57B
18430  F57B     NOP
204:           		B.run_time = (EB->bat_energy / TEN_SEC_HOUR) / fabs(net_balance);
18432  0EF8     MOVLW 0xF8
18434  C4E3     MOVFF PLUSW1, POSTINC1
18436  F4E6     NOP
18438  C4E3     MOVFF PLUSW1, POSTINC1
1843A  F4E6     NOP
1843C  C4E3     MOVFF PLUSW1, POSTINC1
1843E  F4E6     NOP
18440  C4E3     MOVFF PLUSW1, POSTINC1
18442  F4E6     NOP
18444  EC0C     CALL 0x1FC18, 0
18446  F0FE     NOP
18448  0061     MOVFFL ltemp0, POSTINC1
1844A  F404     NOP
1844C  F4E6     NOP
1844E  0061     MOVFFL ttemp5, POSTINC1
18450  F408     NOP
18452  F4E6     NOP
18454  0061     MOVFFL wtemp1, POSTINC1
18456  F40C     NOP
18458  F4E6     NOP
1845A  0061     MOVFFL ttemp1, POSTINC1
1845C  F410     NOP
1845E  F4E6     NOP
18460  0E00     MOVLW 0x0
18462  6EE6     MOVWF 0xFE6, ACCESS
18464  0E00     MOVLW 0x0
18466  6EE6     MOVWF 0xFE6, ACCESS
18468  0EB4     MOVLW 0xB4
1846A  6EE6     MOVWF 0xFE6, ACCESS
1846C  0E43     MOVLW 0x43
1846E  6EE6     MOVWF 0xFE6, ACCESS
18470  0EEE     MOVLW 0xEE
18472  0061     MOVFFL PLUSW1, wtemp5
18474  F38C     NOP
18476  F50B     NOP
18478  0EEF     MOVLW 0xEF
1847A  0061     MOVFFL PLUSW1, 0x50C
1847C  F38C     NOP
1847E  F50C     NOP
18480  0E2C     MOVLW 0x2C
18482  240B     ADDWF 0xB, W, ACCESS
18484  6ED9     MOVWF 0xFD9, ACCESS
18486  0E00     MOVLW 0x0
18488  200C     ADDWFC 0xC, W, ACCESS
1848A  6EDA     MOVWF __end_of_UART2_tx_vect_isr, ACCESS
1848C  C4DE     MOVFF POSTINC2, POSTINC1
1848E  F4E6     NOP
18490  C4DE     MOVFF POSTINC2, POSTINC1
18492  F4E6     NOP
18494  C4DE     MOVFF POSTINC2, POSTINC1
18496  F4E6     NOP
18498  C4DE     MOVFF POSTINC2, POSTINC1
1849A  F4E6     NOP
1849C  ECD2     CALL 0x187A4, 0
1849E  F0C3     NOP
184A0  0061     MOVFFL ltemp0, POSTINC1
184A2  F404     NOP
184A4  F4E6     NOP
184A6  0061     MOVFFL ttemp5, POSTINC1
184A8  F408     NOP
184AA  F4E6     NOP
184AC  0061     MOVFFL wtemp1, POSTINC1
184AE  F40C     NOP
184B0  F4E6     NOP
184B2  0061     MOVFFL ttemp1, POSTINC1
184B4  F410     NOP
184B6  F4E6     NOP
184B8  ECD2     CALL 0x187A4, 0
184BA  F0C3     NOP
184BC  0061     MOVFFL ltemp0, 0x574
184BE  F404     NOP
184C0  F574     NOP
184C2  0061     MOVFFL ttemp5, 0x575
184C4  F408     NOP
184C6  F575     NOP
184C8  0061     MOVFFL wtemp1, 0x576
184CA  F40C     NOP
184CC  F576     NOP
184CE  0061     MOVFFL ttemp1, 0x577
184D0  F410     NOP
184D2  F577     NOP
205:           		if (B.run_time > BAT_RUN_MAX) {
184D4  C574     MOVFF 0x574, POSTINC1
184D6  F4E6     NOP
184D8  C575     MOVFF 0x575, POSTINC1
184DA  F4E6     NOP
184DC  C576     MOVFF 0x576, POSTINC1
184DE  F4E6     NOP
184E0  C577     MOVFF 0x577, POSTINC1
184E2  F4E6     NOP
184E4  0E00     MOVLW 0x0
184E6  6EE6     MOVWF 0xFE6, ACCESS
184E8  0E00     MOVLW 0x0
184EA  6EE6     MOVWF 0xFE6, ACCESS
184EC  0E8C     MOVLW 0x8C
184EE  6EE6     MOVWF 0xFE6, ACCESS
184F0  0E43     MOVLW 0x43
184F2  6EE6     MOVWF 0xFE6, ACCESS
184F4  EC60     CALL 0x1D6C0, 0
184F6  F0EB     NOP
184F8  B001     BTFSC __ptext283, 0, ACCESS
184FA  D009     BRA 0x850E
206:           			B.run_time = BAT_RUN_MAX;
184FC  0E00     MOVLW 0x0
184FE  0105     MOVLB 0x5
18500  6F74     MOVWF CM2CON0, BANKED
18502  0E00     MOVLW 0x0
18504  6F75     MOVWF CM2CON1, BANKED
18506  0E8C     MOVLW 0x8C
18508  6F76     MOVWF CM2NCH, BANKED
1850A  0E43     MOVLW 0x43
1850C  6F77     MOVWF CM2PCH, BANKED
207:           		}
208:           		if (B.run_time < 0.0001f) {
1850E  0E17     MOVLW 0x17
18510  6EE6     MOVWF 0xFE6, ACCESS
18512  0EB7     MOVLW 0xB7
18514  6EE6     MOVWF 0xFE6, ACCESS
18516  0ED1     MOVLW 0xD1
18518  6EE6     MOVWF 0xFE6, ACCESS
1851A  0E38     MOVLW 0x38
1851C  6EE6     MOVWF 0xFE6, ACCESS
1851E  C574     MOVFF 0x574, POSTINC1
18520  F4E6     NOP
18522  C575     MOVFF 0x575, POSTINC1
18524  F4E6     NOP
18526  C576     MOVFF 0x576, POSTINC1
18528  F4E6     NOP
1852A  C577     MOVFF 0x577, POSTINC1
1852C  F4E6     NOP
1852E  EC60     CALL 0x1D6C0, 0
18530  F0EB     NOP
18532  B001     BTFSC __ptext283, 0, ACCESS
18534  D009     BRA 0x8548
209:           			B.run_time = 0.0001f;
18536  0E17     MOVLW 0x17
18538  0105     MOVLB 0x5
1853A  6F74     MOVWF CM2CON0, BANKED
1853C  0EB7     MOVLW 0xB7
1853E  6F75     MOVWF CM2CON1, BANKED
18540  0ED1     MOVLW 0xD1
18542  6F76     MOVWF CM2NCH, BANKED
18544  0E38     MOVLW 0x38
18546  6F77     MOVWF CM2PCH, BANKED
210:           		}
211:           		/*
212:           		 * reset possible battery energy sync function
213:           		 */
214:           		if (cc_mode != STATUS_FLOATING) {
18548  044B     DECF HLVDCON1, W, ACCESS
1854A  104C     IORWF ZCDCON, W, ACCESS
1854C  B4D8     BTFSC 0xFD8, 2, ACCESS
1854E  D028     BRA 0x85A0
215:           			if (B.FM80_charged && (EB->bat_energy < BAT_ENERGY_LOW)) {
18550  0105     MOVLB 0x5
18552  5162     MOVF PMD2, W, BANKED
18554  B4D8     BTFSC 0xFD8, 2, ACCESS
18556  D024     BRA 0x85A0
18558  0E00     MOVLW 0x0
1855A  6EE6     MOVWF 0xFE6, ACCESS
1855C  0E00     MOVLW 0x0
1855E  6EE6     MOVWF 0xFE6, ACCESS
18560  0E61     MOVLW 0x61
18562  6EE6     MOVWF 0xFE6, ACCESS
18564  0E4A     MOVLW 0x4A
18566  6EE6     MOVWF 0xFE6, ACCESS
18568  0EF2     MOVLW 0xF2
1856A  0061     MOVFFL PLUSW1, wtemp5
1856C  F38C     NOP
1856E  F50B     NOP
18570  0EF3     MOVLW 0xF3
18572  0061     MOVFFL PLUSW1, 0x50C
18574  F38C     NOP
18576  F50C     NOP
18578  0E2C     MOVLW 0x2C
1857A  240B     ADDWF 0xB, W, ACCESS
1857C  6ED9     MOVWF 0xFD9, ACCESS
1857E  0E00     MOVLW 0x0
18580  200C     ADDWFC 0xC, W, ACCESS
18582  6EDA     MOVWF __end_of_UART2_tx_vect_isr, ACCESS
18584  C4DE     MOVFF POSTINC2, POSTINC1
18586  F4E6     NOP
18588  C4DE     MOVFF POSTINC2, POSTINC1
1858A  F4E6     NOP
1858C  C4DE     MOVFF POSTINC2, POSTINC1
1858E  F4E6     NOP
18590  C4DE     MOVFF POSTINC2, POSTINC1
18592  F4E6     NOP
18594  EC60     CALL 0x1D6C0, 0
18596  F0EB     NOP
18598  B001     BTFSC __ptext283, 0, ACCESS
1859A  D002     BRA 0x85A0
216:           				B.FM80_charged = false;
1859C  0105     MOVLB 0x5
1859E  6B62     CLRF PMD2, BANKED
217:           			}
218:           		}
219:           	}
220:           	net_energy = EB->bat_energy + net_balance; // inverter/battery power conversion correction
185A0  0EF8     MOVLW 0xF8
185A2  C4E3     MOVFF PLUSW1, POSTINC1
185A4  F4E6     NOP
185A6  C4E3     MOVFF PLUSW1, POSTINC1
185A8  F4E6     NOP
185AA  C4E3     MOVFF PLUSW1, POSTINC1
185AC  F4E6     NOP
185AE  C4E3     MOVFF PLUSW1, POSTINC1
185B0  F4E6     NOP
185B2  0EF2     MOVLW 0xF2
185B4  0061     MOVFFL PLUSW1, wtemp5
185B6  F38C     NOP
185B8  F50B     NOP
185BA  0EF3     MOVLW 0xF3
185BC  0061     MOVFFL PLUSW1, 0x50C
185BE  F38C     NOP
185C0  F50C     NOP
185C2  0E2C     MOVLW 0x2C
185C4  240B     ADDWF 0xB, W, ACCESS
185C6  6ED9     MOVWF 0xFD9, ACCESS
185C8  0E00     MOVLW 0x0
185CA  200C     ADDWFC 0xC, W, ACCESS
185CC  6EDA     MOVWF __end_of_UART2_tx_vect_isr, ACCESS
185CE  C4DE     MOVFF POSTINC2, POSTINC1
185D0  F4E6     NOP
185D2  C4DE     MOVFF POSTINC2, POSTINC1
185D4  F4E6     NOP
185D6  C4DE     MOVFF POSTINC2, POSTINC1
185D8  F4E6     NOP
185DA  C4DE     MOVFF POSTINC2, POSTINC1
185DC  F4E6     NOP
185DE  EC30     CALL 0x17860, 0
185E0  F0BC     NOP
185E2  0EFC     MOVLW 0xFC
185E4  0061     MOVFFL ltemp0, PLUSW1
185E6  F404     NOP
185E8  F4E3     NOP
185EA  0EFD     MOVLW 0xFD
185EC  0061     MOVFFL ttemp5, PLUSW1
185EE  F408     NOP
185F0  F4E3     NOP
185F2  0EFE     MOVLW 0xFE
185F4  0061     MOVFFL wtemp1, PLUSW1
185F6  F40C     NOP
185F8  F4E3     NOP
185FA  0EFF     MOVLW 0xFF
185FC  0061     MOVFFL ttemp1, PLUSW1
185FE  F410     NOP
18600  F4E3     NOP
221:           	/*
222:           	 * set battery energy limits
223:           	 */
224:           	EB->bat_energy = net_energy - IDLE_DRAIN; // system electronic power drain
18602  0E00     MOVLW 0x0
18604  6EE6     MOVWF 0xFE6, ACCESS
18606  0E00     MOVLW 0x0
18608  6EE6     MOVWF 0xFE6, ACCESS
1860A  0E20     MOVLW 0x20
1860C  6EE6     MOVWF 0xFE6, ACCESS
1860E  0EC1     MOVLW 0xC1
18610  6EE6     MOVWF 0xFE6, ACCESS
18612  0EF8     MOVLW 0xF8
18614  C4E3     MOVFF PLUSW1, POSTINC1
18616  F4E6     NOP
18618  C4E3     MOVFF PLUSW1, POSTINC1
1861A  F4E6     NOP
1861C  C4E3     MOVFF PLUSW1, POSTINC1
1861E  F4E6     NOP
18620  C4E3     MOVFF PLUSW1, POSTINC1
18622  F4E6     NOP
18624  EC30     CALL 0x17860, 0
18626  F0BC     NOP
18628  0EF6     MOVLW 0xF6
1862A  0061     MOVFFL PLUSW1, wtemp5
1862C  F38C     NOP
1862E  F50B     NOP
18630  0EF7     MOVLW 0xF7
18632  0061     MOVFFL PLUSW1, 0x50C
18634  F38C     NOP
18636  F50C     NOP
18638  0E2C     MOVLW 0x2C
1863A  240B     ADDWF 0xB, W, ACCESS
1863C  6ED9     MOVWF 0xFD9, ACCESS
1863E  0E00     MOVLW 0x0
18640  200C     ADDWFC 0xC, W, ACCESS
18642  6EDA     MOVWF __end_of_UART2_tx_vect_isr, ACCESS
18644  0061     MOVFFL ltemp0, POSTINC2
18646  F404     NOP
18648  F4DE     NOP
1864A  0061     MOVFFL ttemp5, POSTINC2
1864C  F408     NOP
1864E  F4DE     NOP
18650  0061     MOVFFL wtemp1, POSTINC2
18652  F40C     NOP
18654  F4DE     NOP
18656  0061     MOVFFL ttemp1, POSTINC2
18658  F410     NOP
1865A  F4DE     NOP
225:           
226:           	if (EB->bat_energy > BAT_ENERGY) { // limit up energy
1865C  0EF6     MOVLW 0xF6
1865E  0061     MOVFFL PLUSW1, wtemp5
18660  F38C     NOP
18662  F50B     NOP
18664  0EF7     MOVLW 0xF7
18666  0061     MOVFFL PLUSW1, 0x50C
18668  F38C     NOP
1866A  F50C     NOP
1866C  0E2C     MOVLW 0x2C
1866E  240B     ADDWF 0xB, W, ACCESS
18670  6ED9     MOVWF 0xFD9, ACCESS
18672  0E00     MOVLW 0x0
18674  200C     ADDWFC 0xC, W, ACCESS
18676  6EDA     MOVWF __end_of_UART2_tx_vect_isr, ACCESS
18678  C4DE     MOVFF POSTINC2, POSTINC1
1867A  F4E6     NOP
1867C  C4DE     MOVFF POSTINC2, POSTINC1
1867E  F4E6     NOP
18680  C4DE     MOVFF POSTINC2, POSTINC1
18682  F4E6     NOP
18684  C4DE     MOVFF POSTINC2, POSTINC1
18686  F4E6     NOP
18688  0E00     MOVLW 0x0
1868A  6EE6     MOVWF 0xFE6, ACCESS
1868C  0E00     MOVLW 0x0
1868E  6EE6     MOVWF 0xFE6, ACCESS
18690  0EE1     MOVLW 0xE1
18692  6EE6     MOVWF 0xFE6, ACCESS
18694  0E49     MOVLW 0x49
18696  6EE6     MOVWF 0xFE6, ACCESS
18698  EC60     CALL 0x1D6C0, 0
1869A  F0EB     NOP
1869C  B001     BTFSC __ptext283, 0, ACCESS
1869E  D016     BRA 0x86CC
227:           		EB->bat_energy = BAT_ENERGY;
186A0  0EF6     MOVLW 0xF6
186A2  0061     MOVFFL PLUSW1, wtemp5
186A4  F38C     NOP
186A6  F50B     NOP
186A8  0EF7     MOVLW 0xF7
186AA  0061     MOVFFL PLUSW1, 0x50C
186AC  F38C     NOP
186AE  F50C     NOP
186B0  0E2C     MOVLW 0x2C
186B2  240B     ADDWF 0xB, W, ACCESS
186B4  6ED9     MOVWF 0xFD9, ACCESS
186B6  0E00     MOVLW 0x0
186B8  200C     ADDWFC 0xC, W, ACCESS
186BA  6EDA     MOVWF __end_of_UART2_tx_vect_isr, ACCESS
186BC  0E00     MOVLW 0x0
186BE  6EDE     MOVWF 0xFDE, ACCESS
186C0  0E00     MOVLW 0x0
186C2  6EDE     MOVWF 0xFDE, ACCESS
186C4  0EE1     MOVLW 0xE1
186C6  6EDE     MOVWF 0xFDE, ACCESS
186C8  0E49     MOVLW 0x49
186CA  6EDD     MOVWF 0xFDD, ACCESS
228:           	}
229:           	if (EB->bat_energy <= 0.0001f) { // limit down energy
186CC  0EF6     MOVLW 0xF6
186CE  0061     MOVFFL PLUSW1, wtemp5
186D0  F38C     NOP
186D2  F50B     NOP
186D4  0EF7     MOVLW 0xF7
186D6  0061     MOVFFL PLUSW1, 0x50C
186D8  F38C     NOP
186DA  F50C     NOP
186DC  0E2C     MOVLW 0x2C
186DE  240B     ADDWF 0xB, W, ACCESS
186E0  6ED9     MOVWF 0xFD9, ACCESS
186E2  0E00     MOVLW 0x0
186E4  200C     ADDWFC 0xC, W, ACCESS
186E6  6EDA     MOVWF __end_of_UART2_tx_vect_isr, ACCESS
186E8  C4DE     MOVFF POSTINC2, POSTINC1
186EA  F4E6     NOP
186EC  C4DE     MOVFF POSTINC2, POSTINC1
186EE  F4E6     NOP
186F0  C4DE     MOVFF POSTINC2, POSTINC1
186F2  F4E6     NOP
186F4  C4DE     MOVFF POSTINC2, POSTINC1
186F6  F4E6     NOP
186F8  0E17     MOVLW 0x17
186FA  6EE6     MOVWF 0xFE6, ACCESS
186FC  0EB7     MOVLW 0xB7
186FE  6EE6     MOVWF 0xFE6, ACCESS
18700  0ED1     MOVLW 0xD1
18702  6EE6     MOVWF 0xFE6, ACCESS
18704  0E38     MOVLW 0x38
18706  6EE6     MOVWF 0xFE6, ACCESS
18708  EC60     CALL 0x1D6C0, 0
1870A  F0EB     NOP
1870C  A001     BTFSS __ptext283, 0, ACCESS
1870E  D016     BRA 0x873C
230:           		EB->bat_energy = 0.0001f;
18710  0EF6     MOVLW 0xF6
18712  0061     MOVFFL PLUSW1, wtemp5
18714  F38C     NOP
18716  F50B     NOP
18718  0EF7     MOVLW 0xF7
1871A  0061     MOVFFL PLUSW1, 0x50C
1871C  F38C     NOP
1871E  F50C     NOP
18720  0E2C     MOVLW 0x2C
18722  240B     ADDWF 0xB, W, ACCESS
18724  6ED9     MOVWF 0xFD9, ACCESS
18726  0E00     MOVLW 0x0
18728  200C     ADDWFC 0xC, W, ACCESS
1872A  6EDA     MOVWF __end_of_UART2_tx_vect_isr, ACCESS
1872C  0E17     MOVLW 0x17
1872E  6EDE     MOVWF 0xFDE, ACCESS
18730  0EB7     MOVLW 0xB7
18732  6EDE     MOVWF 0xFDE, ACCESS
18734  0ED1     MOVLW 0xD1
18736  6EDE     MOVWF 0xFDE, ACCESS
18738  0E38     MOVLW 0x38
1873A  6EDD     MOVWF 0xFDD, ACCESS
231:           	}
232:           
233:           	if (B.pv_update) { // solar day status has changed
1873C  0105     MOVLB 0x5
1873E  5164     MOVF PMD4, W, BANKED
18740  B4D8     BTFSC 0xFD8, 2, ACCESS
18742  D02B     BRA 0x879A
234:           		B.pv_update = false;
18744  6B64     CLRF PMD4, BANKED
235:           		if (B.pv_prev == STATUS_SLEEPING) { // day to night update
18746  516B     MOVF MD1CON1, W, BANKED
18748  116C     IORWF MD1SRC, W, BANKED
1874A  A4D8     BTFSS 0xFD8, 2, ACCESS
1874C  D003     BRA 0x8754
236:           			run_day_to_night();
1874E  EC22     CALL 0x1EC44, 0
18750  F0F6     NOP
237:           		} else { // night to day update
18752  D023     BRA 0x879A
238:           			pv_Wh_daily_prev = pv_Wh_daily;
18754  C639     MOVFF pv_Wh_daily, pv_Wh_daily_prev
18756  F631     NOP
18758  C63A     MOVFF 0x63A, 0x632
1875A  F632     NOP
1875C  C63B     MOVFF 0x63B, 0x633
1875E  F633     NOP
18760  C63C     MOVFF 0x63C, 0x634
18762  F634     NOP
239:           			ac_Wh_daily_prev = ac_Wh_daily;
18764  C635     MOVFF ac_Wh_daily, ac_Wh_daily_prev
18766  F62D     NOP
18768  C636     MOVFF 0x636, 0x62E
1876A  F62E     NOP
1876C  C637     MOVFF 0x637, 0x62F
1876E  F62F     NOP
18770  C638     MOVFF 0x638, 0x630
18772  F630     NOP
240:           			pv_Wh_daily = 0.0001f;
18774  0E17     MOVLW 0x17
18776  0106     MOVLB 0x6
18778  6F39     MOVWF CLKRCON, BANKED
1877A  0EB7     MOVLW 0xB7
1877C  6F3A     MOVWF CLKRCLK, BANKED
1877E  0ED1     MOVLW 0xD1
18780  6F3B     MOVWF 0x3B, BANKED
18782  0E38     MOVLW 0x38
18784  6F3C     MOVWF 0x3C, BANKED
241:           			ac_Wh_daily = 0.0001f;
18786  0E17     MOVLW 0x17
18788  6F35     MOVWF 0x35, BANKED
1878A  0EB7     MOVLW 0xB7
1878C  6F36     MOVWF 0x36, BANKED
1878E  0ED1     MOVLW 0xD1
18790  6F37     MOVWF 0x37, BANKED
18792  0E38     MOVLW 0x38
18794  6F38     MOVWF BOOTREG, BANKED
242:           			run_night_to_day();
18796  ECA1     CALL 0x1EB42, 0
18798  F0F5     NOP
243:           		}
244:           	}
245:           }
1879A  0EF6     MOVLW 0xF6
1879A  0EF6     MOVLW 0xF6
1879A  0EF6     MOVLW 0xF6
1879A  0EF6     MOVLW 0xF6
1879A  0EF6     MOVLW 0xF6
246:           
247:           void DATAEE_WriteByte(const uint16_t bAdd, const uint8_t bData)
0AE0  52E6     MOVF 0xFE6, F, ACCESS
248:           {
249:           	uint8_t GIEBitValue = INTCON0bits.GIE;
0AE2  AED6     BTFSS 0xFD6, 7, ACCESS
0AE4  D003     BRA 0xAEC
0AE6  6A0C     CLRF 0xC, ACCESS
0AE8  2A0C     INCF 0xC, F, ACCESS
0AEA  D001     BRA 0xAEE
0AEC  6A0C     CLRF 0xC, ACCESS
0AEE  0EFF     MOVLW 0xFF
0AF0  0061     MOVFFL 0x50C, PLUSW1
0AF2  F430     NOP
0AF4  F4E3     NOP
250:           
251:           	//Set NVMADR with the target word address (0x380000 - 0x3803FF)
252:           	NVMADRU = 0x38;
0AF6  0E38     MOVLW 0x38
0AF8  0100     MOVLB 0x0
0AFA  6F45     MOVWF NVMADRU, BANKED
253:           	NVMADRH = (uint8_t) ((bAdd & 0xFF00) >> 8);
0AFC  0EFE     MOVLW 0xFE
0AFE  24E1     ADDWF 0xFE1, W, ACCESS
0B00  6ED9     MOVWF 0xFD9, ACCESS
0B02  0EFF     MOVLW 0xFF
0B04  20E2     ADDWFC 0xFE2, W, ACCESS
0B06  6EDA     MOVWF __end_of_UART2_tx_vect_isr, ACCESS
0B08  50DF     MOVF 0xFDF, W, ACCESS
0B0A  6F44     MOVWF NVMADRH, BANKED
254:           	NVMADRL = (uint8_t) (bAdd & 0x00FF);
0B0C  0EFD     MOVLW 0xFD
0B0E  C4E3     MOVFF PLUSW1, NVMADR
0B10  F043     NOP
255:           
256:           	//Load NVMDATL with desired byte
257:           	NVMDATL = bData;
0B12  0EFC     MOVLW 0xFC
0B14  C4E3     MOVFF PLUSW1, NVMDAT
0B16  F046     NOP
258:           
259:           	//Set the NVMCMD control bits for DFM Byte Write operation
260:           	NVMCON1bits.NVMCMD = 0b011;
0B18  5141     MOVF NVMCON1, W, BANKED
0B1A  0BF8     ANDLW 0xF8
0B1C  0903     IORLW 0x3
0B1E  6F41     MOVWF NVMCON1, BANKED
261:           
262:           	//Disable all interrupts
263:           	INTCON0bits.GIE = 0;
0B20  9ED6     BCF 0xFD6, 7, ACCESS
264:           
265:           	//Perform the unlock sequence and start Page Erase
266:           	NVMLOCK = 0x55;
0B22  0E55     MOVLW 0x55
0B24  6F42     MOVWF NVMLOCK, BANKED
267:           	NVMLOCK = 0xAA;
0B26  0EAA     MOVLW 0xAA
0B28  6F42     MOVWF NVMLOCK, BANKED
268:           
269:           	//Start DFM write and wait for the operation to complete
270:           	NVMCON0bits.GO = 1;
0B2A  8140     BSF NVMCON0, 0, BANKED
271:           	while (NVMCON0bits.GO);
0B2C  B140     BTFSC NVMCON0, 0, BANKED
0B2E  D7FE     BRA 0xB2C
272:           
273:           	//Restore all the interrupts
274:           	INTCON0bits.GIE = GIEBitValue;
0B30  0EFF     MOVLW 0xFF
0B32  B0E3     BTFSC 0xFE3, 0, ACCESS
0B34  D002     BRA 0xB3A
0B36  9ED6     BCF 0xFD6, 7, ACCESS
0B38  D001     BRA 0xB3C
0B3A  8ED6     BSF 0xFD6, 7, ACCESS
275:           
276:           	//Set the NVMCMD control bits for Word Read operation to avoid accidental writes
277:           	NVMCON1bits.NVMCMD = 0b000;
0B3C  0EF8     MOVLW 0xF8
0B3E  0100     MOVLB 0x0
0B40  1741     ANDWF NVMCON1, F, BANKED
278:           }
0B42  52E5     MOVF 0xFE5, F, ACCESS
0B42  52E5     MOVF 0xFE5, F, ACCESS
0B42  52E5     MOVF 0xFE5, F, ACCESS
0B42  52E5     MOVF 0xFE5, F, ACCESS
0B42  52E5     MOVF 0xFE5, F, ACCESS
279:           
280:           uint8_t DATAEE_ReadByte(const uint16_t bAdd)
281:           {
282:           	//Set NVMADR with the target word address (0x380000 - 0x3803FF)
283:           	NVMADRU = 0x38;
1D14  0E38     MOVLW 0x38
1D16  0100     MOVLB 0x0
1D18  6F45     MOVWF NVMADRU, BANKED
284:           	NVMADRH = (uint8_t) ((bAdd & 0xFF00) >> 8);
1D1A  0EFF     MOVLW 0xFF
1D1C  24E1     ADDWF 0xFE1, W, ACCESS
1D1E  6ED9     MOVWF 0xFD9, ACCESS
1D20  0EFF     MOVLW 0xFF
1D22  20E2     ADDWFC 0xFE2, W, ACCESS
1D24  6EDA     MOVWF __end_of_UART2_tx_vect_isr, ACCESS
1D26  50DF     MOVF 0xFDF, W, ACCESS
1D28  6F44     MOVWF NVMADRH, BANKED
285:           	NVMADRL = (uint8_t) (bAdd & 0x00FF);
1D2A  0EFE     MOVLW 0xFE
1D2C  C4E3     MOVFF PLUSW1, NVMADR
1D2E  F043     NOP
286:           
287:           	//Set the NVMCMD control bits for DFM Byte Read operation
288:           	NVMCON1bits.NVMCMD = 0b000;
1D30  0EF8     MOVLW 0xF8
1D32  1741     ANDWF NVMCON1, F, BANKED
289:           	NVMCON0bits.GO = 1;
1D34  8140     BSF NVMCON0, 0, BANKED
290:           
291:           	return NVMDATL;
1D36  0060     MOVFFL NVMDAT, ltemp0
1D38  F118     NOP
1D3A  F501     NOP
292:           }
1D3C  52E5     MOVF 0xFE5, F, ACCESS
1D3C  52E5     MOVF 0xFE5, F, ACCESS
1D3C  52E5     MOVF 0xFE5, F, ACCESS
293:           
294:           /*
295:            * static SOC table for LiFePO4
296:            */
297:           uint16_t Volts_to_SOC(const uint16_t bvw, const uint16_t bvf)
1E2DE  52E6     MOVF 0xFE6, F, ACCESS
1E2E0  52E6     MOVF 0xFE6, F, ACCESS
1E2E2  52E6     MOVF 0xFE6, F, ACCESS
298:           {
299:           	uint8_t slot;
300:           	uint16_t soc = 0;
1E2E4  0EFD     MOVLW 0xFD
1E2E6  6AE3     CLRF 0xFE3, ACCESS
1E2E8  0EFE     MOVLW 0xFE
1E2EA  6AE3     CLRF 0xFE3, ACCESS
301:           
302:           	/*
303:           	 * walk up the table
304:           	 */
305:           	for (slot = 0; slot < BVSOC_SLOTS; slot++) {
1E2EC  0EFF     MOVLW 0xFF
1E2EE  6AE3     CLRF 0xFE3, ACCESS
306:           		if ((bvw * 1000 + bvf * 100) > BVSOC_TABLE[slot][0]) {
1E2F0  0EF9     MOVLW 0xF9
1E2F2  0061     MOVFFL PLUSW1, wtemp5
1E2F4  F38C     NOP
1E2F6  F50B     NOP
1E2F8  0EFA     MOVLW 0xFA
1E2FA  0061     MOVFFL PLUSW1, 0x50C
1E2FC  F38C     NOP
1E2FE  F50C     NOP
1E300  0E64     MOVLW 0x64
1E302  020B     MULWF 0xB, ACCESS
1E304  0061     MOVFFL PROD, ltemp2
1E306  F3CC     NOP
1E308  F509     NOP
1E30A  0061     MOVFFL PRODH, ttemp3
1E30C  F3D0     NOP
1E30E  F50A     NOP
1E310  020C     MULWF 0xC, ACCESS
1E312  50F3     MOVF 0xFF3, W, ACCESS
1E314  260A     ADDWF 0xA, F, ACCESS
1E316  0EE8     MOVLW 0xE8
1E318  6E0B     MOVWF 0xB, ACCESS
1E31A  0E03     MOVLW 0x3
1E31C  6E0C     MOVWF 0xC, ACCESS
1E31E  0EFB     MOVLW 0xFB
1E320  50E3     MOVF 0xFE3, W, ACCESS
1E322  020B     MULWF 0xB, ACCESS
1E324  0061     MOVFFL PROD, ttemp2
1E326  F3CC     NOP
1E328  F507     NOP
1E32A  0061     MOVFFL PRODH, 0x508
1E32C  F3D0     NOP
1E32E  F508     NOP
1E330  020C     MULWF 0xC, ACCESS
1E332  50F3     MOVF 0xFF3, W, ACCESS
1E334  2608     ADDWF 0x8, F, ACCESS
1E336  0EFC     MOVLW 0xFC
1E338  50E3     MOVF 0xFE3, W, ACCESS
1E33A  020B     MULWF 0xB, ACCESS
1E33C  50F3     MOVF 0xFF3, W, ACCESS
1E33E  2608     ADDWF 0x8, F, ACCESS
1E340  5009     MOVF 0x9, W, ACCESS
1E342  2407     ADDWF 0x7, W, ACCESS
1E344  6E01     MOVWF __ptext283, ACCESS
1E346  500A     MOVF 0xA, W, ACCESS
1E348  2008     ADDWFC 0x8, W, ACCESS
1E34A  6E02     MOVWF ___rparam_used, ACCESS
1E34C  6A03     CLRF __activetblptr, ACCESS
1E34E  6A04     CLRF __activetblptr, ACCESS
1E350  0EFF     MOVLW 0xFF
1E352  50E3     MOVF 0xFE3, W, ACCESS
1E354  0D08     MULLW 0x8
1E356  0E69     MOVLW 0x69
1E358  24F3     ADDWF 0xFF3, W, ACCESS
1E35A  6EF6     MOVWF 0xFF6, ACCESS
1E35C  0EF9     MOVLW 0xF9
1E35E  20F4     ADDWFC 0xFF4, W, ACCESS
1E360  6EF7     MOVWF 0xFF7, ACCESS
1E362  6AF8     CLRF 0xFF8, ACCESS
1E364  0E00     MOVLW 0x0
1E366  22F8     ADDWFC 0xFF8, F, ACCESS
1E368  5001     MOVF __ptext283, W, ACCESS
1E36A  0009     TBLRD*+
1E36C  5CF5     SUBWF 0xFF5, W, ACCESS
1E36E  5002     MOVF ___rparam_used, W, ACCESS
1E370  0009     TBLRD*+
1E372  58F5     SUBWFB 0xFF5, W, ACCESS
1E374  5003     MOVF __activetblptr, W, ACCESS
1E376  0009     TBLRD*+
1E378  58F5     SUBWFB 0xFF5, W, ACCESS
1E37A  5004     MOVF __activetblptr, W, ACCESS
1E37C  0009     TBLRD*+
1E37E  58F5     SUBWFB 0xFF5, W, ACCESS
1E380  B0D8     BTFSC 0xFD8, 0, ACCESS
1E382  D020     BRA 0xE3C4
307:           			soc = (uint16_t) BVSOC_TABLE[slot][1];
1E384  0EFF     MOVLW 0xFF
1E386  50E3     MOVF 0xFE3, W, ACCESS
1E388  0D08     MULLW 0x8
1E38A  0E04     MOVLW 0x4
1E38C  26F3     ADDWF 0xFF3, F, ACCESS
1E38E  0E00     MOVLW 0x0
1E390  22F4     ADDWFC 0xFF4, F, ACCESS
1E392  0E69     MOVLW 0x69
1E394  24F3     ADDWF 0xFF3, W, ACCESS
1E396  6EF6     MOVWF 0xFF6, ACCESS
1E398  0EF9     MOVLW 0xF9
1E39A  20F4     ADDWFC 0xFF4, W, ACCESS
1E39C  6EF7     MOVWF 0xFF7, ACCESS
1E39E  6AF8     CLRF 0xFF8, ACCESS
1E3A0  0E00     MOVLW 0x0
1E3A2  22F8     ADDWFC 0xFF8, F, ACCESS
1E3A4  0009     TBLRD*+
1E3A6  0061     MOVFFL TABLAT, wtemp5
1E3A8  F3D4     NOP
1E3AA  F50B     NOP
1E3AC  0009     TBLRD*+
1E3AE  0061     MOVFFL TABLAT, 0x50C
1E3B0  F3D4     NOP
1E3B2  F50C     NOP
1E3B4  0EFD     MOVLW 0xFD
1E3B6  0061     MOVFFL wtemp5, PLUSW1
1E3B8  F42C     NOP
1E3BA  F4E3     NOP
1E3BC  0EFE     MOVLW 0xFE
1E3BE  0061     MOVFFL 0x50C, PLUSW1
1E3C0  F430     NOP
1E3C2  F4E3     NOP
308:           		}
309:           	}
1E3C4  0EFF     MOVLW 0xFF
1E3C6  2AE3     INCF 0xFE3, F, ACCESS
1E3C8  0EFF     MOVLW 0xFF
1E3CA  0061     MOVFFL PLUSW1, ltemp0
1E3CC  F38C     NOP
1E3CE  F501     NOP
1E3D0  0E0B     MOVLW 0xB
1E3D2  6401     CPFSGT __ptext283, ACCESS
1E3D4  D78D     BRA 0xE2F0
310:           	return soc;
1E3D6  0EFD     MOVLW 0xFD
1E3D8  0061     MOVFFL PLUSW1, ltemp0
1E3DA  F38C     NOP
1E3DC  F501     NOP
1E3DE  0EFE     MOVLW 0xFE
1E3E0  0061     MOVFFL PLUSW1, ttemp5
1E3E2  F38C     NOP
1E3E4  F502     NOP
311:           }
1E3E6  0EF9     MOVLW 0xF9
1E3E6  0EF9     MOVLW 0xF9
1E3E6  0EF9     MOVLW 0xF9
1E3E6  0EF9     MOVLW 0xF9
1E3E6  0EF9     MOVLW 0xF9
312:           
313:           device_id_data_t DeviceID_Read(device_id_address_t address)
1DC04  0E06     MOVLW 0x6
1DC06  26E1     ADDWF 0xFE1, F, ACCESS
1DC08  0E00     MOVLW 0x0
1DC0A  22E2     ADDWFC 0xFE2, F, ACCESS
314:           {
315:           	device_id_data_t deviceID;
316:           
317:           	//Save the table pointer
318:           	uint32_t tablePointer = ((uint32_t) TBLPTRU << 16) | ((uint32_t) TBLPTRH << 8) | ((uint32_t) TBLPTRL);
1DC0C  0061     MOVFFL TBLPTRH, ltemp2
1DC0E  F3DC     NOP
1DC10  F509     NOP
1DC12  6A0A     CLRF 0xA, ACCESS
1DC14  6A0B     CLRF 0xB, ACCESS
1DC16  6A0C     CLRF 0xC, ACCESS
1DC18  0061     MOVFFL wtemp5, 0x50C
1DC1A  F42C     NOP
1DC1C  F50C     NOP
1DC1E  0061     MOVFFL ttemp3, wtemp5
1DC20  F428     NOP
1DC22  F50B     NOP
1DC24  0061     MOVFFL ltemp2, ttemp3
1DC26  F424     NOP
1DC28  F50A     NOP
1DC2A  6A09     CLRF 0x9, ACCESS
1DC2C  0061     MOVFFL TBLPTRU, ltemp1
1DC2E  F3E0     NOP
1DC30  F505     NOP
1DC32  6A06     CLRF 0x6, ACCESS
1DC34  6A07     CLRF 0x7, ACCESS
1DC36  6A08     CLRF 0x8, ACCESS
1DC38  0061     MOVFFL 0x506, 0x508
1DC3A  F418     NOP
1DC3C  F508     NOP
1DC3E  0061     MOVFFL ltemp1, ttemp2
1DC40  F414     NOP
1DC42  F507     NOP
1DC44  6A06     CLRF 0x6, ACCESS
1DC46  6A05     CLRF 0x5, ACCESS
1DC48  5009     MOVF 0x9, W, ACCESS
1DC4A  1205     IORWF 0x5, F, ACCESS
1DC4C  500A     MOVF 0xA, W, ACCESS
1DC4E  1206     IORWF 0x6, F, ACCESS
1DC50  500B     MOVF 0xB, W, ACCESS
1DC52  1207     IORWF 0x7, F, ACCESS
1DC54  500C     MOVF 0xC, W, ACCESS
1DC56  1208     IORWF 0x8, F, ACCESS
1DC58  50F6     MOVF 0xFF6, W, ACCESS
1DC5A  1005     IORWF 0x5, W, ACCESS
1DC5C  6E09     MOVWF 0x9, ACCESS
1DC5E  5006     MOVF 0x6, W, ACCESS
1DC60  6E0A     MOVWF 0xA, ACCESS
1DC62  5007     MOVF 0x7, W, ACCESS
1DC64  6E0B     MOVWF 0xB, ACCESS
1DC66  5008     MOVF 0x8, W, ACCESS
1DC68  6E0C     MOVWF 0xC, ACCESS
1DC6A  0EFA     MOVLW 0xFA
1DC6C  0061     MOVFFL ltemp2, PLUSW1
1DC6E  F424     NOP
1DC70  F4E3     NOP
1DC72  0EFB     MOVLW 0xFB
1DC74  0061     MOVFFL ttemp3, PLUSW1
1DC76  F428     NOP
1DC78  F4E3     NOP
1DC7A  0EFC     MOVLW 0xFC
1DC7C  0061     MOVFFL wtemp5, PLUSW1
1DC7E  F42C     NOP
1DC80  F4E3     NOP
1DC82  0EFD     MOVLW 0xFD
1DC84  0061     MOVFFL 0x50C, PLUSW1
1DC86  F430     NOP
1DC88  F4E3     NOP
319:           
320:           	//Load table pointer with Device ID address 
321:           	TBLPTRU = (uint8_t) (address >> 16);
1DC8A  0EF9     MOVLW 0xF9
1DC8C  24E1     ADDWF 0xFE1, W, ACCESS
1DC8E  6ED9     MOVWF 0xFD9, ACCESS
1DC90  0EFF     MOVLW 0xFF
1DC92  20E2     ADDWFC 0xFE2, W, ACCESS
1DC94  6EDA     MOVWF __end_of_UART2_tx_vect_isr, ACCESS
1DC96  50DF     MOVF 0xFDF, W, ACCESS
1DC98  6EF8     MOVWF 0xFF8, ACCESS
322:           	TBLPTRH = (uint8_t) (address >> 8);
1DC9A  0EF8     MOVLW 0xF8
1DC9C  24E1     ADDWF 0xFE1, W, ACCESS
1DC9E  6ED9     MOVWF 0xFD9, ACCESS
1DCA0  0EFF     MOVLW 0xFF
1DCA2  20E2     ADDWFC 0xFE2, W, ACCESS
1DCA4  6EDA     MOVWF __end_of_UART2_tx_vect_isr, ACCESS
1DCA6  50DF     MOVF 0xFDF, W, ACCESS
1DCA8  6EF7     MOVWF 0xFF7, ACCESS
323:           	TBLPTRL = (uint8_t) address;
1DCAA  0EF7     MOVLW 0xF7
1DCAC  C4E3     MOVFF PLUSW1, TBLPTR
1DCAE  F4F6     NOP
324:           
325:           	//Execute table read and increment table pointer 
326:           	asm("TBLRD*+");
1DCB0  0009     TBLRD*+
327:           
328:           	deviceID = (device_id_data_t) TABLAT;
1DCB2  50F5     MOVF 0xFF5, W, ACCESS
1DCB4  6E0B     MOVWF 0xB, ACCESS
1DCB6  6A0C     CLRF 0xC, ACCESS
1DCB8  0EFE     MOVLW 0xFE
1DCBA  0061     MOVFFL wtemp5, PLUSW1
1DCBC  F42C     NOP
1DCBE  F4E3     NOP
1DCC0  0EFF     MOVLW 0xFF
1DCC2  0061     MOVFFL 0x50C, PLUSW1
1DCC4  F430     NOP
1DCC6  F4E3     NOP
329:           
330:           	//Execute table read 
331:           	asm("TBLRD*");
1DCC8  0008     TBLRD*
332:           
333:           	deviceID |= (device_id_data_t) (TABLAT << 8);
1DCCA  50F5     MOVF 0xFF5, W, ACCESS
1DCCC  6E0C     MOVWF 0xC, ACCESS
1DCCE  6A0B     CLRF 0xB, ACCESS
1DCD0  0EFE     MOVLW 0xFE
1DCD2  0061     MOVFFL PLUSW1, ltemp0
1DCD4  F38C     NOP
1DCD6  F501     NOP
1DCD8  500B     MOVF 0xB, W, ACCESS
1DCDA  1201     IORWF __ptext283, F, ACCESS
1DCDC  0EFE     MOVLW 0xFE
1DCDE  0061     MOVFFL ltemp0, PLUSW1
1DCE0  F404     NOP
1DCE2  F4E3     NOP
1DCE4  0EFF     MOVLW 0xFF
1DCE6  0061     MOVFFL PLUSW1, ltemp0
1DCE8  F38C     NOP
1DCEA  F501     NOP
1DCEC  500C     MOVF 0xC, W, ACCESS
1DCEE  1201     IORWF __ptext283, F, ACCESS
1DCF0  0EFF     MOVLW 0xFF
1DCF2  0061     MOVFFL ltemp0, PLUSW1
1DCF4  F404     NOP
1DCF6  F4E3     NOP
334:           
335:           	//Restore the table pointer
336:           	TBLPTRU = (uint8_t) (tablePointer >> 16);
1DCF8  0EFC     MOVLW 0xFC
1DCFA  24E1     ADDWF 0xFE1, W, ACCESS
1DCFC  6ED9     MOVWF 0xFD9, ACCESS
1DCFE  0EFF     MOVLW 0xFF
1DD00  20E2     ADDWFC 0xFE2, W, ACCESS
1DD02  6EDA     MOVWF __end_of_UART2_tx_vect_isr, ACCESS
1DD04  50DF     MOVF 0xFDF, W, ACCESS
1DD06  6EF8     MOVWF 0xFF8, ACCESS
337:           	TBLPTRH = (uint8_t) (tablePointer >> 8);
1DD08  0EFB     MOVLW 0xFB
1DD0A  24E1     ADDWF 0xFE1, W, ACCESS
1DD0C  6ED9     MOVWF 0xFD9, ACCESS
1DD0E  0EFF     MOVLW 0xFF
1DD10  20E2     ADDWFC 0xFE2, W, ACCESS
1DD12  6EDA     MOVWF __end_of_UART2_tx_vect_isr, ACCESS
1DD14  50DF     MOVF 0xFDF, W, ACCESS
1DD16  6EF7     MOVWF 0xFF7, ACCESS
338:           	TBLPTRL = (uint8_t) tablePointer;
1DD18  0EFA     MOVLW 0xFA
1DD1A  C4E3     MOVFF PLUSW1, TBLPTR
1DD1C  F4F6     NOP
339:           
340:           	return deviceID;
1DD1E  0EFE     MOVLW 0xFE
1DD20  0061     MOVFFL PLUSW1, ltemp0
1DD22  F38C     NOP
1DD24  F501     NOP
1DD26  0EFF     MOVLW 0xFF
1DD28  0061     MOVFFL PLUSW1, ttemp5
1DD2A  F38C     NOP
1DD2C  F502     NOP
341:           }
122C  C4D8     MOVFF STATUS, 0xAEB
1DD2E  0EF7     MOVLW 0xF7
1DD2E  0EF7     MOVLW 0xF7
1DD2E  0EF7     MOVLW 0xF7
1DD2E  0EF7     MOVLW 0xF7
1DD2E  0EF7     MOVLW 0xF7
342:           
343:           /*
344:            * pack UNIX tm time/date into FM80 compatible 16-bit values
345:            */
346:           void update_time(struct tm * ts, EB_data * EB)
347:           {
348:           	EB->time = (
1C622  0EFE     MOVLW 0xFE
1C624  C4E3     MOVFF PLUSW1, FSR2
1C626  F4D9     NOP
1C628  0EFF     MOVLW 0xFF
1C62A  C4E3     MOVFF PLUSW1, FSR2H
1C62C  F4DA     NOP
1C62E  0061     MOVFFL POSTINC2, wtemp5
1C630  F378     NOP
1C632  F50B     NOP
1C634  0061     MOVFFL POSTDEC2, 0x50C
1C636  F374     NOP
1C638  F50C     NOP
1C63A  340C     RLCF 0xC, W, ACCESS
1C63C  300C     RRCF 0xC, W, ACCESS
1C63E  6E0A     MOVWF 0xA, ACCESS
1C640  300B     RRCF 0xB, W, ACCESS
1C642  6E09     MOVWF 0x9, ACCESS
1C644  0E0F     MOVLW 0xF
1C646  1609     ANDWF 0x9, F, ACCESS
1C648  0E00     MOVLW 0x0
1C64A  160A     ANDWF 0xA, F, ACCESS
1C64C  0EFE     MOVLW 0xFE
1C64E  0061     MOVFFL PLUSW1, wtemp5
1C650  F38C     NOP
1C652  F50B     NOP
1C654  0EFF     MOVLW 0xFF
1C656  0061     MOVFFL PLUSW1, 0x50C
1C658  F38C     NOP
1C65A  F50C     NOP
1C65C  0E02     MOVLW 0x2
1C65E  240B     ADDWF 0xB, W, ACCESS
1C660  6ED9     MOVWF 0xFD9, ACCESS
1C662  0E00     MOVLW 0x0
1C664  200C     ADDWFC 0xC, W, ACCESS
1C666  6EDA     MOVWF __end_of_UART2_tx_vect_isr, ACCESS
1C668  0061     MOVFFL POSTINC2, wtemp5
1C66A  F378     NOP
1C66C  F50B     NOP
1C66E  0061     MOVFFL POSTDEC2, 0x50C
1C670  F374     NOP
1C672  F50C     NOP
1C674  0E3F     MOVLW 0x3F
1C676  160B     ANDWF 0xB, F, ACCESS
1C678  0E00     MOVLW 0x0
1C67A  160C     ANDWF 0xC, F, ACCESS
1C67C  0E05     MOVLW 0x5
1C67E  90D8     BCF 0xFD8, 0, ACCESS
1C680  360B     RLCF 0xB, F, ACCESS
1C682  360C     RLCF 0xC, F, ACCESS
1C684  2EE8     DECFSZ 0xFE8, F, ACCESS
1C686  D7FB     BRA 0xC67E
1C688  0EFE     MOVLW 0xFE
1C68A  0061     MOVFFL PLUSW1, ttemp2
1C68C  F38C     NOP
1C68E  F507     NOP
1C690  0EFF     MOVLW 0xFF
1C692  0061     MOVFFL PLUSW1, 0x508
1C694  F38C     NOP
1C696  F508     NOP
1C698  0E04     MOVLW 0x4
1C69A  2407     ADDWF 0x7, W, ACCESS
1C69C  6ED9     MOVWF 0xFD9, ACCESS
1C69E  0E00     MOVLW 0x0
1C6A0  2008     ADDWFC 0x8, W, ACCESS
1C6A2  6EDA     MOVWF __end_of_UART2_tx_vect_isr, ACCESS
1C6A4  0061     MOVFFL POSTINC2, ttemp2
1C6A6  F378     NOP
1C6A8  F507     NOP
1C6AA  0061     MOVFFL POSTDEC2, 0x508
1C6AC  F374     NOP
1C6AE  F508     NOP
1C6B0  0E1F     MOVLW 0x1F
1C6B2  1607     ANDWF 0x7, F, ACCESS
1C6B4  0E00     MOVLW 0x0
1C6B6  1608     ANDWF 0x8, F, ACCESS
1C6B8  0E0B     MOVLW 0xB
1C6BA  90D8     BCF 0xFD8, 0, ACCESS
1C6BC  3607     RLCF 0x7, F, ACCESS
1C6BE  3608     RLCF 0x8, F, ACCESS
1C6C0  2EE8     DECFSZ 0xFE8, F, ACCESS
1C6C2  D7FB     BRA 0xC6BA
1C6C4  500B     MOVF 0xB, W, ACCESS
1C6C6  1007     IORWF 0x7, W, ACCESS
1C6C8  6E05     MOVWF 0x5, ACCESS
1C6CA  500C     MOVF 0xC, W, ACCESS
1C6CC  1008     IORWF 0x8, W, ACCESS
1C6CE  6E06     MOVWF 0x6, ACCESS
1C6D0  5009     MOVF 0x9, W, ACCESS
1C6D2  1005     IORWF 0x5, W, ACCESS
1C6D4  6E0B     MOVWF 0xB, ACCESS
1C6D6  500A     MOVF 0xA, W, ACCESS
1C6D8  1006     IORWF 0x6, W, ACCESS
1C6DA  6E0C     MOVWF 0xC, ACCESS
1C6DC  0EFC     MOVLW 0xFC
1C6DE  0061     MOVFFL PLUSW1, ltemp2
1C6E0  F38C     NOP
1C6E2  F509     NOP
1C6E4  0EFD     MOVLW 0xFD
1C6E6  0061     MOVFFL PLUSW1, ttemp3
1C6E8  F38C     NOP
1C6EA  F50A     NOP
1C6EC  0E36     MOVLW 0x36
1C6EE  2409     ADDWF 0x9, W, ACCESS
1C6F0  6ED9     MOVWF 0xFD9, ACCESS
1C6F2  0E00     MOVLW 0x0
1C6F4  200A     ADDWFC 0xA, W, ACCESS
1C6F6  6EDA     MOVWF __end_of_UART2_tx_vect_isr, ACCESS
1C6F8  0061     MOVFFL wtemp5, POSTINC2
1C6FA  F42C     NOP
1C6FC  F4DE     NOP
1C6FE  0061     MOVFFL 0x50C, POSTDEC2
1C700  F430     NOP
1C702  F4DD     NOP
349:           		(uint16_t) ((ts->tm_hour & 0x1F) << 11) |
350:           		(uint16_t) ((ts->tm_min & 0x3F) << 5) |
351:           		(uint16_t) ((ts->tm_sec & 0x1F) >> 1)
352:           		);
353:           	EB->date = (
1C704  0EFE     MOVLW 0xFE
1C706  0061     MOVFFL PLUSW1, wtemp5
1C708  F38C     NOP
1C70A  F50B     NOP
1C70C  0EFF     MOVLW 0xFF
1C70E  0061     MOVFFL PLUSW1, 0x50C
1C710  F38C     NOP
1C712  F50C     NOP
1C714  0E06     MOVLW 0x6
1C716  240B     ADDWF 0xB, W, ACCESS
1C718  6ED9     MOVWF 0xFD9, ACCESS
1C71A  0E00     MOVLW 0x0
1C71C  200C     ADDWFC 0xC, W, ACCESS
1C71E  6EDA     MOVWF __end_of_UART2_tx_vect_isr, ACCESS
1C720  0061     MOVFFL POSTINC2, wtemp5
1C722  F378     NOP
1C724  F50B     NOP
1C726  0061     MOVFFL POSTDEC2, 0x50C
1C728  F374     NOP
1C72A  F50C     NOP
1C72C  0E1F     MOVLW 0x1F
1C72E  160B     ANDWF 0xB, F, ACCESS
1C730  0E00     MOVLW 0x0
1C732  160C     ANDWF 0xC, F, ACCESS
1C734  0EFE     MOVLW 0xFE
1C736  0061     MOVFFL PLUSW1, ltemp2
1C738  F38C     NOP
1C73A  F509     NOP
1C73C  0EFF     MOVLW 0xFF
1C73E  0061     MOVFFL PLUSW1, ttemp3
1C740  F38C     NOP
1C742  F50A     NOP
1C744  0E08     MOVLW 0x8
1C746  2409     ADDWF 0x9, W, ACCESS
1C748  6ED9     MOVWF 0xFD9, ACCESS
1C74A  0E00     MOVLW 0x0
1C74C  200A     ADDWFC 0xA, W, ACCESS
1C74E  6EDA     MOVWF __end_of_UART2_tx_vect_isr, ACCESS
1C750  0061     MOVFFL POSTINC2, ltemp2
1C752  F378     NOP
1C754  F509     NOP
1C756  0061     MOVFFL POSTDEC2, ttemp3
1C758  F374     NOP
1C75A  F50A     NOP
1C75C  0E0F     MOVLW 0xF
1C75E  1609     ANDWF 0x9, F, ACCESS
1C760  0E00     MOVLW 0x0
1C762  160A     ANDWF 0xA, F, ACCESS
1C764  0E05     MOVLW 0x5
1C766  90D8     BCF 0xFD8, 0, ACCESS
1C768  3609     RLCF 0x9, F, ACCESS
1C76A  360A     RLCF 0xA, F, ACCESS
1C76C  2EE8     DECFSZ 0xFE8, F, ACCESS
1C76E  D7FB     BRA 0xC766
1C770  0EFE     MOVLW 0xFE
1C772  0061     MOVFFL PLUSW1, ttemp2
1C774  F38C     NOP
1C776  F507     NOP
1C778  0EFF     MOVLW 0xFF
1C77A  0061     MOVFFL PLUSW1, 0x508
1C77C  F38C     NOP
1C77E  F508     NOP
1C780  0E0A     MOVLW 0xA
1C782  2407     ADDWF 0x7, W, ACCESS
1C784  6ED9     MOVWF 0xFD9, ACCESS
1C786  0E00     MOVLW 0x0
1C788  2008     ADDWFC 0x8, W, ACCESS
1C78A  6EDA     MOVWF __end_of_UART2_tx_vect_isr, ACCESS
1C78C  0061     MOVFFL POSTINC2, ttemp2
1C78E  F378     NOP
1C790  F507     NOP
1C792  0061     MOVFFL POSTDEC2, 0x508
1C794  F374     NOP
1C796  F508     NOP
1C798  0E30     MOVLW 0x30
1C79A  2407     ADDWF 0x7, W, ACCESS
1C79C  6E05     MOVWF 0x5, ACCESS
1C79E  0EF8     MOVLW 0xF8
1C7A0  2008     ADDWFC 0x8, W, ACCESS
1C7A2  6E06     MOVWF 0x6, ACCESS
1C7A4  0E7F     MOVLW 0x7F
1C7A6  1605     ANDWF 0x5, F, ACCESS
1C7A8  0E00     MOVLW 0x0
1C7AA  1606     ANDWF 0x6, F, ACCESS
1C7AC  0E09     MOVLW 0x9
1C7AE  90D8     BCF 0xFD8, 0, ACCESS
1C7B0  3605     RLCF 0x5, F, ACCESS
1C7B2  3606     RLCF 0x6, F, ACCESS
1C7B4  2EE8     DECFSZ 0xFE8, F, ACCESS
1C7B6  D7FB     BRA 0xC7AE
1C7B8  5009     MOVF 0x9, W, ACCESS
1C7BA  1005     IORWF 0x5, W, ACCESS
1C7BC  6E07     MOVWF 0x7, ACCESS
1C7BE  500A     MOVF 0xA, W, ACCESS
1C7C0  1006     IORWF 0x6, W, ACCESS
1C7C2  6E08     MOVWF 0x8, ACCESS
1C7C4  500B     MOVF 0xB, W, ACCESS
1C7C6  1007     IORWF 0x7, W, ACCESS
1C7C8  6E09     MOVWF 0x9, ACCESS
1C7CA  500C     MOVF 0xC, W, ACCESS
1C7CC  1008     IORWF 0x8, W, ACCESS
1C7CE  6E0A     MOVWF 0xA, ACCESS
1C7D0  0EFC     MOVLW 0xFC
1C7D2  0061     MOVFFL PLUSW1, wtemp5
1C7D4  F38C     NOP
1C7D6  F50B     NOP
1C7D8  0EFD     MOVLW 0xFD
1C7DA  0061     MOVFFL PLUSW1, 0x50C
1C7DC  F38C     NOP
1C7DE  F50C     NOP
1C7E0  0E38     MOVLW 0x38
1C7E2  240B     ADDWF 0xB, W, ACCESS
1C7E4  6ED9     MOVWF 0xFD9, ACCESS
1C7E6  0E00     MOVLW 0x0
1C7E8  200C     ADDWFC 0xC, W, ACCESS
1C7EA  6EDA     MOVWF __end_of_UART2_tx_vect_isr, ACCESS
1C7EC  0061     MOVFFL ltemp2, POSTINC2
1C7EE  F424     NOP
1C7F0  F4DE     NOP
1C7F2  0061     MOVFFL ttemp3, POSTDEC2
1C7F4  F428     NOP
1C7F6  F4DD     NOP
354:           		(uint16_t) (((ts->tm_year - 2000) & 0x7F) << 9) |
355:           		(uint16_t) ((ts->tm_mon & 0x0F) << 5) |
356:           		(uint16_t) (ts->tm_mday & 0x1F)
357:           		);
358:           }
1C7F8  52E5     MOVF 0xFE5, F, ACCESS
1C7F8  52E5     MOVF 0xFE5, F, ACCESS
1C7F8  52E5     MOVF 0xFE5, F, ACCESS
1C7F8  52E5     MOVF 0xFE5, F, ACCESS
1C7F8  52E5     MOVF 0xFE5, F, ACCESS
---  /opt/microchip/xc8/v2.41/pic/sources/c99/common/xxtofl.c  ------------------------------------------
1:             // since we use tests on the size of operands, suppress the warnings that
2:             // would be generated
3:             #pragma warning disable 757
4:             
5:             /* Convert an integer to a 32-bit floating point value.
6:              * sign : is val actually a signed value
7:              * val  : the incoming integer (signed or unsigned) for conversion, cast to a signed long
8:              */ 
9:             double
10:            __xxtofl(unsigned char sign, signed long val)
1BA6A  0E05     MOVLW 0x5
1BA6C  26E1     ADDWF 0xFE1, F, ACCESS
1BA6E  0E00     MOVLW 0x0
1BA70  22E2     ADDWFC 0xFE2, F, ACCESS
11:            {
12:            	unsigned char exp;
13:            	unsigned long arg;
14:            
15:            	if(sign && val < 0) {
1BA72  0EFA     MOVLW 0xFA
1BA74  50E3     MOVF 0xFE3, W, ACCESS
1BA76  B4D8     BTFSC 0xFD8, 2, ACCESS
1BA78  D01D     BRA 0xBAB4
1BA7A  0EF9     MOVLW 0xF9
1BA7C  AEE3     BTFSS 0xFE3, 7, ACCESS
1BA7E  D01A     BRA 0xBAB4
16:            		arg = (unsigned long) -val;
1BA80  0EF6     MOVLW 0xF6
1BA82  0061     MOVFFL PLUSW1, ltemp2
1BA84  F38C     NOP
1BA86  F509     NOP
1BA88  0EF7     MOVLW 0xF7
1BA8A  0061     MOVFFL PLUSW1, ttemp3
1BA8C  F38C     NOP
1BA8E  F50A     NOP
1BA90  0EF8     MOVLW 0xF8
1BA92  0061     MOVFFL PLUSW1, wtemp5
1BA94  F38C     NOP
1BA96  F50B     NOP
1BA98  0EF9     MOVLW 0xF9
1BA9A  0061     MOVFFL PLUSW1, 0x50C
1BA9C  F38C     NOP
1BA9E  F50C     NOP
1BAA0  1E09     COMF 0x9, F, ACCESS
1BAA2  1E0A     COMF 0xA, F, ACCESS
1BAA4  1E0B     COMF 0xB, F, ACCESS
1BAA6  1E0C     COMF 0xC, F, ACCESS
1BAA8  2A09     INCF 0x9, F, ACCESS
1BAAA  0E00     MOVLW 0x0
1BAAC  220A     ADDWFC 0xA, F, ACCESS
1BAAE  220B     ADDWFC 0xB, F, ACCESS
1BAB0  220C     ADDWFC 0xC, F, ACCESS
1BAB2  D010     BRA 0xBAD4
17:            	}
18:            	else {
19:            		arg = (unsigned long) val;
1BAB4  0EF6     MOVLW 0xF6
1BAB6  0061     MOVFFL PLUSW1, ltemp2
1BAB8  F38C     NOP
1BABA  F509     NOP
1BABC  0EF7     MOVLW 0xF7
1BABE  0061     MOVFFL PLUSW1, ttemp3
1BAC0  F38C     NOP
1BAC2  F50A     NOP
1BAC4  0EF8     MOVLW 0xF8
1BAC6  0061     MOVFFL PLUSW1, wtemp5
1BAC8  F38C     NOP
1BACA  F50B     NOP
1BACC  0EF9     MOVLW 0xF9
1BACE  0061     MOVFFL PLUSW1, 0x50C
1BAD0  F38C     NOP
1BAD2  F50C     NOP
1BAD4  0EFB     MOVLW 0xFB
1BAD6  0061     MOVFFL ltemp2, PLUSW1
1BAD8  F424     NOP
1BADA  F4E3     NOP
1BADC  0EFC     MOVLW 0xFC
1BADE  0061     MOVFFL ttemp3, PLUSW1
1BAE0  F428     NOP
1BAE2  F4E3     NOP
1BAE4  0EFD     MOVLW 0xFD
1BAE6  0061     MOVFFL wtemp5, PLUSW1
1BAE8  F42C     NOP
1BAEA  F4E3     NOP
1BAEC  0EFE     MOVLW 0xFE
1BAEE  0061     MOVFFL 0x50C, PLUSW1
1BAF0  F430     NOP
1BAF2  F4E3     NOP
20:            	}
21:            	if(val == 0)
1BAF4  0EF6     MOVLW 0xF6
1BAF6  50E3     MOVF 0xFE3, W, ACCESS
1BAF8  E113     BNZ 0xBB20
1BAFA  0EF7     MOVLW 0xF7
1BAFC  50E3     MOVF 0xFE3, W, ACCESS
1BAFE  E110     BNZ 0xBB20
1BB00  0EF8     MOVLW 0xF8
1BB02  50E3     MOVF 0xFE3, W, ACCESS
1BB04  E10D     BNZ 0xBB20
1BB06  0EF9     MOVLW 0xF9
1BB08  50E3     MOVF 0xFE3, W, ACCESS
1BB0A  A4D8     BTFSS 0xFD8, 2, ACCESS
1BB0C  D009     BRA 0xBB20
22:            		return 0.0;
1BB0E  0E00     MOVLW 0x0
1BB10  6E01     MOVWF __ptext283, ACCESS
1BB12  0E00     MOVLW 0x0
1BB14  6E02     MOVWF ___rparam_used, ACCESS
1BB16  0E00     MOVLW 0x0
1BB18  6E03     MOVWF __activetblptr, ACCESS
1BB1A  0E00     MOVLW 0x0
1BB1C  6E04     MOVWF __activetblptr, ACCESS
1BB1E  D0A2     BRA 0xBC64
23:            	exp = (127 + 23);
1BB20  0E96     MOVLW 0x96
1BB22  6E0C     MOVWF 0xC, ACCESS
1BB24  0EFF     MOVLW 0xFF
1BB26  0061     MOVFFL 0x50C, PLUSW1
1BB28  F430     NOP
1BB2A  F4E3     NOP
24:            	while(arg & ~0x1FFFFFFUL) {
1BB2C  D00B     BRA 0xBB44
1BB44  50E1     MOVF 0xFE1, W, ACCESS
1BB46  0FFB     ADDLW 0xFB
1BB48  6ED9     MOVWF 0xFD9, ACCESS
1BB4A  50E2     MOVF 0xFE2, W, ACCESS
1BB4C  6EDA     MOVWF __end_of_UART2_tx_vect_isr, ACCESS
1BB4E  0EFF     MOVLW 0xFF
1BB50  22DA     ADDWFC __end_of_UART2_tx_vect_isr, F, ACCESS
1BB52  52DE     MOVF 0xFDE, F, ACCESS
1BB54  52DE     MOVF 0xFDE, F, ACCESS
1BB56  52DE     MOVF 0xFDE, F, ACCESS
1BB58  0EFE     MOVLW 0xFE
1BB5A  14DD     ANDWF 0xFDD, W, ACCESS
1BB5C  B4D8     BTFSC 0xFD8, 2, ACCESS
1BB5E  D018     BRA 0xBB90
1BB60  D7E6     BRA 0xBB2E
25:            		++exp;
1BB2E  0EFF     MOVLW 0xFF
1BB30  2AE3     INCF 0xFE3, F, ACCESS
26:            		arg >>= 1;
1BB32  90D8     BCF 0xFD8, 0, ACCESS
1BB34  0EFE     MOVLW 0xFE
1BB36  32E3     RRCF 0xFE3, F, ACCESS
1BB38  0EFD     MOVLW 0xFD
1BB3A  32E3     RRCF 0xFE3, F, ACCESS
1BB3C  0EFC     MOVLW 0xFC
1BB3E  32E3     RRCF 0xFE3, F, ACCESS
1BB40  0EFB     MOVLW 0xFB
1BB42  32E3     RRCF 0xFE3, F, ACCESS
27:            	}
28:            	while(arg & ~0xFFFFFFUL) {
1BB90  50E1     MOVF 0xFE1, W, ACCESS
1BB92  0FFB     ADDLW 0xFB
1BB94  6ED9     MOVWF 0xFD9, ACCESS
1BB96  50E2     MOVF 0xFE2, W, ACCESS
1BB98  6EDA     MOVWF __end_of_UART2_tx_vect_isr, ACCESS
1BB9A  0EFF     MOVLW 0xFF
1BB9C  22DA     ADDWFC __end_of_UART2_tx_vect_isr, F, ACCESS
1BB9E  52DE     MOVF 0xFDE, F, ACCESS
1BBA0  52DE     MOVF 0xFDE, F, ACCESS
1BBA2  52DE     MOVF 0xFDE, F, ACCESS
1BBA4  0EFF     MOVLW 0xFF
1BBA6  14DD     ANDWF 0xFDD, W, ACCESS
1BBA8  B4D8     BTFSC 0xFD8, 2, ACCESS
1BBAA  D00C     BRA 0xBBC4
1BBAC  D7DA     BRA 0xBB62
29:            		++exp;
1BB62  0EFF     MOVLW 0xFF
1BB64  2AE3     INCF 0xFE3, F, ACCESS
30:            		++arg;
1BB66  50E1     MOVF 0xFE1, W, ACCESS
1BB68  0FFB     ADDLW 0xFB
1BB6A  6ED9     MOVWF 0xFD9, ACCESS
1BB6C  50E2     MOVF 0xFE2, W, ACCESS
1BB6E  6EDA     MOVWF __end_of_UART2_tx_vect_isr, ACCESS
1BB70  0EFF     MOVLW 0xFF
1BB72  22DA     ADDWFC __end_of_UART2_tx_vect_isr, F, ACCESS
1BB74  2ADE     INCF 0xFDE, F, ACCESS
1BB76  0E00     MOVLW 0x0
1BB78  22DE     ADDWFC 0xFDE, F, ACCESS
1BB7A  22DE     ADDWFC 0xFDE, F, ACCESS
1BB7C  22DE     ADDWFC 0xFDE, F, ACCESS
31:            		arg >>= 1;
1BB7E  90D8     BCF 0xFD8, 0, ACCESS
1BB80  0EFE     MOVLW 0xFE
1BB82  32E3     RRCF 0xFE3, F, ACCESS
1BB84  0EFD     MOVLW 0xFD
1BB86  32E3     RRCF 0xFE3, F, ACCESS
1BB88  0EFC     MOVLW 0xFC
1BB8A  32E3     RRCF 0xFE3, F, ACCESS
1BB8C  0EFB     MOVLW 0xFB
1BB8E  32E3     RRCF 0xFE3, F, ACCESS
32:            	}
33:            	while(!(arg & 0x800000UL) && exp > 1) {
1BBC4  0EFD     MOVLW 0xFD
1BBC6  BEE3     BTFSC 0xFE3, 7, ACCESS
1BBC8  D007     BRA 0xBBD8
1BBCA  0EFF     MOVLW 0xFF
1BBCC  0061     MOVFFL PLUSW1, ltemp0
1BBCE  F38C     NOP
1BBD0  F501     NOP
1BBD2  0E02     MOVLW 0x2
1BBD4  6001     CPFSLT __ptext283, ACCESS
1BBD6  D7EB     BRA 0xBBAE
34:            		--exp;
1BBAE  0EFF     MOVLW 0xFF
1BBB0  06E3     DECF 0xFE3, F, ACCESS
35:            		arg <<= 1;
1BBB2  90D8     BCF 0xFD8, 0, ACCESS
1BBB4  0EFB     MOVLW 0xFB
1BBB6  36E3     RLCF 0xFE3, F, ACCESS
1BBB8  0EFC     MOVLW 0xFC
1BBBA  36E3     RLCF 0xFE3, F, ACCESS
1BBBC  0EFD     MOVLW 0xFD
1BBBE  36E3     RLCF 0xFE3, F, ACCESS
1BBC0  0EFE     MOVLW 0xFE
1BBC2  36E3     RLCF 0xFE3, F, ACCESS
36:            	}
37:            	if(!(exp & 1))
1BBD8  0EFF     MOVLW 0xFF
1BBDA  B0E3     BTFSC 0xFE3, 0, ACCESS
1BBDC  D002     BRA 0xBBE2
38:            		arg &= ~0x800000UL;
1BBDE  0EFD     MOVLW 0xFD
1BBE0  9EE3     BCF 0xFE3, 7, ACCESS
39:            	exp >>= 1;
1BBE2  50E1     MOVF 0xFE1, W, ACCESS
1BBE4  0FFF     ADDLW 0xFF
1BBE6  6ED9     MOVWF 0xFD9, ACCESS
1BBE8  50E2     MOVF 0xFE2, W, ACCESS
1BBEA  6EDA     MOVWF __end_of_UART2_tx_vect_isr, ACCESS
1BBEC  0EFF     MOVLW 0xFF
1BBEE  22DA     ADDWFC __end_of_UART2_tx_vect_isr, F, ACCESS
1BBF0  90D8     BCF 0xFD8, 0, ACCESS
1BBF2  32DF     RRCF 0xFDF, F, ACCESS
40:            	arg |= (unsigned long)exp << 24;
1BBF4  0EFF     MOVLW 0xFF
1BBF6  0061     MOVFFL PLUSW1, 0x50C
1BBF8  F38C     NOP
1BBFA  F50C     NOP
1BBFC  0061     MOVFFL 0x50C, ltemp1
1BBFE  F430     NOP
1BC00  F505     NOP
1BC02  6A06     CLRF 0x6, ACCESS
1BC04  6A07     CLRF 0x7, ACCESS
1BC06  6A08     CLRF 0x8, ACCESS
1BC08  0061     MOVFFL ltemp1, 0x508
1BC0A  F414     NOP
1BC0C  F508     NOP
1BC0E  6A07     CLRF 0x7, ACCESS
1BC10  6A06     CLRF 0x6, ACCESS
1BC12  6A05     CLRF 0x5, ACCESS
1BC14  50E1     MOVF 0xFE1, W, ACCESS
1BC16  0FFB     ADDLW 0xFB
1BC18  6ED9     MOVWF 0xFD9, ACCESS
1BC1A  50E2     MOVF 0xFE2, W, ACCESS
1BC1C  6EDA     MOVWF __end_of_UART2_tx_vect_isr, ACCESS
1BC1E  0EFF     MOVLW 0xFF
1BC20  22DA     ADDWFC __end_of_UART2_tx_vect_isr, F, ACCESS
1BC22  5005     MOVF 0x5, W, ACCESS
1BC24  12DE     IORWF 0xFDE, F, ACCESS
1BC26  5006     MOVF 0x6, W, ACCESS
1BC28  12DE     IORWF 0xFDE, F, ACCESS
1BC2A  5007     MOVF 0x7, W, ACCESS
1BC2C  12DE     IORWF 0xFDE, F, ACCESS
1BC2E  5008     MOVF 0x8, W, ACCESS
1BC30  12DE     IORWF 0xFDE, F, ACCESS
41:            	if(sign && val < 0)
1BC32  0EFA     MOVLW 0xFA
1BC34  50E3     MOVF 0xFE3, W, ACCESS
1BC36  B4D8     BTFSC 0xFD8, 2, ACCESS
1BC38  D005     BRA 0xBC44
1BC3A  0EF9     MOVLW 0xF9
1BC3C  AEE3     BTFSS 0xFE3, 7, ACCESS
1BC3E  D002     BRA 0xBC44
42:            		arg |= 0x80000000UL;
1BC40  0EFE     MOVLW 0xFE
1BC42  8EE3     BSF 0xFE3, 7, ACCESS
43:            	return *(double *)&arg;
1BC44  0EFB     MOVLW 0xFB
1BC46  0061     MOVFFL PLUSW1, ltemp0
1BC48  F38C     NOP
1BC4A  F501     NOP
1BC4C  0EFC     MOVLW 0xFC
1BC4E  0061     MOVFFL PLUSW1, ttemp5
1BC50  F38C     NOP
1BC52  F502     NOP
1BC54  0EFD     MOVLW 0xFD
1BC56  0061     MOVFFL PLUSW1, wtemp1
1BC58  F38C     NOP
1BC5A  F503     NOP
1BC5C  0EFE     MOVLW 0xFE
1BC5E  0061     MOVFFL PLUSW1, ttemp1
1BC60  F38C     NOP
1BC62  F504     NOP
44:            }
1BC64  0EF6     MOVLW 0xF6
1BC66  26E1     ADDWF 0xFE1, F, ACCESS
1BC68  0EFF     MOVLW 0xFF
1BC6A  22E2     ADDWFC 0xFE2, F, ACCESS
1BC6A  22E2     ADDWFC 0xFE2, F, ACCESS
---  /opt/microchip/xc8/v2.41/pic/sources/c99/common/toupper.c  -----------------------------------------
1:             #include <ctype.h>
2:             #include "libc.h"
3:             
4:             int toupper(int c)
5:             {
6:             	if (islower(c)) return c & 0x5f;
118A  0EFE     MOVLW 0xFE
118C  50E3     MOVF 0xFE3, W, ACCESS
118E  0F9F     ADDLW 0x9F
1190  6E0B     MOVWF 0xB, ACCESS
1192  0EFF     MOVLW 0xFF
1194  0061     MOVFFL PLUSW1, 0x50C
1196  F38C     NOP
1198  F50C     NOP
119A  0EFF     MOVLW 0xFF
119C  220C     ADDWFC 0xC, F, ACCESS
119E  500C     MOVF 0xC, W, ACCESS
11A0  E111     BNZ 0x11C4
11A2  0E1A     MOVLW 0x1A
11A4  5C0B     SUBWF 0xB, W, ACCESS
11A6  B0D8     BTFSC 0xFD8, 0, ACCESS
11A8  D00D     BRA 0x11C4
11AA  0EFE     MOVLW 0xFE
11AC  0061     MOVFFL PLUSW1, ltemp0
11AE  F38C     NOP
11B0  F501     NOP
11B2  0EFF     MOVLW 0xFF
11B4  0061     MOVFFL PLUSW1, ttemp5
11B6  F38C     NOP
11B8  F502     NOP
11BA  0E5F     MOVLW 0x5F
11BC  1601     ANDWF __ptext283, F, ACCESS
11BE  0E00     MOVLW 0x0
11C0  1602     ANDWF ___rparam_used, F, ACCESS
11C2  D008     BRA 0x11D4
7:             	return c;
11C4  0EFE     MOVLW 0xFE
11C6  0061     MOVFFL PLUSW1, ltemp0
11C8  F38C     NOP
11CA  F501     NOP
11CC  0EFF     MOVLW 0xFF
11CE  0061     MOVFFL PLUSW1, ttemp5
11D0  F38C     NOP
11D2  F502     NOP
8:             }
11D4  52E5     MOVF 0xFE5, F, ACCESS
11D6  52E5     MOVF 0xFE5, F, ACCESS
11D6  52E5     MOVF 0xFE5, F, ACCESS
9:             
10:            int __toupper_l(int c, locale_t l)
11:            {
12:            	return toupper(c);
13:            }
14:            
15:            weak_alias(__toupper_l, toupper_l);
---  /opt/microchip/xc8/v2.41/pic/sources/c99/common/tolower.c  -----------------------------------------
1:             #include <ctype.h>
2:             #include "libc.h"
3:             
4:             int tolower(int c)
5:             {
6:             	if (isupper(c)) return c | 32;
113A  0EFE     MOVLW 0xFE
113C  50E3     MOVF 0xFE3, W, ACCESS
113E  0FBF     ADDLW 0xBF
1140  6E0B     MOVWF 0xB, ACCESS
1142  0EFF     MOVLW 0xFF
1144  0061     MOVFFL PLUSW1, 0x50C
1146  F38C     NOP
1148  F50C     NOP
114A  0EFF     MOVLW 0xFF
114C  220C     ADDWFC 0xC, F, ACCESS
114E  500C     MOVF 0xC, W, ACCESS
1150  E111     BNZ 0x1174
1152  0E1A     MOVLW 0x1A
1154  5C0B     SUBWF 0xB, W, ACCESS
1156  B0D8     BTFSC 0xFD8, 0, ACCESS
1158  D00D     BRA 0x1174
115A  0EFE     MOVLW 0xFE
115C  0061     MOVFFL PLUSW1, ltemp0
115E  F38C     NOP
1160  F501     NOP
1162  0EFF     MOVLW 0xFF
1164  0061     MOVFFL PLUSW1, ttemp5
1166  F38C     NOP
1168  F502     NOP
116A  0E20     MOVLW 0x20
116C  1201     IORWF __ptext283, F, ACCESS
116E  0E00     MOVLW 0x0
1170  1202     IORWF ___rparam_used, F, ACCESS
1172  D008     BRA 0x1184
7:             	return c;
1174  0EFE     MOVLW 0xFE
1176  0061     MOVFFL PLUSW1, ltemp0
1178  F38C     NOP
117A  F501     NOP
117C  0EFF     MOVLW 0xFF
117E  0061     MOVFFL PLUSW1, ttemp5
1180  F38C     NOP
1182  F502     NOP
8:             }
1184  52E5     MOVF 0xFE5, F, ACCESS
1186  52E5     MOVF 0xFE5, F, ACCESS
1186  52E5     MOVF 0xFE5, F, ACCESS
9:             
10:            int __tolower_l(int c, locale_t l)
11:            {
12:            	return tolower(c);
13:            }
14:            
15:            weak_alias(__tolower_l, tolower_l);
---  /opt/microchip/xc8/v2.41/pic/sources/c99/common/strncmp.c  -----------------------------------------
1:             #include <string.h>
2:             
3:             int strncmp(const char *_l, const char *_r, size_t n)
1C43E  52E6     MOVF 0xFE6, F, ACCESS
1C440  52E6     MOVF 0xFE6, F, ACCESS
1C442  52E6     MOVF 0xFE6, F, ACCESS
1C444  52E6     MOVF 0xFE6, F, ACCESS
4:             {
5:             	const unsigned char *l=(void *)_l, *r=(void *)_r;
1C446  0EFA     MOVLW 0xFA
1C448  0061     MOVFFL PLUSW1, wtemp5
1C44A  F38C     NOP
1C44C  F50B     NOP
1C44E  0EFB     MOVLW 0xFB
1C450  0061     MOVFFL PLUSW1, 0x50C
1C452  F38C     NOP
1C454  F50C     NOP
1C456  0EFF     MOVLW 0xFF
1C458  0061     MOVFFL 0x50C, PLUSW1
1C45A  F430     NOP
1C45C  F4E3     NOP
1C45E  0EFE     MOVLW 0xFE
1C460  0061     MOVFFL wtemp5, PLUSW1
1C462  F42C     NOP
1C464  F4E3     NOP
1C466  0EF8     MOVLW 0xF8
1C468  0061     MOVFFL PLUSW1, wtemp5
1C46A  F38C     NOP
1C46C  F50B     NOP
1C46E  0EF9     MOVLW 0xF9
1C470  0061     MOVFFL PLUSW1, 0x50C
1C472  F38C     NOP
1C474  F50C     NOP
1C476  0EFD     MOVLW 0xFD
1C478  0061     MOVFFL 0x50C, PLUSW1
1C47A  F430     NOP
1C47C  F4E3     NOP
1C47E  0EFC     MOVLW 0xFC
1C480  0061     MOVFFL wtemp5, PLUSW1
1C482  F42C     NOP
1C484  F4E3     NOP
6:             	if (!n--) return 0;
1C486  0EF6     MOVLW 0xF6
1C488  0061     MOVFFL PLUSW1, ltemp0
1C48A  F38C     NOP
1C48C  F501     NOP
1C48E  0E01     MOVLW 0x1
1C490  5E01     SUBWF __ptext283, F, ACCESS
1C492  0EF6     MOVLW 0xF6
1C494  0061     MOVFFL ltemp0, PLUSW1
1C496  F404     NOP
1C498  F4E3     NOP
1C49A  0EF7     MOVLW 0xF7
1C49C  0061     MOVFFL PLUSW1, ltemp0
1C49E  F38C     NOP
1C4A0  F501     NOP
1C4A2  0E00     MOVLW 0x0
1C4A4  5A01     SUBWFB __ptext283, F, ACCESS
1C4A6  0EF7     MOVLW 0xF7
1C4A8  0061     MOVFFL ltemp0, PLUSW1
1C4AA  F404     NOP
1C4AC  F4E3     NOP
1C4AE  0EF6     MOVLW 0xF6
1C4B0  28E3     INCF 0xFE3, W, ACCESS
1C4B2  E13F     BNZ 0xC532
1C4B4  0EF7     MOVLW 0xF7
1C4B6  28E3     INCF 0xFE3, W, ACCESS
1C4B8  A4D8     BTFSS 0xFD8, 2, ACCESS
1C4BA  D03B     BRA 0xC532
1C4BC  0E00     MOVLW 0x0
1C4BE  6E01     MOVWF __ptext283, ACCESS
1C4C0  0E00     MOVLW 0x0
1C4C2  6E02     MOVWF ___rparam_used, ACCESS
1C4C4  D0A9     BRA 0xC618
7:             	for (; *l && *r && n && *l == *r ; l++, r++, n--);
1C4C6  0EFE     MOVLW 0xFE
1C4C8  50E3     MOVF 0xFE3, W, ACCESS
1C4CA  0F01     ADDLW 0x1
1C4CC  6E01     MOVWF __ptext283, ACCESS
1C4CE  0EFE     MOVLW 0xFE
1C4D0  0061     MOVFFL ltemp0, PLUSW1
1C4D2  F404     NOP
1C4D4  F4E3     NOP
1C4D6  6A01     CLRF __ptext283, ACCESS
1C4D8  0EFF     MOVLW 0xFF
1C4DA  50E3     MOVF 0xFE3, W, ACCESS
1C4DC  2001     ADDWFC __ptext283, W, ACCESS
1C4DE  6E01     MOVWF __ptext283, ACCESS
1C4E0  0EFF     MOVLW 0xFF
1C4E2  0061     MOVFFL ltemp0, PLUSW1
1C4E4  F404     NOP
1C4E6  F4E3     NOP
1C4E8  0EFC     MOVLW 0xFC
1C4EA  50E3     MOVF 0xFE3, W, ACCESS
1C4EC  0F01     ADDLW 0x1
1C4EE  6E01     MOVWF __ptext283, ACCESS
1C4F0  0EFC     MOVLW 0xFC
1C4F2  0061     MOVFFL ltemp0, PLUSW1
1C4F4  F404     NOP
1C4F6  F4E3     NOP
1C4F8  6A01     CLRF __ptext283, ACCESS
1C4FA  0EFD     MOVLW 0xFD
1C4FC  50E3     MOVF 0xFE3, W, ACCESS
1C4FE  2001     ADDWFC __ptext283, W, ACCESS
1C500  6E01     MOVWF __ptext283, ACCESS
1C502  0EFD     MOVLW 0xFD
1C504  0061     MOVFFL ltemp0, PLUSW1
1C506  F404     NOP
1C508  F4E3     NOP
1C50A  0EF6     MOVLW 0xF6
1C50C  0061     MOVFFL PLUSW1, ltemp0
1C50E  F38C     NOP
1C510  F501     NOP
1C512  0E01     MOVLW 0x1
1C514  5E01     SUBWF __ptext283, F, ACCESS
1C516  0EF6     MOVLW 0xF6
1C518  0061     MOVFFL ltemp0, PLUSW1
1C51A  F404     NOP
1C51C  F4E3     NOP
1C51E  0EF7     MOVLW 0xF7
1C520  0061     MOVFFL PLUSW1, ltemp0
1C522  F38C     NOP
1C524  F501     NOP
1C526  0E00     MOVLW 0x0
1C528  5A01     SUBWFB __ptext283, F, ACCESS
1C52A  0EF7     MOVLW 0xF7
1C52C  0061     MOVFFL ltemp0, PLUSW1
1C52E  F404     NOP
1C530  F4E3     NOP
1C532  50E1     MOVF 0xFE1, W, ACCESS
1C534  0FFE     ADDLW 0xFE
1C536  6ED9     MOVWF 0xFD9, ACCESS
1C538  50E2     MOVF 0xFE2, W, ACCESS
1C53A  6EDA     MOVWF __end_of_UART2_tx_vect_isr, ACCESS
1C53C  0EFF     MOVLW 0xFF
1C53E  22DA     ADDWFC __end_of_UART2_tx_vect_isr, F, ACCESS
1C540  C4DE     MOVFF POSTINC2, TBLPTR
1C542  F4F6     NOP
1C544  C4DD     MOVFF POSTDEC2, TBLPTRH
1C546  F4F7     NOP
1C548  0E00     MOVLW 0x0
1C54A  6EF8     MOVWF 0xFF8, ACCESS
1C54C  0008     TBLRD*
1C54E  50F5     MOVF 0xFF5, W, ACCESS
1C550  0900     IORLW 0x0
1C552  B4D8     BTFSC 0xFD8, 2, ACCESS
1C554  D03E     BRA 0xC5D2
1C556  50E1     MOVF 0xFE1, W, ACCESS
1C558  0FFC     ADDLW 0xFC
1C55A  6ED9     MOVWF 0xFD9, ACCESS
1C55C  50E2     MOVF 0xFE2, W, ACCESS
1C55E  6EDA     MOVWF __end_of_UART2_tx_vect_isr, ACCESS
1C560  0EFF     MOVLW 0xFF
1C562  22DA     ADDWFC __end_of_UART2_tx_vect_isr, F, ACCESS
1C564  C4DE     MOVFF POSTINC2, TBLPTR
1C566  F4F6     NOP
1C568  C4DD     MOVFF POSTDEC2, TBLPTRH
1C56A  F4F7     NOP
1C56C  0E00     MOVLW 0x0
1C56E  6EF8     MOVWF 0xFF8, ACCESS
1C570  0008     TBLRD*
1C572  50F5     MOVF 0xFF5, W, ACCESS
1C574  0900     IORLW 0x0
1C576  B4D8     BTFSC 0xFD8, 2, ACCESS
1C578  D02C     BRA 0xC5D2
1C57A  0EF6     MOVLW 0xF6
1C57C  0061     MOVFFL PLUSW1, ltemp0
1C57E  F38C     NOP
1C580  F501     NOP
1C582  0EF7     MOVLW 0xF7
1C584  50E3     MOVF 0xFE3, W, ACCESS
1C586  1001     IORWF __ptext283, W, ACCESS
1C588  B4D8     BTFSC 0xFD8, 2, ACCESS
1C58A  D023     BRA 0xC5D2
1C58C  50E1     MOVF 0xFE1, W, ACCESS
1C58E  0FFE     ADDLW 0xFE
1C590  6ED9     MOVWF 0xFD9, ACCESS
1C592  50E2     MOVF 0xFE2, W, ACCESS
1C594  6EDA     MOVWF __end_of_UART2_tx_vect_isr, ACCESS
1C596  0EFF     MOVLW 0xFF
1C598  22DA     ADDWFC __end_of_UART2_tx_vect_isr, F, ACCESS
1C59A  C4DE     MOVFF POSTINC2, TBLPTR
1C59C  F4F6     NOP
1C59E  C4DD     MOVFF POSTDEC2, TBLPTRH
1C5A0  F4F7     NOP
1C5A2  0E00     MOVLW 0x0
1C5A4  6EF8     MOVWF 0xFF8, ACCESS
1C5A6  0008     TBLRD*
1C5A8  0061     MOVFFL TABLAT, 0x50C
1C5AA  F3D4     NOP
1C5AC  F50C     NOP
1C5AE  50E1     MOVF 0xFE1, W, ACCESS
1C5B0  0FFC     ADDLW 0xFC
1C5B2  6ED9     MOVWF 0xFD9, ACCESS
1C5B4  50E2     MOVF 0xFE2, W, ACCESS
1C5B6  6EDA     MOVWF __end_of_UART2_tx_vect_isr, ACCESS
1C5B8  0EFF     MOVLW 0xFF
1C5BA  22DA     ADDWFC __end_of_UART2_tx_vect_isr, F, ACCESS
1C5BC  C4DE     MOVFF POSTINC2, TBLPTR
1C5BE  F4F6     NOP
1C5C0  C4DD     MOVFF POSTDEC2, TBLPTRH
1C5C2  F4F7     NOP
1C5C4  0E00     MOVLW 0x0
1C5C6  6EF8     MOVWF 0xFF8, ACCESS
1C5C8  0008     TBLRD*
1C5CA  50F5     MOVF 0xFF5, W, ACCESS
1C5CC  180C     XORWF 0xC, W, ACCESS
1C5CE  B4D8     BTFSC 0xFD8, 2, ACCESS
1C5D0  D77A     BRA 0xC4C6
8:             	return *l - *r;
1C5D2  50E1     MOVF 0xFE1, W, ACCESS
1C5D4  0FFE     ADDLW 0xFE
1C5D6  6ED9     MOVWF 0xFD9, ACCESS
1C5D8  50E2     MOVF 0xFE2, W, ACCESS
1C5DA  6EDA     MOVWF __end_of_UART2_tx_vect_isr, ACCESS
1C5DC  0EFF     MOVLW 0xFF
1C5DE  22DA     ADDWFC __end_of_UART2_tx_vect_isr, F, ACCESS
1C5E0  C4DE     MOVFF POSTINC2, TBLPTR
1C5E2  F4F6     NOP
1C5E4  C4DD     MOVFF POSTDEC2, TBLPTRH
1C5E6  F4F7     NOP
1C5E8  0E00     MOVLW 0x0
1C5EA  6EF8     MOVWF 0xFF8, ACCESS
1C5EC  0008     TBLRD*
1C5EE  50F5     MOVF 0xFF5, W, ACCESS
1C5F0  6E01     MOVWF __ptext283, ACCESS
1C5F2  6A02     CLRF ___rparam_used, ACCESS
1C5F4  50E1     MOVF 0xFE1, W, ACCESS
1C5F6  0FFC     ADDLW 0xFC
1C5F8  6ED9     MOVWF 0xFD9, ACCESS
1C5FA  50E2     MOVF 0xFE2, W, ACCESS
1C5FC  6EDA     MOVWF __end_of_UART2_tx_vect_isr, ACCESS
1C5FE  0EFF     MOVLW 0xFF
1C600  22DA     ADDWFC __end_of_UART2_tx_vect_isr, F, ACCESS
1C602  C4DE     MOVFF POSTINC2, TBLPTR
1C604  F4F6     NOP
1C606  C4DD     MOVFF POSTDEC2, TBLPTRH
1C608  F4F7     NOP
1C60A  0E00     MOVLW 0x0
1C60C  6EF8     MOVWF 0xFF8, ACCESS
1C60E  0008     TBLRD*
1C610  50F5     MOVF 0xFF5, W, ACCESS
1C612  5E01     SUBWF __ptext283, F, ACCESS
1C614  0E00     MOVLW 0x0
1C616  5A02     SUBWFB ___rparam_used, F, ACCESS
9:             }
1C618  0EF6     MOVLW 0xF6
1C61A  26E1     ADDWF 0xFE1, F, ACCESS
1C61C  0EFF     MOVLW 0xFF
1C61E  22E2     ADDWFC 0xFE2, F, ACCESS
1C61E  22E2     ADDWFC 0xFE2, F, ACCESS
---  /opt/microchip/xc8/v2.41/pic/sources/c99/common/strlen.c  ------------------------------------------
1:             #include <string.h>
2:             #include <stdint.h>
3:             #include <limits.h>
4:             
5:             size_t strlen(const char *s)
0384  52E6     MOVF 0xFE6, F, ACCESS
0386  52E6     MOVF 0xFE6, F, ACCESS
6:             {
7:             	const char *a = s;
0388  0EFC     MOVLW 0xFC
038A  0061     MOVFFL PLUSW1, wtemp5
038C  F38C     NOP
038E  F50B     NOP
0390  0EFD     MOVLW 0xFD
0392  0061     MOVFFL PLUSW1, 0x50C
0394  F38C     NOP
0396  F50C     NOP
0398  0EFF     MOVLW 0xFF
039A  0061     MOVFFL 0x50C, PLUSW1
039C  F430     NOP
039E  F4E3     NOP
03A0  0EFE     MOVLW 0xFE
03A2  0061     MOVFFL wtemp5, PLUSW1
03A4  F42C     NOP
03A6  F4E3     NOP
8:             	while(*s) {
03A8  D011     BRA 0x3CC
03CC  0EFC     MOVLW 0xFC
03CE  C4E3     MOVFF PLUSW1, TBLPTR
03D0  F4F6     NOP
03D2  0EFD     MOVLW 0xFD
03D4  C4E3     MOVFF PLUSW1, TBLPTRH
03D6  F4F7     NOP
03D8  0E00     MOVLW 0x0
03DA  6EF8     MOVWF 0xFF8, ACCESS
03DC  0E3F     MOVLW 0x3F
03DE  64F7     CPFSGT 0xFF7, ACCESS
03E0  D003     BRA 0x3E8
03E2  0008     TBLRD*
03E4  50F5     MOVF 0xFF5, W, ACCESS
03E6  D005     BRA 0x3F2
03E8  C4F6     MOVFF TBLPTR, FSR0
03EA  F4E9     NOP
03EC  C4F7     MOVFF TBLPTRH, FSR0H
03EE  F4EA     NOP
03F0  50EF     MOVF 0xFEF, W, ACCESS
03F2  0900     IORLW 0x0
03F4  A4D8     BTFSS 0xFD8, 2, ACCESS
03F6  D7D9     BRA 0x3AA
9:             		s++;
03AA  0EFC     MOVLW 0xFC
03AC  50E3     MOVF 0xFE3, W, ACCESS
03AE  0F01     ADDLW 0x1
03B0  6E01     MOVWF __ptext283, ACCESS
03B2  0EFC     MOVLW 0xFC
03B4  0061     MOVFFL ltemp0, PLUSW1
03B6  F404     NOP
03B8  F4E3     NOP
03BA  6A01     CLRF __ptext283, ACCESS
03BC  0EFD     MOVLW 0xFD
03BE  50E3     MOVF 0xFE3, W, ACCESS
03C0  2001     ADDWFC __ptext283, W, ACCESS
03C2  6E01     MOVWF __ptext283, ACCESS
03C4  0EFD     MOVLW 0xFD
03C6  0061     MOVFFL ltemp0, PLUSW1
03C8  F404     NOP
03CA  F4E3     NOP
10:            	}
11:            	return (size_t)(s-a);
03F8  0EFC     MOVLW 0xFC
03FA  0061     MOVFFL PLUSW1, ltemp0
03FC  F38C     NOP
03FE  F501     NOP
0400  0EFD     MOVLW 0xFD
0402  0061     MOVFFL PLUSW1, ttemp5
0404  F38C     NOP
0406  F502     NOP
0408  0EFE     MOVLW 0xFE
040A  50E3     MOVF 0xFE3, W, ACCESS
040C  5E01     SUBWF __ptext283, F, ACCESS
040E  0EFF     MOVLW 0xFF
0410  50E3     MOVF 0xFE3, W, ACCESS
0412  5A02     SUBWFB ___rparam_used, F, ACCESS
12:            }
0414  52E5     MOVF 0xFE5, F, ACCESS
0416  52E5     MOVF 0xFE5, F, ACCESS
0418  52E5     MOVF 0xFE5, F, ACCESS
041A  52E5     MOVF 0xFE5, F, ACCESS
041A  52E5     MOVF 0xFE5, F, ACCESS
---  /opt/microchip/xc8/v2.41/pic/sources/c99/common/strcpy.c  ------------------------------------------
1:             #include <string.h>
2:             
3:             char *strcpy(char *restrict dest, const char *restrict src)
1F9EE  52E6     MOVF 0xFE6, F, ACCESS
1F9F0  52E6     MOVF 0xFE6, F, ACCESS
1F9F2  52E6     MOVF 0xFE6, F, ACCESS
1F9F4  52E6     MOVF 0xFE6, F, ACCESS
4:             {
5:             	const char *s = src;
1F9F6  0EF8     MOVLW 0xF8
1F9F8  0061     MOVFFL PLUSW1, wtemp5
1F9FA  F38C     NOP
1F9FC  F50B     NOP
1F9FE  0EF9     MOVLW 0xF9
1FA00  0061     MOVFFL PLUSW1, 0x50C
1FA02  F38C     NOP
1FA04  F50C     NOP
1FA06  0EFF     MOVLW 0xFF
1FA08  0061     MOVFFL 0x50C, PLUSW1
1FA0A  F430     NOP
1FA0C  F4E3     NOP
1FA0E  0EFE     MOVLW 0xFE
1FA10  0061     MOVFFL wtemp5, PLUSW1
1FA12  F42C     NOP
1FA14  F4E3     NOP
6:             	char *d = dest;
1FA16  0EFA     MOVLW 0xFA
1FA18  0061     MOVFFL PLUSW1, wtemp5
1FA1A  F38C     NOP
1FA1C  F50B     NOP
1FA1E  0EFB     MOVLW 0xFB
1FA20  0061     MOVFFL PLUSW1, 0x50C
1FA22  F38C     NOP
1FA24  F50C     NOP
1FA26  0EFD     MOVLW 0xFD
1FA28  0061     MOVFFL 0x50C, PLUSW1
1FA2A  F430     NOP
1FA2C  F4E3     NOP
1FA2E  0EFC     MOVLW 0xFC
1FA30  0061     MOVFFL wtemp5, PLUSW1
1FA32  F42C     NOP
1FA34  F4E3     NOP
7:             	while ((*d++ = *s++));
1FA36  50E1     MOVF 0xFE1, W, ACCESS
1FA38  0FFE     ADDLW 0xFE
1FA3A  6ED9     MOVWF 0xFD9, ACCESS
1FA3C  50E2     MOVF 0xFE2, W, ACCESS
1FA3E  6EDA     MOVWF __end_of_UART2_tx_vect_isr, ACCESS
1FA40  0EFF     MOVLW 0xFF
1FA42  22DA     ADDWFC __end_of_UART2_tx_vect_isr, F, ACCESS
1FA44  0061     MOVFFL INDF2, wtemp5
1FA46  F37C     NOP
1FA48  F50B     NOP
1FA4A  0E01     MOVLW 0x1
1FA4C  26DE     ADDWF 0xFDE, F, ACCESS
1FA4E  0061     MOVFFL INDF2, 0x50C
1FA50  F37C     NOP
1FA52  F50C     NOP
1FA54  0E00     MOVLW 0x0
1FA56  22DD     ADDWFC 0xFDD, F, ACCESS
1FA58  0061     MOVFFL wtemp5, TBLPTR
1FA5A  F42C     NOP
1FA5C  F4F6     NOP
1FA5E  0061     MOVFFL 0x50C, TBLPTRH
1FA60  F430     NOP
1FA62  F4F7     NOP
1FA64  0E00     MOVLW 0x0
1FA66  6EF8     MOVWF 0xFF8, ACCESS
1FA68  50E1     MOVF 0xFE1, W, ACCESS
1FA6A  0FFC     ADDLW 0xFC
1FA6C  6ED9     MOVWF 0xFD9, ACCESS
1FA6E  50E2     MOVF 0xFE2, W, ACCESS
1FA70  6EDA     MOVWF __end_of_UART2_tx_vect_isr, ACCESS
1FA72  0EFF     MOVLW 0xFF
1FA74  22DA     ADDWFC __end_of_UART2_tx_vect_isr, F, ACCESS
1FA76  0061     MOVFFL INDF2, wtemp5
1FA78  F37C     NOP
1FA7A  F50B     NOP
1FA7C  0E01     MOVLW 0x1
1FA7E  26DE     ADDWF 0xFDE, F, ACCESS
1FA80  0061     MOVFFL INDF2, 0x50C
1FA82  F37C     NOP
1FA84  F50C     NOP
1FA86  0E00     MOVLW 0x0
1FA88  22DD     ADDWFC 0xFDD, F, ACCESS
1FA8A  0061     MOVFFL wtemp5, FSR2
1FA8C  F42C     NOP
1FA8E  F4D9     NOP
1FA90  0061     MOVFFL 0x50C, FSR2H
1FA92  F430     NOP
1FA94  F4DA     NOP
1FA96  0008     TBLRD*
1FA98  C4F5     MOVFF TABLAT, INDF2
1FA9A  F4DF     NOP
1FA9C  50DF     MOVF 0xFDF, W, ACCESS
1FA9E  A4D8     BTFSS 0xFD8, 2, ACCESS
1FAA0  D7CA     BRA 0xFA36
8:             	return dest;
9:             }
1FAA2  0EF8     MOVLW 0xF8
1FAA4  26E1     ADDWF 0xFE1, F, ACCESS
1FAA6  0EFF     MOVLW 0xFF
1FAA8  22E2     ADDWFC 0xFE2, F, ACCESS
1FAA8  22E2     ADDWFC 0xFE2, F, ACCESS
---  /opt/microchip/xc8/v2.41/pic/sources/c99/common/sprcmul.c  -----------------------------------------
1:             /* SP relaxed compliance floating point multiply intrinsic function */
2:             #include <stdint.h>
3:             #include "fpform.h"
4:             
5:             /* SP Multiply */
6:             /* single monolithic routine */
7:             SP
8:             SPMUL(SP b, SP a) {
1705E  0E0D     MOVLW 0xD
17060  26E1     ADDWF 0xFE1, F, ACCESS
17062  0E00     MOVLW 0x0
17064  22E2     ADDWFC 0xFE2, F, ACCESS
9:             	unsigned char sign;	/* sign of result */
10:            	unsigned char bexp;	/* Dst exponent */
11:            	unsigned char aexp;	/* Src exponent */
12:            	uint32_t grs;		/* Guard, round, sticky */
13:            	SFP prod;
14:            	wordProduct temp;	/* intermediate mult results ; exponent of result */
15:            
16:            	/* Unpack and check operands */
17:            	sign = (*(SFP *) & b).fAsBytes.d & 0x80;
17066  0EF2     MOVLW 0xF2
17068  24E1     ADDWF 0xFE1, W, ACCESS
1706A  6ED9     MOVWF 0xFD9, ACCESS
1706C  0EFF     MOVLW 0xFF
1706E  20E2     ADDWFC 0xFE2, W, ACCESS
17070  6EDA     MOVWF __end_of_UART2_tx_vect_isr, ACCESS
17072  50DF     MOVF 0xFDF, W, ACCESS
17074  6E0C     MOVWF 0xC, ACCESS
17076  0E80     MOVLW 0x80
17078  160C     ANDWF 0xC, F, ACCESS
1707A  0EFF     MOVLW 0xFF
1707C  0061     MOVFFL 0x50C, PLUSW1
1707E  F430     NOP
17080  F4E3     NOP
18:            	bexp = (unsigned char)(((*(SFP *) & b).fAsBytes.d) << 1);
17082  0EF2     MOVLW 0xF2
17084  24E1     ADDWF 0xFE1, W, ACCESS
17086  6ED9     MOVWF 0xFD9, ACCESS
17088  0EFF     MOVLW 0xFF
1708A  20E2     ADDWFC 0xFE2, W, ACCESS
1708C  6EDA     MOVWF __end_of_UART2_tx_vect_isr, ACCESS
1708E  50DF     MOVF 0xFDF, W, ACCESS
17090  6E0C     MOVWF 0xC, ACCESS
17092  90D8     BCF 0xFD8, 0, ACCESS
17094  340C     RLCF 0xC, W, ACCESS
17096  6E0B     MOVWF 0xB, ACCESS
17098  0EFD     MOVLW 0xFD
1709A  0061     MOVFFL wtemp5, PLUSW1
1709C  F42C     NOP
1709E  F4E3     NOP
19:            	if ((*(SFP *) & b).fAsBytes.c & 0x80) {
170A0  0EF1     MOVLW 0xF1
170A2  24E1     ADDWF 0xFE1, W, ACCESS
170A4  6ED9     MOVWF 0xFD9, ACCESS
170A6  0EFF     MOVLW 0xFF
170A8  20E2     ADDWFC 0xFE2, W, ACCESS
170AA  6EDA     MOVWF __end_of_UART2_tx_vect_isr, ACCESS
170AC  AEDF     BTFSS 0xFDF, 7, ACCESS
170AE  D002     BRA 0x70B4
20:            		bexp |= 0x1;
170B0  0EFD     MOVLW 0xFD
170B2  80E3     BSF 0xFE3, 0, ACCESS
21:            	}
22:            
23:            	/* Destination normal ? */
24:            	if (bexp) {
170B4  0EFD     MOVLW 0xFD
170B6  50E3     MOVF 0xFE3, W, ACCESS
170B8  B4D8     BTFSC 0xFD8, 2, ACCESS
170BA  D01F     BRA 0x70FA
25:            		/* Destination inf or NaN ? */
26:            		if (bexp == 0xFF) {
170BC  0EFD     MOVLW 0xFD
170BE  28E3     INCF 0xFE3, W, ACCESS
170C0  A4D8     BTFSS 0xFD8, 2, ACCESS
170C2  D018     BRA 0x70F4
27:            			/* Make it inf */
28:            			b = 0;
170C4  0E00     MOVLW 0x0
170C6  6E09     MOVWF 0x9, ACCESS
170C8  0E00     MOVLW 0x0
170CA  6E0A     MOVWF 0xA, ACCESS
170CC  0E00     MOVLW 0x0
170CE  6E0B     MOVWF 0xB, ACCESS
170D0  0E00     MOVLW 0x0
170D2  6E0C     MOVWF 0xC, ACCESS
170D4  0EEF     MOVLW 0xEF
170D6  0061     MOVFFL ltemp2, PLUSW1
170D8  F424     NOP
170DA  F4E3     NOP
170DC  0EF0     MOVLW 0xF0
170DE  0061     MOVFFL ttemp3, PLUSW1
170E0  F428     NOP
170E2  F4E3     NOP
170E4  0EF1     MOVLW 0xF1
170E6  0061     MOVFFL wtemp5, PLUSW1
170E8  F42C     NOP
170EA  F4E3     NOP
170EC  0EF2     MOVLW 0xF2
170EE  0061     MOVFFL 0x50C, PLUSW1
170F0  F430     NOP
170F2  F4E3     NOP
29:            		}
30:            		// and in the implied 1-bit to b's fraction
31:            		(*(SFP *) & b).i |= (int32_t) 1 << SPFRCB;
170F4  0EF1     MOVLW 0xF1
170F6  8EE3     BSF 0xFE3, 7, ACCESS
32:            
33:            	}
170F8  D018     BRA 0x712A
34:            	else {
35:            		/* Make it zero */
36:            		b = 0;
170FA  0E00     MOVLW 0x0
170FC  6E09     MOVWF 0x9, ACCESS
170FE  0E00     MOVLW 0x0
17100  6E0A     MOVWF 0xA, ACCESS
17102  0E00     MOVLW 0x0
17104  6E0B     MOVWF 0xB, ACCESS
17106  0E00     MOVLW 0x0
17108  6E0C     MOVWF 0xC, ACCESS
1710A  0EEF     MOVLW 0xEF
1710C  0061     MOVFFL ltemp2, PLUSW1
1710E  F424     NOP
17110  F4E3     NOP
17112  0EF0     MOVLW 0xF0
17114  0061     MOVFFL ttemp3, PLUSW1
17116  F428     NOP
17118  F4E3     NOP
1711A  0EF1     MOVLW 0xF1
1711C  0061     MOVFFL wtemp5, PLUSW1
1711E  F42C     NOP
17120  F4E3     NOP
17122  0EF2     MOVLW 0xF2
17124  0061     MOVFFL 0x50C, PLUSW1
17126  F430     NOP
17128  F4E3     NOP
37:            	}
38:            
39:            	sign ^= (*(SFP *) & a).fAsBytes.d & 0x80;
1712A  0EEE     MOVLW 0xEE
1712C  24E1     ADDWF 0xFE1, W, ACCESS
1712E  6ED9     MOVWF 0xFD9, ACCESS
17130  0EFF     MOVLW 0xFF
17132  20E2     ADDWFC 0xFE2, W, ACCESS
17134  6EDA     MOVWF __end_of_UART2_tx_vect_isr, ACCESS
17136  50DF     MOVF 0xFDF, W, ACCESS
17138  6E0C     MOVWF 0xC, ACCESS
1713A  0E80     MOVLW 0x80
1713C  160C     ANDWF 0xC, F, ACCESS
1713E  50E1     MOVF 0xFE1, W, ACCESS
17140  0FFF     ADDLW 0xFF
17142  6ED9     MOVWF 0xFD9, ACCESS
17144  50E2     MOVF 0xFE2, W, ACCESS
17146  6EDA     MOVWF __end_of_UART2_tx_vect_isr, ACCESS
17148  0EFF     MOVLW 0xFF
1714A  22DA     ADDWFC __end_of_UART2_tx_vect_isr, F, ACCESS
1714C  500C     MOVF 0xC, W, ACCESS
1714E  1ADF     XORWF 0xFDF, F, ACCESS
40:            	aexp = (unsigned char)(((*(SFP *) & a).fAsBytes.d) << 1);
17150  0EEE     MOVLW 0xEE
17152  24E1     ADDWF 0xFE1, W, ACCESS
17154  6ED9     MOVWF 0xFD9, ACCESS
17156  0EFF     MOVLW 0xFF
17158  20E2     ADDWFC 0xFE2, W, ACCESS
1715A  6EDA     MOVWF __end_of_UART2_tx_vect_isr, ACCESS
1715C  50DF     MOVF 0xFDF, W, ACCESS
1715E  6E0C     MOVWF 0xC, ACCESS
17160  90D8     BCF 0xFD8, 0, ACCESS
17162  340C     RLCF 0xC, W, ACCESS
17164  6E0B     MOVWF 0xB, ACCESS
17166  0EFE     MOVLW 0xFE
17168  0061     MOVFFL wtemp5, PLUSW1
1716A  F42C     NOP
1716C  F4E3     NOP
41:            	if ((*(SFP *) & a).fAsBytes.c & 0x80) {
1716E  0EED     MOVLW 0xED
17170  24E1     ADDWF 0xFE1, W, ACCESS
17172  6ED9     MOVWF 0xFD9, ACCESS
17174  0EFF     MOVLW 0xFF
17176  20E2     ADDWFC 0xFE2, W, ACCESS
17178  6EDA     MOVWF __end_of_UART2_tx_vect_isr, ACCESS
1717A  AEDF     BTFSS 0xFDF, 7, ACCESS
1717C  D002     BRA 0x7182
42:            		aexp |= 0x1;
1717E  0EFE     MOVLW 0xFE
17180  80E3     BSF 0xFE3, 0, ACCESS
43:            	}
44:            	/* Destination normal ? */
45:            	if (aexp) {
17182  0EFE     MOVLW 0xFE
17184  50E3     MOVF 0xFE3, W, ACCESS
17186  B4D8     BTFSC 0xFD8, 2, ACCESS
17188  D01F     BRA 0x71C8
46:            
47:            		/* Destination inf or NaN ? */
48:            		if (aexp == 0xFF) {
1718A  0EFE     MOVLW 0xFE
1718C  28E3     INCF 0xFE3, W, ACCESS
1718E  A4D8     BTFSS 0xFD8, 2, ACCESS
17190  D018     BRA 0x71C2
49:            			/* Make it inf */
50:            			a = 0;
17192  0E00     MOVLW 0x0
17194  6E09     MOVWF 0x9, ACCESS
17196  0E00     MOVLW 0x0
17198  6E0A     MOVWF 0xA, ACCESS
1719A  0E00     MOVLW 0x0
1719C  6E0B     MOVWF 0xB, ACCESS
1719E  0E00     MOVLW 0x0
171A0  6E0C     MOVWF 0xC, ACCESS
171A2  0EEB     MOVLW 0xEB
171A4  0061     MOVFFL ltemp2, PLUSW1
171A6  F424     NOP
171A8  F4E3     NOP
171AA  0EEC     MOVLW 0xEC
171AC  0061     MOVFFL ttemp3, PLUSW1
171AE  F428     NOP
171B0  F4E3     NOP
171B2  0EED     MOVLW 0xED
171B4  0061     MOVFFL wtemp5, PLUSW1
171B6  F42C     NOP
171B8  F4E3     NOP
171BA  0EEE     MOVLW 0xEE
171BC  0061     MOVFFL 0x50C, PLUSW1
171BE  F430     NOP
171C0  F4E3     NOP
51:            		}
52:            		// and in the implied 1-bit to a's fraction
53:            		(*(SFP *) & a).i |= (int32_t) 1 << SPFRCB;
171C2  0EED     MOVLW 0xED
171C4  8EE3     BSF 0xFE3, 7, ACCESS
54:            	}
171C6  D018     BRA 0x71F8
55:            	else {
56:            		/* Make it zero */
57:            		a = 0;
171C8  0E00     MOVLW 0x0
171CA  6E09     MOVWF 0x9, ACCESS
171CC  0E00     MOVLW 0x0
171CE  6E0A     MOVWF 0xA, ACCESS
171D0  0E00     MOVLW 0x0
171D2  6E0B     MOVWF 0xB, ACCESS
171D4  0E00     MOVLW 0x0
171D6  6E0C     MOVWF 0xC, ACCESS
171D8  0EEB     MOVLW 0xEB
171DA  0061     MOVFFL ltemp2, PLUSW1
171DC  F424     NOP
171DE  F4E3     NOP
171E0  0EEC     MOVLW 0xEC
171E2  0061     MOVFFL ttemp3, PLUSW1
171E4  F428     NOP
171E6  F4E3     NOP
171E8  0EED     MOVLW 0xED
171EA  0061     MOVFFL wtemp5, PLUSW1
171EC  F42C     NOP
171EE  F4E3     NOP
171F0  0EEE     MOVLW 0xEE
171F2  0061     MOVFFL 0x50C, PLUSW1
171F4  F430     NOP
171F6  F4E3     NOP
58:            	}
59:            
60:            	/* Multiply */
61:            
62:            	/* Special operand check */
63:            
64:            	/* Source or destination zero ? Result zero */
65:            	if (aexp == 0 || bexp == 0) {
171F8  0EFE     MOVLW 0xFE
171FA  50E3     MOVF 0xFE3, W, ACCESS
171FC  B4D8     BTFSC 0xFD8, 2, ACCESS
171FE  D004     BRA 0x7208
17200  0EFD     MOVLW 0xFD
17202  50E3     MOVF 0xFE3, W, ACCESS
17204  A4D8     BTFSS 0xFD8, 2, ACCESS
17206  D009     BRA 0x721A
66:            		return 0.0;
17208  0E00     MOVLW 0x0
1720A  6E01     MOVWF __ptext283, ACCESS
1720C  0E00     MOVLW 0x0
1720E  6E02     MOVWF ___rparam_used, ACCESS
17210  0E00     MOVLW 0x0
17212  6E03     MOVWF __activetblptr, ACCESS
17214  0E00     MOVLW 0x0
17216  6E04     MOVWF __activetblptr, ACCESS
17218  D31E     BRA 0x7856
67:            	}
68:            
69:            //    we decompose a 24 bit multiply into 9 8 bit multiplies as follows:
70:            //
71:            //    b's fraction is b1|b2|b3 and a's fraction is a1|a2|a3
72:            //
73:            //    then ab is the (48 bit) sum of these 9 16 bit intermediate products shifted appropriately
74:            //
75:            //
76:            //                                     a3b3
77:            //                                   a2b3
78:            //                                   a3b2
79:            //                                 a1b3
80:            //                                 a2b2
81:            //                                 a3b1
82:            //                               a1b2
83:            //                               a2b1
84:            //                             a1b1
85:            //
86:            //   in this algorithm we compute the product to be the upper 24 bits of the sum and grs to be the lower 24 bits
87:            //   shifted 8 to the left     then we renormalize and round as usual.
88:            //
89:            
90:            #define LOWBYTE(x)  (*(unsigned char *)(&x))
91:            #define MIDBYTE(x)  (*(((unsigned char *)(&x))+1))
92:            #define HIGHBYTE(x) (*(((unsigned char *)(&x))+2))
93:            
94:            #ifdef _PIC18
95:            	temp.n = HIGHBYTE(a) * LOWBYTE(b);
1721A  0EEF     MOVLW 0xEF
1721C  0061     MOVFFL PLUSW1, 0x50C
1721E  F38C     NOP
17220  F50C     NOP
17222  0EED     MOVLW 0xED
17224  24E1     ADDWF 0xFE1, W, ACCESS
17226  6ED9     MOVWF 0xFD9, ACCESS
17228  0EFF     MOVLW 0xFF
1722A  20E2     ADDWFC 0xFE2, W, ACCESS
1722C  6EDA     MOVWF __end_of_UART2_tx_vect_isr, ACCESS
1722E  50DF     MOVF 0xFDF, W, ACCESS
17230  020C     MULWF 0xC, ACCESS
17232  0EFB     MOVLW 0xFB
17234  C4F3     MOVFF PROD, PLUSW1
17236  F4E3     NOP
17238  0EFC     MOVLW 0xFC
1723A  C4F4     MOVFF PRODH, PLUSW1
1723C  F4E3     NOP
96:            	grs = temp.nAsBytes.a;
1723E  0EFB     MOVLW 0xFB
17240  0061     MOVFFL PLUSW1, 0x50C
17242  F38C     NOP
17244  F50C     NOP
17246  0061     MOVFFL 0x50C, ltemp1
17248  F430     NOP
1724A  F505     NOP
1724C  6A06     CLRF 0x6, ACCESS
1724E  6A07     CLRF 0x7, ACCESS
17250  6A08     CLRF 0x8, ACCESS
17252  0EF7     MOVLW 0xF7
17254  0061     MOVFFL ltemp1, PLUSW1
17256  F414     NOP
17258  F4E3     NOP
1725A  0EF8     MOVLW 0xF8
1725C  0061     MOVFFL 0x506, PLUSW1
1725E  F418     NOP
17260  F4E3     NOP
17262  0EF9     MOVLW 0xF9
17264  0061     MOVFFL ttemp2, PLUSW1
17266  F41C     NOP
17268  F4E3     NOP
1726A  0EFA     MOVLW 0xFA
1726C  0061     MOVFFL 0x508, PLUSW1
1726E  F420     NOP
17270  F4E3     NOP
97:            	prod.i = temp.nAsBytes.b;
17272  0EFC     MOVLW 0xFC
17274  24E1     ADDWF 0xFE1, W, ACCESS
17276  6ED9     MOVWF 0xFD9, ACCESS
17278  0EFF     MOVLW 0xFF
1727A  20E2     ADDWFC 0xFE2, W, ACCESS
1727C  6EDA     MOVWF __end_of_UART2_tx_vect_isr, ACCESS
1727E  50DF     MOVF 0xFDF, W, ACCESS
17280  6E0C     MOVWF 0xC, ACCESS
17282  0061     MOVFFL 0x50C, ltemp1
17284  F430     NOP
17286  F505     NOP
17288  6A06     CLRF 0x6, ACCESS
1728A  6A07     CLRF 0x7, ACCESS
1728C  6A08     CLRF 0x8, ACCESS
1728E  0EF3     MOVLW 0xF3
17290  0061     MOVFFL ltemp1, PLUSW1
17292  F414     NOP
17294  F4E3     NOP
17296  0EF4     MOVLW 0xF4
17298  0061     MOVFFL 0x506, PLUSW1
1729A  F418     NOP
1729C  F4E3     NOP
1729E  0EF5     MOVLW 0xF5
172A0  0061     MOVFFL ttemp2, PLUSW1
172A2  F41C     NOP
172A4  F4E3     NOP
172A6  0EF6     MOVLW 0xF6
172A8  0061     MOVFFL 0x508, PLUSW1
172AA  F420     NOP
172AC  F4E3     NOP
98:            	temp.n = MIDBYTE(a) * MIDBYTE(b);
172AE  0EF0     MOVLW 0xF0
172B0  24E1     ADDWF 0xFE1, W, ACCESS
172B2  6ED9     MOVWF 0xFD9, ACCESS
172B4  0EFF     MOVLW 0xFF
172B6  20E2     ADDWFC 0xFE2, W, ACCESS
172B8  6EDA     MOVWF __end_of_UART2_tx_vect_isr, ACCESS
172BA  50DF     MOVF 0xFDF, W, ACCESS
172BC  6E0C     MOVWF 0xC, ACCESS
172BE  0EEC     MOVLW 0xEC
172C0  24E1     ADDWF 0xFE1, W, ACCESS
172C2  6ED9     MOVWF 0xFD9, ACCESS
172C4  0EFF     MOVLW 0xFF
172C6  20E2     ADDWFC 0xFE2, W, ACCESS
172C8  6EDA     MOVWF __end_of_UART2_tx_vect_isr, ACCESS
172CA  50DF     MOVF 0xFDF, W, ACCESS
172CC  020C     MULWF 0xC, ACCESS
172CE  0EFB     MOVLW 0xFB
172D0  C4F3     MOVFF PROD, PLUSW1
172D2  F4E3     NOP
172D4  0EFC     MOVLW 0xFC
172D6  C4F4     MOVFF PRODH, PLUSW1
172D8  F4E3     NOP
99:            	grs += temp.nAsBytes.a;
172DA  50E1     MOVF 0xFE1, W, ACCESS
172DC  0FF7     ADDLW 0xF7
172DE  6ED9     MOVWF 0xFD9, ACCESS
172E0  50E2     MOVF 0xFE2, W, ACCESS
172E2  6EDA     MOVWF __end_of_UART2_tx_vect_isr, ACCESS
172E4  0EFF     MOVLW 0xFF
172E6  22DA     ADDWFC __end_of_UART2_tx_vect_isr, F, ACCESS
172E8  0EFB     MOVLW 0xFB
172EA  50E3     MOVF 0xFE3, W, ACCESS
172EC  26DE     ADDWF 0xFDE, F, ACCESS
172EE  0E00     MOVLW 0x0
172F0  22DE     ADDWFC 0xFDE, F, ACCESS
172F2  22DE     ADDWFC 0xFDE, F, ACCESS
172F4  22DE     ADDWFC 0xFDE, F, ACCESS
100:           	prod.i += temp.nAsBytes.b;
172F6  50E1     MOVF 0xFE1, W, ACCESS
172F8  0FF3     ADDLW 0xF3
172FA  6ED9     MOVWF 0xFD9, ACCESS
172FC  50E2     MOVF 0xFE2, W, ACCESS
172FE  6EDA     MOVWF __end_of_UART2_tx_vect_isr, ACCESS
17300  0EFF     MOVLW 0xFF
17302  22DA     ADDWFC __end_of_UART2_tx_vect_isr, F, ACCESS
17304  0EFC     MOVLW 0xFC
17306  24E1     ADDWF 0xFE1, W, ACCESS
17308  6EE9     MOVWF 0xFE9, ACCESS
1730A  0EFF     MOVLW 0xFF
1730C  20E2     ADDWFC 0xFE2, W, ACCESS
1730E  6EEA     MOVWF 0xFEA, ACCESS
17310  50EF     MOVF 0xFEF, W, ACCESS
17312  26DE     ADDWF 0xFDE, F, ACCESS
17314  0E00     MOVLW 0x0
17316  22DE     ADDWFC 0xFDE, F, ACCESS
17318  22DE     ADDWFC 0xFDE, F, ACCESS
1731A  22DE     ADDWFC 0xFDE, F, ACCESS
101:           	temp.n = LOWBYTE(a) * HIGHBYTE(b);
1731C  0EF1     MOVLW 0xF1
1731E  24E1     ADDWF 0xFE1, W, ACCESS
17320  6ED9     MOVWF 0xFD9, ACCESS
17322  0EFF     MOVLW 0xFF
17324  20E2     ADDWFC 0xFE2, W, ACCESS
17326  6EDA     MOVWF __end_of_UART2_tx_vect_isr, ACCESS
17328  50DF     MOVF 0xFDF, W, ACCESS
1732A  6E0C     MOVWF 0xC, ACCESS
1732C  0EEB     MOVLW 0xEB
1732E  50E3     MOVF 0xFE3, W, ACCESS
17330  020C     MULWF 0xC, ACCESS
17332  0EFB     MOVLW 0xFB
17334  C4F3     MOVFF PROD, PLUSW1
17336  F4E3     NOP
17338  0EFC     MOVLW 0xFC
1733A  C4F4     MOVFF PRODH, PLUSW1
1733C  F4E3     NOP
102:           	grs += temp.nAsBytes.a;
1733E  50E1     MOVF 0xFE1, W, ACCESS
17340  0FF7     ADDLW 0xF7
17342  6ED9     MOVWF 0xFD9, ACCESS
17344  50E2     MOVF 0xFE2, W, ACCESS
17346  6EDA     MOVWF __end_of_UART2_tx_vect_isr, ACCESS
17348  0EFF     MOVLW 0xFF
1734A  22DA     ADDWFC __end_of_UART2_tx_vect_isr, F, ACCESS
1734C  0EFB     MOVLW 0xFB
1734E  50E3     MOVF 0xFE3, W, ACCESS
17350  26DE     ADDWF 0xFDE, F, ACCESS
17352  0E00     MOVLW 0x0
17354  22DE     ADDWFC 0xFDE, F, ACCESS
17356  22DE     ADDWFC 0xFDE, F, ACCESS
17358  22DE     ADDWFC 0xFDE, F, ACCESS
103:           	prod.i += temp.nAsBytes.b;
1735A  50E1     MOVF 0xFE1, W, ACCESS
1735C  0FF3     ADDLW 0xF3
1735E  6ED9     MOVWF 0xFD9, ACCESS
17360  50E2     MOVF 0xFE2, W, ACCESS
17362  6EDA     MOVWF __end_of_UART2_tx_vect_isr, ACCESS
17364  0EFF     MOVLW 0xFF
17366  22DA     ADDWFC __end_of_UART2_tx_vect_isr, F, ACCESS
17368  0EFC     MOVLW 0xFC
1736A  24E1     ADDWF 0xFE1, W, ACCESS
1736C  6EE9     MOVWF 0xFE9, ACCESS
1736E  0EFF     MOVLW 0xFF
17370  20E2     ADDWFC 0xFE2, W, ACCESS
17372  6EEA     MOVWF 0xFEA, ACCESS
17374  50EF     MOVF 0xFEF, W, ACCESS
17376  26DE     ADDWF 0xFDE, F, ACCESS
17378  0E00     MOVLW 0x0
1737A  22DE     ADDWFC 0xFDE, F, ACCESS
1737C  22DE     ADDWFC 0xFDE, F, ACCESS
1737E  22DE     ADDWFC 0xFDE, F, ACCESS
104:           	grs <<= 8;
17380  50E1     MOVF 0xFE1, W, ACCESS
17382  0FF7     ADDLW 0xF7
17384  6ED9     MOVWF 0xFD9, ACCESS
17386  50E2     MOVF 0xFE2, W, ACCESS
17388  6EDA     MOVWF __end_of_UART2_tx_vect_isr, ACCESS
1738A  0EFF     MOVLW 0xFF
1738C  22DA     ADDWFC __end_of_UART2_tx_vect_isr, F, ACCESS
1738E  0E08     MOVLW 0x8
17390  90D8     BCF 0xFD8, 0, ACCESS
17392  36DE     RLCF 0xFDE, F, ACCESS
17394  36DE     RLCF 0xFDE, F, ACCESS
17396  36DE     RLCF 0xFDE, F, ACCESS
17398  36DD     RLCF 0xFDD, F, ACCESS
1739A  52DD     MOVF 0xFDD, F, ACCESS
1739C  52DD     MOVF 0xFDD, F, ACCESS
1739E  2EE8     DECFSZ 0xFE8, F, ACCESS
173A0  D7F7     BRA 0x7390
105:           	temp.n = LOWBYTE(a) * MIDBYTE(b);
173A2  0EF0     MOVLW 0xF0
173A4  24E1     ADDWF 0xFE1, W, ACCESS
173A6  6ED9     MOVWF 0xFD9, ACCESS
173A8  0EFF     MOVLW 0xFF
173AA  20E2     ADDWFC 0xFE2, W, ACCESS
173AC  6EDA     MOVWF __end_of_UART2_tx_vect_isr, ACCESS
173AE  50DF     MOVF 0xFDF, W, ACCESS
173B0  6E0C     MOVWF 0xC, ACCESS
173B2  0EEB     MOVLW 0xEB
173B4  50E3     MOVF 0xFE3, W, ACCESS
173B6  020C     MULWF 0xC, ACCESS
173B8  0EFB     MOVLW 0xFB
173BA  C4F3     MOVFF PROD, PLUSW1
173BC  F4E3     NOP
173BE  0EFC     MOVLW 0xFC
173C0  C4F4     MOVFF PRODH, PLUSW1
173C2  F4E3     NOP
106:           	grs += (unsigned long)temp.n;
173C4  0EFB     MOVLW 0xFB
173C6  0061     MOVFFL PLUSW1, wtemp5
173C8  F38C     NOP
173CA  F50B     NOP
173CC  0EFC     MOVLW 0xFC
173CE  0061     MOVFFL PLUSW1, 0x50C
173D0  F38C     NOP
173D2  F50C     NOP
173D4  50E1     MOVF 0xFE1, W, ACCESS
173D6  0FF7     ADDLW 0xF7
173D8  6ED9     MOVWF 0xFD9, ACCESS
173DA  50E2     MOVF 0xFE2, W, ACCESS
173DC  6EDA     MOVWF __end_of_UART2_tx_vect_isr, ACCESS
173DE  0EFF     MOVLW 0xFF
173E0  22DA     ADDWFC __end_of_UART2_tx_vect_isr, F, ACCESS
173E2  500B     MOVF 0xB, W, ACCESS
173E4  26DE     ADDWF 0xFDE, F, ACCESS
173E6  500C     MOVF 0xC, W, ACCESS
173E8  22DE     ADDWFC 0xFDE, F, ACCESS
173EA  0E00     MOVLW 0x0
173EC  22DE     ADDWFC 0xFDE, F, ACCESS
173EE  22DE     ADDWFC 0xFDE, F, ACCESS
107:           	temp.n = MIDBYTE(a) * LOWBYTE(b);
173F0  0EEF     MOVLW 0xEF
173F2  0061     MOVFFL PLUSW1, 0x50C
173F4  F38C     NOP
173F6  F50C     NOP
173F8  0EEC     MOVLW 0xEC
173FA  24E1     ADDWF 0xFE1, W, ACCESS
173FC  6ED9     MOVWF 0xFD9, ACCESS
173FE  0EFF     MOVLW 0xFF
17400  20E2     ADDWFC 0xFE2, W, ACCESS
17402  6EDA     MOVWF __end_of_UART2_tx_vect_isr, ACCESS
17404  50DF     MOVF 0xFDF, W, ACCESS
17406  020C     MULWF 0xC, ACCESS
17408  0EFB     MOVLW 0xFB
1740A  C4F3     MOVFF PROD, PLUSW1
1740C  F4E3     NOP
1740E  0EFC     MOVLW 0xFC
17410  C4F4     MOVFF PRODH, PLUSW1
17412  F4E3     NOP
108:           	grs += (unsigned long)temp.n;
17414  0EFB     MOVLW 0xFB
17416  0061     MOVFFL PLUSW1, wtemp5
17418  F38C     NOP
1741A  F50B     NOP
1741C  0EFC     MOVLW 0xFC
1741E  0061     MOVFFL PLUSW1, 0x50C
17420  F38C     NOP
17422  F50C     NOP
17424  50E1     MOVF 0xFE1, W, ACCESS
17426  0FF7     ADDLW 0xF7
17428  6ED9     MOVWF 0xFD9, ACCESS
1742A  50E2     MOVF 0xFE2, W, ACCESS
1742C  6EDA     MOVWF __end_of_UART2_tx_vect_isr, ACCESS
1742E  0EFF     MOVLW 0xFF
17430  22DA     ADDWFC __end_of_UART2_tx_vect_isr, F, ACCESS
17432  500B     MOVF 0xB, W, ACCESS
17434  26DE     ADDWF 0xFDE, F, ACCESS
17436  500C     MOVF 0xC, W, ACCESS
17438  22DE     ADDWFC 0xFDE, F, ACCESS
1743A  0E00     MOVLW 0x0
1743C  22DE     ADDWFC 0xFDE, F, ACCESS
1743E  22DE     ADDWFC 0xFDE, F, ACCESS
109:           	grs <<= 8;
17440  50E1     MOVF 0xFE1, W, ACCESS
17442  0FF7     ADDLW 0xF7
17444  6ED9     MOVWF 0xFD9, ACCESS
17446  50E2     MOVF 0xFE2, W, ACCESS
17448  6EDA     MOVWF __end_of_UART2_tx_vect_isr, ACCESS
1744A  0EFF     MOVLW 0xFF
1744C  22DA     ADDWFC __end_of_UART2_tx_vect_isr, F, ACCESS
1744E  0E08     MOVLW 0x8
17450  90D8     BCF 0xFD8, 0, ACCESS
17452  36DE     RLCF 0xFDE, F, ACCESS
17454  36DE     RLCF 0xFDE, F, ACCESS
17456  36DE     RLCF 0xFDE, F, ACCESS
17458  36DD     RLCF 0xFDD, F, ACCESS
1745A  52DD     MOVF 0xFDD, F, ACCESS
1745C  52DD     MOVF 0xFDD, F, ACCESS
1745E  2EE8     DECFSZ 0xFE8, F, ACCESS
17460  D7F7     BRA 0x7450
110:           	temp.n = LOWBYTE(a) * LOWBYTE(b);
17462  0EEF     MOVLW 0xEF
17464  0061     MOVFFL PLUSW1, 0x50C
17466  F38C     NOP
17468  F50C     NOP
1746A  0EEB     MOVLW 0xEB
1746C  50E3     MOVF 0xFE3, W, ACCESS
1746E  020C     MULWF 0xC, ACCESS
17470  0EFB     MOVLW 0xFB
17472  C4F3     MOVFF PROD, PLUSW1
17474  F4E3     NOP
17476  0EFC     MOVLW 0xFC
17478  C4F4     MOVFF PRODH, PLUSW1
1747A  F4E3     NOP
111:           	grs += (unsigned long)temp.n;
1747C  0EFB     MOVLW 0xFB
1747E  0061     MOVFFL PLUSW1, wtemp5
17480  F38C     NOP
17482  F50B     NOP
17484  0EFC     MOVLW 0xFC
17486  0061     MOVFFL PLUSW1, 0x50C
17488  F38C     NOP
1748A  F50C     NOP
1748C  50E1     MOVF 0xFE1, W, ACCESS
1748E  0FF7     ADDLW 0xF7
17490  6ED9     MOVWF 0xFD9, ACCESS
17492  50E2     MOVF 0xFE2, W, ACCESS
17494  6EDA     MOVWF __end_of_UART2_tx_vect_isr, ACCESS
17496  0EFF     MOVLW 0xFF
17498  22DA     ADDWFC __end_of_UART2_tx_vect_isr, F, ACCESS
1749A  500B     MOVF 0xB, W, ACCESS
1749C  26DE     ADDWF 0xFDE, F, ACCESS
1749E  500C     MOVF 0xC, W, ACCESS
174A0  22DE     ADDWFC 0xFDE, F, ACCESS
174A2  0E00     MOVLW 0x0
174A4  22DE     ADDWFC 0xFDE, F, ACCESS
174A6  22DE     ADDWFC 0xFDE, F, ACCESS
112:           	temp.n = HIGHBYTE(a) * MIDBYTE(b);
174A8  0EF0     MOVLW 0xF0
174AA  24E1     ADDWF 0xFE1, W, ACCESS
174AC  6ED9     MOVWF 0xFD9, ACCESS
174AE  0EFF     MOVLW 0xFF
174B0  20E2     ADDWFC 0xFE2, W, ACCESS
174B2  6EDA     MOVWF __end_of_UART2_tx_vect_isr, ACCESS
174B4  50DF     MOVF 0xFDF, W, ACCESS
174B6  6E0C     MOVWF 0xC, ACCESS
174B8  0EED     MOVLW 0xED
174BA  24E1     ADDWF 0xFE1, W, ACCESS
174BC  6ED9     MOVWF 0xFD9, ACCESS
174BE  0EFF     MOVLW 0xFF
174C0  20E2     ADDWFC 0xFE2, W, ACCESS
174C2  6EDA     MOVWF __end_of_UART2_tx_vect_isr, ACCESS
174C4  50DF     MOVF 0xFDF, W, ACCESS
174C6  020C     MULWF 0xC, ACCESS
174C8  0EFB     MOVLW 0xFB
174CA  C4F3     MOVFF PROD, PLUSW1
174CC  F4E3     NOP
174CE  0EFC     MOVLW 0xFC
174D0  C4F4     MOVFF PRODH, PLUSW1
174D2  F4E3     NOP
113:           	prod.i += (unsigned long)temp.n;
174D4  0EFB     MOVLW 0xFB
174D6  0061     MOVFFL PLUSW1, wtemp5
174D8  F38C     NOP
174DA  F50B     NOP
174DC  0EFC     MOVLW 0xFC
174DE  0061     MOVFFL PLUSW1, 0x50C
174E0  F38C     NOP
174E2  F50C     NOP
174E4  50E1     MOVF 0xFE1, W, ACCESS
174E6  0FF3     ADDLW 0xF3
174E8  6ED9     MOVWF 0xFD9, ACCESS
174EA  50E2     MOVF 0xFE2, W, ACCESS
174EC  6EDA     MOVWF __end_of_UART2_tx_vect_isr, ACCESS
174EE  0EFF     MOVLW 0xFF
174F0  22DA     ADDWFC __end_of_UART2_tx_vect_isr, F, ACCESS
174F2  500B     MOVF 0xB, W, ACCESS
174F4  26DE     ADDWF 0xFDE, F, ACCESS
174F6  500C     MOVF 0xC, W, ACCESS
174F8  22DE     ADDWFC 0xFDE, F, ACCESS
174FA  0E00     MOVLW 0x0
174FC  22DE     ADDWFC 0xFDE, F, ACCESS
174FE  22DE     ADDWFC 0xFDE, F, ACCESS
114:           	temp.n = MIDBYTE(a) * HIGHBYTE(b);
17500  0EF1     MOVLW 0xF1
17502  24E1     ADDWF 0xFE1, W, ACCESS
17504  6ED9     MOVWF 0xFD9, ACCESS
17506  0EFF     MOVLW 0xFF
17508  20E2     ADDWFC 0xFE2, W, ACCESS
1750A  6EDA     MOVWF __end_of_UART2_tx_vect_isr, ACCESS
1750C  50DF     MOVF 0xFDF, W, ACCESS
1750E  6E0C     MOVWF 0xC, ACCESS
17510  0EEC     MOVLW 0xEC
17512  24E1     ADDWF 0xFE1, W, ACCESS
17514  6ED9     MOVWF 0xFD9, ACCESS
17516  0EFF     MOVLW 0xFF
17518  20E2     ADDWFC 0xFE2, W, ACCESS
1751A  6EDA     MOVWF __end_of_UART2_tx_vect_isr, ACCESS
1751C  50DF     MOVF 0xFDF, W, ACCESS
1751E  020C     MULWF 0xC, ACCESS
17520  0EFB     MOVLW 0xFB
17522  C4F3     MOVFF PROD, PLUSW1
17524  F4E3     NOP
17526  0EFC     MOVLW 0xFC
17528  C4F4     MOVFF PRODH, PLUSW1
1752A  F4E3     NOP
115:           	prod.i += (unsigned long)temp.n;
1752C  0EFB     MOVLW 0xFB
1752E  0061     MOVFFL PLUSW1, wtemp5
17530  F38C     NOP
17532  F50B     NOP
17534  0EFC     MOVLW 0xFC
17536  0061     MOVFFL PLUSW1, 0x50C
17538  F38C     NOP
1753A  F50C     NOP
1753C  50E1     MOVF 0xFE1, W, ACCESS
1753E  0FF3     ADDLW 0xF3
17540  6ED9     MOVWF 0xFD9, ACCESS
17542  50E2     MOVF 0xFE2, W, ACCESS
17544  6EDA     MOVWF __end_of_UART2_tx_vect_isr, ACCESS
17546  0EFF     MOVLW 0xFF
17548  22DA     ADDWFC __end_of_UART2_tx_vect_isr, F, ACCESS
1754A  500B     MOVF 0xB, W, ACCESS
1754C  26DE     ADDWF 0xFDE, F, ACCESS
1754E  500C     MOVF 0xC, W, ACCESS
17550  22DE     ADDWFC 0xFDE, F, ACCESS
17552  0E00     MOVLW 0x0
17554  22DE     ADDWFC 0xFDE, F, ACCESS
17556  22DE     ADDWFC 0xFDE, F, ACCESS
116:           	temp.n = HIGHBYTE(a) * HIGHBYTE(b);
17558  0EF1     MOVLW 0xF1
1755A  24E1     ADDWF 0xFE1, W, ACCESS
1755C  6ED9     MOVWF 0xFD9, ACCESS
1755E  0EFF     MOVLW 0xFF
17560  20E2     ADDWFC 0xFE2, W, ACCESS
17562  6EDA     MOVWF __end_of_UART2_tx_vect_isr, ACCESS
17564  50DF     MOVF 0xFDF, W, ACCESS
17566  6E0C     MOVWF 0xC, ACCESS
17568  0EED     MOVLW 0xED
1756A  24E1     ADDWF 0xFE1, W, ACCESS
1756C  6ED9     MOVWF 0xFD9, ACCESS
1756E  0EFF     MOVLW 0xFF
17570  20E2     ADDWFC 0xFE2, W, ACCESS
17572  6EDA     MOVWF __end_of_UART2_tx_vect_isr, ACCESS
17574  50DF     MOVF 0xFDF, W, ACCESS
17576  020C     MULWF 0xC, ACCESS
17578  0EFB     MOVLW 0xFB
1757A  C4F3     MOVFF PROD, PLUSW1
1757C  F4E3     NOP
1757E  0EFC     MOVLW 0xFC
17580  C4F4     MOVFF PRODH, PLUSW1
17582  F4E3     NOP
117:           	prod.i += (((unsigned long)temp.n) << 8);
17584  0EFB     MOVLW 0xFB
17586  0061     MOVFFL PLUSW1, wtemp5
17588  F38C     NOP
1758A  F50B     NOP
1758C  0EFC     MOVLW 0xFC
1758E  0061     MOVFFL PLUSW1, 0x50C
17590  F38C     NOP
17592  F50C     NOP
17594  500B     MOVF 0xB, W, ACCESS
17596  6E05     MOVWF 0x5, ACCESS
17598  500C     MOVF 0xC, W, ACCESS
1759A  6E06     MOVWF 0x6, ACCESS
1759C  6A07     CLRF 0x7, ACCESS
1759E  6A08     CLRF 0x8, ACCESS
175A0  0061     MOVFFL ttemp2, 0x508
175A2  F41C     NOP
175A4  F508     NOP
175A6  0061     MOVFFL 0x506, ttemp2
175A8  F418     NOP
175AA  F507     NOP
175AC  0061     MOVFFL ltemp1, 0x506
175AE  F414     NOP
175B0  F506     NOP
175B2  6A05     CLRF 0x5, ACCESS
175B4  50E1     MOVF 0xFE1, W, ACCESS
175B6  0FF3     ADDLW 0xF3
175B8  6ED9     MOVWF 0xFD9, ACCESS
175BA  50E2     MOVF 0xFE2, W, ACCESS
175BC  6EDA     MOVWF __end_of_UART2_tx_vect_isr, ACCESS
175BE  0EFF     MOVLW 0xFF
175C0  22DA     ADDWFC __end_of_UART2_tx_vect_isr, F, ACCESS
175C2  5005     MOVF 0x5, W, ACCESS
175C4  26DE     ADDWF 0xFDE, F, ACCESS
175C6  5006     MOVF 0x6, W, ACCESS
175C8  22DE     ADDWFC 0xFDE, F, ACCESS
175CA  5007     MOVF 0x7, W, ACCESS
175CC  22DE     ADDWFC 0xFDE, F, ACCESS
175CE  5008     MOVF 0x8, W, ACCESS
175D0  22DE     ADDWFC 0xFDE, F, ACCESS
118:           #else
119:           	temp.n = _Umul8_16(HIGHBYTE(a), LOWBYTE(b));
120:           	grs = temp.nAsBytes.a;
121:           	prod.i = temp.nAsBytes.b;
122:           	temp.n = _Umul8_16(MIDBYTE(a), MIDBYTE(b));
123:           	grs += temp.nAsBytes.a;
124:           	prod.i += temp.nAsBytes.b;
125:           	temp.n = _Umul8_16(LOWBYTE(a), HIGHBYTE(b));
126:           	grs += temp.nAsBytes.a;
127:           	prod.i += temp.nAsBytes.b;
128:           	grs <<= 8;
129:           	temp.n = _Umul8_16(LOWBYTE(a), MIDBYTE(b));
130:           	grs += (unsigned long)temp.n;
131:           	temp.n = _Umul8_16(MIDBYTE(a), LOWBYTE(b));
132:           	grs += (unsigned long)temp.n;
133:           	grs <<= 8;
134:           	temp.n = _Umul8_16(LOWBYTE(a), LOWBYTE(b));
135:           	grs += (unsigned long)temp.n;
136:           	temp.n = _Umul8_16(HIGHBYTE(a), MIDBYTE(b));
137:           	prod.i += (unsigned long)temp.n;
138:           	temp.n = _Umul8_16(MIDBYTE(a), HIGHBYTE(b));
139:           	prod.i += (unsigned long)temp.n;
140:           	temp.n = _Umul8_16(HIGHBYTE(a), HIGHBYTE(b));
141:           	prod.i += (((unsigned long)temp.n) << 8);
142:           #endif
143:           
144:           	// first add the overflow bit from the lower half to the upper half
145:           	prod.i += (grs >> 24);
175D2  50E1     MOVF 0xFE1, W, ACCESS
175D4  0FF3     ADDLW 0xF3
175D6  6ED9     MOVWF 0xFD9, ACCESS
175D8  50E2     MOVF 0xFE2, W, ACCESS
175DA  6EDA     MOVWF __end_of_UART2_tx_vect_isr, ACCESS
175DC  0EFF     MOVLW 0xFF
175DE  22DA     ADDWFC __end_of_UART2_tx_vect_isr, F, ACCESS
175E0  0EFA     MOVLW 0xFA
175E2  24E1     ADDWF 0xFE1, W, ACCESS
175E4  6EE9     MOVWF 0xFE9, ACCESS
175E6  0EFF     MOVLW 0xFF
175E8  20E2     ADDWFC 0xFE2, W, ACCESS
175EA  6EEA     MOVWF 0xFEA, ACCESS
175EC  50EF     MOVF 0xFEF, W, ACCESS
175EE  26DE     ADDWF 0xFDE, F, ACCESS
175F0  0E00     MOVLW 0x0
175F2  22DE     ADDWFC 0xFDE, F, ACCESS
175F4  22DE     ADDWFC 0xFDE, F, ACCESS
175F6  22DE     ADDWFC 0xFDE, F, ACCESS
146:           	grs <<= 8;
175F8  50E1     MOVF 0xFE1, W, ACCESS
175FA  0FF7     ADDLW 0xF7
175FC  6ED9     MOVWF 0xFD9, ACCESS
175FE  50E2     MOVF 0xFE2, W, ACCESS
17600  6EDA     MOVWF __end_of_UART2_tx_vect_isr, ACCESS
17602  0EFF     MOVLW 0xFF
17604  22DA     ADDWFC __end_of_UART2_tx_vect_isr, F, ACCESS
17606  0E08     MOVLW 0x8
17608  90D8     BCF 0xFD8, 0, ACCESS
1760A  36DE     RLCF 0xFDE, F, ACCESS
1760C  36DE     RLCF 0xFDE, F, ACCESS
1760E  36DE     RLCF 0xFDE, F, ACCESS
17610  36DD     RLCF 0xFDD, F, ACCESS
17612  52DD     MOVF 0xFDD, F, ACCESS
17614  52DD     MOVF 0xFDD, F, ACCESS
17616  2EE8     DECFSZ 0xFE8, F, ACCESS
17618  D7F7     BRA 0x7608
147:           
148:           	/* Add source exponent, minus (bias - 1) */
149:           	temp.i = bexp + aexp - 126;
1761A  0EFD     MOVLW 0xFD
1761C  50E3     MOVF 0xFE3, W, ACCESS
1761E  6E0B     MOVWF 0xB, ACCESS
17620  6A0C     CLRF 0xC, ACCESS
17622  0EFE     MOVLW 0xFE
17624  50E3     MOVF 0xFE3, W, ACCESS
17626  260B     ADDWF 0xB, F, ACCESS
17628  0E00     MOVLW 0x0
1762A  220C     ADDWFC 0xC, F, ACCESS
1762C  0E82     MOVLW 0x82
1762E  240B     ADDWF 0xB, W, ACCESS
17630  6E09     MOVWF 0x9, ACCESS
17632  0EFF     MOVLW 0xFF
17634  200C     ADDWFC 0xC, W, ACCESS
17636  6E0A     MOVWF 0xA, ACCESS
17638  0EFB     MOVLW 0xFB
1763A  0061     MOVFFL ltemp2, PLUSW1
1763C  F424     NOP
1763E  F4E3     NOP
17640  0EFC     MOVLW 0xFC
17642  0061     MOVFFL ttemp3, PLUSW1
17644  F428     NOP
17646  F4E3     NOP
150:           
151:           	/* Renormalize  */
152:           	while (!(prod.i & ((int32_t) 1 << SPFRCB))) {
17648  D021     BRA 0x768C
1768C  0EF5     MOVLW 0xF5
1768E  AEE3     BTFSS 0xFE3, 7, ACCESS
17690  D7DC     BRA 0x764A
153:           		prod.i <<= 1;
1764A  90D8     BCF 0xFD8, 0, ACCESS
1764C  0EF3     MOVLW 0xF3
1764E  36E3     RLCF 0xFE3, F, ACCESS
17650  0EF4     MOVLW 0xF4
17652  36E3     RLCF 0xFE3, F, ACCESS
17654  0EF5     MOVLW 0xF5
17656  36E3     RLCF 0xFE3, F, ACCESS
17658  0EF6     MOVLW 0xF6
1765A  36E3     RLCF 0xFE3, F, ACCESS
154:           		if (grs & 0x80000000) {
1765C  0EFA     MOVLW 0xFA
1765E  AEE3     BTFSS 0xFE3, 7, ACCESS
17660  D002     BRA 0x7666
155:           			prod.i |= 0x1;
17662  0EF3     MOVLW 0xF3
17664  80E3     BSF 0xFE3, 0, ACCESS
156:           		}
157:           		grs <<= 1;
17666  90D8     BCF 0xFD8, 0, ACCESS
17668  0EF7     MOVLW 0xF7
1766A  36E3     RLCF 0xFE3, F, ACCESS
1766C  0EF8     MOVLW 0xF8
1766E  36E3     RLCF 0xFE3, F, ACCESS
17670  0EF9     MOVLW 0xF9
17672  36E3     RLCF 0xFE3, F, ACCESS
17674  0EFA     MOVLW 0xFA
17676  36E3     RLCF 0xFE3, F, ACCESS
158:           		--temp.i;
17678  50E1     MOVF 0xFE1, W, ACCESS
1767A  0FFB     ADDLW 0xFB
1767C  6ED9     MOVWF 0xFD9, ACCESS
1767E  50E2     MOVF 0xFE2, W, ACCESS
17680  6EDA     MOVWF __end_of_UART2_tx_vect_isr, ACCESS
17682  0EFF     MOVLW 0xFF
17684  22DA     ADDWFC __end_of_UART2_tx_vect_isr, F, ACCESS
17686  06DE     DECF 0xFDE, F, ACCESS
17688  0E00     MOVLW 0x0
1768A  5ADD     SUBWFB 0xFDD, F, ACCESS
159:           	}
160:           
161:           	/* Round, check overflow, underflow */
162:           	// reuse aexp as round up flag
163:           	aexp = 0;
17692  0EFE     MOVLW 0xFE
17694  6AE3     CLRF 0xFE3, ACCESS
164:           	if (grs & 0x80000000) {
17696  0EFA     MOVLW 0xFA
17698  AEE3     BTFSS 0xFE3, 7, ACCESS
1769A  D020     BRA 0x76DC
165:           		if (grs & 0x7FFFFFFF) {
1769C  50E1     MOVF 0xFE1, W, ACCESS
1769E  0FF7     ADDLW 0xF7
176A0  6ED9     MOVWF 0xFD9, ACCESS
176A2  50E2     MOVF 0xFE2, W, ACCESS
176A4  6EDA     MOVWF __end_of_UART2_tx_vect_isr, ACCESS
176A6  0EFF     MOVLW 0xFF
176A8  22DA     ADDWFC __end_of_UART2_tx_vect_isr, F, ACCESS
176AA  0EFF     MOVLW 0xFF
176AC  14DE     ANDWF 0xFDE, W, ACCESS
176AE  6E09     MOVWF 0x9, ACCESS
176B0  0EFF     MOVLW 0xFF
176B2  14DE     ANDWF 0xFDE, W, ACCESS
176B4  6E0A     MOVWF 0xA, ACCESS
176B6  0EFF     MOVLW 0xFF
176B8  14DE     ANDWF 0xFDE, W, ACCESS
176BA  6E0B     MOVWF 0xB, ACCESS
176BC  0E7F     MOVLW 0x7F
176BE  14DE     ANDWF 0xFDE, W, ACCESS
176C0  6E0C     MOVWF 0xC, ACCESS
176C2  5009     MOVF 0x9, W, ACCESS
176C4  100A     IORWF 0xA, W, ACCESS
176C6  100B     IORWF 0xB, W, ACCESS
176C8  100C     IORWF 0xC, W, ACCESS
176CA  B4D8     BTFSC 0xFD8, 2, ACCESS
176CC  D004     BRA 0x76D6
166:           			aexp = 1;
176CE  0EFE     MOVLW 0xFE
176D0  6AE3     CLRF 0xFE3, ACCESS
176D2  2AE3     INCF 0xFE3, F, ACCESS
167:           		}
176D4  D003     BRA 0x76DC
168:           		else {
169:           			if (prod.i & 1) {
176D6  0EF3     MOVLW 0xF3
176D8  B0E3     BTFSC 0xFE3, 0, ACCESS
176DA  D7F9     BRA 0x76CE
170:           				aexp = 1;
171:           			}
172:           		}
173:           	}
174:           	if (aexp) {
176DC  0EFE     MOVLW 0xFE
176DE  50E3     MOVF 0xFE3, W, ACCESS
176E0  B4D8     BTFSC 0xFD8, 2, ACCESS
176E2  D036     BRA 0x7750
175:           		++prod.i;
176E4  50E1     MOVF 0xFE1, W, ACCESS
176E6  0FF3     ADDLW 0xF3
176E8  6ED9     MOVWF 0xFD9, ACCESS
176EA  50E2     MOVF 0xFE2, W, ACCESS
176EC  6EDA     MOVWF __end_of_UART2_tx_vect_isr, ACCESS
176EE  0EFF     MOVLW 0xFF
176F0  22DA     ADDWFC __end_of_UART2_tx_vect_isr, F, ACCESS
176F2  2ADE     INCF 0xFDE, F, ACCESS
176F4  0E00     MOVLW 0x0
176F6  22DE     ADDWFC 0xFDE, F, ACCESS
176F8  22DE     ADDWFC 0xFDE, F, ACCESS
176FA  22DE     ADDWFC 0xFDE, F, ACCESS
176:           		if (prod.i & ((int32_t) 1 << (SPFRCB + 1))) {
176FC  0EF6     MOVLW 0xF6
176FE  A0E3     BTFSS 0xFE3, 0, ACCESS
17700  D027     BRA 0x7750
177:           			prod.i = prod.i >> 1;
17702  0E01     MOVLW 0x1
17704  6E0C     MOVWF 0xC, ACCESS
17706  50E1     MOVF 0xFE1, W, ACCESS
17708  0FF3     ADDLW 0xF3
1770A  6ED9     MOVWF 0xFD9, ACCESS
1770C  50E2     MOVF 0xFE2, W, ACCESS
1770E  6EDA     MOVWF __end_of_UART2_tx_vect_isr, ACCESS
17710  0EFF     MOVLW 0xFF
17712  22DA     ADDWFC __end_of_UART2_tx_vect_isr, F, ACCESS
17714  280C     INCF 0xC, W, ACCESS
17716  52DE     MOVF 0xFDE, F, ACCESS
17718  D008     BRA 0x772A
1771A  52DE     MOVF 0xFDE, F, ACCESS
1771C  90D8     BCF 0xFD8, 0, ACCESS
1771E  BEDC     BTFSC _UART2_rx_vect_isr, 7, ACCESS
17720  80D8     BSF 0xFD8, 0, ACCESS
17722  32DD     RRCF 0xFDD, F, ACCESS
17724  32DD     RRCF 0xFDD, F, ACCESS
17726  32DD     RRCF 0xFDD, F, ACCESS
17728  32DE     RRCF 0xFDE, F, ACCESS
1772A  2EE8     DECFSZ 0xFE8, F, ACCESS
1772C  D7F6     BRA 0x771A
178:           			++temp.i;
1772E  0EFB     MOVLW 0xFB
17730  50E3     MOVF 0xFE3, W, ACCESS
17732  0F01     ADDLW 0x1
17734  6E01     MOVWF __ptext283, ACCESS
17736  0EFB     MOVLW 0xFB
17738  0061     MOVFFL ltemp0, PLUSW1
1773A  F404     NOP
1773C  F4E3     NOP
1773E  6A01     CLRF __ptext283, ACCESS
17740  0EFC     MOVLW 0xFC
17742  50E3     MOVF 0xFE3, W, ACCESS
17744  2001     ADDWFC __ptext283, W, ACCESS
17746  6E01     MOVWF __ptext283, ACCESS
17748  0EFC     MOVLW 0xFC
1774A  0061     MOVFFL ltemp0, PLUSW1
1774C  F404     NOP
1774E  F4E3     NOP
179:           		}
180:           	}
181:           
182:           	/* Overflow ? Return infinity */
183:           	if (!(temp.i < SPEXPM)) {
17750  0EFC     MOVLW 0xFC
17752  BEE3     BTFSC 0xFE3, 7, ACCESS
17754  D020     BRA 0x7796
17756  0EFC     MOVLW 0xFC
17758  50E3     MOVF 0xFE3, W, ACCESS
1775A  E104     BNZ 0x7764
1775C  0EFB     MOVLW 0xFB
1775E  28E3     INCF 0xFE3, W, ACCESS
17760  A0D8     BTFSS 0xFD8, 0, ACCESS
17762  D019     BRA 0x7796
184:           		prod.i = 0x7F800000;
17764  0E00     MOVLW 0x0
17766  6E09     MOVWF 0x9, ACCESS
17768  0E00     MOVLW 0x0
1776A  6E0A     MOVWF 0xA, ACCESS
1776C  0E80     MOVLW 0x80
1776E  6E0B     MOVWF 0xB, ACCESS
17770  0E7F     MOVLW 0x7F
17772  6E0C     MOVWF 0xC, ACCESS
17774  0EF3     MOVLW 0xF3
17776  0061     MOVFFL ltemp2, PLUSW1
17778  F424     NOP
1777A  F4E3     NOP
1777C  0EF4     MOVLW 0xF4
1777E  0061     MOVFFL ttemp3, PLUSW1
17780  F428     NOP
17782  F4E3     NOP
17784  0EF5     MOVLW 0xF5
17786  0061     MOVFFL wtemp5, PLUSW1
17788  F42C     NOP
1778A  F4E3     NOP
1778C  0EF6     MOVLW 0xF6
1778E  0061     MOVFFL 0x50C, PLUSW1
17790  F430     NOP
17792  F4E3     NOP
185:           	}
17794  D044     BRA 0x781E
186:           	/* Underflow ? Flush to zero */
187:           	else if (!(0 < temp.i)) {
17796  0EFC     MOVLW 0xFC
17798  BEE3     BTFSC 0xFE3, 7, ACCESS
1779A  D007     BRA 0x77AA
1779C  0EFC     MOVLW 0xFC
1779E  50E3     MOVF 0xFE3, W, ACCESS
177A0  E10F     BNZ 0x77C0
177A2  0EFB     MOVLW 0xFB
177A4  04E3     DECF 0xFE3, W, ACCESS
177A6  B0D8     BTFSC 0xFD8, 0, ACCESS
177A8  D00B     BRA 0x77C0
188:           		prod.i = 0;
177AA  0EF3     MOVLW 0xF3
177AC  6AE3     CLRF 0xFE3, ACCESS
177AE  0EF4     MOVLW 0xF4
177B0  6AE3     CLRF 0xFE3, ACCESS
177B2  0EF5     MOVLW 0xF5
177B4  6AE3     CLRF 0xFE3, ACCESS
177B6  0EF6     MOVLW 0xF6
177B8  6AE3     CLRF 0xFE3, ACCESS
189:                           // no negative 0 for now
190:                           sign=0;
177BA  0EFF     MOVLW 0xFF
177BC  6AE3     CLRF 0xFE3, ACCESS
191:           	}
177BE  D02F     BRA 0x781E
192:           	else {
193:           		/* Pack and return result */
194:           		bexp = (unsigned char)temp.i;	// it fits in 8 bits !
177C0  0EFB     MOVLW 0xFB
177C2  0061     MOVFFL PLUSW1, ltemp0
177C4  F38C     NOP
177C6  F501     NOP
177C8  0EFD     MOVLW 0xFD
177CA  0061     MOVFFL ltemp0, PLUSW1
177CC  F404     NOP
177CE  F4E3     NOP
195:           		prod.i &= SPFRCM;	// trim away the leading 1
177D0  50E1     MOVF 0xFE1, W, ACCESS
177D2  0FF3     ADDLW 0xF3
177D4  6ED9     MOVWF 0xFD9, ACCESS
177D6  50E2     MOVF 0xFE2, W, ACCESS
177D8  6EDA     MOVWF __end_of_UART2_tx_vect_isr, ACCESS
177DA  0EFF     MOVLW 0xFF
177DC  22DA     ADDWFC __end_of_UART2_tx_vect_isr, F, ACCESS
177DE  0EFF     MOVLW 0xFF
177E0  16DE     ANDWF 0xFDE, F, ACCESS
177E2  0EFF     MOVLW 0xFF
177E4  16DE     ANDWF 0xFDE, F, ACCESS
177E6  0E7F     MOVLW 0x7F
177E8  16DE     ANDWF 0xFDE, F, ACCESS
177EA  0E00     MOVLW 0x0
177EC  16DE     ANDWF 0xFDE, F, ACCESS
196:           		if (bexp & 0x1) {
177EE  0EFD     MOVLW 0xFD
177F0  A0E3     BTFSS 0xFE3, 0, ACCESS
177F2  D008     BRA 0x7804
197:           			prod.fAsBytes.c |= 0x80;
177F4  0EF5     MOVLW 0xF5
177F6  24E1     ADDWF 0xFE1, W, ACCESS
177F8  6ED9     MOVWF 0xFD9, ACCESS
177FA  0EFF     MOVLW 0xFF
177FC  20E2     ADDWFC 0xFE2, W, ACCESS
177FE  6EDA     MOVWF __end_of_UART2_tx_vect_isr, ACCESS
17800  0E00     MOVLW 0x0
17802  8EDB     BSF __end_of_UART2_tx_vect_isr, 7, ACCESS
198:           		}
199:           		prod.fAsBytes.d = bexp >> 1;
17804  0EF6     MOVLW 0xF6
17806  24E1     ADDWF 0xFE1, W, ACCESS
17808  6ED9     MOVWF 0xFD9, ACCESS
1780A  0EFF     MOVLW 0xFF
1780C  20E2     ADDWFC 0xFE2, W, ACCESS
1780E  6EDA     MOVWF __end_of_UART2_tx_vect_isr, ACCESS
17810  0EFD     MOVLW 0xFD
17812  0061     MOVFFL PLUSW1, 0x50C
17814  F38C     NOP
17816  F50C     NOP
17818  90D8     BCF 0xFD8, 0, ACCESS
1781A  300C     RRCF 0xC, W, ACCESS
1781C  6EDF     MOVWF 0xFDF, ACCESS
200:           	}
201:           	prod.fAsBytes.d |= sign;
1781E  0EFF     MOVLW 0xFF
17820  0061     MOVFFL PLUSW1, 0x50C
17822  F38C     NOP
17824  F50C     NOP
17826  0EF6     MOVLW 0xF6
17828  24E1     ADDWF 0xFE1, W, ACCESS
1782A  6ED9     MOVWF 0xFD9, ACCESS
1782C  0EFF     MOVLW 0xFF
1782E  20E2     ADDWFC 0xFE2, W, ACCESS
17830  6EDA     MOVWF __end_of_UART2_tx_vect_isr, ACCESS
17832  500C     MOVF 0xC, W, ACCESS
17834  12DF     IORWF 0xFDF, F, ACCESS
202:           
203:           	return prod.f;
17836  0EF3     MOVLW 0xF3
17838  0061     MOVFFL PLUSW1, ltemp0
1783A  F38C     NOP
1783C  F501     NOP
1783E  0EF4     MOVLW 0xF4
17840  0061     MOVFFL PLUSW1, ttemp5
17842  F38C     NOP
17844  F502     NOP
17846  0EF5     MOVLW 0xF5
17848  0061     MOVFFL PLUSW1, wtemp1
1784A  F38C     NOP
1784C  F503     NOP
1784E  0EF6     MOVLW 0xF6
17850  0061     MOVFFL PLUSW1, ttemp1
17852  F38C     NOP
17854  F504     NOP
204:           
205:           }
17856  0EEB     MOVLW 0xEB
17858  26E1     ADDWF 0xFE1, F, ACCESS
1785A  0EFF     MOVLW 0xFF
1785C  22E2     ADDWFC 0xFE2, F, ACCESS
1785C  22E2     ADDWFC 0xFE2, F, ACCESS
206:           
---  /opt/microchip/xc8/v2.41/pic/sources/c99/common/sprcdiv.c  -----------------------------------------
1:             /* SP relaxed compliance floating point divide intrinsic function */
2:             #include <stdint.h>
3:             #include "fpform.h"
4:             
5:             /* SP Divide */
6:             #ifdef __PICC__
7:             SP
8:             SPDIV(SP a, SP b)
9:             #else
10:            SP
11:            SPDIV(SP b, SP a)
187A4  0E0D     MOVLW 0xD
187A6  26E1     ADDWF 0xFE1, F, ACCESS
187A8  0E00     MOVLW 0x0
187AA  22E2     ADDWFC 0xFE2, F, ACCESS
12:            #endif
13:            {
14:            #define A_FRACTION    (*(SFP *)&a)
15:            #define B_FRACTION    (*(SFP *)&b)
16:            	unsigned char sign;	/* sign of result */
17:            
18:            	unsigned char bexp;	/* Dst exponent */
19:            	unsigned char aexp;	/* Src exponent */
20:            	int16_t new_exp;
21:            	uint32_t grs;		/* Guard, round, sticky */
22:            	uint32_t rem;
23:            
24:            	/* Unpack and check operands */
25:            	// put b's sign as the result sign ...
26:            	sign = B_FRACTION.fAsBytes.d & 0x80;
187AC  0EF2     MOVLW 0xF2
187AE  24E1     ADDWF 0xFE1, W, ACCESS
187B0  6ED9     MOVWF 0xFD9, ACCESS
187B2  0EFF     MOVLW 0xFF
187B4  20E2     ADDWFC 0xFE2, W, ACCESS
187B6  6EDA     MOVWF __end_of_UART2_tx_vect_isr, ACCESS
187B8  50DF     MOVF 0xFDF, W, ACCESS
187BA  6E0C     MOVWF 0xC, ACCESS
187BC  0E80     MOVLW 0x80
187BE  160C     ANDWF 0xC, F, ACCESS
187C0  0EFF     MOVLW 0xFF
187C2  0061     MOVFFL 0x50C, PLUSW1
187C4  F430     NOP
187C6  F4E3     NOP
27:            	bexp = (unsigned char)(B_FRACTION.fAsBytes.d << 1);
187C8  0EF2     MOVLW 0xF2
187CA  24E1     ADDWF 0xFE1, W, ACCESS
187CC  6ED9     MOVWF 0xFD9, ACCESS
187CE  0EFF     MOVLW 0xFF
187D0  20E2     ADDWFC 0xFE2, W, ACCESS
187D2  6EDA     MOVWF __end_of_UART2_tx_vect_isr, ACCESS
187D4  50DF     MOVF 0xFDF, W, ACCESS
187D6  6E0C     MOVWF 0xC, ACCESS
187D8  90D8     BCF 0xFD8, 0, ACCESS
187DA  340C     RLCF 0xC, W, ACCESS
187DC  6E0B     MOVWF 0xB, ACCESS
187DE  0EFE     MOVLW 0xFE
187E0  0061     MOVFFL wtemp5, PLUSW1
187E2  F42C     NOP
187E4  F4E3     NOP
28:            	if (B_FRACTION.fAsBytes.c & 0x80) {
187E6  0EF1     MOVLW 0xF1
187E8  24E1     ADDWF 0xFE1, W, ACCESS
187EA  6ED9     MOVWF 0xFD9, ACCESS
187EC  0EFF     MOVLW 0xFF
187EE  20E2     ADDWFC 0xFE2, W, ACCESS
187F0  6EDA     MOVWF __end_of_UART2_tx_vect_isr, ACCESS
187F2  AEDF     BTFSS 0xFDF, 7, ACCESS
187F4  D002     BRA 0x87FA
29:            		bexp |= 0x1;
187F6  0EFE     MOVLW 0xFE
187F8  80E3     BSF 0xFE3, 0, ACCESS
30:            	}
31:            
32:            	/* Destination normal ? */
33:            	if (bexp) {
187FA  0EFE     MOVLW 0xFE
187FC  50E3     MOVF 0xFE3, W, ACCESS
187FE  B4D8     BTFSC 0xFD8, 2, ACCESS
18800  D026     BRA 0x884E
34:            		/* Destination inf or NaN ? */
35:            		if (bexp == 0xFF) {
18802  0EFE     MOVLW 0xFE
18804  28E3     INCF 0xFE3, W, ACCESS
18806  A4D8     BTFSS 0xFD8, 2, ACCESS
18808  D018     BRA 0x883A
36:            			/* Make it inf */
37:            			b = 0;
1880A  0E00     MOVLW 0x0
1880C  6E09     MOVWF 0x9, ACCESS
1880E  0E00     MOVLW 0x0
18810  6E0A     MOVWF 0xA, ACCESS
18812  0E00     MOVLW 0x0
18814  6E0B     MOVWF 0xB, ACCESS
18816  0E00     MOVLW 0x0
18818  6E0C     MOVWF 0xC, ACCESS
1881A  0EEF     MOVLW 0xEF
1881C  0061     MOVFFL ltemp2, PLUSW1
1881E  F424     NOP
18820  F4E3     NOP
18822  0EF0     MOVLW 0xF0
18824  0061     MOVFFL ttemp3, PLUSW1
18826  F428     NOP
18828  F4E3     NOP
1882A  0EF1     MOVLW 0xF1
1882C  0061     MOVFFL wtemp5, PLUSW1
1882E  F42C     NOP
18830  F4E3     NOP
18832  0EF2     MOVLW 0xF2
18834  0061     MOVFFL 0x50C, PLUSW1
18836  F430     NOP
18838  F4E3     NOP
38:            		}
39:            		// OR in the hidden 1-bit to b's fraction
40:            		B_FRACTION.i |= (int32_t) 1 << SPFRCB;
1883A  0EF1     MOVLW 0xF1
1883C  8EE3     BSF 0xFE3, 7, ACCESS
41:            		// and zero out the upper byte so we can safely shift
42:            		B_FRACTION.fAsBytes.d = 0;
1883E  0EF2     MOVLW 0xF2
18840  24E1     ADDWF 0xFE1, W, ACCESS
18842  6ED9     MOVWF 0xFD9, ACCESS
18844  0EFF     MOVLW 0xFF
18846  20E2     ADDWFC 0xFE2, W, ACCESS
18848  6EDA     MOVWF __end_of_UART2_tx_vect_isr, ACCESS
1884A  6ADF     CLRF 0xFDF, ACCESS
43:            	}
1884C  D018     BRA 0x887E
44:            	else {
45:            		/* Make it zero */
46:            		b = 0;
1884E  0E00     MOVLW 0x0
18850  6E09     MOVWF 0x9, ACCESS
18852  0E00     MOVLW 0x0
18854  6E0A     MOVWF 0xA, ACCESS
18856  0E00     MOVLW 0x0
18858  6E0B     MOVWF 0xB, ACCESS
1885A  0E00     MOVLW 0x0
1885C  6E0C     MOVWF 0xC, ACCESS
1885E  0EEF     MOVLW 0xEF
18860  0061     MOVFFL ltemp2, PLUSW1
18862  F424     NOP
18864  F4E3     NOP
18866  0EF0     MOVLW 0xF0
18868  0061     MOVFFL ttemp3, PLUSW1
1886A  F428     NOP
1886C  F4E3     NOP
1886E  0EF1     MOVLW 0xF1
18870  0061     MOVFFL wtemp5, PLUSW1
18872  F42C     NOP
18874  F4E3     NOP
18876  0EF2     MOVLW 0xF2
18878  0061     MOVFFL 0x50C, PLUSW1
1887A  F430     NOP
1887C  F4E3     NOP
47:            	}
48:            	// xor a's sign into the result sign
49:            	sign ^= A_FRACTION.fAsBytes.d & 0x80;
1887E  0EEE     MOVLW 0xEE
18880  24E1     ADDWF 0xFE1, W, ACCESS
18882  6ED9     MOVWF 0xFD9, ACCESS
18884  0EFF     MOVLW 0xFF
18886  20E2     ADDWFC 0xFE2, W, ACCESS
18888  6EDA     MOVWF __end_of_UART2_tx_vect_isr, ACCESS
1888A  50DF     MOVF 0xFDF, W, ACCESS
1888C  6E0C     MOVWF 0xC, ACCESS
1888E  0E80     MOVLW 0x80
18890  160C     ANDWF 0xC, F, ACCESS
18892  50E1     MOVF 0xFE1, W, ACCESS
18894  0FFF     ADDLW 0xFF
18896  6ED9     MOVWF 0xFD9, ACCESS
18898  50E2     MOVF 0xFE2, W, ACCESS
1889A  6EDA     MOVWF __end_of_UART2_tx_vect_isr, ACCESS
1889C  0EFF     MOVLW 0xFF
1889E  22DA     ADDWFC __end_of_UART2_tx_vect_isr, F, ACCESS
188A0  500C     MOVF 0xC, W, ACCESS
188A2  1ADF     XORWF 0xFDF, F, ACCESS
50:            	aexp = (unsigned char)(A_FRACTION.fAsBytes.d << 1);
188A4  0EEE     MOVLW 0xEE
188A6  24E1     ADDWF 0xFE1, W, ACCESS
188A8  6ED9     MOVWF 0xFD9, ACCESS
188AA  0EFF     MOVLW 0xFF
188AC  20E2     ADDWFC 0xFE2, W, ACCESS
188AE  6EDA     MOVWF __end_of_UART2_tx_vect_isr, ACCESS
188B0  50DF     MOVF 0xFDF, W, ACCESS
188B2  6E0C     MOVWF 0xC, ACCESS
188B4  90D8     BCF 0xFD8, 0, ACCESS
188B6  340C     RLCF 0xC, W, ACCESS
188B8  6E0B     MOVWF 0xB, ACCESS
188BA  0EFD     MOVLW 0xFD
188BC  0061     MOVFFL wtemp5, PLUSW1
188BE  F42C     NOP
188C0  F4E3     NOP
51:            	if (A_FRACTION.fAsBytes.c & 0x80) {
188C2  0EED     MOVLW 0xED
188C4  24E1     ADDWF 0xFE1, W, ACCESS
188C6  6ED9     MOVWF 0xFD9, ACCESS
188C8  0EFF     MOVLW 0xFF
188CA  20E2     ADDWFC 0xFE2, W, ACCESS
188CC  6EDA     MOVWF __end_of_UART2_tx_vect_isr, ACCESS
188CE  AEDF     BTFSS 0xFDF, 7, ACCESS
188D0  D002     BRA 0x88D6
52:            		aexp |= 0x1;
188D2  0EFD     MOVLW 0xFD
188D4  80E3     BSF 0xFE3, 0, ACCESS
53:            	}
54:            
55:            	/* Destination normal ? */
56:            	if (aexp) {
188D6  0EFD     MOVLW 0xFD
188D8  50E3     MOVF 0xFE3, W, ACCESS
188DA  B4D8     BTFSC 0xFD8, 2, ACCESS
188DC  D026     BRA 0x892A
57:            		/* Destination inf or NaN ? */
58:            		if (aexp == 0xFF) {
188DE  0EFD     MOVLW 0xFD
188E0  28E3     INCF 0xFE3, W, ACCESS
188E2  A4D8     BTFSS 0xFD8, 2, ACCESS
188E4  D018     BRA 0x8916
59:            			/* Make it inf */
60:            			a = 0;
188E6  0E00     MOVLW 0x0
188E8  6E09     MOVWF 0x9, ACCESS
188EA  0E00     MOVLW 0x0
188EC  6E0A     MOVWF 0xA, ACCESS
188EE  0E00     MOVLW 0x0
188F0  6E0B     MOVWF 0xB, ACCESS
188F2  0E00     MOVLW 0x0
188F4  6E0C     MOVWF 0xC, ACCESS
188F6  0EEB     MOVLW 0xEB
188F8  0061     MOVFFL ltemp2, PLUSW1
188FA  F424     NOP
188FC  F4E3     NOP
188FE  0EEC     MOVLW 0xEC
18900  0061     MOVFFL ttemp3, PLUSW1
18902  F428     NOP
18904  F4E3     NOP
18906  0EED     MOVLW 0xED
18908  0061     MOVFFL wtemp5, PLUSW1
1890A  F42C     NOP
1890C  F4E3     NOP
1890E  0EEE     MOVLW 0xEE
18910  0061     MOVFFL 0x50C, PLUSW1
18912  F430     NOP
18914  F4E3     NOP
61:            		}
62:            		// OR in the hidden 1-bit to a's fraction
63:            		A_FRACTION.i |= (int32_t) 1 << SPFRCB;
18916  0EED     MOVLW 0xED
18918  8EE3     BSF 0xFE3, 7, ACCESS
64:            		// and zero out the upper bits so we can safely shift
65:            		A_FRACTION.fAsBytes.d = 0;
1891A  0EEE     MOVLW 0xEE
1891C  24E1     ADDWF 0xFE1, W, ACCESS
1891E  6ED9     MOVWF 0xFD9, ACCESS
18920  0EFF     MOVLW 0xFF
18922  20E2     ADDWFC 0xFE2, W, ACCESS
18924  6EDA     MOVWF __end_of_UART2_tx_vect_isr, ACCESS
18926  6ADF     CLRF 0xFDF, ACCESS
66:            	}
18928  D018     BRA 0x895A
67:            	else {
68:            		/* Make it zero */
69:            		a = 0;
1892A  0E00     MOVLW 0x0
1892C  6E09     MOVWF 0x9, ACCESS
1892E  0E00     MOVLW 0x0
18930  6E0A     MOVWF 0xA, ACCESS
18932  0E00     MOVLW 0x0
18934  6E0B     MOVWF 0xB, ACCESS
18936  0E00     MOVLW 0x0
18938  6E0C     MOVWF 0xC, ACCESS
1893A  0EEB     MOVLW 0xEB
1893C  0061     MOVFFL ltemp2, PLUSW1
1893E  F424     NOP
18940  F4E3     NOP
18942  0EEC     MOVLW 0xEC
18944  0061     MOVFFL ttemp3, PLUSW1
18946  F428     NOP
18948  F4E3     NOP
1894A  0EED     MOVLW 0xED
1894C  0061     MOVFFL wtemp5, PLUSW1
1894E  F42C     NOP
18950  F4E3     NOP
18952  0EEE     MOVLW 0xEE
18954  0061     MOVFFL 0x50C, PLUSW1
18956  F430     NOP
18958  F4E3     NOP
70:            	}
71:            
72:            	/* Special operand check */
73:            
74:            	/* Denominator zero ? Result infinity */
75:            	if (A_FRACTION.i == 0) {
1895A  0EEB     MOVLW 0xEB
1895C  50E3     MOVF 0xFE3, W, ACCESS
1895E  E139     BNZ 0x89D2
18960  0EEC     MOVLW 0xEC
18962  50E3     MOVF 0xFE3, W, ACCESS
18964  E136     BNZ 0x89D2
18966  0EED     MOVLW 0xED
18968  50E3     MOVF 0xFE3, W, ACCESS
1896A  E133     BNZ 0x89D2
1896C  0EEE     MOVLW 0xEE
1896E  50E3     MOVF 0xFE3, W, ACCESS
18970  A4D8     BTFSS 0xFD8, 2, ACCESS
18972  D02F     BRA 0x89D2
76:            		B_FRACTION.i = 0;
18974  0EEF     MOVLW 0xEF
18976  6AE3     CLRF 0xFE3, ACCESS
18978  0EF0     MOVLW 0xF0
1897A  6AE3     CLRF 0xFE3, ACCESS
1897C  0EF1     MOVLW 0xF1
1897E  6AE3     CLRF 0xFE3, ACCESS
18980  0EF2     MOVLW 0xF2
18982  6AE3     CLRF 0xFE3, ACCESS
77:            		B_FRACTION.fAsWords.wordB |= (SPEXPM << 7);
18984  0EF1     MOVLW 0xF1
18986  24E1     ADDWF 0xFE1, W, ACCESS
18988  6ED9     MOVWF 0xFD9, ACCESS
1898A  0EFF     MOVLW 0xFF
1898C  20E2     ADDWFC 0xFE2, W, ACCESS
1898E  6EDA     MOVWF __end_of_UART2_tx_vect_isr, ACCESS
18990  0E80     MOVLW 0x80
18992  12DE     IORWF 0xFDE, F, ACCESS
18994  0E7F     MOVLW 0x7F
18996  12DD     IORWF 0xFDD, F, ACCESS
78:            		B_FRACTION.fAsBytes.d |= sign;
18998  0EFF     MOVLW 0xFF
1899A  0061     MOVFFL PLUSW1, 0x50C
1899C  F38C     NOP
1899E  F50C     NOP
189A0  0EF2     MOVLW 0xF2
189A2  24E1     ADDWF 0xFE1, W, ACCESS
189A4  6ED9     MOVWF 0xFD9, ACCESS
189A6  0EFF     MOVLW 0xFF
189A8  20E2     ADDWFC 0xFE2, W, ACCESS
189AA  6EDA     MOVWF __end_of_UART2_tx_vect_isr, ACCESS
189AC  500C     MOVF 0xC, W, ACCESS
189AE  12DF     IORWF 0xFDF, F, ACCESS
79:            		return b;
189B0  0EEF     MOVLW 0xEF
189B2  0061     MOVFFL PLUSW1, ltemp0
189B4  F38C     NOP
189B6  F501     NOP
189B8  0EF0     MOVLW 0xF0
189BA  0061     MOVFFL PLUSW1, ttemp5
189BC  F38C     NOP
189BE  F502     NOP
189C0  0EF1     MOVLW 0xF1
189C2  0061     MOVFFL PLUSW1, wtemp1
189C4  F38C     NOP
189C6  F503     NOP
189C8  0EF2     MOVLW 0xF2
189CA  0061     MOVFFL PLUSW1, ttemp1
189CC  F38C     NOP
189CE  F504     NOP
189D0  D19F     BRA 0x8D10
80:            	}
81:            
82:            	/* Numerator zero ? Result zero */
83:            	if (!bexp) {
189D2  0EFE     MOVLW 0xFE
189D4  50E3     MOVF 0xFE3, W, ACCESS
189D6  A4D8     BTFSS 0xFD8, 2, ACCESS
189D8  D009     BRA 0x89EC
84:            		B_FRACTION.i = 0;
85:            		return b;
189DA  0E00     MOVLW 0x0
189DC  6E01     MOVWF __ptext283, ACCESS
189DE  0E00     MOVLW 0x0
189E0  6E02     MOVWF ___rparam_used, ACCESS
189E2  0E00     MOVLW 0x0
189E4  6E03     MOVWF __activetblptr, ACCESS
189E6  0E00     MOVLW 0x0
189E8  6E04     MOVWF __activetblptr, ACCESS
189EA  D192     BRA 0x8D10
86:            	}
87:            
88:            	/* Subtract denominator exponent, minus bias */
89:            	new_exp = bexp - aexp + 127;
189EC  0EFE     MOVLW 0xFE
189EE  50E3     MOVF 0xFE3, W, ACCESS
189F0  6E0B     MOVWF 0xB, ACCESS
189F2  6A0C     CLRF 0xC, ACCESS
189F4  0EFD     MOVLW 0xFD
189F6  50E3     MOVF 0xFE3, W, ACCESS
189F8  5E0B     SUBWF 0xB, F, ACCESS
189FA  0E00     MOVLW 0x0
189FC  5A0C     SUBWFB 0xC, F, ACCESS
189FE  0E7F     MOVLW 0x7F
18A00  260B     ADDWF 0xB, F, ACCESS
18A02  0E00     MOVLW 0x0
18A04  220C     ADDWFC 0xC, F, ACCESS
18A06  0EFB     MOVLW 0xFB
18A08  0061     MOVFFL wtemp5, PLUSW1
18A0A  F42C     NOP
18A0C  F4E3     NOP
18A0E  0EFC     MOVLW 0xFC
18A10  0061     MOVFFL 0x50C, PLUSW1
18A12  F430     NOP
18A14  F4E3     NOP
90:            
91:            	/* Divide loop */
92:            	rem = (uint32_t)B_FRACTION.i;
18A16  0EEF     MOVLW 0xEF
18A18  0061     MOVFFL PLUSW1, ltemp2
18A1A  F38C     NOP
18A1C  F509     NOP
18A1E  0EF0     MOVLW 0xF0
18A20  0061     MOVFFL PLUSW1, ttemp3
18A22  F38C     NOP
18A24  F50A     NOP
18A26  0EF1     MOVLW 0xF1
18A28  0061     MOVFFL PLUSW1, wtemp5
18A2A  F38C     NOP
18A2C  F50B     NOP
18A2E  0EF2     MOVLW 0xF2
18A30  0061     MOVFFL PLUSW1, 0x50C
18A32  F38C     NOP
18A34  F50C     NOP
18A36  0EF7     MOVLW 0xF7
18A38  0061     MOVFFL ltemp2, PLUSW1
18A3A  F424     NOP
18A3C  F4E3     NOP
18A3E  0EF8     MOVLW 0xF8
18A40  0061     MOVFFL ttemp3, PLUSW1
18A42  F428     NOP
18A44  F4E3     NOP
18A46  0EF9     MOVLW 0xF9
18A48  0061     MOVFFL wtemp5, PLUSW1
18A4A  F42C     NOP
18A4C  F4E3     NOP
18A4E  0EFA     MOVLW 0xFA
18A50  0061     MOVFFL 0x50C, PLUSW1
18A52  F430     NOP
18A54  F4E3     NOP
93:            	B_FRACTION.i = 0;
18A56  0EEF     MOVLW 0xEF
18A58  6AE3     CLRF 0xFE3, ACCESS
18A5A  0EF0     MOVLW 0xF0
18A5C  6AE3     CLRF 0xFE3, ACCESS
18A5E  0EF1     MOVLW 0xF1
18A60  6AE3     CLRF 0xFE3, ACCESS
18A62  0EF2     MOVLW 0xF2
18A64  6AE3     CLRF 0xFE3, ACCESS
94:            	grs = 0;
18A66  0EF3     MOVLW 0xF3
18A68  6AE3     CLRF 0xFE3, ACCESS
18A6A  0EF4     MOVLW 0xF4
18A6C  6AE3     CLRF 0xFE3, ACCESS
18A6E  0EF5     MOVLW 0xF5
18A70  6AE3     CLRF 0xFE3, ACCESS
18A72  0EF6     MOVLW 0xF6
18A74  6AE3     CLRF 0xFE3, ACCESS
95:            	// reuse aexp as the loop counter ...
96:            	aexp = 0;
18A76  0EFD     MOVLW 0xFD
18A78  6AE3     CLRF 0xFE3, ACCESS
97:            	while (aexp < 26) {
18A7A  D050     BRA 0x8B1C
18B1C  0EFD     MOVLW 0xFD
18B1E  0061     MOVFFL PLUSW1, ltemp0
18B20  F38C     NOP
18B22  F501     NOP
18B24  0E19     MOVLW 0x19
18B26  6401     CPFSGT __ptext283, ACCESS
18B28  D7A9     BRA 0x8A7C
98:            
99:            		/* Shift remainder, quotient left */
100:           		if (aexp) {
18A7C  0EFD     MOVLW 0xFD
18A7E  50E3     MOVF 0xFE3, W, ACCESS
18A80  B4D8     BTFSC 0xFD8, 2, ACCESS
18A82  D020     BRA 0x8AC4
101:           			rem <<= 1;
18A84  90D8     BCF 0xFD8, 0, ACCESS
18A86  0EF7     MOVLW 0xF7
18A88  36E3     RLCF 0xFE3, F, ACCESS
18A8A  0EF8     MOVLW 0xF8
18A8C  36E3     RLCF 0xFE3, F, ACCESS
18A8E  0EF9     MOVLW 0xF9
18A90  36E3     RLCF 0xFE3, F, ACCESS
18A92  0EFA     MOVLW 0xFA
18A94  36E3     RLCF 0xFE3, F, ACCESS
102:           			B_FRACTION.i <<= 1;
18A96  90D8     BCF 0xFD8, 0, ACCESS
18A98  0EEF     MOVLW 0xEF
18A9A  36E3     RLCF 0xFE3, F, ACCESS
18A9C  0EF0     MOVLW 0xF0
18A9E  36E3     RLCF 0xFE3, F, ACCESS
18AA0  0EF1     MOVLW 0xF1
18AA2  36E3     RLCF 0xFE3, F, ACCESS
18AA4  0EF2     MOVLW 0xF2
18AA6  36E3     RLCF 0xFE3, F, ACCESS
103:           			if (grs & 0x80000000) {
18AA8  0EF6     MOVLW 0xF6
18AAA  AEE3     BTFSS 0xFE3, 7, ACCESS
18AAC  D002     BRA 0x8AB2
104:           				B_FRACTION.i |= 0x1;
18AAE  0EEF     MOVLW 0xEF
18AB0  80E3     BSF 0xFE3, 0, ACCESS
105:           			}
106:           			grs <<= 1;
18AB2  90D8     BCF 0xFD8, 0, ACCESS
18AB4  0EF3     MOVLW 0xF3
18AB6  36E3     RLCF 0xFE3, F, ACCESS
18AB8  0EF4     MOVLW 0xF4
18ABA  36E3     RLCF 0xFE3, F, ACCESS
18ABC  0EF5     MOVLW 0xF5
18ABE  36E3     RLCF 0xFE3, F, ACCESS
18AC0  0EF6     MOVLW 0xF6
18AC2  36E3     RLCF 0xFE3, F, ACCESS
107:           		}
108:           
109:           		/* Restoring divide */
110:           
111:           		/* Remainder not less than divisor ? */
112:           		if (!(rem < A_FRACTION.i)) {
18AC4  50E1     MOVF 0xFE1, W, ACCESS
18AC6  0FF7     ADDLW 0xF7
18AC8  6ED9     MOVWF 0xFD9, ACCESS
18ACA  50E2     MOVF 0xFE2, W, ACCESS
18ACC  6EDA     MOVWF __end_of_UART2_tx_vect_isr, ACCESS
18ACE  0EFF     MOVLW 0xFF
18AD0  22DA     ADDWFC __end_of_UART2_tx_vect_isr, F, ACCESS
18AD2  0EEB     MOVLW 0xEB
18AD4  50E3     MOVF 0xFE3, W, ACCESS
18AD6  5CDE     SUBWF 0xFDE, W, ACCESS
18AD8  0EEC     MOVLW 0xEC
18ADA  50E3     MOVF 0xFE3, W, ACCESS
18ADC  58DE     SUBWFB 0xFDE, W, ACCESS
18ADE  0EED     MOVLW 0xED
18AE0  50E3     MOVF 0xFE3, W, ACCESS
18AE2  58DE     SUBWFB 0xFDE, W, ACCESS
18AE4  0EEE     MOVLW 0xEE
18AE6  50E3     MOVF 0xFE3, W, ACCESS
18AE8  58DE     SUBWFB 0xFDE, W, ACCESS
18AEA  A0D8     BTFSS 0xFD8, 0, ACCESS
18AEC  D015     BRA 0x8B18
113:           
114:           			/* Set quotient bit, subtract divisor */
115:           			grs |= 0x40000000;
18AEE  0EF6     MOVLW 0xF6
18AF0  8CE3     BSF 0xFE3, 6, ACCESS
116:           			rem -= (uint32_t)A_FRACTION.i;
18AF2  50E1     MOVF 0xFE1, W, ACCESS
18AF4  0FF7     ADDLW 0xF7
18AF6  6ED9     MOVWF 0xFD9, ACCESS
18AF8  50E2     MOVF 0xFE2, W, ACCESS
18AFA  6EDA     MOVWF __end_of_UART2_tx_vect_isr, ACCESS
18AFC  0EFF     MOVLW 0xFF
18AFE  22DA     ADDWFC __end_of_UART2_tx_vect_isr, F, ACCESS
18B00  0EEB     MOVLW 0xEB
18B02  50E3     MOVF 0xFE3, W, ACCESS
18B04  5EDE     SUBWF 0xFDE, F, ACCESS
18B06  0EEC     MOVLW 0xEC
18B08  50E3     MOVF 0xFE3, W, ACCESS
18B0A  5ADE     SUBWFB 0xFDE, F, ACCESS
18B0C  0EED     MOVLW 0xED
18B0E  50E3     MOVF 0xFE3, W, ACCESS
18B10  5ADE     SUBWFB 0xFDE, F, ACCESS
18B12  0EEE     MOVLW 0xEE
18B14  50E3     MOVF 0xFE3, W, ACCESS
18B16  5ADE     SUBWFB 0xFDE, F, ACCESS
117:           		}
118:           		++aexp;
18B18  0EFD     MOVLW 0xFD
18B1A  2AE3     INCF 0xFE3, F, ACCESS
119:           	}
120:           
121:           	/* Sticky bit is nonzero remainder */
122:           	if (rem) {
18B2A  0EF7     MOVLW 0xF7
18B2C  50E3     MOVF 0xFE3, W, ACCESS
18B2E  E10A     BNZ 0x8B44
18B30  0EF8     MOVLW 0xF8
18B32  50E3     MOVF 0xFE3, W, ACCESS
18B34  E107     BNZ 0x8B44
18B36  0EF9     MOVLW 0xF9
18B38  50E3     MOVF 0xFE3, W, ACCESS
18B3A  E104     BNZ 0x8B44
18B3C  0EFA     MOVLW 0xFA
18B3E  50E3     MOVF 0xFE3, W, ACCESS
18B40  B4D8     BTFSC 0xFD8, 2, ACCESS
18B42  D024     BRA 0x8B8C
123:           		grs |= 1;
18B44  0EF3     MOVLW 0xF3
18B46  80E3     BSF 0xFE3, 0, ACCESS
18B48  D021     BRA 0x8B8C
124:           	}
125:           
126:           	/* Renormalize */
127:           	while (!(B_FRACTION.i & ((int32_t) 1 << SPFRCB))) {
18B8C  0EF1     MOVLW 0xF1
18B8E  AEE3     BTFSS 0xFE3, 7, ACCESS
18B90  D7DC     BRA 0x8B4A
128:           		B_FRACTION.i <<= 1;
18B4A  90D8     BCF 0xFD8, 0, ACCESS
18B4C  0EEF     MOVLW 0xEF
18B4E  36E3     RLCF 0xFE3, F, ACCESS
18B50  0EF0     MOVLW 0xF0
18B52  36E3     RLCF 0xFE3, F, ACCESS
18B54  0EF1     MOVLW 0xF1
18B56  36E3     RLCF 0xFE3, F, ACCESS
18B58  0EF2     MOVLW 0xF2
18B5A  36E3     RLCF 0xFE3, F, ACCESS
129:           		if (grs & 0x80000000) {
18B5C  0EF6     MOVLW 0xF6
18B5E  AEE3     BTFSS 0xFE3, 7, ACCESS
18B60  D002     BRA 0x8B66
130:           			B_FRACTION.i |= 0x1;
18B62  0EEF     MOVLW 0xEF
18B64  80E3     BSF 0xFE3, 0, ACCESS
131:           		}
132:           		grs <<= 1;
18B66  90D8     BCF 0xFD8, 0, ACCESS
18B68  0EF3     MOVLW 0xF3
18B6A  36E3     RLCF 0xFE3, F, ACCESS
18B6C  0EF4     MOVLW 0xF4
18B6E  36E3     RLCF 0xFE3, F, ACCESS
18B70  0EF5     MOVLW 0xF5
18B72  36E3     RLCF 0xFE3, F, ACCESS
18B74  0EF6     MOVLW 0xF6
18B76  36E3     RLCF 0xFE3, F, ACCESS
133:           		--new_exp;
18B78  50E1     MOVF 0xFE1, W, ACCESS
18B7A  0FFB     ADDLW 0xFB
18B7C  6ED9     MOVWF 0xFD9, ACCESS
18B7E  50E2     MOVF 0xFE2, W, ACCESS
18B80  6EDA     MOVWF __end_of_UART2_tx_vect_isr, ACCESS
18B82  0EFF     MOVLW 0xFF
18B84  22DA     ADDWFC __end_of_UART2_tx_vect_isr, F, ACCESS
18B86  06DE     DECF 0xFDE, F, ACCESS
18B88  0E00     MOVLW 0x0
18B8A  5ADD     SUBWFB 0xFDD, F, ACCESS
134:           	}
135:           
136:           	/* Round result and check overflow, underflow */
137:           	/* Round */
138:           	// reuse aexp again as the round-up flag ...
139:           	aexp = 0;
18B92  0EFD     MOVLW 0xFD
18B94  6AE3     CLRF 0xFE3, ACCESS
140:           	if (grs & ((uint32_t) 1 << 31)) {
18B96  0EF6     MOVLW 0xF6
18B98  AEE3     BTFSS 0xFE3, 7, ACCESS
18B9A  D020     BRA 0x8BDC
141:           		if (grs & (((uint32_t) 1 << 31) - 1)) {
18B9C  50E1     MOVF 0xFE1, W, ACCESS
18B9E  0FF3     ADDLW 0xF3
18BA0  6ED9     MOVWF 0xFD9, ACCESS
18BA2  50E2     MOVF 0xFE2, W, ACCESS
18BA4  6EDA     MOVWF __end_of_UART2_tx_vect_isr, ACCESS
18BA6  0EFF     MOVLW 0xFF
18BA8  22DA     ADDWFC __end_of_UART2_tx_vect_isr, F, ACCESS
18BAA  0EFF     MOVLW 0xFF
18BAC  14DE     ANDWF 0xFDE, W, ACCESS
18BAE  6E09     MOVWF 0x9, ACCESS
18BB0  0EFF     MOVLW 0xFF
18BB2  14DE     ANDWF 0xFDE, W, ACCESS
18BB4  6E0A     MOVWF 0xA, ACCESS
18BB6  0EFF     MOVLW 0xFF
18BB8  14DE     ANDWF 0xFDE, W, ACCESS
18BBA  6E0B     MOVWF 0xB, ACCESS
18BBC  0E7F     MOVLW 0x7F
18BBE  14DE     ANDWF 0xFDE, W, ACCESS
18BC0  6E0C     MOVWF 0xC, ACCESS
18BC2  5009     MOVF 0x9, W, ACCESS
18BC4  100A     IORWF 0xA, W, ACCESS
18BC6  100B     IORWF 0xB, W, ACCESS
18BC8  100C     IORWF 0xC, W, ACCESS
18BCA  B4D8     BTFSC 0xFD8, 2, ACCESS
18BCC  D004     BRA 0x8BD6
142:           			aexp = 1;
18BCE  0EFD     MOVLW 0xFD
18BD0  6AE3     CLRF 0xFE3, ACCESS
18BD2  2AE3     INCF 0xFE3, F, ACCESS
143:           		}
18BD4  D003     BRA 0x8BDC
144:           		else {
145:           			if (B_FRACTION.i & 1) {
18BD6  0EEF     MOVLW 0xEF
18BD8  B0E3     BTFSC 0xFE3, 0, ACCESS
18BDA  D7F9     BRA 0x8BCE
146:           				aexp = 1;
147:           			}
148:           		}
149:           	}
150:           	if (aexp) {
18BDC  0EFD     MOVLW 0xFD
18BDE  50E3     MOVF 0xFE3, W, ACCESS
18BE0  B4D8     BTFSC 0xFD8, 2, ACCESS
18BE2  D036     BRA 0x8C50
151:           		++B_FRACTION.i;
18BE4  50E1     MOVF 0xFE1, W, ACCESS
18BE6  0FEF     ADDLW 0xEF
18BE8  6ED9     MOVWF 0xFD9, ACCESS
18BEA  50E2     MOVF 0xFE2, W, ACCESS
18BEC  6EDA     MOVWF __end_of_UART2_tx_vect_isr, ACCESS
18BEE  0EFF     MOVLW 0xFF
18BF0  22DA     ADDWFC __end_of_UART2_tx_vect_isr, F, ACCESS
18BF2  2ADE     INCF 0xFDE, F, ACCESS
18BF4  0E00     MOVLW 0x0
18BF6  22DE     ADDWFC 0xFDE, F, ACCESS
18BF8  22DE     ADDWFC 0xFDE, F, ACCESS
18BFA  22DE     ADDWFC 0xFDE, F, ACCESS
152:           		if (B_FRACTION.i & ((int32_t) 1 << (SPFRCB + 1))) {
18BFC  0EF2     MOVLW 0xF2
18BFE  A0E3     BTFSS 0xFE3, 0, ACCESS
18C00  D027     BRA 0x8C50
153:           			B_FRACTION.i = B_FRACTION.i >> 1;
18C02  0E01     MOVLW 0x1
18C04  6E0C     MOVWF 0xC, ACCESS
18C06  50E1     MOVF 0xFE1, W, ACCESS
18C08  0FEF     ADDLW 0xEF
18C0A  6ED9     MOVWF 0xFD9, ACCESS
18C0C  50E2     MOVF 0xFE2, W, ACCESS
18C0E  6EDA     MOVWF __end_of_UART2_tx_vect_isr, ACCESS
18C10  0EFF     MOVLW 0xFF
18C12  22DA     ADDWFC __end_of_UART2_tx_vect_isr, F, ACCESS
18C14  280C     INCF 0xC, W, ACCESS
18C16  52DE     MOVF 0xFDE, F, ACCESS
18C18  D008     BRA 0x8C2A
18C1A  52DE     MOVF 0xFDE, F, ACCESS
18C1C  90D8     BCF 0xFD8, 0, ACCESS
18C1E  BEDC     BTFSC _UART2_rx_vect_isr, 7, ACCESS
18C20  80D8     BSF 0xFD8, 0, ACCESS
18C22  32DD     RRCF 0xFDD, F, ACCESS
18C24  32DD     RRCF 0xFDD, F, ACCESS
18C26  32DD     RRCF 0xFDD, F, ACCESS
18C28  32DE     RRCF 0xFDE, F, ACCESS
18C2A  2EE8     DECFSZ 0xFE8, F, ACCESS
18C2C  D7F6     BRA 0x8C1A
154:           			++new_exp;
18C2E  0EFB     MOVLW 0xFB
18C30  50E3     MOVF 0xFE3, W, ACCESS
18C32  0F01     ADDLW 0x1
18C34  6E01     MOVWF __ptext283, ACCESS
18C36  0EFB     MOVLW 0xFB
18C38  0061     MOVFFL ltemp0, PLUSW1
18C3A  F404     NOP
18C3C  F4E3     NOP
18C3E  6A01     CLRF __ptext283, ACCESS
18C40  0EFC     MOVLW 0xFC
18C42  50E3     MOVF 0xFE3, W, ACCESS
18C44  2001     ADDWFC __ptext283, W, ACCESS
18C46  6E01     MOVWF __ptext283, ACCESS
18C48  0EFC     MOVLW 0xFC
18C4A  0061     MOVFFL ltemp0, PLUSW1
18C4C  F404     NOP
18C4E  F4E3     NOP
155:           		}
156:           	}
157:           
158:           	/* Overflow ? Return infinity */
159:           	if (!(new_exp < SPEXPM)) {
18C50  0EFC     MOVLW 0xFC
18C52  BEE3     BTFSC 0xFE3, 7, ACCESS
18C54  D01B     BRA 0x8C8C
18C56  0EFC     MOVLW 0xFC
18C58  50E3     MOVF 0xFE3, W, ACCESS
18C5A  E104     BNZ 0x8C64
18C5C  0EFB     MOVLW 0xFB
18C5E  28E3     INCF 0xFE3, W, ACCESS
18C60  A0D8     BTFSS 0xFD8, 0, ACCESS
18C62  D014     BRA 0x8C8C
160:           		new_exp = SPEXPM;
18C64  0EFF     MOVLW 0xFF
18C66  6E0B     MOVWF 0xB, ACCESS
18C68  0E00     MOVLW 0x0
18C6A  6E0C     MOVWF 0xC, ACCESS
18C6C  0EFB     MOVLW 0xFB
18C6E  0061     MOVFFL wtemp5, PLUSW1
18C70  F42C     NOP
18C72  F4E3     NOP
18C74  0EFC     MOVLW 0xFC
18C76  0061     MOVFFL 0x50C, PLUSW1
18C78  F430     NOP
18C7A  F4E3     NOP
161:           		B_FRACTION.i = 0;
18C7C  0EEF     MOVLW 0xEF
18C7E  6AE3     CLRF 0xFE3, ACCESS
18C80  0EF0     MOVLW 0xF0
18C82  6AE3     CLRF 0xFE3, ACCESS
18C84  0EF1     MOVLW 0xF1
18C86  6AE3     CLRF 0xFE3, ACCESS
18C88  0EF2     MOVLW 0xF2
18C8A  6AE3     CLRF 0xFE3, ACCESS
162:           	}
163:           
164:           	/* Underflow ? Flush to zero */
165:           	if (!(0 < new_exp)) {
18C8C  0EFC     MOVLW 0xFC
18C8E  BEE3     BTFSC 0xFE3, 7, ACCESS
18C90  D007     BRA 0x8CA0
18C92  0EFC     MOVLW 0xFC
18C94  50E3     MOVF 0xFE3, W, ACCESS
18C96  E112     BNZ 0x8CBC
18C98  0EFB     MOVLW 0xFB
18C9A  04E3     DECF 0xFE3, W, ACCESS
18C9C  B0D8     BTFSC 0xFD8, 0, ACCESS
18C9E  D00E     BRA 0x8CBC
166:           		new_exp = 0;
18CA0  0EFB     MOVLW 0xFB
18CA2  6AE3     CLRF 0xFE3, ACCESS
18CA4  0EFC     MOVLW 0xFC
18CA6  6AE3     CLRF 0xFE3, ACCESS
167:           		B_FRACTION.i = 0;
18CA8  0EEF     MOVLW 0xEF
18CAA  6AE3     CLRF 0xFE3, ACCESS
18CAC  0EF0     MOVLW 0xF0
18CAE  6AE3     CLRF 0xFE3, ACCESS
18CB0  0EF1     MOVLW 0xF1
18CB2  6AE3     CLRF 0xFE3, ACCESS
18CB4  0EF2     MOVLW 0xF2
18CB6  6AE3     CLRF 0xFE3, ACCESS
168:                           // no negative fp 0 for now
169:                           sign = 0;
18CB8  0EFF     MOVLW 0xFF
18CBA  6AE3     CLRF 0xFE3, ACCESS
170:           	}
171:           
172:           	/* Pack and return result */
173:           	bexp = (unsigned char)new_exp;
18CBC  0EFB     MOVLW 0xFB
18CBE  0061     MOVFFL PLUSW1, ltemp0
18CC0  F38C     NOP
18CC2  F501     NOP
18CC4  0EFE     MOVLW 0xFE
18CC6  0061     MOVFFL ltemp0, PLUSW1
18CC8  F404     NOP
18CCA  F4E3     NOP
174:           	// set the low bit of the exponent ...
175:           	if (bexp & 0x1) {
18CCC  0EFE     MOVLW 0xFE
18CCE  A0E3     BTFSS 0xFE3, 0, ACCESS
18CD0  D009     BRA 0x8CE4
176:           		B_FRACTION.fAsBytes.c |= 0x80;
18CD2  0EF1     MOVLW 0xF1
18CD4  24E1     ADDWF 0xFE1, W, ACCESS
18CD6  6ED9     MOVWF 0xFD9, ACCESS
18CD8  0EFF     MOVLW 0xFF
18CDA  20E2     ADDWFC 0xFE2, W, ACCESS
18CDC  6EDA     MOVWF __end_of_UART2_tx_vect_isr, ACCESS
18CDE  0E00     MOVLW 0x0
18CE0  8EDB     BSF __end_of_UART2_tx_vect_isr, 7, ACCESS
177:           	}
18CE2  D008     BRA 0x8CF4
178:           	// AND out the leading 1
179:           	else {
180:           		B_FRACTION.fAsBytes.c &= 0x7F;
18CE4  0EF1     MOVLW 0xF1
18CE6  24E1     ADDWF 0xFE1, W, ACCESS
18CE8  6ED9     MOVWF 0xFD9, ACCESS
18CEA  0EFF     MOVLW 0xFF
18CEC  20E2     ADDWFC 0xFE2, W, ACCESS
18CEE  6EDA     MOVWF __end_of_UART2_tx_vect_isr, ACCESS
18CF0  0E7F     MOVLW 0x7F
18CF2  16DF     ANDWF 0xFDF, F, ACCESS
181:           	}
182:           	B_FRACTION.fAsBytes.d = bexp >> 1;
18CF4  0EF2     MOVLW 0xF2
18CF6  24E1     ADDWF 0xFE1, W, ACCESS
18CF8  6ED9     MOVWF 0xFD9, ACCESS
18CFA  0EFF     MOVLW 0xFF
18CFC  20E2     ADDWFC 0xFE2, W, ACCESS
18CFE  6EDA     MOVWF __end_of_UART2_tx_vect_isr, ACCESS
18D00  0EFE     MOVLW 0xFE
18D02  0061     MOVFFL PLUSW1, 0x50C
18D04  F38C     NOP
18D06  F50C     NOP
18D08  90D8     BCF 0xFD8, 0, ACCESS
18D0A  300C     RRCF 0xC, W, ACCESS
18D0C  6EDF     MOVWF 0xFDF, ACCESS
18D0E  D644     BRA 0x8998
183:           	B_FRACTION.fAsBytes.d |= sign;
184:           	return b;
185:           }
18D10  0EEB     MOVLW 0xEB
18D12  26E1     ADDWF 0xFE1, F, ACCESS
18D14  0EFF     MOVLW 0xFF
18D16  22E2     ADDWFC 0xFE2, F, ACCESS
18D16  22E2     ADDWFC 0xFE2, F, ACCESS
186:           
---  /opt/microchip/xc8/v2.41/pic/sources/c99/common/sprcadd.c  -----------------------------------------
1:             /* SP relaxed compliance floating point add intrinsic function */
2:             #include <stdint.h>
3:             #include "fpform.h"
4:             
5:             
6:             // single monlithic add function
7:             
8:             /* SP Add */
9:             SP
10:            SPADD(SP b, SP a) {
17860  52E6     MOVF 0xFE6, F, ACCESS
17862  52E6     MOVF 0xFE6, F, ACCESS
17864  52E6     MOVF 0xFE6, F, ACCESS
17866  52E6     MOVF 0xFE6, F, ACCESS
11:            #define A_FRACTION    (*(SFP *)&a)
12:            #define B_FRACTION    (*(SFP *)&b)
13:            	unsigned char signs;	/* leftmost bit stores sign of b, next bit stores
14:            				   0 if and only if a and b have the same sign  */
15:            	unsigned char bexp;	/* Dst exponent */
16:            	unsigned char aexp;	/* Src exponent */
17:            	unsigned char grs;	/* Guard, round, sticky */
18:            
19:            
20:            	/* Unpack and check operands */
21:            	signs = B_FRACTION.fAsBytes.d & 0x80;
17868  0EFB     MOVLW 0xFB
1786A  24E1     ADDWF 0xFE1, W, ACCESS
1786C  6ED9     MOVWF 0xFD9, ACCESS
1786E  0EFF     MOVLW 0xFF
17870  20E2     ADDWFC 0xFE2, W, ACCESS
17872  6EDA     MOVWF __end_of_UART2_tx_vect_isr, ACCESS
17874  50DF     MOVF 0xFDF, W, ACCESS
17876  6E0C     MOVWF 0xC, ACCESS
17878  0E80     MOVLW 0x80
1787A  160C     ANDWF 0xC, F, ACCESS
1787C  0EFF     MOVLW 0xFF
1787E  0061     MOVFFL 0x50C, PLUSW1
17880  F430     NOP
17882  F4E3     NOP
22:            	bexp = (unsigned char)(B_FRACTION.fAsBytes.d << 1);
17884  0EFB     MOVLW 0xFB
17886  24E1     ADDWF 0xFE1, W, ACCESS
17888  6ED9     MOVWF 0xFD9, ACCESS
1788A  0EFF     MOVLW 0xFF
1788C  20E2     ADDWFC 0xFE2, W, ACCESS
1788E  6EDA     MOVWF __end_of_UART2_tx_vect_isr, ACCESS
17890  50DF     MOVF 0xFDF, W, ACCESS
17892  6E0C     MOVWF 0xC, ACCESS
17894  90D8     BCF 0xFD8, 0, ACCESS
17896  340C     RLCF 0xC, W, ACCESS
17898  6E0B     MOVWF 0xB, ACCESS
1789A  0EFD     MOVLW 0xFD
1789C  0061     MOVFFL wtemp5, PLUSW1
1789E  F42C     NOP
178A0  F4E3     NOP
23:            	if (B_FRACTION.fAsBytes.c & 0x80) {
178A2  0EFA     MOVLW 0xFA
178A4  24E1     ADDWF 0xFE1, W, ACCESS
178A6  6ED9     MOVWF 0xFD9, ACCESS
178A8  0EFF     MOVLW 0xFF
178AA  20E2     ADDWFC 0xFE2, W, ACCESS
178AC  6EDA     MOVWF __end_of_UART2_tx_vect_isr, ACCESS
178AE  AEDF     BTFSS 0xFDF, 7, ACCESS
178B0  D002     BRA 0x78B6
24:            		bexp |= 0x1;
178B2  0EFD     MOVLW 0xFD
178B4  80E3     BSF 0xFE3, 0, ACCESS
25:            	}
26:            
27:            	/* Destination normal ? */
28:            	if (bexp) {
178B6  0EFD     MOVLW 0xFD
178B8  50E3     MOVF 0xFE3, W, ACCESS
178BA  B4D8     BTFSC 0xFD8, 2, ACCESS
178BC  D026     BRA 0x790A
29:            		/* Destination inf or NaN ? */
30:            		if (bexp == 0xFF) {
178BE  0EFD     MOVLW 0xFD
178C0  28E3     INCF 0xFE3, W, ACCESS
178C2  A4D8     BTFSS 0xFD8, 2, ACCESS
178C4  D018     BRA 0x78F6
31:            			/* Make it inf */
32:            			b = 0;
178C6  0E00     MOVLW 0x0
178C8  6E09     MOVWF 0x9, ACCESS
178CA  0E00     MOVLW 0x0
178CC  6E0A     MOVWF 0xA, ACCESS
178CE  0E00     MOVLW 0x0
178D0  6E0B     MOVWF 0xB, ACCESS
178D2  0E00     MOVLW 0x0
178D4  6E0C     MOVWF 0xC, ACCESS
178D6  0EF8     MOVLW 0xF8
178D8  0061     MOVFFL ltemp2, PLUSW1
178DA  F424     NOP
178DC  F4E3     NOP
178DE  0EF9     MOVLW 0xF9
178E0  0061     MOVFFL ttemp3, PLUSW1
178E2  F428     NOP
178E4  F4E3     NOP
178E6  0EFA     MOVLW 0xFA
178E8  0061     MOVFFL wtemp5, PLUSW1
178EA  F42C     NOP
178EC  F4E3     NOP
178EE  0EFB     MOVLW 0xFB
178F0  0061     MOVFFL 0x50C, PLUSW1
178F2  F430     NOP
178F4  F4E3     NOP
33:            		}
34:            		// OR in the hidden 1-bit to b's fraction
35:            		B_FRACTION.i |= (int32_t) 1 << SPFRCB;
178F6  0EFA     MOVLW 0xFA
178F8  8EE3     BSF 0xFE3, 7, ACCESS
36:            		// and zero out the upper byte so we can safely shift
37:            		B_FRACTION.fAsBytes.d = 0;
178FA  0EFB     MOVLW 0xFB
178FC  24E1     ADDWF 0xFE1, W, ACCESS
178FE  6ED9     MOVWF 0xFD9, ACCESS
17900  0EFF     MOVLW 0xFF
17902  20E2     ADDWFC 0xFE2, W, ACCESS
17904  6EDA     MOVWF __end_of_UART2_tx_vect_isr, ACCESS
17906  6ADF     CLRF 0xFDF, ACCESS
38:            	}
17908  D018     BRA 0x793A
39:            	else {
40:            		/* Make it zero */
41:            		b = 0;
1790A  0E00     MOVLW 0x0
1790C  6E09     MOVWF 0x9, ACCESS
1790E  0E00     MOVLW 0x0
17910  6E0A     MOVWF 0xA, ACCESS
17912  0E00     MOVLW 0x0
17914  6E0B     MOVWF 0xB, ACCESS
17916  0E00     MOVLW 0x0
17918  6E0C     MOVWF 0xC, ACCESS
1791A  0EF8     MOVLW 0xF8
1791C  0061     MOVFFL ltemp2, PLUSW1
1791E  F424     NOP
17920  F4E3     NOP
17922  0EF9     MOVLW 0xF9
17924  0061     MOVFFL ttemp3, PLUSW1
17926  F428     NOP
17928  F4E3     NOP
1792A  0EFA     MOVLW 0xFA
1792C  0061     MOVFFL wtemp5, PLUSW1
1792E  F42C     NOP
17930  F4E3     NOP
17932  0EFB     MOVLW 0xFB
17934  0061     MOVFFL 0x50C, PLUSW1
17936  F430     NOP
17938  F4E3     NOP
42:            	}
43:            
44:            	aexp = A_FRACTION.fAsBytes.d & 0x80;
1793A  0EF7     MOVLW 0xF7
1793C  24E1     ADDWF 0xFE1, W, ACCESS
1793E  6ED9     MOVWF 0xFD9, ACCESS
17940  0EFF     MOVLW 0xFF
17942  20E2     ADDWFC 0xFE2, W, ACCESS
17944  6EDA     MOVWF __end_of_UART2_tx_vect_isr, ACCESS
17946  50DF     MOVF 0xFDF, W, ACCESS
17948  6E0C     MOVWF 0xC, ACCESS
1794A  0E80     MOVLW 0x80
1794C  160C     ANDWF 0xC, F, ACCESS
1794E  0EFE     MOVLW 0xFE
17950  0061     MOVFFL 0x50C, PLUSW1
17952  F430     NOP
17954  F4E3     NOP
45:            	// sign of a different from sign of b?
46:            	if (aexp != signs) {
17956  50E1     MOVF 0xFE1, W, ACCESS
17958  0FFE     ADDLW 0xFE
1795A  6ED9     MOVWF 0xFD9, ACCESS
1795C  50E2     MOVF 0xFE2, W, ACCESS
1795E  6EDA     MOVWF __end_of_UART2_tx_vect_isr, ACCESS
17960  0EFF     MOVLW 0xFF
17962  22DA     ADDWFC __end_of_UART2_tx_vect_isr, F, ACCESS
17964  0EFF     MOVLW 0xFF
17966  50E3     MOVF 0xFE3, W, ACCESS
17968  18DE     XORWF 0xFDE, W, ACCESS
1796A  B4D8     BTFSC 0xFD8, 2, ACCESS
1796C  D002     BRA 0x7972
47:            		signs |= 0x40;
1796E  0EFF     MOVLW 0xFF
17970  8CE3     BSF 0xFE3, 6, ACCESS
48:            	}
49:            	aexp = (unsigned char)(A_FRACTION.fAsBytes.d << 1);
17972  0EF7     MOVLW 0xF7
17974  24E1     ADDWF 0xFE1, W, ACCESS
17976  6ED9     MOVWF 0xFD9, ACCESS
17978  0EFF     MOVLW 0xFF
1797A  20E2     ADDWFC 0xFE2, W, ACCESS
1797C  6EDA     MOVWF __end_of_UART2_tx_vect_isr, ACCESS
1797E  50DF     MOVF 0xFDF, W, ACCESS
17980  6E0C     MOVWF 0xC, ACCESS
17982  90D8     BCF 0xFD8, 0, ACCESS
17984  340C     RLCF 0xC, W, ACCESS
17986  6E0B     MOVWF 0xB, ACCESS
17988  0EFE     MOVLW 0xFE
1798A  0061     MOVFFL wtemp5, PLUSW1
1798C  F42C     NOP
1798E  F4E3     NOP
50:            	if (A_FRACTION.fAsBytes.c & 0x80) {
17990  0EF6     MOVLW 0xF6
17992  24E1     ADDWF 0xFE1, W, ACCESS
17994  6ED9     MOVWF 0xFD9, ACCESS
17996  0EFF     MOVLW 0xFF
17998  20E2     ADDWFC 0xFE2, W, ACCESS
1799A  6EDA     MOVWF __end_of_UART2_tx_vect_isr, ACCESS
1799C  AEDF     BTFSS 0xFDF, 7, ACCESS
1799E  D002     BRA 0x79A4
51:            		aexp |= 0x1;
179A0  0EFE     MOVLW 0xFE
179A2  80E3     BSF 0xFE3, 0, ACCESS
52:            	}
53:            
54:            	/* Destination normal ? */
55:            	if (aexp) {
179A4  0EFE     MOVLW 0xFE
179A6  50E3     MOVF 0xFE3, W, ACCESS
179A8  B4D8     BTFSC 0xFD8, 2, ACCESS
179AA  D026     BRA 0x79F8
56:            		/* Destination inf or NaN ? */
57:            		if (aexp == 0xFF) {
179AC  0EFE     MOVLW 0xFE
179AE  28E3     INCF 0xFE3, W, ACCESS
179B0  A4D8     BTFSS 0xFD8, 2, ACCESS
179B2  D018     BRA 0x79E4
58:            			/* Make it inf */
59:            			a = 0;
179B4  0E00     MOVLW 0x0
179B6  6E09     MOVWF 0x9, ACCESS
179B8  0E00     MOVLW 0x0
179BA  6E0A     MOVWF 0xA, ACCESS
179BC  0E00     MOVLW 0x0
179BE  6E0B     MOVWF 0xB, ACCESS
179C0  0E00     MOVLW 0x0
179C2  6E0C     MOVWF 0xC, ACCESS
179C4  0EF4     MOVLW 0xF4
179C6  0061     MOVFFL ltemp2, PLUSW1
179C8  F424     NOP
179CA  F4E3     NOP
179CC  0EF5     MOVLW 0xF5
179CE  0061     MOVFFL ttemp3, PLUSW1
179D0  F428     NOP
179D2  F4E3     NOP
179D4  0EF6     MOVLW 0xF6
179D6  0061     MOVFFL wtemp5, PLUSW1
179D8  F42C     NOP
179DA  F4E3     NOP
179DC  0EF7     MOVLW 0xF7
179DE  0061     MOVFFL 0x50C, PLUSW1
179E0  F430     NOP
179E2  F4E3     NOP
60:            		}
61:            		// OR in the hidden 1-bit to a's fraction
62:            		A_FRACTION.i |= (int32_t) 1 << SPFRCB;
179E4  0EF6     MOVLW 0xF6
179E6  8EE3     BSF 0xFE3, 7, ACCESS
63:            		// and zero out the upper bits so we can safely shift
64:            		A_FRACTION.fAsBytes.d = 0;
179E8  0EF7     MOVLW 0xF7
179EA  24E1     ADDWF 0xFE1, W, ACCESS
179EC  6ED9     MOVWF 0xFD9, ACCESS
179EE  0EFF     MOVLW 0xFF
179F0  20E2     ADDWFC 0xFE2, W, ACCESS
179F2  6EDA     MOVWF __end_of_UART2_tx_vect_isr, ACCESS
179F4  6ADF     CLRF 0xFDF, ACCESS
65:            	}
179F6  D018     BRA 0x7A28
66:            	else {
67:            		/* Make it zero */
68:            		a = 0;
179F8  0E00     MOVLW 0x0
179FA  6E09     MOVWF 0x9, ACCESS
179FC  0E00     MOVLW 0x0
179FE  6E0A     MOVWF 0xA, ACCESS
17A00  0E00     MOVLW 0x0
17A02  6E0B     MOVWF 0xB, ACCESS
17A04  0E00     MOVLW 0x0
17A06  6E0C     MOVWF 0xC, ACCESS
17A08  0EF4     MOVLW 0xF4
17A0A  0061     MOVFFL ltemp2, PLUSW1
17A0C  F424     NOP
17A0E  F4E3     NOP
17A10  0EF5     MOVLW 0xF5
17A12  0061     MOVFFL ttemp3, PLUSW1
17A14  F428     NOP
17A16  F4E3     NOP
17A18  0EF6     MOVLW 0xF6
17A1A  0061     MOVFFL wtemp5, PLUSW1
17A1C  F42C     NOP
17A1E  F4E3     NOP
17A20  0EF7     MOVLW 0xF7
17A22  0061     MOVFFL 0x50C, PLUSW1
17A24  F430     NOP
17A26  F4E3     NOP
69:            	}
70:            
71:            	/* Add */
72:            
73:            	/* Get smaller operand in b */
74:            
75:            	if (aexp < bexp) {
17A28  50E1     MOVF 0xFE1, W, ACCESS
17A2A  0FFE     ADDLW 0xFE
17A2C  6ED9     MOVWF 0xFD9, ACCESS
17A2E  50E2     MOVF 0xFE2, W, ACCESS
17A30  6EDA     MOVWF __end_of_UART2_tx_vect_isr, ACCESS
17A32  0EFF     MOVLW 0xFF
17A34  22DA     ADDWFC __end_of_UART2_tx_vect_isr, F, ACCESS
17A36  0EFD     MOVLW 0xFD
17A38  50E3     MOVF 0xFE3, W, ACCESS
17A3A  5CDE     SUBWF 0xFDE, W, ACCESS
17A3C  B0D8     BTFSC 0xFD8, 0, ACCESS
17A3E  D09E     BRA 0x7B7C
76:            		// do I need to reverse the sign?
77:            		if (signs & 0x40) {
17A40  0EFF     MOVLW 0xFF
17A42  ACE3     BTFSS 0xFE3, 6, ACCESS
17A44  D002     BRA 0x7A4A
78:            			signs ^= 0x80;
17A46  0EFF     MOVLW 0xFF
17A48  7EE3     BTG 0xFE3, 7, ACCESS
79:            		}
80:            		// use  grs as swap space
81:            		grs = bexp;
17A4A  0EFD     MOVLW 0xFD
17A4C  0061     MOVFFL PLUSW1, ltemp0
17A4E  F38C     NOP
17A50  F501     NOP
17A52  0EFC     MOVLW 0xFC
17A54  0061     MOVFFL ltemp0, PLUSW1
17A56  F404     NOP
17A58  F4E3     NOP
82:            		bexp = aexp;
17A5A  0EFE     MOVLW 0xFE
17A5C  0061     MOVFFL PLUSW1, ltemp0
17A5E  F38C     NOP
17A60  F501     NOP
17A62  0EFD     MOVLW 0xFD
17A64  0061     MOVFFL ltemp0, PLUSW1
17A66  F404     NOP
17A68  F4E3     NOP
83:            		aexp = grs;
17A6A  0EFC     MOVLW 0xFC
17A6C  0061     MOVFFL PLUSW1, ltemp0
17A6E  F38C     NOP
17A70  F501     NOP
17A72  0EFE     MOVLW 0xFE
17A74  0061     MOVFFL ltemp0, PLUSW1
17A76  F404     NOP
17A78  F4E3     NOP
84:            		grs = B_FRACTION.fAsBytes.a;
17A7A  0EF8     MOVLW 0xF8
17A7C  0061     MOVFFL PLUSW1, ltemp0
17A7E  F38C     NOP
17A80  F501     NOP
17A82  0EFC     MOVLW 0xFC
17A84  0061     MOVFFL ltemp0, PLUSW1
17A86  F404     NOP
17A88  F4E3     NOP
85:            		B_FRACTION.fAsBytes.a = A_FRACTION.fAsBytes.a;
17A8A  0EF4     MOVLW 0xF4
17A8C  0061     MOVFFL PLUSW1, ltemp0
17A8E  F38C     NOP
17A90  F501     NOP
17A92  0EF8     MOVLW 0xF8
17A94  0061     MOVFFL ltemp0, PLUSW1
17A96  F404     NOP
17A98  F4E3     NOP
86:            		A_FRACTION.fAsBytes.a = grs;
17A9A  0EFC     MOVLW 0xFC
17A9C  0061     MOVFFL PLUSW1, ltemp0
17A9E  F38C     NOP
17AA0  F501     NOP
17AA2  0EF4     MOVLW 0xF4
17AA4  0061     MOVFFL ltemp0, PLUSW1
17AA6  F404     NOP
17AA8  F4E3     NOP
87:            		grs = B_FRACTION.fAsBytes.b;
17AAA  0EF9     MOVLW 0xF9
17AAC  24E1     ADDWF 0xFE1, W, ACCESS
17AAE  6ED9     MOVWF 0xFD9, ACCESS
17AB0  0EFF     MOVLW 0xFF
17AB2  20E2     ADDWFC 0xFE2, W, ACCESS
17AB4  6EDA     MOVWF __end_of_UART2_tx_vect_isr, ACCESS
17AB6  50DF     MOVF 0xFDF, W, ACCESS
17AB8  6E0C     MOVWF 0xC, ACCESS
17ABA  0EFC     MOVLW 0xFC
17ABC  0061     MOVFFL 0x50C, PLUSW1
17ABE  F430     NOP
17AC0  F4E3     NOP
88:            		B_FRACTION.fAsBytes.b = A_FRACTION.fAsBytes.b;
17AC2  0EF5     MOVLW 0xF5
17AC4  24E1     ADDWF 0xFE1, W, ACCESS
17AC6  6ED9     MOVWF 0xFD9, ACCESS
17AC8  0EFF     MOVLW 0xFF
17ACA  20E2     ADDWFC 0xFE2, W, ACCESS
17ACC  6EDA     MOVWF __end_of_UART2_tx_vect_isr, ACCESS
17ACE  0EF9     MOVLW 0xF9
17AD0  24E1     ADDWF 0xFE1, W, ACCESS
17AD2  6EE9     MOVWF 0xFE9, ACCESS
17AD4  0EFF     MOVLW 0xFF
17AD6  20E2     ADDWFC 0xFE2, W, ACCESS
17AD8  6EEA     MOVWF 0xFEA, ACCESS
17ADA  C4DF     MOVFF INDF2, INDF0
17ADC  F4EF     NOP
89:            		A_FRACTION.fAsBytes.b = grs;
17ADE  0EF5     MOVLW 0xF5
17AE0  24E1     ADDWF 0xFE1, W, ACCESS
17AE2  6ED9     MOVWF 0xFD9, ACCESS
17AE4  0EFF     MOVLW 0xFF
17AE6  20E2     ADDWFC 0xFE2, W, ACCESS
17AE8  6EDA     MOVWF __end_of_UART2_tx_vect_isr, ACCESS
17AEA  0EFC     MOVLW 0xFC
17AEC  C4E3     MOVFF PLUSW1, INDF2
17AEE  F4DF     NOP
90:            		grs = B_FRACTION.fAsBytes.c;
17AF0  0EFA     MOVLW 0xFA
17AF2  24E1     ADDWF 0xFE1, W, ACCESS
17AF4  6ED9     MOVWF 0xFD9, ACCESS
17AF6  0EFF     MOVLW 0xFF
17AF8  20E2     ADDWFC 0xFE2, W, ACCESS
17AFA  6EDA     MOVWF __end_of_UART2_tx_vect_isr, ACCESS
17AFC  50DF     MOVF 0xFDF, W, ACCESS
17AFE  6E0C     MOVWF 0xC, ACCESS
17B00  0EFC     MOVLW 0xFC
17B02  0061     MOVFFL 0x50C, PLUSW1
17B04  F430     NOP
17B06  F4E3     NOP
91:            		B_FRACTION.fAsBytes.c = A_FRACTION.fAsBytes.c;
17B08  0EF6     MOVLW 0xF6
17B0A  24E1     ADDWF 0xFE1, W, ACCESS
17B0C  6ED9     MOVWF 0xFD9, ACCESS
17B0E  0EFF     MOVLW 0xFF
17B10  20E2     ADDWFC 0xFE2, W, ACCESS
17B12  6EDA     MOVWF __end_of_UART2_tx_vect_isr, ACCESS
17B14  0EFA     MOVLW 0xFA
17B16  24E1     ADDWF 0xFE1, W, ACCESS
17B18  6EE9     MOVWF 0xFE9, ACCESS
17B1A  0EFF     MOVLW 0xFF
17B1C  20E2     ADDWFC 0xFE2, W, ACCESS
17B1E  6EEA     MOVWF 0xFEA, ACCESS
17B20  C4DF     MOVFF INDF2, INDF0
17B22  F4EF     NOP
92:            		A_FRACTION.fAsBytes.c = grs;
17B24  0EF6     MOVLW 0xF6
17B26  24E1     ADDWF 0xFE1, W, ACCESS
17B28  6ED9     MOVWF 0xFD9, ACCESS
17B2A  0EFF     MOVLW 0xFF
17B2C  20E2     ADDWFC 0xFE2, W, ACCESS
17B2E  6EDA     MOVWF __end_of_UART2_tx_vect_isr, ACCESS
17B30  0EFC     MOVLW 0xFC
17B32  C4E3     MOVFF PLUSW1, INDF2
17B34  F4DF     NOP
93:            		grs = B_FRACTION.fAsBytes.d;
17B36  0EFB     MOVLW 0xFB
17B38  24E1     ADDWF 0xFE1, W, ACCESS
17B3A  6ED9     MOVWF 0xFD9, ACCESS
17B3C  0EFF     MOVLW 0xFF
17B3E  20E2     ADDWFC 0xFE2, W, ACCESS
17B40  6EDA     MOVWF __end_of_UART2_tx_vect_isr, ACCESS
17B42  50DF     MOVF 0xFDF, W, ACCESS
17B44  6E0C     MOVWF 0xC, ACCESS
17B46  0EFC     MOVLW 0xFC
17B48  0061     MOVFFL 0x50C, PLUSW1
17B4A  F430     NOP
17B4C  F4E3     NOP
94:            		B_FRACTION.fAsBytes.d = A_FRACTION.fAsBytes.d;
17B4E  0EF7     MOVLW 0xF7
17B50  24E1     ADDWF 0xFE1, W, ACCESS
17B52  6ED9     MOVWF 0xFD9, ACCESS
17B54  0EFF     MOVLW 0xFF
17B56  20E2     ADDWFC 0xFE2, W, ACCESS
17B58  6EDA     MOVWF __end_of_UART2_tx_vect_isr, ACCESS
17B5A  0EFB     MOVLW 0xFB
17B5C  24E1     ADDWF 0xFE1, W, ACCESS
17B5E  6EE9     MOVWF 0xFE9, ACCESS
17B60  0EFF     MOVLW 0xFF
17B62  20E2     ADDWFC 0xFE2, W, ACCESS
17B64  6EEA     MOVWF 0xFEA, ACCESS
17B66  C4DF     MOVFF INDF2, INDF0
17B68  F4EF     NOP
95:            		A_FRACTION.fAsBytes.d = grs;
17B6A  0EF7     MOVLW 0xF7
17B6C  24E1     ADDWF 0xFE1, W, ACCESS
17B6E  6ED9     MOVWF 0xFD9, ACCESS
17B70  0EFF     MOVLW 0xFF
17B72  20E2     ADDWFC 0xFE2, W, ACCESS
17B74  6EDA     MOVWF __end_of_UART2_tx_vect_isr, ACCESS
17B76  0EFC     MOVLW 0xFC
17B78  C4E3     MOVFF PLUSW1, INDF2
17B7A  F4DF     NOP
96:            	}
97:            
98:            	grs = 0;
17B7C  0EFC     MOVLW 0xFC
17B7E  6AE3     CLRF 0xFE3, ACCESS
99:            	/* If all ones will shift through G,R, then S = significand nonzero */
100:           	if ((aexp - bexp) > (SPFRCB + 2)) {
17B80  0EFE     MOVLW 0xFE
17B82  50E3     MOVF 0xFE3, W, ACCESS
17B84  6E0B     MOVWF 0xB, ACCESS
17B86  6A0C     CLRF 0xC, ACCESS
17B88  0EFD     MOVLW 0xFD
17B8A  50E3     MOVF 0xFE3, W, ACCESS
17B8C  5E0B     SUBWF 0xB, F, ACCESS
17B8E  0E00     MOVLW 0x0
17B90  5A0C     SUBWFB 0xC, F, ACCESS
17B92  BE0C     BTFSC 0xC, 7, ACCESS
17B94  D062     BRA 0x7C5A
17B96  500C     MOVF 0xC, W, ACCESS
17B98  E104     BNZ 0x7BA2
17B9A  0E1A     MOVLW 0x1A
17B9C  5C0B     SUBWF 0xB, W, ACCESS
17B9E  A0D8     BTFSS 0xFD8, 0, ACCESS
17BA0  D05C     BRA 0x7C5A
101:           		grs = B_FRACTION.i ? 1 : 0;
17BA2  0EF8     MOVLW 0xF8
17BA4  50E3     MOVF 0xFE3, W, ACCESS
17BA6  E10A     BNZ 0x7BBC
17BA8  0EF9     MOVLW 0xF9
17BAA  50E3     MOVF 0xFE3, W, ACCESS
17BAC  E107     BNZ 0x7BBC
17BAE  0EFA     MOVLW 0xFA
17BB0  50E3     MOVF 0xFE3, W, ACCESS
17BB2  E104     BNZ 0x7BBC
17BB4  0EFB     MOVLW 0xFB
17BB6  50E3     MOVF 0xFE3, W, ACCESS
17BB8  B4D8     BTFSC 0xFD8, 2, ACCESS
17BBA  D003     BRA 0x7BC2
17BBC  6A0C     CLRF 0xC, ACCESS
17BBE  2A0C     INCF 0xC, F, ACCESS
17BC0  D001     BRA 0x7BC4
17BC2  6A0C     CLRF 0xC, ACCESS
17BC4  0EFC     MOVLW 0xFC
17BC6  0061     MOVFFL 0x50C, PLUSW1
17BC8  F430     NOP
17BCA  F4E3     NOP
102:           		B_FRACTION.i = 0;
17BCC  0EF8     MOVLW 0xF8
17BCE  6AE3     CLRF 0xFE3, ACCESS
17BD0  0EF9     MOVLW 0xF9
17BD2  6AE3     CLRF 0xFE3, ACCESS
17BD4  0EFA     MOVLW 0xFA
17BD6  6AE3     CLRF 0xFE3, ACCESS
17BD8  0EFB     MOVLW 0xFB
17BDA  6AE3     CLRF 0xFE3, ACCESS
103:           		bexp = aexp;
17BDC  0EFE     MOVLW 0xFE
17BDE  0061     MOVFFL PLUSW1, ltemp0
17BE0  F38C     NOP
17BE2  F501     NOP
17BE4  0EFD     MOVLW 0xFD
17BE6  0061     MOVFFL ltemp0, PLUSW1
17BE8  F404     NOP
17BEA  F4E3     NOP
104:           	}
17BEC  D042     BRA 0x7C72
105:           	else {
106:           		while (bexp < aexp) {
17C5A  50E1     MOVF 0xFE1, W, ACCESS
17C5C  0FFD     ADDLW 0xFD
17C5E  6ED9     MOVWF 0xFD9, ACCESS
17C60  50E2     MOVF 0xFE2, W, ACCESS
17C62  6EDA     MOVWF __end_of_UART2_tx_vect_isr, ACCESS
17C64  0EFF     MOVLW 0xFF
17C66  22DA     ADDWFC __end_of_UART2_tx_vect_isr, F, ACCESS
17C68  0EFE     MOVLW 0xFE
17C6A  50E3     MOVF 0xFE3, W, ACCESS
17C6C  5CDE     SUBWF 0xFDE, W, ACCESS
17C6E  A0D8     BTFSS 0xFD8, 0, ACCESS
17C70  D7BE     BRA 0x7BEE
107:           			/* Shift smaller operand right until exponents equal */
108:           			/* save the bits shifted out in grs    */
109:           			if (grs & 1) {
17BEE  0EFC     MOVLW 0xFC
17BF0  A0E3     BTFSS 0xFE3, 0, ACCESS
17BF2  D00D     BRA 0x7C0E
110:           				grs = (grs >> 1) | 0x1;
17BF4  0EFC     MOVLW 0xFC
17BF6  0061     MOVFFL PLUSW1, 0x50C
17BF8  F38C     NOP
17BFA  F50C     NOP
17BFC  90D8     BCF 0xFD8, 0, ACCESS
17BFE  320C     RRCF 0xC, F, ACCESS
17C00  0E01     MOVLW 0x1
17C02  120C     IORWF 0xC, F, ACCESS
17C04  0EFC     MOVLW 0xFC
17C06  0061     MOVFFL 0x50C, PLUSW1
17C08  F430     NOP
17C0A  F4E3     NOP
111:           			}
17C0C  D009     BRA 0x7C20
112:           			else {
113:           				grs >>= 1;
17C0E  50E1     MOVF 0xFE1, W, ACCESS
17C10  0FFC     ADDLW 0xFC
17C12  6ED9     MOVWF 0xFD9, ACCESS
17C14  50E2     MOVF 0xFE2, W, ACCESS
17C16  6EDA     MOVWF __end_of_UART2_tx_vect_isr, ACCESS
17C18  0EFF     MOVLW 0xFF
17C1A  22DA     ADDWFC __end_of_UART2_tx_vect_isr, F, ACCESS
17C1C  90D8     BCF 0xFD8, 0, ACCESS
17C1E  32DF     RRCF 0xFDF, F, ACCESS
114:           			}
115:           			if (B_FRACTION.i & 0x1) {
17C20  0EF8     MOVLW 0xF8
17C22  A0E3     BTFSS 0xFE3, 0, ACCESS
17C24  D002     BRA 0x7C2A
116:           				grs |= 0x80;
17C26  0EFC     MOVLW 0xFC
17C28  8EE3     BSF 0xFE3, 7, ACCESS
117:           			}
118:           			B_FRACTION.i >>= 1;
17C2A  0E01     MOVLW 0x1
17C2C  6E0C     MOVWF 0xC, ACCESS
17C2E  50E1     MOVF 0xFE1, W, ACCESS
17C30  0FF8     ADDLW 0xF8
17C32  6ED9     MOVWF 0xFD9, ACCESS
17C34  50E2     MOVF 0xFE2, W, ACCESS
17C36  6EDA     MOVWF __end_of_UART2_tx_vect_isr, ACCESS
17C38  0EFF     MOVLW 0xFF
17C3A  22DA     ADDWFC __end_of_UART2_tx_vect_isr, F, ACCESS
17C3C  280C     INCF 0xC, W, ACCESS
17C3E  52DE     MOVF 0xFDE, F, ACCESS
17C40  D008     BRA 0x7C52
17C42  52DE     MOVF 0xFDE, F, ACCESS
17C44  90D8     BCF 0xFD8, 0, ACCESS
17C46  BEDC     BTFSC _UART2_rx_vect_isr, 7, ACCESS
17C48  80D8     BSF 0xFD8, 0, ACCESS
17C4A  32DD     RRCF 0xFDD, F, ACCESS
17C4C  32DD     RRCF 0xFDD, F, ACCESS
17C4E  32DD     RRCF 0xFDD, F, ACCESS
17C50  32DE     RRCF 0xFDE, F, ACCESS
17C52  2EE8     DECFSZ 0xFE8, F, ACCESS
17C54  D7F6     BRA 0x7C42
119:           			bexp++;
17C56  0EFD     MOVLW 0xFD
17C58  2AE3     INCF 0xFE3, F, ACCESS
120:           		}
121:           	}
122:           
123:           	/* Add or subtract magnitude ? */
124:           	if (!(signs & 0x40)) {
17C72  0EFF     MOVLW 0xFF
17C74  BCE3     BTFSC 0xFE3, 6, ACCESS
17C76  D066     BRA 0x7D44
125:           
126:           		/* Quick exit for 0 + 0, same sign */
127:           		if (!bexp) {
17C78  0EFD     MOVLW 0xFD
17C7A  50E3     MOVF 0xFE3, W, ACCESS
17C7C  B4D8     BTFSC 0xFD8, 2, ACCESS
128:           			return 0.0;
17C7E  D0F2     BRA 0x7E64
129:           		}
130:           
131:           		/* Add magnitude */
132:           		B_FRACTION.i += A_FRACTION.i;
17C80  0EF8     MOVLW 0xF8
17C82  50E3     MOVF 0xFE3, W, ACCESS
17C84  6E01     MOVWF __ptext283, ACCESS
17C86  0EF4     MOVLW 0xF4
17C88  50E3     MOVF 0xFE3, W, ACCESS
17C8A  2601     ADDWF __ptext283, F, ACCESS
17C8C  0EF8     MOVLW 0xF8
17C8E  0061     MOVFFL ltemp0, PLUSW1
17C90  F404     NOP
17C92  F4E3     NOP
17C94  0EF9     MOVLW 0xF9
17C96  50E3     MOVF 0xFE3, W, ACCESS
17C98  6E01     MOVWF __ptext283, ACCESS
17C9A  0EF5     MOVLW 0xF5
17C9C  50E3     MOVF 0xFE3, W, ACCESS
17C9E  2201     ADDWFC __ptext283, F, ACCESS
17CA0  0EF9     MOVLW 0xF9
17CA2  0061     MOVFFL ltemp0, PLUSW1
17CA4  F404     NOP
17CA6  F4E3     NOP
17CA8  0EFA     MOVLW 0xFA
17CAA  50E3     MOVF 0xFE3, W, ACCESS
17CAC  6E01     MOVWF __ptext283, ACCESS
17CAE  0EF6     MOVLW 0xF6
17CB0  50E3     MOVF 0xFE3, W, ACCESS
17CB2  2201     ADDWFC __ptext283, F, ACCESS
17CB4  0EFA     MOVLW 0xFA
17CB6  0061     MOVFFL ltemp0, PLUSW1
17CB8  F404     NOP
17CBA  F4E3     NOP
17CBC  0EFB     MOVLW 0xFB
17CBE  50E3     MOVF 0xFE3, W, ACCESS
17CC0  6E01     MOVWF __ptext283, ACCESS
17CC2  0EF7     MOVLW 0xF7
17CC4  50E3     MOVF 0xFE3, W, ACCESS
17CC6  2201     ADDWFC __ptext283, F, ACCESS
17CC8  0EFB     MOVLW 0xFB
17CCA  0061     MOVFFL ltemp0, PLUSW1
17CCC  F404     NOP
17CCE  F4E3     NOP
133:           		// did it overflow?
134:           		if (B_FRACTION.i & ((int32_t) 1 << (SPFRCB + 1))) {
17CD0  0EFB     MOVLW 0xFB
17CD2  A0E3     BTFSS 0xFE3, 0, ACCESS
17CD4  D101     BRA 0x7ED8
135:           			if (grs & 1) {
17CD6  0EFC     MOVLW 0xFC
17CD8  A0E3     BTFSS 0xFE3, 0, ACCESS
17CDA  D00D     BRA 0x7CF6
136:           				grs = (grs >> 1) | 0x1;
17CDC  0EFC     MOVLW 0xFC
17CDE  0061     MOVFFL PLUSW1, 0x50C
17CE0  F38C     NOP
17CE2  F50C     NOP
17CE4  90D8     BCF 0xFD8, 0, ACCESS
17CE6  320C     RRCF 0xC, F, ACCESS
17CE8  0E01     MOVLW 0x1
17CEA  120C     IORWF 0xC, F, ACCESS
17CEC  0EFC     MOVLW 0xFC
17CEE  0061     MOVFFL 0x50C, PLUSW1
17CF0  F430     NOP
17CF2  F4E3     NOP
137:           			}
17CF4  D009     BRA 0x7D08
138:           			else {
139:           				grs >>= 1;
17CF6  50E1     MOVF 0xFE1, W, ACCESS
17CF8  0FFC     ADDLW 0xFC
17CFA  6ED9     MOVWF 0xFD9, ACCESS
17CFC  50E2     MOVF 0xFE2, W, ACCESS
17CFE  6EDA     MOVWF __end_of_UART2_tx_vect_isr, ACCESS
17D00  0EFF     MOVLW 0xFF
17D02  22DA     ADDWFC __end_of_UART2_tx_vect_isr, F, ACCESS
17D04  90D8     BCF 0xFD8, 0, ACCESS
17D06  32DF     RRCF 0xFDF, F, ACCESS
140:           			}
141:           			if (B_FRACTION.i & 1) {
17D08  0EF8     MOVLW 0xF8
17D0A  A0E3     BTFSS 0xFE3, 0, ACCESS
17D0C  D002     BRA 0x7D12
142:           				grs |= 0x80;
17D0E  0EFC     MOVLW 0xFC
17D10  8EE3     BSF 0xFE3, 7, ACCESS
143:           			}
144:           			B_FRACTION.i >>= 1;
17D12  0E01     MOVLW 0x1
17D14  6E0C     MOVWF 0xC, ACCESS
17D16  50E1     MOVF 0xFE1, W, ACCESS
17D18  0FF8     ADDLW 0xF8
17D1A  6ED9     MOVWF 0xFD9, ACCESS
17D1C  50E2     MOVF 0xFE2, W, ACCESS
17D1E  6EDA     MOVWF __end_of_UART2_tx_vect_isr, ACCESS
17D20  0EFF     MOVLW 0xFF
17D22  22DA     ADDWFC __end_of_UART2_tx_vect_isr, F, ACCESS
17D24  280C     INCF 0xC, W, ACCESS
17D26  52DE     MOVF 0xFDE, F, ACCESS
17D28  D008     BRA 0x7D3A
17D2A  52DE     MOVF 0xFDE, F, ACCESS
17D2C  90D8     BCF 0xFD8, 0, ACCESS
17D2E  BEDC     BTFSC _UART2_rx_vect_isr, 7, ACCESS
17D30  80D8     BSF 0xFD8, 0, ACCESS
17D32  32DD     RRCF 0xFDD, F, ACCESS
17D34  32DD     RRCF 0xFDD, F, ACCESS
17D36  32DD     RRCF 0xFDD, F, ACCESS
17D38  32DE     RRCF 0xFDE, F, ACCESS
17D3A  2EE8     DECFSZ 0xFE8, F, ACCESS
17D3C  D7F6     BRA 0x7D2A
145:           			++bexp;
17D3E  0EFD     MOVLW 0xFD
17D40  2AE3     INCF 0xFE3, F, ACCESS
17D42  D0CA     BRA 0x7ED8
146:           		}
147:           
148:           	}
149:           	else {
150:           
151:           		/* Subtract magnitude */
152:           
153:           		if (B_FRACTION.i < A_FRACTION.i) {
17D44  50E1     MOVF 0xFE1, W, ACCESS
17D46  0FF8     ADDLW 0xF8
17D48  6ED9     MOVWF 0xFD9, ACCESS
17D4A  50E2     MOVF 0xFE2, W, ACCESS
17D4C  6EDA     MOVWF __end_of_UART2_tx_vect_isr, ACCESS
17D4E  0EFF     MOVLW 0xFF
17D50  22DA     ADDWFC __end_of_UART2_tx_vect_isr, F, ACCESS
17D52  0EF4     MOVLW 0xF4
17D54  50E3     MOVF 0xFE3, W, ACCESS
17D56  5CDE     SUBWF 0xFDE, W, ACCESS
17D58  0EF5     MOVLW 0xF5
17D5A  50E3     MOVF 0xFE3, W, ACCESS
17D5C  58DE     SUBWFB 0xFDE, W, ACCESS
17D5E  0EF6     MOVLW 0xF6
17D60  50E3     MOVF 0xFE3, W, ACCESS
17D62  58DE     SUBWFB 0xFDE, W, ACCESS
17D64  50DE     MOVF 0xFDE, W, ACCESS
17D66  0A80     XORLW 0x80
17D68  6E01     MOVWF __ptext283, ACCESS
17D6A  0EF7     MOVLW 0xF7
17D6C  50E3     MOVF 0xFE3, W, ACCESS
17D6E  0A80     XORLW 0x80
17D70  5801     SUBWFB __ptext283, W, ACCESS
17D72  B0D8     BTFSC 0xFD8, 0, ACCESS
17D74  D053     BRA 0x7E1C
154:           			B_FRACTION.i = A_FRACTION.i - B_FRACTION.i - 1;
17D76  0EF4     MOVLW 0xF4
17D78  0061     MOVFFL PLUSW1, ltemp2
17D7A  F38C     NOP
17D7C  F509     NOP
17D7E  0EF5     MOVLW 0xF5
17D80  0061     MOVFFL PLUSW1, ttemp3
17D82  F38C     NOP
17D84  F50A     NOP
17D86  0EF6     MOVLW 0xF6
17D88  0061     MOVFFL PLUSW1, wtemp5
17D8A  F38C     NOP
17D8C  F50B     NOP
17D8E  0EF7     MOVLW 0xF7
17D90  0061     MOVFFL PLUSW1, 0x50C
17D92  F38C     NOP
17D94  F50C     NOP
17D96  0EF8     MOVLW 0xF8
17D98  50E3     MOVF 0xFE3, W, ACCESS
17D9A  5E09     SUBWF 0x9, F, ACCESS
17D9C  0EF9     MOVLW 0xF9
17D9E  50E3     MOVF 0xFE3, W, ACCESS
17DA0  5A0A     SUBWFB 0xA, F, ACCESS
17DA2  0EFA     MOVLW 0xFA
17DA4  50E3     MOVF 0xFE3, W, ACCESS
17DA6  5A0B     SUBWFB 0xB, F, ACCESS
17DA8  0EFB     MOVLW 0xFB
17DAA  50E3     MOVF 0xFE3, W, ACCESS
17DAC  5A0C     SUBWFB 0xC, F, ACCESS
17DAE  0EFF     MOVLW 0xFF
17DB0  2409     ADDWF 0x9, W, ACCESS
17DB2  6E05     MOVWF 0x5, ACCESS
17DB4  0EFF     MOVLW 0xFF
17DB6  200A     ADDWFC 0xA, W, ACCESS
17DB8  6E06     MOVWF 0x6, ACCESS
17DBA  0EFF     MOVLW 0xFF
17DBC  200B     ADDWFC 0xB, W, ACCESS
17DBE  6E07     MOVWF 0x7, ACCESS
17DC0  0EFF     MOVLW 0xFF
17DC2  200C     ADDWFC 0xC, W, ACCESS
17DC4  6E08     MOVWF 0x8, ACCESS
17DC6  0EF8     MOVLW 0xF8
17DC8  0061     MOVFFL ltemp1, PLUSW1
17DCA  F414     NOP
17DCC  F4E3     NOP
17DCE  0EF9     MOVLW 0xF9
17DD0  0061     MOVFFL 0x506, PLUSW1
17DD2  F418     NOP
17DD4  F4E3     NOP
17DD6  0EFA     MOVLW 0xFA
17DD8  0061     MOVFFL ttemp2, PLUSW1
17DDA  F41C     NOP
17DDC  F4E3     NOP
17DDE  0EFB     MOVLW 0xFB
17DE0  0061     MOVFFL 0x508, PLUSW1
17DE2  F420     NOP
17DE4  F4E3     NOP
155:           			signs ^= 0x80;
17DE6  0EFF     MOVLW 0xFF
17DE8  7EE3     BTG 0xFE3, 7, ACCESS
156:           			grs = ~grs + 1;
17DEA  0EFC     MOVLW 0xFC
17DEC  50E3     MOVF 0xFE3, W, ACCESS
17DEE  0800     SUBLW 0x0
17DF0  6E0C     MOVWF 0xC, ACCESS
17DF2  0EFC     MOVLW 0xFC
17DF4  0061     MOVFFL 0x50C, PLUSW1
17DF6  F430     NOP
17DF8  F4E3     NOP
157:           			if (!grs) {
17DFA  0EFC     MOVLW 0xFC
17DFC  50E3     MOVF 0xFE3, W, ACCESS
17DFE  A4D8     BTFSS 0xFD8, 2, ACCESS
17E00  D020     BRA 0x7E42
158:           				++B_FRACTION.i;
17E02  50E1     MOVF 0xFE1, W, ACCESS
17E04  0FF8     ADDLW 0xF8
17E06  6ED9     MOVWF 0xFD9, ACCESS
17E08  50E2     MOVF 0xFE2, W, ACCESS
17E0A  6EDA     MOVWF __end_of_UART2_tx_vect_isr, ACCESS
17E0C  0EFF     MOVLW 0xFF
17E0E  22DA     ADDWFC __end_of_UART2_tx_vect_isr, F, ACCESS
17E10  2ADE     INCF 0xFDE, F, ACCESS
17E12  0E00     MOVLW 0x0
17E14  22DE     ADDWFC 0xFDE, F, ACCESS
17E16  22DE     ADDWFC 0xFDE, F, ACCESS
17E18  22DE     ADDWFC 0xFDE, F, ACCESS
17E1A  D013     BRA 0x7E42
159:           			}
160:           		}
161:           		else {
162:           			B_FRACTION.i -= A_FRACTION.i;
17E1C  50E1     MOVF 0xFE1, W, ACCESS
17E1E  0FF8     ADDLW 0xF8
17E20  6ED9     MOVWF 0xFD9, ACCESS
17E22  50E2     MOVF 0xFE2, W, ACCESS
17E24  6EDA     MOVWF __end_of_UART2_tx_vect_isr, ACCESS
17E26  0EFF     MOVLW 0xFF
17E28  22DA     ADDWFC __end_of_UART2_tx_vect_isr, F, ACCESS
17E2A  0EF4     MOVLW 0xF4
17E2C  50E3     MOVF 0xFE3, W, ACCESS
17E2E  5EDE     SUBWF 0xFDE, F, ACCESS
17E30  0EF5     MOVLW 0xF5
17E32  50E3     MOVF 0xFE3, W, ACCESS
17E34  5ADE     SUBWFB 0xFDE, F, ACCESS
17E36  0EF6     MOVLW 0xF6
17E38  50E3     MOVF 0xFE3, W, ACCESS
17E3A  5ADE     SUBWFB 0xFDE, F, ACCESS
17E3C  0EF7     MOVLW 0xF7
17E3E  50E3     MOVF 0xFE3, W, ACCESS
17E40  5ADE     SUBWFB 0xFDE, F, ACCESS
163:           		}
164:           
165:           		/* True zero ? */
166:           		if (!B_FRACTION.i && !grs) {
17E42  0EF8     MOVLW 0xF8
17E44  50E3     MOVF 0xFE3, W, ACCESS
17E46  E145     BNZ 0x7ED2
17E48  0EF9     MOVLW 0xF9
17E4A  50E3     MOVF 0xFE3, W, ACCESS
17E4C  E142     BNZ 0x7ED2
17E4E  0EFA     MOVLW 0xFA
17E50  50E3     MOVF 0xFE3, W, ACCESS
17E52  E13F     BNZ 0x7ED2
17E54  0EFB     MOVLW 0xFB
17E56  50E3     MOVF 0xFE3, W, ACCESS
17E58  A4D8     BTFSS 0xFD8, 2, ACCESS
17E5A  D03B     BRA 0x7ED2
17E5C  0EFC     MOVLW 0xFC
17E5E  50E3     MOVF 0xFE3, W, ACCESS
17E60  A4D8     BTFSS 0xFD8, 2, ACCESS
17E62  D037     BRA 0x7ED2
167:           			return 0.0;
17E64  0E00     MOVLW 0x0
17E66  6E01     MOVWF __ptext283, ACCESS
17E68  0E00     MOVLW 0x0
17E6A  6E02     MOVWF ___rparam_used, ACCESS
17E6C  0E00     MOVLW 0x0
17E6E  6E03     MOVWF __activetblptr, ACCESS
17E70  0E00     MOVLW 0x0
17E72  6E04     MOVWF __activetblptr, ACCESS
17E74  D0C6     BRA 0x8002
168:           		}
169:           
170:           		/* Renormalize */
171:           		while (!(B_FRACTION.i & ((int32_t) 1 << SPFRCB))) {
17ED2  0EFA     MOVLW 0xFA
17ED4  AEE3     BTFSS 0xFE3, 7, ACCESS
17ED6  D7CF     BRA 0x7E76
172:           			B_FRACTION.i <<= 1;
17E76  90D8     BCF 0xFD8, 0, ACCESS
17E78  0EF8     MOVLW 0xF8
17E7A  36E3     RLCF 0xFE3, F, ACCESS
17E7C  0EF9     MOVLW 0xF9
17E7E  36E3     RLCF 0xFE3, F, ACCESS
17E80  0EFA     MOVLW 0xFA
17E82  36E3     RLCF 0xFE3, F, ACCESS
17E84  0EFB     MOVLW 0xFB
17E86  36E3     RLCF 0xFE3, F, ACCESS
173:           			if (grs & 0x80) {
17E88  0EFC     MOVLW 0xFC
17E8A  AEE3     BTFSS 0xFE3, 7, ACCESS
17E8C  D002     BRA 0x7E92
174:           				B_FRACTION.i |= 0x1;
17E8E  0EF8     MOVLW 0xF8
17E90  80E3     BSF 0xFE3, 0, ACCESS
175:           			}
176:           			if (grs & 1) {
17E92  0EFC     MOVLW 0xFC
17E94  A0E3     BTFSS 0xFE3, 0, ACCESS
17E96  D00E     BRA 0x7EB4
177:           				grs = (unsigned char)((grs << 1) | 0x1);
17E98  0EFC     MOVLW 0xFC
17E9A  0061     MOVFFL PLUSW1, 0x50C
17E9C  F38C     NOP
17E9E  F50C     NOP
17EA0  90D8     BCF 0xFD8, 0, ACCESS
17EA2  340C     RLCF 0xC, W, ACCESS
17EA4  6E0B     MOVWF 0xB, ACCESS
17EA6  0E01     MOVLW 0x1
17EA8  120B     IORWF 0xB, F, ACCESS
17EAA  0EFC     MOVLW 0xFC
17EAC  0061     MOVFFL wtemp5, PLUSW1
17EAE  F42C     NOP
17EB0  F4E3     NOP
178:           			}
17EB2  D009     BRA 0x7EC6
179:           			else {
180:           				grs <<= 1;
17EB4  50E1     MOVF 0xFE1, W, ACCESS
17EB6  0FFC     ADDLW 0xFC
17EB8  6ED9     MOVWF 0xFD9, ACCESS
17EBA  50E2     MOVF 0xFE2, W, ACCESS
17EBC  6EDA     MOVWF __end_of_UART2_tx_vect_isr, ACCESS
17EBE  0EFF     MOVLW 0xFF
17EC0  22DA     ADDWFC __end_of_UART2_tx_vect_isr, F, ACCESS
17EC2  90D8     BCF 0xFD8, 0, ACCESS
17EC4  36DF     RLCF 0xFDF, F, ACCESS
181:           			}
182:           			if (bexp) {
17EC6  0EFD     MOVLW 0xFD
17EC8  50E3     MOVF 0xFE3, W, ACCESS
17ECA  B4D8     BTFSC 0xFD8, 2, ACCESS
17ECC  D002     BRA 0x7ED2
183:           				--bexp;
17ECE  0EFD     MOVLW 0xFD
17ED0  06E3     DECF 0xFE3, F, ACCESS
184:           			}
185:           		}
186:           	}
187:           
188:           	/* Round, check overflow, underflow */
189:           
190:           	/* Round */
191:           	// reuse aexp as the rounding flag ...
192:           	aexp = 0;
17ED8  0EFE     MOVLW 0xFE
17EDA  6AE3     CLRF 0xFE3, ACCESS
193:           	if (grs & 0x80) {
17EDC  0EFC     MOVLW 0xFC
17EDE  AEE3     BTFSS 0xFE3, 7, ACCESS
17EE0  D00F     BRA 0x7F00
194:           		if (grs & 0x7f) {
17EE2  0EFC     MOVLW 0xFC
17EE4  0061     MOVFFL PLUSW1, 0x50C
17EE6  F38C     NOP
17EE8  F50C     NOP
17EEA  0E7F     MOVLW 0x7F
17EEC  160C     ANDWF 0xC, F, ACCESS
17EEE  B4D8     BTFSC 0xFD8, 2, ACCESS
17EF0  D004     BRA 0x7EFA
195:           			aexp = 1;
17EF2  0EFE     MOVLW 0xFE
17EF4  6AE3     CLRF 0xFE3, ACCESS
17EF6  2AE3     INCF 0xFE3, F, ACCESS
196:           		}
17EF8  D003     BRA 0x7F00
197:           		else {
198:           			if (B_FRACTION.i & 1) {
17EFA  0EF8     MOVLW 0xF8
17EFC  B0E3     BTFSC 0xFE3, 0, ACCESS
17EFE  D7F9     BRA 0x7EF2
199:           				aexp = 1;
200:           			}
201:           		}
202:           	}
203:           	if (aexp) {
17F00  0EFE     MOVLW 0xFE
17F02  50E3     MOVF 0xFE3, W, ACCESS
17F04  B4D8     BTFSC 0xFD8, 2, ACCESS
17F06  D02B     BRA 0x7F5E
204:           		++B_FRACTION.i;
17F08  50E1     MOVF 0xFE1, W, ACCESS
17F0A  0FF8     ADDLW 0xF8
17F0C  6ED9     MOVWF 0xFD9, ACCESS
17F0E  50E2     MOVF 0xFE2, W, ACCESS
17F10  6EDA     MOVWF __end_of_UART2_tx_vect_isr, ACCESS
17F12  0EFF     MOVLW 0xFF
17F14  22DA     ADDWFC __end_of_UART2_tx_vect_isr, F, ACCESS
17F16  2ADE     INCF 0xFDE, F, ACCESS
17F18  0E00     MOVLW 0x0
17F1A  22DE     ADDWFC 0xFDE, F, ACCESS
17F1C  22DE     ADDWFC 0xFDE, F, ACCESS
17F1E  22DE     ADDWFC 0xFDE, F, ACCESS
205:           		if (B_FRACTION.i & ((int32_t) 1 << (SPFRCB + 1))) {
17F20  0EFB     MOVLW 0xFB
17F22  A0E3     BTFSS 0xFE3, 0, ACCESS
17F24  D01C     BRA 0x7F5E
206:           			B_FRACTION.i = B_FRACTION.i >> 1;
17F26  0E01     MOVLW 0x1
17F28  6E0C     MOVWF 0xC, ACCESS
17F2A  50E1     MOVF 0xFE1, W, ACCESS
17F2C  0FF8     ADDLW 0xF8
17F2E  6ED9     MOVWF 0xFD9, ACCESS
17F30  50E2     MOVF 0xFE2, W, ACCESS
17F32  6EDA     MOVWF __end_of_UART2_tx_vect_isr, ACCESS
17F34  0EFF     MOVLW 0xFF
17F36  22DA     ADDWFC __end_of_UART2_tx_vect_isr, F, ACCESS
17F38  280C     INCF 0xC, W, ACCESS
17F3A  52DE     MOVF 0xFDE, F, ACCESS
17F3C  D008     BRA 0x7F4E
17F3E  52DE     MOVF 0xFDE, F, ACCESS
17F40  90D8     BCF 0xFD8, 0, ACCESS
17F42  BEDC     BTFSC _UART2_rx_vect_isr, 7, ACCESS
17F44  80D8     BSF 0xFD8, 0, ACCESS
17F46  32DD     RRCF 0xFDD, F, ACCESS
17F48  32DD     RRCF 0xFDD, F, ACCESS
17F4A  32DD     RRCF 0xFDD, F, ACCESS
17F4C  32DE     RRCF 0xFDE, F, ACCESS
17F4E  2EE8     DECFSZ 0xFE8, F, ACCESS
17F50  D7F6     BRA 0x7F3E
207:           			if (!(bexp == 0xFF)) {
17F52  0EFD     MOVLW 0xFD
17F54  28E3     INCF 0xFE3, W, ACCESS
17F56  B4D8     BTFSC 0xFD8, 2, ACCESS
17F58  D002     BRA 0x7F5E
208:           				++bexp;
17F5A  0EFD     MOVLW 0xFD
17F5C  2AE3     INCF 0xFE3, F, ACCESS
209:           			}
210:           		}
211:           	}
212:           
213:           	/* Overflow ? Return infinity */
214:           	/* Underflow ? Flush to zero */
215:           	if (bexp == 0xFF || bexp == 0) {
17F5E  0EFD     MOVLW 0xFD
17F60  28E3     INCF 0xFE3, W, ACCESS
17F62  B4D8     BTFSC 0xFD8, 2, ACCESS
17F64  D004     BRA 0x7F6E
17F66  0EFD     MOVLW 0xFD
17F68  50E3     MOVF 0xFE3, W, ACCESS
17F6A  A4D8     BTFSS 0xFD8, 2, ACCESS
17F6C  D00E     BRA 0x7F8A
216:           		B_FRACTION.i = 0;
17F6E  0EF8     MOVLW 0xF8
17F70  6AE3     CLRF 0xFE3, ACCESS
17F72  0EF9     MOVLW 0xF9
17F74  6AE3     CLRF 0xFE3, ACCESS
17F76  0EFA     MOVLW 0xFA
17F78  6AE3     CLRF 0xFE3, ACCESS
17F7A  0EFB     MOVLW 0xFB
17F7C  6AE3     CLRF 0xFE3, ACCESS
217:                           // no negative 0 for now
218:                           if (bexp == 0) {
17F7E  0EFD     MOVLW 0xFD
17F80  50E3     MOVF 0xFE3, W, ACCESS
17F82  A4D8     BTFSS 0xFD8, 2, ACCESS
17F84  D002     BRA 0x7F8A
219:           		        signs=0;
17F86  0EFF     MOVLW 0xFF
17F88  6AE3     CLRF 0xFE3, ACCESS
220:                           }
221:           	}
222:           
223:           	/* Pack and return result */
224:           	// set the low bit of the exponent ...
225:           	if (bexp & 0x1) {
17F8A  0EFD     MOVLW 0xFD
17F8C  A0E3     BTFSS 0xFE3, 0, ACCESS
17F8E  D009     BRA 0x7FA2
226:           		B_FRACTION.fAsBytes.c |= 0x80;
17F90  0EFA     MOVLW 0xFA
17F92  24E1     ADDWF 0xFE1, W, ACCESS
17F94  6ED9     MOVWF 0xFD9, ACCESS
17F96  0EFF     MOVLW 0xFF
17F98  20E2     ADDWFC 0xFE2, W, ACCESS
17F9A  6EDA     MOVWF __end_of_UART2_tx_vect_isr, ACCESS
17F9C  0E00     MOVLW 0x0
17F9E  8EDB     BSF __end_of_UART2_tx_vect_isr, 7, ACCESS
227:           	}
17FA0  D008     BRA 0x7FB2
228:           	// AND out the leading 1
229:           	else {
230:           		B_FRACTION.fAsBytes.c &= 0x7F;
17FA2  0EFA     MOVLW 0xFA
17FA4  24E1     ADDWF 0xFE1, W, ACCESS
17FA6  6ED9     MOVWF 0xFD9, ACCESS
17FA8  0EFF     MOVLW 0xFF
17FAA  20E2     ADDWFC 0xFE2, W, ACCESS
17FAC  6EDA     MOVWF __end_of_UART2_tx_vect_isr, ACCESS
17FAE  0E7F     MOVLW 0x7F
17FB0  16DF     ANDWF 0xFDF, F, ACCESS
231:           	}
232:           	B_FRACTION.fAsBytes.d = bexp >> 1;
17FB2  0EFB     MOVLW 0xFB
17FB4  24E1     ADDWF 0xFE1, W, ACCESS
17FB6  6ED9     MOVWF 0xFD9, ACCESS
17FB8  0EFF     MOVLW 0xFF
17FBA  20E2     ADDWFC 0xFE2, W, ACCESS
17FBC  6EDA     MOVWF __end_of_UART2_tx_vect_isr, ACCESS
17FBE  0EFD     MOVLW 0xFD
17FC0  0061     MOVFFL PLUSW1, 0x50C
17FC2  F38C     NOP
17FC4  F50C     NOP
17FC6  90D8     BCF 0xFD8, 0, ACCESS
17FC8  300C     RRCF 0xC, W, ACCESS
17FCA  6EDF     MOVWF 0xFDF, ACCESS
233:           	if (signs & 0x80) {
17FCC  0EFF     MOVLW 0xFF
17FCE  AEE3     BTFSS 0xFE3, 7, ACCESS
17FD0  D008     BRA 0x7FE2
234:           		B_FRACTION.fAsBytes.d |= 0x80;
17FD2  0EFB     MOVLW 0xFB
17FD4  24E1     ADDWF 0xFE1, W, ACCESS
17FD6  6ED9     MOVWF 0xFD9, ACCESS
17FD8  0EFF     MOVLW 0xFF
17FDA  20E2     ADDWFC 0xFE2, W, ACCESS
17FDC  6EDA     MOVWF __end_of_UART2_tx_vect_isr, ACCESS
17FDE  0E00     MOVLW 0x0
17FE0  8EDB     BSF __end_of_UART2_tx_vect_isr, 7, ACCESS
235:           	}
236:           	return b;
17FE2  0EF8     MOVLW 0xF8
17FE4  0061     MOVFFL PLUSW1, ltemp0
17FE6  F38C     NOP
17FE8  F501     NOP
17FEA  0EF9     MOVLW 0xF9
17FEC  0061     MOVFFL PLUSW1, ttemp5
17FEE  F38C     NOP
17FF0  F502     NOP
17FF2  0EFA     MOVLW 0xFA
17FF4  0061     MOVFFL PLUSW1, wtemp1
17FF6  F38C     NOP
17FF8  F503     NOP
17FFA  0EFB     MOVLW 0xFB
17FFC  0061     MOVFFL PLUSW1, ttemp1
17FFE  F38C     NOP
18000  F504     NOP
237:           }
18002  0EF4     MOVLW 0xF4
18004  26E1     ADDWF 0xFE1, F, ACCESS
18006  0EFF     MOVLW 0xFF
18008  22E2     ADDWFC 0xFE2, F, ACCESS
18008  22E2     ADDWFC 0xFE2, F, ACCESS
238:           
239:           /* SP Subtract */
240:           #ifdef __PICC__
241:           SP
242:           SPSUB(SP a, SP b)
243:           #else
244:           SP
245:           SPSUB(SP b, SP a)
246:           #endif
247:           {
248:           	(*(SFP *) & a).i ^= 0x80000000; 
1B80  0EFB     MOVLW 0xFB
1B82  7EE3     BTG 0xFE3, 7, ACCESS
249:           	return __fladd(b, a);
1B84  0EF8     MOVLW 0xF8
1B86  C4E3     MOVFF PLUSW1, POSTINC1
1B88  F4E6     NOP
1B8A  C4E3     MOVFF PLUSW1, POSTINC1
1B8C  F4E6     NOP
1B8E  C4E3     MOVFF PLUSW1, POSTINC1
1B90  F4E6     NOP
1B92  C4E3     MOVFF PLUSW1, POSTINC1
1B94  F4E6     NOP
1B96  0EF8     MOVLW 0xF8
1B98  C4E3     MOVFF PLUSW1, POSTINC1
1B9A  F4E6     NOP
1B9C  C4E3     MOVFF PLUSW1, POSTINC1
1B9E  F4E6     NOP
1BA0  C4E3     MOVFF PLUSW1, POSTINC1
1BA2  F4E6     NOP
1BA4  C4E3     MOVFF PLUSW1, POSTINC1
1BA6  F4E6     NOP
1BA8  EC30     CALL 0x17860, 0
1BAA  F0BC     NOP
250:           }
1BAC  0EF8     MOVLW 0xF8
1BAC  0EF8     MOVLW 0xF8
1BAC  0EF8     MOVLW 0xF8
1BAC  0EF8     MOVLW 0xF8
1BAC  0EF8     MOVLW 0xF8
251:           
---  /opt/microchip/xc8/v2.41/pic/sources/c99/common/printf.c  ------------------------------------------
1:             #include <stdio.h>
2:             #include <stdarg.h>
3:             #include "stdio_impl.h"
4:             
5:             int printf(const char *restrict fmt, ...)
0DAE  52E6     MOVF 0xFE6, F, ACCESS
0DB0  52E6     MOVF 0xFE6, F, ACCESS
6:             {
7:             	int ret;
8:             	va_list ap;
9:             	va_start(ap, fmt);
0DB2  0EFB     MOVLW 0xFB
0DB4  24E1     ADDWF 0xFE1, W, ACCESS
0DB6  6E0B     MOVWF 0xB, ACCESS
0DB8  0EFF     MOVLW 0xFF
0DBA  20E2     ADDWFC 0xFE2, W, ACCESS
0DBC  6E0C     MOVWF 0xC, ACCESS
0DBE  0EFF     MOVLW 0xFF
0DC0  0061     MOVFFL 0x50C, PLUSW1
0DC2  F430     NOP
0DC4  F4E3     NOP
0DC6  0EFE     MOVLW 0xFE
0DC8  0061     MOVFFL wtemp5, PLUSW1
0DCA  F42C     NOP
0DCC  F4E3     NOP
10:            	ret = vfprintf(stdout, fmt, ap);
0DCE  0EFE     MOVLW 0xFE
0DD0  24E1     ADDWF 0xFE1, W, ACCESS
0DD2  6E01     MOVWF __ptext283, ACCESS
0DD4  0EFF     MOVLW 0xFF
0DD6  20E2     ADDWFC 0xFE2, W, ACCESS
0DD8  6E02     MOVWF ___rparam_used, ACCESS
0DDA  0061     MOVFFL ltemp0, POSTINC1
0DDC  F404     NOP
0DDE  F4E6     NOP
0DE0  0061     MOVFFL ttemp5, POSTINC1
0DE2  F408     NOP
0DE4  F4E6     NOP
0DE6  0EF9     MOVLW 0xF9
0DE8  C4E3     MOVFF PLUSW1, POSTINC1
0DEA  F4E6     NOP
0DEC  C4E3     MOVFF PLUSW1, POSTINC1
0DEE  F4E6     NOP
0DF0  0E00     MOVLW 0x0
0DF2  6EE6     MOVWF 0xFE6, ACCESS
0DF4  0E00     MOVLW 0x0
0DF6  6EE6     MOVWF 0xFE6, ACCESS
0DF8  EC61     CALL 0x1FEC2, 0
0DFA  F0FF     NOP
11:            	va_end(ap);
12:            	return ret;
13:            }
0DFC  52E5     MOVF 0xFE5, F, ACCESS
0DFE  52E5     MOVF 0xFE5, F, ACCESS
0E00  52E5     MOVF 0xFE5, F, ACCESS
0E02  50E7     MOVF 0xFE7, W, ACCESS
0E04  5EE1     SUBWF 0xFE1, F, ACCESS
0E06  0E00     MOVLW 0x0
0E08  5AE2     SUBWFB 0xFE2, F, ACCESS
0E08  5AE2     SUBWFB 0xFE2, F, ACCESS
---  /opt/microchip/xc8/v2.41/pic/sources/c99/common/nf_snprintf.c  -------------------------------------
1:             #include <stdarg.h>
2:             #include <stdio.h>
3:             #include <errno.h>
4:             #include <limits.h>
5:             
6:             #include "stdio_impl.h"
7:             
8:             #ifdef STDIO_NO_FILE_IO
9:             /* "No file system" snprintf */
10:            
11:            #define MIN(a, b) ((a) < (b) ? (a) : (b))
12:            
13:            int snprintf(char *restrict s, size_t n, const char *restrict fmt, ...)
1C06A  0E12     MOVLW 0x12
1C06C  26E1     ADDWF 0xFE1, F, ACCESS
1C06E  0E00     MOVLW 0x0
1C070  22E2     ADDWFC 0xFE2, F, ACCESS
14:            {
15:            	int cnt;
16:            	va_list ap;
17:            	FILE f;
18:            
19:            	if (n > INT_MAX) {
1C072  0EEA     MOVLW 0xEA
1C074  0061     MOVFFL PLUSW1, ltemp0
1C076  F38C     NOP
1C078  F501     NOP
1C07A  0E80     MOVLW 0x80
1C07C  5E01     SUBWF __ptext283, F, ACCESS
1C07E  B0D8     BTFSC 0xFD8, 0, ACCESS
1C080  D0E2     BRA 0xC246
20:            		errno = EOVERFLOW;
21:            		return -1;
22:            	}
23:            	va_start(ap, fmt);
1C082  0EE7     MOVLW 0xE7
1C084  24E1     ADDWF 0xFE1, W, ACCESS
1C086  6E0B     MOVWF 0xB, ACCESS
1C088  0EFF     MOVLW 0xFF
1C08A  20E2     ADDWFC 0xFE2, W, ACCESS
1C08C  6E0C     MOVWF 0xC, ACCESS
1C08E  0EFD     MOVLW 0xFD
1C090  0061     MOVFFL 0x50C, PLUSW1
1C092  F430     NOP
1C094  F4E3     NOP
1C096  0EFC     MOVLW 0xFC
1C098  0061     MOVFFL wtemp5, PLUSW1
1C09A  F42C     NOP
1C09C  F4E3     NOP
24:            	f.buffer = s;
1C09E  0EEB     MOVLW 0xEB
1C0A0  0061     MOVFFL PLUSW1, wtemp5
1C0A2  F38C     NOP
1C0A4  F50B     NOP
1C0A6  0EEC     MOVLW 0xEC
1C0A8  0061     MOVFFL PLUSW1, 0x50C
1C0AA  F38C     NOP
1C0AC  F50C     NOP
1C0AE  0EF1     MOVLW 0xF1
1C0B0  0061     MOVFFL 0x50C, PLUSW1
1C0B2  F430     NOP
1C0B4  F4E3     NOP
1C0B6  0EF0     MOVLW 0xF0
1C0B8  0061     MOVFFL wtemp5, PLUSW1
1C0BA  F42C     NOP
1C0BC  F4E3     NOP
25:            	if(n>1) {
1C0BE  0EEA     MOVLW 0xEA
1C0C0  50E3     MOVF 0xFE3, W, ACCESS
1C0C2  E108     BNZ 0xC0D4
1C0C4  0EE9     MOVLW 0xE9
1C0C6  0061     MOVFFL PLUSW1, ltemp0
1C0C8  F38C     NOP
1C0CA  F501     NOP
1C0CC  0E02     MOVLW 0x2
1C0CE  5E01     SUBWF __ptext283, F, ACCESS
1C0D0  A0D8     BTFSS 0xFD8, 0, ACCESS
1C0D2  D01F     BRA 0xC112
26:            		f.limit = (int)n-1;
1C0D4  0EE9     MOVLW 0xE9
1C0D6  50E3     MOVF 0xFE3, W, ACCESS
1C0D8  0FFF     ADDLW 0xFF
1C0DA  6E0B     MOVWF 0xB, ACCESS
1C0DC  0EEA     MOVLW 0xEA
1C0DE  0061     MOVFFL PLUSW1, 0x50C
1C0E0  F38C     NOP
1C0E2  F50C     NOP
1C0E4  0EFF     MOVLW 0xFF
1C0E6  220C     ADDWFC 0xC, F, ACCESS
1C0E8  0EFA     MOVLW 0xFA
1C0EA  24E1     ADDWF 0xFE1, W, ACCESS
1C0EC  6ED9     MOVWF 0xFD9, ACCESS
1C0EE  0EFF     MOVLW 0xFF
1C0F0  20E2     ADDWFC 0xFE2, W, ACCESS
1C0F2  6EDA     MOVWF __end_of_UART2_tx_vect_isr, ACCESS
1C0F4  0061     MOVFFL wtemp5, POSTINC2
1C0F6  F42C     NOP
1C0F8  F4DE     NOP
1C0FA  0061     MOVFFL 0x50C, POSTDEC2
1C0FC  F430     NOP
1C0FE  F4DD     NOP
27:            		f.count = 0;
1C100  0EF3     MOVLW 0xF3
1C102  24E1     ADDWF 0xFE1, W, ACCESS
1C104  6ED9     MOVWF 0xFD9, ACCESS
1C106  0EFF     MOVLW 0xFF
1C108  20E2     ADDWFC 0xFE2, W, ACCESS
1C10A  6EDA     MOVWF __end_of_UART2_tx_vect_isr, ACCESS
1C10C  6ADE     CLRF 0xFDE, ACCESS
1C10E  6ADD     CLRF 0xFDD, ACCESS
28:            	}
1C110  D014     BRA 0xC13A
29:            	else {
30:            		f.limit = 1;
1C112  0EFA     MOVLW 0xFA
1C114  24E1     ADDWF 0xFE1, W, ACCESS
1C116  6ED9     MOVWF 0xFD9, ACCESS
1C118  0EFF     MOVLW 0xFF
1C11A  20E2     ADDWFC 0xFE2, W, ACCESS
1C11C  6EDA     MOVWF __end_of_UART2_tx_vect_isr, ACCESS
1C11E  0E01     MOVLW 0x1
1C120  6EDE     MOVWF 0xFDE, ACCESS
1C122  0E00     MOVLW 0x0
1C124  6EDD     MOVWF 0xFDD, ACCESS
31:            		f.count = 1;
1C126  0EF3     MOVLW 0xF3
1C128  24E1     ADDWF 0xFE1, W, ACCESS
1C12A  6ED9     MOVWF 0xFD9, ACCESS
1C12C  0EFF     MOVLW 0xFF
1C12E  20E2     ADDWFC 0xFE2, W, ACCESS
1C130  6EDA     MOVWF __end_of_UART2_tx_vect_isr, ACCESS
1C132  0E01     MOVLW 0x1
1C134  6EDE     MOVWF 0xFDE, ACCESS
1C136  0E00     MOVLW 0x0
1C138  6EDD     MOVWF 0xFDD, ACCESS
32:            	}
33:            	cnt = vfprintf(&f, fmt, ap);
1C13A  0EFC     MOVLW 0xFC
1C13C  24E1     ADDWF 0xFE1, W, ACCESS
1C13E  6E01     MOVWF __ptext283, ACCESS
1C140  0EFF     MOVLW 0xFF
1C142  20E2     ADDWFC 0xFE2, W, ACCESS
1C144  6E02     MOVWF ___rparam_used, ACCESS
1C146  0061     MOVFFL ltemp0, POSTINC1
1C148  F404     NOP
1C14A  F4E6     NOP
1C14C  0061     MOVFFL ttemp5, POSTINC1
1C14E  F408     NOP
1C150  F4E6     NOP
1C152  0EE5     MOVLW 0xE5
1C154  C4E3     MOVFF PLUSW1, POSTINC1
1C156  F4E6     NOP
1C158  C4E3     MOVFF PLUSW1, POSTINC1
1C15A  F4E6     NOP
1C15C  0EEC     MOVLW 0xEC
1C15E  24E1     ADDWF 0xFE1, W, ACCESS
1C160  6E01     MOVWF __ptext283, ACCESS
1C162  0EFF     MOVLW 0xFF
1C164  20E2     ADDWFC 0xFE2, W, ACCESS
1C166  6E02     MOVWF ___rparam_used, ACCESS
1C168  0061     MOVFFL ltemp0, POSTINC1
1C16A  F404     NOP
1C16C  F4E6     NOP
1C16E  0061     MOVFFL ttemp5, POSTINC1
1C170  F408     NOP
1C172  F4E6     NOP
1C174  EC61     CALL 0x1FEC2, 0
1C176  F0FF     NOP
1C178  0EFE     MOVLW 0xFE
1C17A  0061     MOVFFL ltemp0, PLUSW1
1C17C  F404     NOP
1C17E  F4E3     NOP
1C180  0EFF     MOVLW 0xFF
1C182  0061     MOVFFL ttemp5, PLUSW1
1C184  F408     NOP
1C186  F4E3     NOP
34:            	if((n>0) && (cnt>=0)) {
1C188  0EE9     MOVLW 0xE9
1C18A  0061     MOVFFL PLUSW1, ltemp0
1C18C  F38C     NOP
1C18E  F501     NOP
1C190  0EEA     MOVLW 0xEA
1C192  50E3     MOVF 0xFE3, W, ACCESS
1C194  1001     IORWF __ptext283, W, ACCESS
1C196  B4D8     BTFSC 0xFD8, 2, ACCESS
1C198  D056     BRA 0xC246
1C19A  0EFF     MOVLW 0xFF
1C19C  BEE3     BTFSC 0xFE3, 7, ACCESS
1C19E  D053     BRA 0xC246
35:            		s[MIN(cnt, (int)n-1)] = '\0';
1C1A0  0EE9     MOVLW 0xE9
1C1A2  50E3     MOVF 0xFE3, W, ACCESS
1C1A4  0FFF     ADDLW 0xFF
1C1A6  6E0B     MOVWF 0xB, ACCESS
1C1A8  0EEA     MOVLW 0xEA
1C1AA  0061     MOVFFL PLUSW1, 0x50C
1C1AC  F38C     NOP
1C1AE  F50C     NOP
1C1B0  0EFF     MOVLW 0xFF
1C1B2  220C     ADDWFC 0xC, F, ACCESS
1C1B4  0EFE     MOVLW 0xFE
1C1B6  0061     MOVFFL PLUSW1, ltemp0
1C1B8  F38C     NOP
1C1BA  F501     NOP
1C1BC  500B     MOVF 0xB, W, ACCESS
1C1BE  5C01     SUBWF __ptext283, W, ACCESS
1C1C0  0EFF     MOVLW 0xFF
1C1C2  50E3     MOVF 0xFE3, W, ACCESS
1C1C4  0A80     XORLW 0x80
1C1C6  6E01     MOVWF __ptext283, ACCESS
1C1C8  500C     MOVF 0xC, W, ACCESS
1C1CA  0A80     XORLW 0x80
1C1CC  5801     SUBWFB __ptext283, W, ACCESS
1C1CE  A0D8     BTFSS 0xFD8, 0, ACCESS
1C1D0  D013     BRA 0xC1F8
1C1D2  0EE9     MOVLW 0xE9
1C1D4  50E3     MOVF 0xFE3, W, ACCESS
1C1D6  0FFF     ADDLW 0xFF
1C1D8  6E0B     MOVWF 0xB, ACCESS
1C1DA  0EEA     MOVLW 0xEA
1C1DC  0061     MOVFFL PLUSW1, 0x50C
1C1DE  F38C     NOP
1C1E0  F50C     NOP
1C1E2  0EFF     MOVLW 0xFF
1C1E4  220C     ADDWFC 0xC, F, ACCESS
1C1E6  0EEE     MOVLW 0xEE
1C1E8  0061     MOVFFL wtemp5, PLUSW1
1C1EA  F42C     NOP
1C1EC  F4E3     NOP
1C1EE  0EEF     MOVLW 0xEF
1C1F0  0061     MOVFFL 0x50C, PLUSW1
1C1F2  F430     NOP
1C1F4  F4E3     NOP
1C1F6  D010     BRA 0xC218
1C1F8  0EFE     MOVLW 0xFE
1C1FA  0061     MOVFFL PLUSW1, ltemp0
1C1FC  F38C     NOP
1C1FE  F501     NOP
1C200  0EEE     MOVLW 0xEE
1C202  0061     MOVFFL ltemp0, PLUSW1
1C204  F404     NOP
1C206  F4E3     NOP
1C208  0EFF     MOVLW 0xFF
1C20A  0061     MOVFFL PLUSW1, ltemp0
1C20C  F38C     NOP
1C20E  F501     NOP
1C210  0EEF     MOVLW 0xEF
1C212  0061     MOVFFL ltemp0, PLUSW1
1C214  F404     NOP
1C216  F4E3     NOP
1C218  0EEE     MOVLW 0xEE
1C21A  0061     MOVFFL PLUSW1, wtemp5
1C21C  F38C     NOP
1C21E  F50B     NOP
1C220  0EEF     MOVLW 0xEF
1C222  0061     MOVFFL PLUSW1, 0x50C
1C224  F38C     NOP
1C226  F50C     NOP
1C228  0EEB     MOVLW 0xEB
1C22A  0061     MOVFFL PLUSW1, ltemp2
1C22C  F38C     NOP
1C22E  F509     NOP
1C230  0EEC     MOVLW 0xEC
1C232  0061     MOVFFL PLUSW1, ttemp3
1C234  F38C     NOP
1C236  F50A     NOP
1C238  500B     MOVF 0xB, W, ACCESS
1C23A  2409     ADDWF 0x9, W, ACCESS
1C23C  6ED9     MOVWF 0xFD9, ACCESS
1C23E  500C     MOVF 0xC, W, ACCESS
1C240  200A     ADDWFC 0xA, W, ACCESS
1C242  6EDA     MOVWF __end_of_UART2_tx_vect_isr, ACCESS
1C244  6ADF     CLRF 0xFDF, ACCESS
36:            	}
37:            	va_end(ap);
38:            	return cnt;
39:            }
1C246  0EEE     MOVLW 0xEE
1C248  26E1     ADDWF 0xFE1, F, ACCESS
1C24A  0EFF     MOVLW 0xFF
1C24C  22E2     ADDWFC 0xFE2, F, ACCESS
1C24E  52E5     MOVF 0xFE5, F, ACCESS
1C250  50E7     MOVF 0xFE7, W, ACCESS
1C252  5EE1     SUBWF 0xFE1, F, ACCESS
1C254  0E00     MOVLW 0x0
1C256  5AE2     SUBWFB 0xFE2, F, ACCESS
1C256  5AE2     SUBWFB 0xFE2, F, ACCESS
40:            #endif
---  /opt/microchip/xc8/v2.41/pic/sources/c99/common/nf_fputs.c  ----------------------------------------
1:             /* "No file system" fputs */
2:             #include <stdio.h>
3:             
4:             #include "stdio_impl.h"
5:             
6:             #ifdef STDIO_NO_FILE_IO
7:             
8:             int fputs(const char *s, FILE *fp)
041E  52E6     MOVF 0xFE6, F, ACCESS
0420  52E6     MOVF 0xFE6, F, ACCESS
0422  52E6     MOVF 0xFE6, F, ACCESS
9:             {
10:                char c;
11:                int i;
12:            
13:                i = 0;
0424  0EFD     MOVLW 0xFD
0426  6AE3     CLRF 0xFE3, ACCESS
0428  0EFE     MOVLW 0xFE
042A  6AE3     CLRF 0xFE3, ACCESS
14:                while ((c = *(s + i))) {
042C  D01D     BRA 0x468
0468  0EFD     MOVLW 0xFD
046A  0061     MOVFFL PLUSW1, wtemp5
046C  F38C     NOP
046E  F50B     NOP
0470  0EFE     MOVLW 0xFE
0472  0061     MOVFFL PLUSW1, 0x50C
0474  F38C     NOP
0476  F50C     NOP
0478  0EFB     MOVLW 0xFB
047A  0061     MOVFFL PLUSW1, ltemp2
047C  F38C     NOP
047E  F509     NOP
0480  0EFC     MOVLW 0xFC
0482  0061     MOVFFL PLUSW1, ttemp3
0484  F38C     NOP
0486  F50A     NOP
0488  500B     MOVF 0xB, W, ACCESS
048A  2409     ADDWF 0x9, W, ACCESS
048C  6ED9     MOVWF 0xFD9, ACCESS
048E  500C     MOVF 0xC, W, ACCESS
0490  200A     ADDWFC 0xA, W, ACCESS
0492  6EDA     MOVWF __end_of_UART2_tx_vect_isr, ACCESS
0494  50DF     MOVF 0xFDF, W, ACCESS
0496  6E0C     MOVWF 0xC, ACCESS
0498  0EFF     MOVLW 0xFF
049A  0061     MOVFFL 0x50C, PLUSW1
049C  F430     NOP
049E  F4E3     NOP
04A0  0EFF     MOVLW 0xFF
04A2  50E3     MOVF 0xFE3, W, ACCESS
04A4  A4D8     BTFSS 0xFD8, 2, ACCESS
04A6  D7C3     BRA 0x42E
15:            	fputc(c,fp);
042E  0EF9     MOVLW 0xF9
0430  C4E3     MOVFF PLUSW1, POSTINC1
0432  F4E6     NOP
0434  C4E3     MOVFF PLUSW1, POSTINC1
0436  F4E6     NOP
0438  0EFD     MOVLW 0xFD
043A  50E3     MOVF 0xFE3, W, ACCESS
043C  6EE6     MOVWF 0xFE6, ACCESS
043E  0E00     MOVLW 0x0
0440  6EE6     MOVWF 0xFE6, ACCESS
0442  ECCB     CALL 0x1DF96, 0
0444  F0EF     NOP
16:                    ++i;
0446  0EFD     MOVLW 0xFD
0448  50E3     MOVF 0xFE3, W, ACCESS
044A  0F01     ADDLW 0x1
044C  6E01     MOVWF __ptext283, ACCESS
044E  0EFD     MOVLW 0xFD
0450  0061     MOVFFL ltemp0, PLUSW1
0452  F404     NOP
0454  F4E3     NOP
0456  6A01     CLRF __ptext283, ACCESS
0458  0EFE     MOVLW 0xFE
045A  50E3     MOVF 0xFE3, W, ACCESS
045C  2001     ADDWFC __ptext283, W, ACCESS
045E  6E01     MOVWF __ptext283, ACCESS
0460  0EFE     MOVLW 0xFE
0462  0061     MOVFFL ltemp0, PLUSW1
0464  F404     NOP
0466  F4E3     NOP
17:                }
18:                return i;
19:            }
04A8  0EF9     MOVLW 0xF9
04AA  26E1     ADDWF 0xFE1, F, ACCESS
04AC  0EFF     MOVLW 0xFF
04AE  22E2     ADDWFC 0xFE2, F, ACCESS
04AE  22E2     ADDWFC 0xFE2, F, ACCESS
20:            
21:            #endif
---  /opt/microchip/xc8/v2.41/pic/sources/c99/common/nf_fputc.c  ----------------------------------------
1:             #include <stdio.h>
2:             
3:             #include "stdio_impl.h"
4:             
5:             #ifdef STDIO_NO_FILE_IO
6:             /* "No file system" fputc */
7:             
8:             int fputc(int c, FILE *fp)
9:             {
10:                extern void putch(char);
11:            
12:                if ((fp == stdout) || (fp == stderr)) {
1DF96  0EFC     MOVLW 0xFC
1DF98  0061     MOVFFL PLUSW1, ltemp0
1DF9A  F38C     NOP
1DF9C  F501     NOP
1DF9E  0EFD     MOVLW 0xFD
1DFA0  50E3     MOVF 0xFE3, W, ACCESS
1DFA2  1001     IORWF __ptext283, W, ACCESS
1DFA4  B4D8     BTFSC 0xFD8, 2, ACCESS
1DFA6  D009     BRA 0xDFBA
1DFA8  0EFC     MOVLW 0xFC
1DFAA  0061     MOVFFL PLUSW1, ltemp0
1DFAC  F38C     NOP
1DFAE  F501     NOP
1DFB0  0EFD     MOVLW 0xFD
1DFB2  50E3     MOVF 0xFE3, W, ACCESS
1DFB4  1001     IORWF __ptext283, W, ACCESS
1DFB6  A4D8     BTFSS 0xFD8, 2, ACCESS
1DFB8  D006     BRA 0xDFC6
13:                    putch((char)c);
1DFBA  0EFE     MOVLW 0xFE
1DFBC  50E3     MOVF 0xFE3, W, ACCESS
1DFBE  6EE6     MOVWF 0xFE6, ACCESS
1DFC0  EC49     CALL 0x2692, 0
1DFC2  F013     NOP
14:                } else {
1DFC4  D072     BRA 0xE0AA
15:            		if((fp->limit == 0) || (fp->count < fp->limit)) {
1DFC6  0EFC     MOVLW 0xFC
1DFC8  0061     MOVFFL PLUSW1, wtemp5
1DFCA  F38C     NOP
1DFCC  F50B     NOP
1DFCE  0EFD     MOVLW 0xFD
1DFD0  0061     MOVFFL PLUSW1, 0x50C
1DFD2  F38C     NOP
1DFD4  F50C     NOP
1DFD6  0E0A     MOVLW 0xA
1DFD8  240B     ADDWF 0xB, W, ACCESS
1DFDA  6ED9     MOVWF 0xFD9, ACCESS
1DFDC  0E00     MOVLW 0x0
1DFDE  200C     ADDWFC 0xC, W, ACCESS
1DFE0  6EDA     MOVWF __end_of_UART2_tx_vect_isr, ACCESS
1DFE2  50DE     MOVF 0xFDE, W, ACCESS
1DFE4  10DE     IORWF 0xFDE, W, ACCESS
1DFE6  B4D8     BTFSC 0xFD8, 2, ACCESS
1DFE8  D026     BRA 0xE036
1DFEA  0EFC     MOVLW 0xFC
1DFEC  0061     MOVFFL PLUSW1, wtemp5
1DFEE  F38C     NOP
1DFF0  F50B     NOP
1DFF2  0EFD     MOVLW 0xFD
1DFF4  0061     MOVFFL PLUSW1, 0x50C
1DFF6  F38C     NOP
1DFF8  F50C     NOP
1DFFA  0E0A     MOVLW 0xA
1DFFC  240B     ADDWF 0xB, W, ACCESS
1DFFE  6ED9     MOVWF 0xFD9, ACCESS
1E000  0E00     MOVLW 0x0
1E002  200C     ADDWFC 0xC, W, ACCESS
1E004  6EDA     MOVWF __end_of_UART2_tx_vect_isr, ACCESS
1E006  0EFC     MOVLW 0xFC
1E008  0061     MOVFFL PLUSW1, wtemp5
1E00A  F38C     NOP
1E00C  F50B     NOP
1E00E  0EFD     MOVLW 0xFD
1E010  0061     MOVFFL PLUSW1, 0x50C
1E012  F38C     NOP
1E014  F50C     NOP
1E016  0E03     MOVLW 0x3
1E018  240B     ADDWF 0xB, W, ACCESS
1E01A  6EE9     MOVWF 0xFE9, ACCESS
1E01C  0E00     MOVLW 0x0
1E01E  200C     ADDWFC 0xC, W, ACCESS
1E020  6EEA     MOVWF 0xFEA, ACCESS
1E022  50DE     MOVF 0xFDE, W, ACCESS
1E024  5CEE     SUBWF 0xFEE, W, ACCESS
1E026  50EE     MOVF 0xFEE, W, ACCESS
1E028  0A80     XORLW 0x80
1E02A  6E01     MOVWF __ptext283, ACCESS
1E02C  50DE     MOVF 0xFDE, W, ACCESS
1E02E  0A80     XORLW 0x80
1E030  5801     SUBWFB __ptext283, W, ACCESS
1E032  B0D8     BTFSC 0xFD8, 0, ACCESS
1E034  D03A     BRA 0xE0AA
16:            #pragma warning push
17:            #pragma warning disable 1498
18:            			fp->buffer[fp->count] = (char)c;
1E036  0EFC     MOVLW 0xFC
1E038  0061     MOVFFL PLUSW1, wtemp5
1E03A  F38C     NOP
1E03C  F50B     NOP
1E03E  0EFD     MOVLW 0xFD
1E040  0061     MOVFFL PLUSW1, 0x50C
1E042  F38C     NOP
1E044  F50C     NOP
1E046  0E03     MOVLW 0x3
1E048  240B     ADDWF 0xB, W, ACCESS
1E04A  6ED9     MOVWF 0xFD9, ACCESS
1E04C  0E00     MOVLW 0x0
1E04E  200C     ADDWFC 0xC, W, ACCESS
1E050  6EDA     MOVWF __end_of_UART2_tx_vect_isr, ACCESS
1E052  0061     MOVFFL POSTINC2, wtemp5
1E054  F378     NOP
1E056  F50B     NOP
1E058  0061     MOVFFL POSTDEC2, 0x50C
1E05A  F374     NOP
1E05C  F50C     NOP
1E05E  0EFC     MOVLW 0xFC
1E060  C4E3     MOVFF PLUSW1, FSR2
1E062  F4D9     NOP
1E064  0EFD     MOVLW 0xFD
1E066  C4E3     MOVFF PLUSW1, FSR2H
1E068  F4DA     NOP
1E06A  0061     MOVFFL POSTINC2, ltemp2
1E06C  F378     NOP
1E06E  F509     NOP
1E070  0061     MOVFFL POSTDEC2, ttemp3
1E072  F374     NOP
1E074  F50A     NOP
1E076  500B     MOVF 0xB, W, ACCESS
1E078  2409     ADDWF 0x9, W, ACCESS
1E07A  6ED9     MOVWF 0xFD9, ACCESS
1E07C  500C     MOVF 0xC, W, ACCESS
1E07E  200A     ADDWFC 0xA, W, ACCESS
1E080  6EDA     MOVWF __end_of_UART2_tx_vect_isr, ACCESS
1E082  0EFE     MOVLW 0xFE
1E084  C4E3     MOVFF PLUSW1, INDF2
1E086  F4DF     NOP
19:            #pragma warning pop
20:            			++fp->count;
1E088  0EFC     MOVLW 0xFC
1E08A  0061     MOVFFL PLUSW1, wtemp5
1E08C  F38C     NOP
1E08E  F50B     NOP
1E090  0EFD     MOVLW 0xFD
1E092  0061     MOVFFL PLUSW1, 0x50C
1E094  F38C     NOP
1E096  F50C     NOP
1E098  0E03     MOVLW 0x3
1E09A  240B     ADDWF 0xB, W, ACCESS
1E09C  6ED9     MOVWF 0xFD9, ACCESS
1E09E  0E00     MOVLW 0x0
1E0A0  200C     ADDWFC 0xC, W, ACCESS
1E0A2  6EDA     MOVWF __end_of_UART2_tx_vect_isr, ACCESS
1E0A4  2ADE     INCF 0xFDE, F, ACCESS
1E0A6  0E00     MOVLW 0x0
1E0A8  22DD     ADDWFC 0xFDD, F, ACCESS
21:            		}
22:                }
23:                return (unsigned char)c;
24:            }
1E0AA  52E5     MOVF 0xFE5, F, ACCESS
1E0AC  52E5     MOVF 0xFE5, F, ACCESS
1E0AE  52E5     MOVF 0xFE5, F, ACCESS
1E0B0  52E5     MOVF 0xFE5, F, ACCESS
1E0B0  52E5     MOVF 0xFE5, F, ACCESS
25:            
26:            #endif
---  /opt/microchip/xc8/v2.41/pic/sources/c99/common/memset.c  ------------------------------------------
1:             #include <string.h>
2:             #include <stdint.h>
3:             
4:             void *memset(void *dest, int c, size_t n)
1B052  52E6     MOVF 0xFE6, F, ACCESS
1B054  52E6     MOVF 0xFE6, F, ACCESS
1B056  52E6     MOVF 0xFE6, F, ACCESS
1B058  52E6     MOVF 0xFE6, F, ACCESS
5:             {
6:             	unsigned char *s = dest;
1B05A  0EFA     MOVLW 0xFA
1B05C  0061     MOVFFL PLUSW1, wtemp5
1B05E  F38C     NOP
1B060  F50B     NOP
1B062  0EFB     MOVLW 0xFB
1B064  0061     MOVFFL PLUSW1, 0x50C
1B066  F38C     NOP
1B068  F50C     NOP
1B06A  0EFD     MOVLW 0xFD
1B06C  0061     MOVFFL 0x50C, PLUSW1
1B06E  F430     NOP
1B070  F4E3     NOP
1B072  0EFC     MOVLW 0xFC
1B074  0061     MOVFFL wtemp5, PLUSW1
1B076  F42C     NOP
1B078  F4E3     NOP
7:             	size_t k;
8:             
9:             	/* Fill head and tail with minimal branching. Each
10:            	 * conditional ensures that all the subsequently used
11:            	 * offsets are well-defined and in the dest region. */
12:            
13:            	if (!n) return dest;
1B07A  0EF6     MOVLW 0xF6
1B07C  0061     MOVFFL PLUSW1, ltemp0
1B07E  F38C     NOP
1B080  F501     NOP
1B082  0EF7     MOVLW 0xF7
1B084  50E3     MOVF 0xFE3, W, ACCESS
1B086  1001     IORWF __ptext283, W, ACCESS
1B088  B4D8     BTFSC 0xFD8, 2, ACCESS
1B08A  D147     BRA 0xB31A
14:            	s[0] = (unsigned char)c;
1B08C  0EFC     MOVLW 0xFC
1B08E  C4E3     MOVFF PLUSW1, FSR2
1B090  F4D9     NOP
1B092  0EFD     MOVLW 0xFD
1B094  C4E3     MOVFF PLUSW1, FSR2H
1B096  F4DA     NOP
1B098  0EF8     MOVLW 0xF8
1B09A  C4E3     MOVFF PLUSW1, INDF2
1B09C  F4DF     NOP
15:            	s[n-1] = (unsigned char)c;
1B09E  0EFC     MOVLW 0xFC
1B0A0  0061     MOVFFL PLUSW1, wtemp5
1B0A2  F38C     NOP
1B0A4  F50B     NOP
1B0A6  0EFD     MOVLW 0xFD
1B0A8  0061     MOVFFL PLUSW1, 0x50C
1B0AA  F38C     NOP
1B0AC  F50C     NOP
1B0AE  0EF6     MOVLW 0xF6
1B0B0  50E3     MOVF 0xFE3, W, ACCESS
1B0B2  260B     ADDWF 0xB, F, ACCESS
1B0B4  0EF7     MOVLW 0xF7
1B0B6  50E3     MOVF 0xFE3, W, ACCESS
1B0B8  220C     ADDWFC 0xC, F, ACCESS
1B0BA  0EFF     MOVLW 0xFF
1B0BC  240B     ADDWF 0xB, W, ACCESS
1B0BE  6ED9     MOVWF 0xFD9, ACCESS
1B0C0  0EFF     MOVLW 0xFF
1B0C2  200C     ADDWFC 0xC, W, ACCESS
1B0C4  6EDA     MOVWF __end_of_UART2_tx_vect_isr, ACCESS
1B0C6  0EF8     MOVLW 0xF8
1B0C8  C4E3     MOVFF PLUSW1, INDF2
1B0CA  F4DF     NOP
16:            	if (n <= 2) return dest;
1B0CC  0EF7     MOVLW 0xF7
1B0CE  50E3     MOVF 0xFE3, W, ACCESS
1B0D0  E108     BNZ 0xB0E2
1B0D2  0EF6     MOVLW 0xF6
1B0D4  0061     MOVFFL PLUSW1, ltemp0
1B0D6  F38C     NOP
1B0D8  F501     NOP
1B0DA  0E03     MOVLW 0x3
1B0DC  5E01     SUBWF __ptext283, F, ACCESS
1B0DE  A0D8     BTFSS 0xFD8, 0, ACCESS
1B0E0  D11C     BRA 0xB31A
17:            	s[1] = (unsigned char)c;
1B0E2  0EFC     MOVLW 0xFC
1B0E4  0061     MOVFFL PLUSW1, wtemp5
1B0E6  F38C     NOP
1B0E8  F50B     NOP
1B0EA  0EFD     MOVLW 0xFD
1B0EC  0061     MOVFFL PLUSW1, 0x50C
1B0EE  F38C     NOP
1B0F0  F50C     NOP
1B0F2  0E01     MOVLW 0x1
1B0F4  240B     ADDWF 0xB, W, ACCESS
1B0F6  6ED9     MOVWF 0xFD9, ACCESS
1B0F8  0E00     MOVLW 0x0
1B0FA  200C     ADDWFC 0xC, W, ACCESS
1B0FC  6EDA     MOVWF __end_of_UART2_tx_vect_isr, ACCESS
1B0FE  0EF8     MOVLW 0xF8
1B100  C4E3     MOVFF PLUSW1, INDF2
1B102  F4DF     NOP
18:            	s[2] = (unsigned char)c;
1B104  0EFC     MOVLW 0xFC
1B106  0061     MOVFFL PLUSW1, wtemp5
1B108  F38C     NOP
1B10A  F50B     NOP
1B10C  0EFD     MOVLW 0xFD
1B10E  0061     MOVFFL PLUSW1, 0x50C
1B110  F38C     NOP
1B112  F50C     NOP
1B114  0E02     MOVLW 0x2
1B116  240B     ADDWF 0xB, W, ACCESS
1B118  6ED9     MOVWF 0xFD9, ACCESS
1B11A  0E00     MOVLW 0x0
1B11C  200C     ADDWFC 0xC, W, ACCESS
1B11E  6EDA     MOVWF __end_of_UART2_tx_vect_isr, ACCESS
1B120  0EF8     MOVLW 0xF8
1B122  C4E3     MOVFF PLUSW1, INDF2
1B124  F4DF     NOP
19:            	s[n-2] = (unsigned char)c;
1B126  0EFC     MOVLW 0xFC
1B128  0061     MOVFFL PLUSW1, wtemp5
1B12A  F38C     NOP
1B12C  F50B     NOP
1B12E  0EFD     MOVLW 0xFD
1B130  0061     MOVFFL PLUSW1, 0x50C
1B132  F38C     NOP
1B134  F50C     NOP
1B136  0EF6     MOVLW 0xF6
1B138  50E3     MOVF 0xFE3, W, ACCESS
1B13A  260B     ADDWF 0xB, F, ACCESS
1B13C  0EF7     MOVLW 0xF7
1B13E  50E3     MOVF 0xFE3, W, ACCESS
1B140  220C     ADDWFC 0xC, F, ACCESS
1B142  0EFE     MOVLW 0xFE
1B144  240B     ADDWF 0xB, W, ACCESS
1B146  6ED9     MOVWF 0xFD9, ACCESS
1B148  0EFF     MOVLW 0xFF
1B14A  200C     ADDWFC 0xC, W, ACCESS
1B14C  6EDA     MOVWF __end_of_UART2_tx_vect_isr, ACCESS
1B14E  0EF8     MOVLW 0xF8
1B150  C4E3     MOVFF PLUSW1, INDF2
1B152  F4DF     NOP
20:            	s[n-3] = (unsigned char)c;
1B154  0EFC     MOVLW 0xFC
1B156  0061     MOVFFL PLUSW1, wtemp5
1B158  F38C     NOP
1B15A  F50B     NOP
1B15C  0EFD     MOVLW 0xFD
1B15E  0061     MOVFFL PLUSW1, 0x50C
1B160  F38C     NOP
1B162  F50C     NOP
1B164  0EF6     MOVLW 0xF6
1B166  50E3     MOVF 0xFE3, W, ACCESS
1B168  260B     ADDWF 0xB, F, ACCESS
1B16A  0EF7     MOVLW 0xF7
1B16C  50E3     MOVF 0xFE3, W, ACCESS
1B16E  220C     ADDWFC 0xC, F, ACCESS
1B170  0EFD     MOVLW 0xFD
1B172  240B     ADDWF 0xB, W, ACCESS
1B174  6ED9     MOVWF 0xFD9, ACCESS
1B176  0EFF     MOVLW 0xFF
1B178  200C     ADDWFC 0xC, W, ACCESS
1B17A  6EDA     MOVWF __end_of_UART2_tx_vect_isr, ACCESS
1B17C  0EF8     MOVLW 0xF8
1B17E  C4E3     MOVFF PLUSW1, INDF2
1B180  F4DF     NOP
21:            	if (n <= 6) return dest;
1B182  0EF7     MOVLW 0xF7
1B184  50E3     MOVF 0xFE3, W, ACCESS
1B186  E108     BNZ 0xB198
1B188  0EF6     MOVLW 0xF6
1B18A  0061     MOVFFL PLUSW1, ltemp0
1B18C  F38C     NOP
1B18E  F501     NOP
1B190  0E07     MOVLW 0x7
1B192  5E01     SUBWF __ptext283, F, ACCESS
1B194  A0D8     BTFSS 0xFD8, 0, ACCESS
1B196  D0C1     BRA 0xB31A
22:            	s[3] = (unsigned char)c;
1B198  0EFC     MOVLW 0xFC
1B19A  0061     MOVFFL PLUSW1, wtemp5
1B19C  F38C     NOP
1B19E  F50B     NOP
1B1A0  0EFD     MOVLW 0xFD
1B1A2  0061     MOVFFL PLUSW1, 0x50C
1B1A4  F38C     NOP
1B1A6  F50C     NOP
1B1A8  0E03     MOVLW 0x3
1B1AA  240B     ADDWF 0xB, W, ACCESS
1B1AC  6ED9     MOVWF 0xFD9, ACCESS
1B1AE  0E00     MOVLW 0x0
1B1B0  200C     ADDWFC 0xC, W, ACCESS
1B1B2  6EDA     MOVWF __end_of_UART2_tx_vect_isr, ACCESS
1B1B4  0EF8     MOVLW 0xF8
1B1B6  C4E3     MOVFF PLUSW1, INDF2
1B1B8  F4DF     NOP
23:            	s[n-4] = (unsigned char)c;
1B1BA  0EFC     MOVLW 0xFC
1B1BC  0061     MOVFFL PLUSW1, wtemp5
1B1BE  F38C     NOP
1B1C0  F50B     NOP
1B1C2  0EFD     MOVLW 0xFD
1B1C4  0061     MOVFFL PLUSW1, 0x50C
1B1C6  F38C     NOP
1B1C8  F50C     NOP
1B1CA  0EF6     MOVLW 0xF6
1B1CC  50E3     MOVF 0xFE3, W, ACCESS
1B1CE  260B     ADDWF 0xB, F, ACCESS
1B1D0  0EF7     MOVLW 0xF7
1B1D2  50E3     MOVF 0xFE3, W, ACCESS
1B1D4  220C     ADDWFC 0xC, F, ACCESS
1B1D6  0EFC     MOVLW 0xFC
1B1D8  240B     ADDWF 0xB, W, ACCESS
1B1DA  6ED9     MOVWF 0xFD9, ACCESS
1B1DC  0EFF     MOVLW 0xFF
1B1DE  200C     ADDWFC 0xC, W, ACCESS
1B1E0  6EDA     MOVWF __end_of_UART2_tx_vect_isr, ACCESS
1B1E2  0EF8     MOVLW 0xF8
1B1E4  C4E3     MOVFF PLUSW1, INDF2
1B1E6  F4DF     NOP
24:            	if (n <= 8) return dest;
1B1E8  0EF7     MOVLW 0xF7
1B1EA  50E3     MOVF 0xFE3, W, ACCESS
1B1EC  E108     BNZ 0xB1FE
1B1EE  0EF6     MOVLW 0xF6
1B1F0  0061     MOVFFL PLUSW1, ltemp0
1B1F2  F38C     NOP
1B1F4  F501     NOP
1B1F6  0E09     MOVLW 0x9
1B1F8  5E01     SUBWF __ptext283, F, ACCESS
1B1FA  A0D8     BTFSS 0xFD8, 0, ACCESS
1B1FC  D08E     BRA 0xB31A
25:            
26:            	/* Advance pointer to align it at a 4-byte boundary,
27:            	 * and truncate n to a multiple of 4. The previous code
28:            	 * already took care of any head/tail that get cut off
29:            	 * by the alignment. */
30:            
31:            	k = -(uintptr_t)s & 3;
1B1FE  0EFC     MOVLW 0xFC
1B200  0061     MOVFFL PLUSW1, wtemp5
1B202  F38C     NOP
1B204  F50B     NOP
1B206  1E0B     COMF 0xB, F, ACCESS
1B208  0EFD     MOVLW 0xFD
1B20A  0061     MOVFFL PLUSW1, 0x50C
1B20C  F38C     NOP
1B20E  F50C     NOP
1B210  1E0C     COMF 0xC, F, ACCESS
1B212  2A0B     INCF 0xB, F, ACCESS
1B214  B4D8     BTFSC 0xFD8, 2, ACCESS
1B216  2A0C     INCF 0xC, F, ACCESS
1B218  0E03     MOVLW 0x3
1B21A  160B     ANDWF 0xB, F, ACCESS
1B21C  0E00     MOVLW 0x0
1B21E  160C     ANDWF 0xC, F, ACCESS
1B220  0EFE     MOVLW 0xFE
1B222  0061     MOVFFL wtemp5, PLUSW1
1B224  F42C     NOP
1B226  F4E3     NOP
1B228  0EFF     MOVLW 0xFF
1B22A  0061     MOVFFL 0x50C, PLUSW1
1B22C  F430     NOP
1B22E  F4E3     NOP
32:            	s += k;
1B230  0EFC     MOVLW 0xFC
1B232  50E3     MOVF 0xFE3, W, ACCESS
1B234  6E01     MOVWF __ptext283, ACCESS
1B236  0EFE     MOVLW 0xFE
1B238  50E3     MOVF 0xFE3, W, ACCESS
1B23A  2601     ADDWF __ptext283, F, ACCESS
1B23C  0EFC     MOVLW 0xFC
1B23E  0061     MOVFFL ltemp0, PLUSW1
1B240  F404     NOP
1B242  F4E3     NOP
1B244  0EFD     MOVLW 0xFD
1B246  50E3     MOVF 0xFE3, W, ACCESS
1B248  6E01     MOVWF __ptext283, ACCESS
1B24A  0EFF     MOVLW 0xFF
1B24C  50E3     MOVF 0xFE3, W, ACCESS
1B24E  2201     ADDWFC __ptext283, F, ACCESS
1B250  0EFD     MOVLW 0xFD
1B252  0061     MOVFFL ltemp0, PLUSW1
1B254  F404     NOP
1B256  F4E3     NOP
33:            	n -= k;
1B258  0EF6     MOVLW 0xF6
1B25A  50E3     MOVF 0xFE3, W, ACCESS
1B25C  6E01     MOVWF __ptext283, ACCESS
1B25E  0EFE     MOVLW 0xFE
1B260  50E3     MOVF 0xFE3, W, ACCESS
1B262  5E01     SUBWF __ptext283, F, ACCESS
1B264  0EF6     MOVLW 0xF6
1B266  0061     MOVFFL ltemp0, PLUSW1
1B268  F404     NOP
1B26A  F4E3     NOP
1B26C  0EF7     MOVLW 0xF7
1B26E  50E3     MOVF 0xFE3, W, ACCESS
1B270  6E01     MOVWF __ptext283, ACCESS
1B272  0EFF     MOVLW 0xFF
1B274  50E3     MOVF 0xFE3, W, ACCESS
1B276  5A01     SUBWFB __ptext283, F, ACCESS
1B278  0EF7     MOVLW 0xF7
1B27A  0061     MOVFFL ltemp0, PLUSW1
1B27C  F404     NOP
1B27E  F4E3     NOP
34:            	n &= (size_t)-4;
1B280  0EFC     MOVLW 0xFC
1B282  6E0B     MOVWF 0xB, ACCESS
1B284  0EFF     MOVLW 0xFF
1B286  6E0C     MOVWF 0xC, ACCESS
1B288  0EF6     MOVLW 0xF6
1B28A  0061     MOVFFL PLUSW1, ltemp0
1B28C  F38C     NOP
1B28E  F501     NOP
1B290  500B     MOVF 0xB, W, ACCESS
1B292  1601     ANDWF __ptext283, F, ACCESS
1B294  0EF6     MOVLW 0xF6
1B296  0061     MOVFFL ltemp0, PLUSW1
1B298  F404     NOP
1B29A  F4E3     NOP
1B29C  0EF7     MOVLW 0xF7
1B29E  0061     MOVFFL PLUSW1, ltemp0
1B2A0  F38C     NOP
1B2A2  F501     NOP
1B2A4  500C     MOVF 0xC, W, ACCESS
1B2A6  1601     ANDWF __ptext283, F, ACCESS
1B2A8  0EF7     MOVLW 0xF7
1B2AA  D02B     BRA 0xB302
35:            
36:            #ifdef __GNUC__
37:            	typedef uint32_t __attribute__((__may_alias__)) u32;
38:            	typedef uint64_t __attribute__((__may_alias__)) u64;
39:            
40:            	u32 c32 = ((u32)-1)/255 * (unsigned char)c;
41:            
42:            	/* In preparation to copy 32 bytes at a time, aligned on
43:            	 * an 8-byte bounary, fill head/tail up to 28 bytes each.
44:            	 * As in the initial byte-based head/tail fill, each
45:            	 * conditional below ensures that the subsequent offsets
46:            	 * are valid (e.g. !(n<=24) implies n>=28). */
47:            
48:            	*(u32 *)(s+0) = c32;
49:            	*(u32 *)(s+n-4) = c32;
50:            	if (n <= 8) return dest;
51:            	*(u32 *)(s+4) = c32;
52:            	*(u32 *)(s+8) = c32;
53:            	*(u32 *)(s+n-12) = c32;
54:            	*(u32 *)(s+n-8) = c32;
55:            	if (n <= 24) return dest;
56:            	*(u32 *)(s+12) = c32;
57:            	*(u32 *)(s+16) = c32;
58:            	*(u32 *)(s+20) = c32;
59:            	*(u32 *)(s+24) = c32;
60:            	*(u32 *)(s+n-28) = c32;
61:            	*(u32 *)(s+n-24) = c32;
62:            	*(u32 *)(s+n-20) = c32;
63:            	*(u32 *)(s+n-16) = c32;
64:            
65:            	/* Align to a multiple of 8 so we can fill 64 bits at a time,
66:            	 * and avoid writing the same bytes twice as much as is
67:            	 * practical without introducing additional branching. */
68:            
69:            	k = 24 + ((uintptr_t)s & 4);
70:            	s += k;
71:            	n -= k;
72:            
73:            	/* If this loop is reached, 28 tail bytes have already been
74:            	 * filled, so any remainder when n drops below 32 can be
75:            	 * safely ignored. */
76:            
77:            	u64 c64 = c32 | ((u64)c32 << 32);
78:            	for (; n >= 32; n-=32, s+=32) {
79:            		*(u64 *)(s+0) = c64;
80:            		*(u64 *)(s+8) = c64;
81:            		*(u64 *)(s+16) = c64;
82:            		*(u64 *)(s+24) = c64;
83:            	}
84:            #else
85:            	/* Pure C fallback with no aliasing violations. */
86:            	for (; n; n--, s++) *s = (unsigned char)c;
1B2AC  0EFC     MOVLW 0xFC
1B2AE  C4E3     MOVFF PLUSW1, FSR2
1B2B0  F4D9     NOP
1B2B2  0EFD     MOVLW 0xFD
1B2B4  C4E3     MOVFF PLUSW1, FSR2H
1B2B6  F4DA     NOP
1B2B8  0EF8     MOVLW 0xF8
1B2BA  C4E3     MOVFF PLUSW1, INDF2
1B2BC  F4DF     NOP
1B2BE  0EF6     MOVLW 0xF6
1B2C0  0061     MOVFFL PLUSW1, ltemp0
1B2C2  F38C     NOP
1B2C4  F501     NOP
1B2C6  0E01     MOVLW 0x1
1B2C8  5E01     SUBWF __ptext283, F, ACCESS
1B2CA  0EF6     MOVLW 0xF6
1B2CC  0061     MOVFFL ltemp0, PLUSW1
1B2CE  F404     NOP
1B2D0  F4E3     NOP
1B2D2  0EF7     MOVLW 0xF7
1B2D4  0061     MOVFFL PLUSW1, ltemp0
1B2D6  F38C     NOP
1B2D8  F501     NOP
1B2DA  0E00     MOVLW 0x0
1B2DC  5A01     SUBWFB __ptext283, F, ACCESS
1B2DE  0EF7     MOVLW 0xF7
1B2E0  0061     MOVFFL ltemp0, PLUSW1
1B2E2  F404     NOP
1B2E4  F4E3     NOP
1B2E6  0EFC     MOVLW 0xFC
1B2E8  50E3     MOVF 0xFE3, W, ACCESS
1B2EA  0F01     ADDLW 0x1
1B2EC  6E01     MOVWF __ptext283, ACCESS
1B2EE  0EFC     MOVLW 0xFC
1B2F0  0061     MOVFFL ltemp0, PLUSW1
1B2F2  F404     NOP
1B2F4  F4E3     NOP
1B2F6  6A01     CLRF __ptext283, ACCESS
1B2F8  0EFD     MOVLW 0xFD
1B2FA  50E3     MOVF 0xFE3, W, ACCESS
1B2FC  2001     ADDWFC __ptext283, W, ACCESS
1B2FE  6E01     MOVWF __ptext283, ACCESS
1B300  0EFD     MOVLW 0xFD
1B302  0061     MOVFFL ltemp0, PLUSW1
1B304  F404     NOP
1B306  F4E3     NOP
1B308  0EF6     MOVLW 0xF6
1B30A  0061     MOVFFL PLUSW1, ltemp0
1B30C  F38C     NOP
1B30E  F501     NOP
1B310  0EF7     MOVLW 0xF7
1B312  50E3     MOVF 0xFE3, W, ACCESS
1B314  1001     IORWF __ptext283, W, ACCESS
1B316  A4D8     BTFSS 0xFD8, 2, ACCESS
1B318  D7C9     BRA 0xB2AC
87:            #endif
88:            
89:            	return dest;
90:            }
1B31A  0EF6     MOVLW 0xF6
1B31C  26E1     ADDWF 0xFE1, F, ACCESS
1B31E  0EFF     MOVLW 0xFF
1B320  22E2     ADDWFC 0xFE2, F, ACCESS
1B320  22E2     ADDWFC 0xFE2, F, ACCESS
---  /opt/microchip/xc8/v2.41/pic/sources/c99/common/memcpy.c  ------------------------------------------
1:             #include <stdlib.h>
2:             
3:             void *
4:             memcpy(void * d1, const void * s1, register size_t n)
1E502  0E05     MOVLW 0x5
1E504  26E1     ADDWF 0xFE1, F, ACCESS
1E506  0E00     MOVLW 0x0
1E508  22E2     ADDWFC 0xFE2, F, ACCESS
5:             {
6:             
7:             	register char *		d;
8:             	register const char *	s;
9:             	register unsigned char tmp;
10:            
11:            	s = s1;
1E50A  0EF7     MOVLW 0xF7
1E50C  0061     MOVFFL PLUSW1, wtemp5
1E50E  F38C     NOP
1E510  F50B     NOP
1E512  0EF8     MOVLW 0xF8
1E514  0061     MOVFFL PLUSW1, 0x50C
1E516  F38C     NOP
1E518  F50C     NOP
1E51A  0EFC     MOVLW 0xFC
1E51C  0061     MOVFFL 0x50C, PLUSW1
1E51E  F430     NOP
1E520  F4E3     NOP
1E522  0EFB     MOVLW 0xFB
1E524  0061     MOVFFL wtemp5, PLUSW1
1E526  F42C     NOP
1E528  F4E3     NOP
12:            	d = d1;
1E52A  0EF9     MOVLW 0xF9
1E52C  0061     MOVFFL PLUSW1, wtemp5
1E52E  F38C     NOP
1E530  F50B     NOP
1E532  0EFA     MOVLW 0xFA
1E534  0061     MOVFFL PLUSW1, 0x50C
1E536  F38C     NOP
1E538  F50C     NOP
1E53A  0EFE     MOVLW 0xFE
1E53C  0061     MOVFFL 0x50C, PLUSW1
1E53E  F430     NOP
1E540  F4E3     NOP
1E542  0EFD     MOVLW 0xFD
1E544  0061     MOVFFL wtemp5, PLUSW1
1E546  F42C     NOP
1E548  F4E3     NOP
13:            	while(n--) {
1E54A  D043     BRA 0xE5D2
1E5D2  0EF5     MOVLW 0xF5
1E5D4  0061     MOVFFL PLUSW1, ltemp0
1E5D6  F38C     NOP
1E5D8  F501     NOP
1E5DA  0E01     MOVLW 0x1
1E5DC  5E01     SUBWF __ptext283, F, ACCESS
1E5DE  0EF5     MOVLW 0xF5
1E5E0  0061     MOVFFL ltemp0, PLUSW1
1E5E2  F404     NOP
1E5E4  F4E3     NOP
1E5E6  0EF6     MOVLW 0xF6
1E5E8  0061     MOVFFL PLUSW1, ltemp0
1E5EA  F38C     NOP
1E5EC  F501     NOP
1E5EE  0E00     MOVLW 0x0
1E5F0  5A01     SUBWFB __ptext283, F, ACCESS
1E5F2  0EF6     MOVLW 0xF6
1E5F4  0061     MOVFFL ltemp0, PLUSW1
1E5F6  F404     NOP
1E5F8  F4E3     NOP
1E5FA  0EF5     MOVLW 0xF5
1E5FC  28E3     INCF 0xFE3, W, ACCESS
1E5FE  E1A6     BNZ 0xE54C
1E600  0EF6     MOVLW 0xF6
1E602  28E3     INCF 0xFE3, W, ACCESS
1E604  A4D8     BTFSS 0xFD8, 2, ACCESS
1E606  D7A2     BRA 0xE54C
14:            		tmp = *s++;
1E54C  0EFB     MOVLW 0xFB
1E54E  C4E3     MOVFF PLUSW1, TBLPTR
1E550  F4F6     NOP
1E552  0EFC     MOVLW 0xFC
1E554  C4E3     MOVFF PLUSW1, TBLPTRH
1E556  F4F7     NOP
1E558  0E00     MOVLW 0x0
1E55A  6EF8     MOVWF 0xFF8, ACCESS
1E55C  0E3F     MOVLW 0x3F
1E55E  64F7     CPFSGT 0xFF7, ACCESS
1E560  D003     BRA 0xE568
1E562  0008     TBLRD*
1E564  50F5     MOVF 0xFF5, W, ACCESS
1E566  D005     BRA 0xE572
1E568  C4F6     MOVFF TBLPTR, FSR0
1E56A  F4E9     NOP
1E56C  C4F7     MOVFF TBLPTRH, FSR0H
1E56E  F4EA     NOP
1E570  50EF     MOVF 0xFEF, W, ACCESS
1E572  6E0C     MOVWF 0xC, ACCESS
1E574  0EFF     MOVLW 0xFF
1E576  0061     MOVFFL 0x50C, PLUSW1
1E578  F430     NOP
1E57A  F4E3     NOP
1E57C  0EFB     MOVLW 0xFB
1E57E  50E3     MOVF 0xFE3, W, ACCESS
1E580  0F01     ADDLW 0x1
1E582  6E01     MOVWF __ptext283, ACCESS
1E584  0EFB     MOVLW 0xFB
1E586  0061     MOVFFL ltemp0, PLUSW1
1E588  F404     NOP
1E58A  F4E3     NOP
1E58C  6A01     CLRF __ptext283, ACCESS
1E58E  0EFC     MOVLW 0xFC
1E590  50E3     MOVF 0xFE3, W, ACCESS
1E592  2001     ADDWFC __ptext283, W, ACCESS
1E594  6E01     MOVWF __ptext283, ACCESS
1E596  0EFC     MOVLW 0xFC
1E598  0061     MOVFFL ltemp0, PLUSW1
1E59A  F404     NOP
1E59C  F4E3     NOP
15:            		*d++ = tmp;
1E59E  0EFD     MOVLW 0xFD
1E5A0  C4E3     MOVFF PLUSW1, FSR2
1E5A2  F4D9     NOP
1E5A4  0EFE     MOVLW 0xFE
1E5A6  C4E3     MOVFF PLUSW1, FSR2H
1E5A8  F4DA     NOP
1E5AA  0EFF     MOVLW 0xFF
1E5AC  C4E3     MOVFF PLUSW1, INDF2
1E5AE  F4DF     NOP
1E5B0  0EFD     MOVLW 0xFD
1E5B2  50E3     MOVF 0xFE3, W, ACCESS
1E5B4  0F01     ADDLW 0x1
1E5B6  6E01     MOVWF __ptext283, ACCESS
1E5B8  0EFD     MOVLW 0xFD
1E5BA  0061     MOVFFL ltemp0, PLUSW1
1E5BC  F404     NOP
1E5BE  F4E3     NOP
1E5C0  6A01     CLRF __ptext283, ACCESS
1E5C2  0EFE     MOVLW 0xFE
1E5C4  50E3     MOVF 0xFE3, W, ACCESS
1E5C6  2001     ADDWFC __ptext283, W, ACCESS
1E5C8  6E01     MOVWF __ptext283, ACCESS
1E5CA  0EFE     MOVLW 0xFE
1E5CC  0061     MOVFFL ltemp0, PLUSW1
1E5CE  F404     NOP
1E5D0  F4E3     NOP
16:            	}
17:            	return d1;
18:            }
1E608  0EF5     MOVLW 0xF5
1E60A  26E1     ADDWF 0xFE1, F, ACCESS
1E60C  0EFF     MOVLW 0xFF
1E60E  22E2     ADDWFC 0xFE2, F, ACCESS
1E60E  22E2     ADDWFC 0xFE2, F, ACCESS
19:            
---  /opt/microchip/xc8/v2.41/pic/sources/c99/common/lwmod.c  -------------------------------------------
1:             // word unsigned modulus
2:             
3:             unsigned int
4:             #ifdef __PICC__
5:             __lwmod(unsigned int divisor, unsigned int dividend)
6:             #else
7:             __lwmod(unsigned int dividend, unsigned int divisor)
1F784  52E6     MOVF 0xFE6, F, ACCESS
8:             #endif
9:             {
10:            	unsigned char	counter;
11:            
12:            	if(divisor != 0) {
1F786  0EFB     MOVLW 0xFB
1F788  0061     MOVFFL PLUSW1, ltemp0
1F78A  F38C     NOP
1F78C  F501     NOP
1F78E  0EFC     MOVLW 0xFC
1F790  50E3     MOVF 0xFE3, W, ACCESS
1F792  1001     IORWF __ptext283, W, ACCESS
1F794  B4D8     BTFSC 0xFD8, 2, ACCESS
1F796  D053     BRA 0xF83E
13:            		counter = 1;
1F798  0EFF     MOVLW 0xFF
1F79A  6AE3     CLRF 0xFE3, ACCESS
1F79C  D012     BRA 0xF7C2
14:            		while((divisor & 0x8000) == 0) {
1F7C4  0EFC     MOVLW 0xFC
1F7C6  AEE3     BTFSS 0xFE3, 7, ACCESS
1F7C8  D7EA     BRA 0xF79E
15:            			divisor <<= 1;
1F79E  0EFB     MOVLW 0xFB
1F7A0  50E3     MOVF 0xFE3, W, ACCESS
1F7A2  90D8     BCF 0xFD8, 0, ACCESS
1F7A4  34E8     RLCF 0xFE8, W, ACCESS
1F7A6  6E01     MOVWF __ptext283, ACCESS
1F7A8  0EFB     MOVLW 0xFB
1F7AA  0061     MOVFFL ltemp0, PLUSW1
1F7AC  F404     NOP
1F7AE  F4E3     NOP
1F7B0  0EFC     MOVLW 0xFC
1F7B2  50E3     MOVF 0xFE3, W, ACCESS
1F7B4  34E8     RLCF 0xFE8, W, ACCESS
1F7B6  6E01     MOVWF __ptext283, ACCESS
1F7B8  0EFC     MOVLW 0xFC
1F7BA  0061     MOVFFL ltemp0, PLUSW1
1F7BC  F404     NOP
1F7BE  F4E3     NOP
16:            			counter++;
1F7C0  0EFF     MOVLW 0xFF
1F7C2  2AE3     INCF 0xFE3, F, ACCESS
17:            		}
18:            		do {
19:            			if(divisor <= dividend)
1F7CA  0EFB     MOVLW 0xFB
1F7CC  0061     MOVFFL PLUSW1, wtemp5
1F7CE  F38C     NOP
1F7D0  F50B     NOP
1F7D2  0EFC     MOVLW 0xFC
1F7D4  0061     MOVFFL PLUSW1, 0x50C
1F7D6  F38C     NOP
1F7D8  F50C     NOP
1F7DA  0EFD     MOVLW 0xFD
1F7DC  0061     MOVFFL PLUSW1, ltemp2
1F7DE  F38C     NOP
1F7E0  F509     NOP
1F7E2  0EFE     MOVLW 0xFE
1F7E4  0061     MOVFFL PLUSW1, ttemp3
1F7E6  F38C     NOP
1F7E8  F50A     NOP
1F7EA  500B     MOVF 0xB, W, ACCESS
1F7EC  5C09     SUBWF 0x9, W, ACCESS
1F7EE  500C     MOVF 0xC, W, ACCESS
1F7F0  580A     SUBWFB 0xA, W, ACCESS
1F7F2  A0D8     BTFSS 0xFD8, 0, ACCESS
1F7F4  D014     BRA 0xF81E
20:            				dividend -= divisor;
1F7F6  0EFD     MOVLW 0xFD
1F7F8  50E3     MOVF 0xFE3, W, ACCESS
1F7FA  6E01     MOVWF __ptext283, ACCESS
1F7FC  0EFB     MOVLW 0xFB
1F7FE  50E3     MOVF 0xFE3, W, ACCESS
1F800  5E01     SUBWF __ptext283, F, ACCESS
1F802  0EFD     MOVLW 0xFD
1F804  0061     MOVFFL ltemp0, PLUSW1
1F806  F404     NOP
1F808  F4E3     NOP
1F80A  0EFE     MOVLW 0xFE
1F80C  50E3     MOVF 0xFE3, W, ACCESS
1F80E  6E01     MOVWF __ptext283, ACCESS
1F810  0EFC     MOVLW 0xFC
1F812  50E3     MOVF 0xFE3, W, ACCESS
1F814  5A01     SUBWFB __ptext283, F, ACCESS
1F816  0EFE     MOVLW 0xFE
1F818  0061     MOVFFL ltemp0, PLUSW1
1F81A  F404     NOP
1F81C  F4E3     NOP
21:            			divisor >>= 1;
1F81E  90D8     BCF 0xFD8, 0, ACCESS
1F820  0EFC     MOVLW 0xFC
1F822  32E3     RRCF 0xFE3, F, ACCESS
1F824  0EFB     MOVLW 0xFB
1F826  32E3     RRCF 0xFE3, F, ACCESS
22:            		} while(--counter != 0);
1F828  0EFF     MOVLW 0xFF
1F82A  50E3     MOVF 0xFE3, W, ACCESS
1F82C  6E01     MOVWF __ptext283, ACCESS
1F82E  0E01     MOVLW 0x1
1F830  5E01     SUBWF __ptext283, F, ACCESS
1F832  0EFF     MOVLW 0xFF
1F834  0061     MOVFFL ltemp0, PLUSW1
1F836  F404     NOP
1F838  F4E3     NOP
1F83A  A4D8     BTFSS 0xFD8, 2, ACCESS
1F83C  D7C6     BRA 0xF7CA
23:            	}
24:            	return dividend;
1F83E  0EFD     MOVLW 0xFD
1F840  0061     MOVFFL PLUSW1, ltemp0
1F842  F38C     NOP
1F844  F501     NOP
1F846  0EFE     MOVLW 0xFE
1F848  0061     MOVFFL PLUSW1, ttemp5
1F84A  F38C     NOP
1F84C  F502     NOP
25:            }
1F84E  0EFB     MOVLW 0xFB
1F850  26E1     ADDWF 0xFE1, F, ACCESS
1F852  0EFF     MOVLW 0xFF
1F854  22E2     ADDWFC 0xFE2, F, ACCESS
1F854  22E2     ADDWFC 0xFE2, F, ACCESS
---  /opt/microchip/xc8/v2.41/pic/sources/c99/common/lwdiv.c  -------------------------------------------
1:             // word unsigned division
2:             
3:             unsigned int
4:             #ifdef __PICC__
5:             __lwdiv(unsigned int divisor, unsigned int dividend)
6:             #else
7:             __lwdiv(unsigned int dividend, unsigned int divisor)
1EA3C  52E6     MOVF 0xFE6, F, ACCESS
1EA3E  52E6     MOVF 0xFE6, F, ACCESS
1EA40  52E6     MOVF 0xFE6, F, ACCESS
8:             #endif
9:             {
10:            	unsigned int	quotient;
11:            	unsigned char	counter;
12:            
13:            	quotient = 0;
1EA42  0EFD     MOVLW 0xFD
1EA44  6AE3     CLRF 0xFE3, ACCESS
1EA46  0EFE     MOVLW 0xFE
1EA48  6AE3     CLRF 0xFE3, ACCESS
14:            	if(divisor != 0) {
1EA4A  0EF9     MOVLW 0xF9
1EA4C  0061     MOVFFL PLUSW1, ltemp0
1EA4E  F38C     NOP
1EA50  F501     NOP
1EA52  0EFA     MOVLW 0xFA
1EA54  50E3     MOVF 0xFE3, W, ACCESS
1EA56  1001     IORWF __ptext283, W, ACCESS
1EA58  B4D8     BTFSC 0xFD8, 2, ACCESS
1EA5A  D066     BRA 0xEB28
15:            		counter = 1;
1EA5C  0EFF     MOVLW 0xFF
1EA5E  6AE3     CLRF 0xFE3, ACCESS
1EA60  D012     BRA 0xEA86
16:            		while((divisor & 0x8000) == 0) {
1EA88  0EFA     MOVLW 0xFA
1EA8A  AEE3     BTFSS 0xFE3, 7, ACCESS
1EA8C  D7EA     BRA 0xEA62
17:            			divisor <<= 1;
1EA62  0EF9     MOVLW 0xF9
1EA64  50E3     MOVF 0xFE3, W, ACCESS
1EA66  90D8     BCF 0xFD8, 0, ACCESS
1EA68  34E8     RLCF 0xFE8, W, ACCESS
1EA6A  6E01     MOVWF __ptext283, ACCESS
1EA6C  0EF9     MOVLW 0xF9
1EA6E  0061     MOVFFL ltemp0, PLUSW1
1EA70  F404     NOP
1EA72  F4E3     NOP
1EA74  0EFA     MOVLW 0xFA
1EA76  50E3     MOVF 0xFE3, W, ACCESS
1EA78  34E8     RLCF 0xFE8, W, ACCESS
1EA7A  6E01     MOVWF __ptext283, ACCESS
1EA7C  0EFA     MOVLW 0xFA
1EA7E  0061     MOVFFL ltemp0, PLUSW1
1EA80  F404     NOP
1EA82  F4E3     NOP
18:            			counter++;
1EA84  0EFF     MOVLW 0xFF
1EA86  2AE3     INCF 0xFE3, F, ACCESS
19:            		}
20:            		do {
21:            			quotient <<= 1;
1EA8E  0EFD     MOVLW 0xFD
1EA90  50E3     MOVF 0xFE3, W, ACCESS
1EA92  90D8     BCF 0xFD8, 0, ACCESS
1EA94  34E8     RLCF 0xFE8, W, ACCESS
1EA96  6E01     MOVWF __ptext283, ACCESS
1EA98  0EFD     MOVLW 0xFD
1EA9A  0061     MOVFFL ltemp0, PLUSW1
1EA9C  F404     NOP
1EA9E  F4E3     NOP
1EAA0  0EFE     MOVLW 0xFE
1EAA2  50E3     MOVF 0xFE3, W, ACCESS
1EAA4  34E8     RLCF 0xFE8, W, ACCESS
1EAA6  6E01     MOVWF __ptext283, ACCESS
1EAA8  0EFE     MOVLW 0xFE
1EAAA  0061     MOVFFL ltemp0, PLUSW1
1EAAC  F404     NOP
1EAAE  F4E3     NOP
22:            			if(divisor <= dividend) {
1EAB0  0EF9     MOVLW 0xF9
1EAB2  0061     MOVFFL PLUSW1, wtemp5
1EAB4  F38C     NOP
1EAB6  F50B     NOP
1EAB8  0EFA     MOVLW 0xFA
1EABA  0061     MOVFFL PLUSW1, 0x50C
1EABC  F38C     NOP
1EABE  F50C     NOP
1EAC0  0EFB     MOVLW 0xFB
1EAC2  0061     MOVFFL PLUSW1, ltemp2
1EAC4  F38C     NOP
1EAC6  F509     NOP
1EAC8  0EFC     MOVLW 0xFC
1EACA  0061     MOVFFL PLUSW1, ttemp3
1EACC  F38C     NOP
1EACE  F50A     NOP
1EAD0  500B     MOVF 0xB, W, ACCESS
1EAD2  5C09     SUBWF 0x9, W, ACCESS
1EAD4  500C     MOVF 0xC, W, ACCESS
1EAD6  580A     SUBWFB 0xA, W, ACCESS
1EAD8  A0D8     BTFSS 0xFD8, 0, ACCESS
1EADA  D016     BRA 0xEB08
23:            				dividend -= divisor;
1EADC  0EFB     MOVLW 0xFB
1EADE  50E3     MOVF 0xFE3, W, ACCESS
1EAE0  6E01     MOVWF __ptext283, ACCESS
1EAE2  0EF9     MOVLW 0xF9
1EAE4  50E3     MOVF 0xFE3, W, ACCESS
1EAE6  5E01     SUBWF __ptext283, F, ACCESS
1EAE8  0EFB     MOVLW 0xFB
1EAEA  0061     MOVFFL ltemp0, PLUSW1
1EAEC  F404     NOP
1EAEE  F4E3     NOP
1EAF0  0EFC     MOVLW 0xFC
1EAF2  50E3     MOVF 0xFE3, W, ACCESS
1EAF4  6E01     MOVWF __ptext283, ACCESS
1EAF6  0EFA     MOVLW 0xFA
1EAF8  50E3     MOVF 0xFE3, W, ACCESS
1EAFA  5A01     SUBWFB __ptext283, F, ACCESS
1EAFC  0EFC     MOVLW 0xFC
1EAFE  0061     MOVFFL ltemp0, PLUSW1
1EB00  F404     NOP
1EB02  F4E3     NOP
24:            				quotient |= 1;
1EB04  0EFD     MOVLW 0xFD
1EB06  80E3     BSF 0xFE3, 0, ACCESS
25:            			}
26:            			divisor >>= 1;
1EB08  90D8     BCF 0xFD8, 0, ACCESS
1EB0A  0EFA     MOVLW 0xFA
1EB0C  32E3     RRCF 0xFE3, F, ACCESS
1EB0E  0EF9     MOVLW 0xF9
1EB10  32E3     RRCF 0xFE3, F, ACCESS
27:            		} while(--counter != 0);
1EB12  0EFF     MOVLW 0xFF
1EB14  50E3     MOVF 0xFE3, W, ACCESS
1EB16  6E01     MOVWF __ptext283, ACCESS
1EB18  0E01     MOVLW 0x1
1EB1A  5E01     SUBWF __ptext283, F, ACCESS
1EB1C  0EFF     MOVLW 0xFF
1EB1E  0061     MOVFFL ltemp0, PLUSW1
1EB20  F404     NOP
1EB22  F4E3     NOP
1EB24  A4D8     BTFSS 0xFD8, 2, ACCESS
1EB26  D7B3     BRA 0xEA8E
28:            	}
29:            	return quotient;
1EB28  0EFD     MOVLW 0xFD
1EB2A  0061     MOVFFL PLUSW1, ltemp0
1EB2C  F38C     NOP
1EB2E  F501     NOP
1EB30  0EFE     MOVLW 0xFE
1EB32  0061     MOVFFL PLUSW1, ttemp5
1EB34  F38C     NOP
1EB36  F502     NOP
30:            }
1EB38  0EF9     MOVLW 0xF9
1EB3A  26E1     ADDWF 0xFE1, F, ACCESS
1EB3C  0EFF     MOVLW 0xFF
1EB3E  22E2     ADDWFC 0xFE2, F, ACCESS
1EB3E  22E2     ADDWFC 0xFE2, F, ACCESS
---  /opt/microchip/xc8/v2.41/pic/sources/c99/common/localtime.c  ---------------------------------------
1:             #include "../time_impl.h"
2:             
3:             struct tm *__gmtime_r(const time_t *restrict, struct tm *restrict);
4:             
5:             struct tm *localtime(const time_t *t)
2582  0EDF     MOVLW 0xDF
6:             {
7:             	static struct tm tm;
8:             	return __gmtime_r(t, &tm);
2584  6EE6     MOVWF 0xFE6, ACCESS
2586  0E09     MOVLW 0x9
2588  6EE6     MOVWF 0xFE6, ACCESS
258A  0EFC     MOVLW 0xFC
258C  C4E3     MOVFF PLUSW1, POSTINC1
258E  F4E6     NOP
2590  C4E3     MOVFF PLUSW1, POSTINC1
2592  F4E6     NOP
2594  EC56     CALL 0x1FAAC, 0
2596  F0FD     NOP
9:             }
2598  52E5     MOVF 0xFE5, F, ACCESS
259A  52E5     MOVF 0xFE5, F, ACCESS
259A  52E5     MOVF 0xFE5, F, ACCESS
---  /opt/microchip/xc8/v2.41/pic/sources/c99/common/llmod.c  -------------------------------------------
1:             // long unsigned unsigned modulus
2:             
3:             unsigned long int
4:             #ifdef __PICC__
5:             __llmod(unsigned long int divisor, unsigned long int dividend)
6:             #else
7:             __llmod(unsigned long int dividend, unsigned long int divisor)
1F5CE  52E6     MOVF 0xFE6, F, ACCESS
8:             #endif
9:             {
10:            	unsigned char	counter;
11:            
12:            	if(divisor != 0) {
1F5D0  0EF7     MOVLW 0xF7
1F5D2  50E3     MOVF 0xFE3, W, ACCESS
1F5D4  E10A     BNZ 0xF5EA
1F5D6  0EF8     MOVLW 0xF8
1F5D8  50E3     MOVF 0xFE3, W, ACCESS
1F5DA  E107     BNZ 0xF5EA
1F5DC  0EF9     MOVLW 0xF9
1F5DE  50E3     MOVF 0xFE3, W, ACCESS
1F5E0  E104     BNZ 0xF5EA
1F5E2  0EFA     MOVLW 0xFA
1F5E4  50E3     MOVF 0xFE3, W, ACCESS
1F5E6  B4D8     BTFSC 0xFD8, 2, ACCESS
1F5E8  D04D     BRA 0xF684
13:            		counter = 1;
1F5EA  0EFF     MOVLW 0xFF
1F5EC  6AE3     CLRF 0xFE3, ACCESS
1F5EE  D00A     BRA 0xF604
14:            		while((divisor & 0x80000000UL) == 0) {
1F606  0EFA     MOVLW 0xFA
1F608  AEE3     BTFSS 0xFE3, 7, ACCESS
1F60A  D7F2     BRA 0xF5F0
15:            			divisor <<= 1;
1F5F0  90D8     BCF 0xFD8, 0, ACCESS
1F5F2  0EF7     MOVLW 0xF7
1F5F4  36E3     RLCF 0xFE3, F, ACCESS
1F5F6  0EF8     MOVLW 0xF8
1F5F8  36E3     RLCF 0xFE3, F, ACCESS
1F5FA  0EF9     MOVLW 0xF9
1F5FC  36E3     RLCF 0xFE3, F, ACCESS
1F5FE  0EFA     MOVLW 0xFA
1F600  36E3     RLCF 0xFE3, F, ACCESS
16:            			counter++;
1F602  0EFF     MOVLW 0xFF
1F604  2AE3     INCF 0xFE3, F, ACCESS
17:            		}
18:            		do {
19:            			if((unsigned long)divisor <= (unsigned long)dividend)
1F60C  50E1     MOVF 0xFE1, W, ACCESS
1F60E  0FFB     ADDLW 0xFB
1F610  6ED9     MOVWF 0xFD9, ACCESS
1F612  50E2     MOVF 0xFE2, W, ACCESS
1F614  6EDA     MOVWF __end_of_UART2_tx_vect_isr, ACCESS
1F616  0EFF     MOVLW 0xFF
1F618  22DA     ADDWFC __end_of_UART2_tx_vect_isr, F, ACCESS
1F61A  0EF7     MOVLW 0xF7
1F61C  50E3     MOVF 0xFE3, W, ACCESS
1F61E  5CDE     SUBWF 0xFDE, W, ACCESS
1F620  0EF8     MOVLW 0xF8
1F622  50E3     MOVF 0xFE3, W, ACCESS
1F624  58DE     SUBWFB 0xFDE, W, ACCESS
1F626  0EF9     MOVLW 0xF9
1F628  50E3     MOVF 0xFE3, W, ACCESS
1F62A  58DE     SUBWFB 0xFDE, W, ACCESS
1F62C  0EFA     MOVLW 0xFA
1F62E  50E3     MOVF 0xFE3, W, ACCESS
1F630  58DE     SUBWFB 0xFDE, W, ACCESS
1F632  A0D8     BTFSS 0xFD8, 0, ACCESS
1F634  D013     BRA 0xF65C
20:            				dividend -= divisor;
1F636  50E1     MOVF 0xFE1, W, ACCESS
1F638  0FFB     ADDLW 0xFB
1F63A  6ED9     MOVWF 0xFD9, ACCESS
1F63C  50E2     MOVF 0xFE2, W, ACCESS
1F63E  6EDA     MOVWF __end_of_UART2_tx_vect_isr, ACCESS
1F640  0EFF     MOVLW 0xFF
1F642  22DA     ADDWFC __end_of_UART2_tx_vect_isr, F, ACCESS
1F644  0EF7     MOVLW 0xF7
1F646  50E3     MOVF 0xFE3, W, ACCESS
1F648  5EDE     SUBWF 0xFDE, F, ACCESS
1F64A  0EF8     MOVLW 0xF8
1F64C  50E3     MOVF 0xFE3, W, ACCESS
1F64E  5ADE     SUBWFB 0xFDE, F, ACCESS
1F650  0EF9     MOVLW 0xF9
1F652  50E3     MOVF 0xFE3, W, ACCESS
1F654  5ADE     SUBWFB 0xFDE, F, ACCESS
1F656  0EFA     MOVLW 0xFA
1F658  50E3     MOVF 0xFE3, W, ACCESS
1F65A  5ADE     SUBWFB 0xFDE, F, ACCESS
21:            			*(unsigned long int *)&divisor >>= 1;
1F65C  90D8     BCF 0xFD8, 0, ACCESS
1F65E  0EFA     MOVLW 0xFA
1F660  32E3     RRCF 0xFE3, F, ACCESS
1F662  0EF9     MOVLW 0xF9
1F664  32E3     RRCF 0xFE3, F, ACCESS
1F666  0EF8     MOVLW 0xF8
1F668  32E3     RRCF 0xFE3, F, ACCESS
1F66A  0EF7     MOVLW 0xF7
1F66C  32E3     RRCF 0xFE3, F, ACCESS
22:            		} while(--counter != 0);
1F66E  0EFF     MOVLW 0xFF
1F670  50E3     MOVF 0xFE3, W, ACCESS
1F672  6E01     MOVWF __ptext283, ACCESS
1F674  0E01     MOVLW 0x1
1F676  5E01     SUBWF __ptext283, F, ACCESS
1F678  0EFF     MOVLW 0xFF
1F67A  0061     MOVFFL ltemp0, PLUSW1
1F67C  F404     NOP
1F67E  F4E3     NOP
1F680  A4D8     BTFSS 0xFD8, 2, ACCESS
1F682  D7C4     BRA 0xF60C
23:            	}
24:            	return dividend;
1F684  0EFB     MOVLW 0xFB
1F686  0061     MOVFFL PLUSW1, ltemp0
1F688  F38C     NOP
1F68A  F501     NOP
1F68C  0EFC     MOVLW 0xFC
1F68E  0061     MOVFFL PLUSW1, ttemp5
1F690  F38C     NOP
1F692  F502     NOP
1F694  0EFD     MOVLW 0xFD
1F696  0061     MOVFFL PLUSW1, wtemp1
1F698  F38C     NOP
1F69A  F503     NOP
1F69C  0EFE     MOVLW 0xFE
1F69E  0061     MOVFFL PLUSW1, ttemp1
1F6A0  F38C     NOP
1F6A2  F504     NOP
25:            }
1F6A4  0EF7     MOVLW 0xF7
1F6A6  26E1     ADDWF 0xFE1, F, ACCESS
1F6A8  0EFF     MOVLW 0xFF
1F6AA  22E2     ADDWFC 0xFE2, F, ACCESS
1F6AA  22E2     ADDWFC 0xFE2, F, ACCESS
---  /opt/microchip/xc8/v2.41/pic/sources/c99/common/lbmod.c  -------------------------------------------
1:             // byte unsigned modulus
2:             
3:             unsigned char
4:             __lbmod(unsigned char dividend, unsigned char divisor)
02EA  52E6     MOVF 0xFE6, F, ACCESS
02EC  52E6     MOVF 0xFE6, F, ACCESS
5:             {
6:             	unsigned char	rem;
7:             	unsigned char	counter;
8:             
9:             	counter = 8;
02EE  0EFF     MOVLW 0xFF
02F0  6AE3     CLRF 0xFE3, ACCESS
02F2  86E3     BSF 0xFE3, 3, ACCESS
10:            	rem = 0;
02F4  0EFE     MOVLW 0xFE
02F6  6AE3     CLRF 0xFE3, ACCESS
11:            	do {
12:            		rem = (unsigned char)((rem << 1) | (dividend >> 7));
02F8  0EFD     MOVLW 0xFD
02FA  0061     MOVFFL PLUSW1, 0x50C
02FC  F38C     NOP
02FE  F50C     NOP
0300  0EFE     MOVLW 0xFE
0302  0061     MOVFFL PLUSW1, wtemp5
0304  F38C     NOP
0306  F50B     NOP
0308  90D8     BCF 0xFD8, 0, ACCESS
030A  340C     RLCF 0xC, W, ACCESS
030C  340B     RLCF 0xB, W, ACCESS
030E  6E0C     MOVWF 0xC, ACCESS
0310  0EFE     MOVLW 0xFE
0312  0061     MOVFFL 0x50C, PLUSW1
0314  F430     NOP
0316  F4E3     NOP
13:            		dividend <<= 1;
0318  50E1     MOVF 0xFE1, W, ACCESS
031A  0FFD     ADDLW 0xFD
031C  6ED9     MOVWF 0xFD9, ACCESS
031E  50E2     MOVF 0xFE2, W, ACCESS
0320  6EDA     MOVWF __end_of_UART2_tx_vect_isr, ACCESS
0322  0EFF     MOVLW 0xFF
0324  22DA     ADDWFC __end_of_UART2_tx_vect_isr, F, ACCESS
0326  90D8     BCF 0xFD8, 0, ACCESS
0328  36DF     RLCF 0xFDF, F, ACCESS
14:            		if(divisor <= rem)
032A  50E1     MOVF 0xFE1, W, ACCESS
032C  0FFE     ADDLW 0xFE
032E  6ED9     MOVWF 0xFD9, ACCESS
0330  50E2     MOVF 0xFE2, W, ACCESS
0332  6EDA     MOVWF __end_of_UART2_tx_vect_isr, ACCESS
0334  0EFF     MOVLW 0xFF
0336  22DA     ADDWFC __end_of_UART2_tx_vect_isr, F, ACCESS
0338  0EFC     MOVLW 0xFC
033A  50E3     MOVF 0xFE3, W, ACCESS
033C  5CDE     SUBWF 0xFDE, W, ACCESS
033E  A0D8     BTFSS 0xFD8, 0, ACCESS
0340  D00D     BRA 0x35C
15:            			rem -= divisor;
0342  0EFC     MOVLW 0xFC
0344  0061     MOVFFL PLUSW1, 0x50C
0346  F38C     NOP
0348  F50C     NOP
034A  50E1     MOVF 0xFE1, W, ACCESS
034C  0FFE     ADDLW 0xFE
034E  6ED9     MOVWF 0xFD9, ACCESS
0350  50E2     MOVF 0xFE2, W, ACCESS
0352  6EDA     MOVWF __end_of_UART2_tx_vect_isr, ACCESS
0354  0EFF     MOVLW 0xFF
0356  22DA     ADDWFC __end_of_UART2_tx_vect_isr, F, ACCESS
0358  500C     MOVF 0xC, W, ACCESS
035A  5EDF     SUBWF 0xFDF, F, ACCESS
16:            	} while(--counter != 0);
035C  0EFF     MOVLW 0xFF
035E  50E3     MOVF 0xFE3, W, ACCESS
0360  6E01     MOVWF __ptext283, ACCESS
0362  0E01     MOVLW 0x1
0364  5E01     SUBWF __ptext283, F, ACCESS
0366  0EFF     MOVLW 0xFF
0368  0061     MOVFFL ltemp0, PLUSW1
036A  F404     NOP
036C  F4E3     NOP
036E  A4D8     BTFSS 0xFD8, 2, ACCESS
0370  D7C3     BRA 0x2F8
17:            	return rem;
0372  0EFE     MOVLW 0xFE
0374  0061     MOVFFL PLUSW1, ltemp0
0376  F38C     NOP
0378  F501     NOP
18:            }
037A  52E5     MOVF 0xFE5, F, ACCESS
037C  52E5     MOVF 0xFE5, F, ACCESS
037E  52E5     MOVF 0xFE5, F, ACCESS
0380  52E5     MOVF 0xFE5, F, ACCESS
0380  52E5     MOVF 0xFE5, F, ACCESS
---  /opt/microchip/xc8/v2.41/pic/sources/c99/common/labs.c  --------------------------------------------
1:             long labs(long a)
2:             {
3:             	return a>0 ? a : -a;
08F4  0EFF     MOVLW 0xFF
08F6  BEE3     BTFSC 0xFE3, 7, ACCESS
08F8  D00D     BRA 0x914
08FA  0EFF     MOVLW 0xFF
08FC  50E3     MOVF 0xFE3, W, ACCESS
08FE  E124     BNZ 0x948
0900  0EFE     MOVLW 0xFE
0902  50E3     MOVF 0xFE3, W, ACCESS
0904  E121     BNZ 0x948
0906  0EFD     MOVLW 0xFD
0908  50E3     MOVF 0xFE3, W, ACCESS
090A  E11E     BNZ 0x948
090C  0EFC     MOVLW 0xFC
090E  04E3     DECF 0xFE3, W, ACCESS
0910  B0D8     BTFSC 0xFD8, 0, ACCESS
0912  D01A     BRA 0x948
0914  0EFC     MOVLW 0xFC
0916  0061     MOVFFL PLUSW1, ltemp0
0918  F38C     NOP
091A  F501     NOP
091C  0EFD     MOVLW 0xFD
091E  0061     MOVFFL PLUSW1, ttemp5
0920  F38C     NOP
0922  F502     NOP
0924  0EFE     MOVLW 0xFE
0926  0061     MOVFFL PLUSW1, wtemp1
0928  F38C     NOP
092A  F503     NOP
092C  0EFF     MOVLW 0xFF
092E  0061     MOVFFL PLUSW1, ttemp1
0930  F38C     NOP
0932  F504     NOP
0934  1E01     COMF __ptext283, F, ACCESS
0936  1E02     COMF ___rparam_used, F, ACCESS
0938  1E03     COMF __activetblptr, F, ACCESS
093A  1E04     COMF __activetblptr, F, ACCESS
093C  2A01     INCF __ptext283, F, ACCESS
093E  0E00     MOVLW 0x0
0940  2202     ADDWFC ___rparam_used, F, ACCESS
0942  2203     ADDWFC __activetblptr, F, ACCESS
0944  2204     ADDWFC __activetblptr, F, ACCESS
0946  D010     BRA 0x968
0948  0EFC     MOVLW 0xFC
094A  0061     MOVFFL PLUSW1, ltemp0
094C  F38C     NOP
094E  F501     NOP
0950  0EFD     MOVLW 0xFD
0952  0061     MOVFFL PLUSW1, ttemp5
0954  F38C     NOP
0956  F502     NOP
0958  0EFE     MOVLW 0xFE
095A  0061     MOVFFL PLUSW1, wtemp1
095C  F38C     NOP
095E  F503     NOP
0960  0EFF     MOVLW 0xFF
0962  0061     MOVFFL PLUSW1, ttemp1
0964  F38C     NOP
0966  F504     NOP
4:             }
0968  52E5     MOVF 0xFE5, F, ACCESS
096A  52E5     MOVF 0xFE5, F, ACCESS
096C  52E5     MOVF 0xFE5, F, ACCESS
096E  52E5     MOVF 0xFE5, F, ACCESS
096E  52E5     MOVF 0xFE5, F, ACCESS
---  /opt/microchip/xc8/v2.41/pic/sources/c99/common/isupper.c  -----------------------------------------
1:             #include <ctype.h>
2:             #include "libc.h"
3:             #undef isupper
4:             
5:             int isupper(int c)
6:             {
7:             	return (unsigned)c-'A' < 26;
1C86  0EFE     MOVLW 0xFE
1C88  50E3     MOVF 0xFE3, W, ACCESS
1C8A  0FBF     ADDLW 0xBF
1C8C  6E0B     MOVWF 0xB, ACCESS
1C8E  0EFF     MOVLW 0xFF
1C90  0061     MOVFFL PLUSW1, 0x50C
1C92  F38C     NOP
1C94  F50C     NOP
1C96  0EFF     MOVLW 0xFF
1C98  220C     ADDWFC 0xC, F, ACCESS
1C9A  500C     MOVF 0xC, W, ACCESS
1C9C  E106     BNZ 0x1CAA
1C9E  0E1A     MOVLW 0x1A
1CA0  5C0B     SUBWF 0xB, W, ACCESS
1CA2  B0D8     BTFSC 0xFD8, 0, ACCESS
1CA4  D002     BRA 0x1CAA
1CA6  0E01     MOVLW 0x1
1CA8  D001     BRA 0x1CAC
1CAA  0E00     MOVLW 0x0
1CAC  6E01     MOVWF __ptext283, ACCESS
1CAE  6A02     CLRF ___rparam_used, ACCESS
8:             }
1CB0  52E5     MOVF 0xFE5, F, ACCESS
1CB2  52E5     MOVF 0xFE5, F, ACCESS
1CB2  52E5     MOVF 0xFE5, F, ACCESS
9:             
10:            int __isupper_l(int c, locale_t l)
11:            {
12:            	return isupper(c);
13:            }
14:            
15:            weak_alias(__isupper_l, isupper_l);
---  /opt/microchip/xc8/v2.41/pic/sources/c99/common/islower.c  -----------------------------------------
1:             #include <ctype.h>
2:             #include "libc.h"
3:             #undef islower
4:             
5:             int islower(int c)
6:             {
7:             	return (unsigned)c-'a' < 26;
1C56  0EFE     MOVLW 0xFE
1C58  50E3     MOVF 0xFE3, W, ACCESS
1C5A  0F9F     ADDLW 0x9F
1C5C  6E0B     MOVWF 0xB, ACCESS
1C5E  0EFF     MOVLW 0xFF
1C60  0061     MOVFFL PLUSW1, 0x50C
1C62  F38C     NOP
1C64  F50C     NOP
1C66  0EFF     MOVLW 0xFF
1C68  220C     ADDWFC 0xC, F, ACCESS
1C6A  500C     MOVF 0xC, W, ACCESS
1C6C  E106     BNZ 0x1C7A
1C6E  0E1A     MOVLW 0x1A
1C70  5C0B     SUBWF 0xB, W, ACCESS
1C72  B0D8     BTFSC 0xFD8, 0, ACCESS
1C74  D002     BRA 0x1C7A
1C76  0E01     MOVLW 0x1
1C78  D001     BRA 0x1C7C
1C7A  0E00     MOVLW 0x0
1C7C  6E01     MOVWF __ptext283, ACCESS
1C7E  6A02     CLRF ___rparam_used, ACCESS
8:             }
1C80  52E5     MOVF 0xFE5, F, ACCESS
1C82  52E5     MOVF 0xFE5, F, ACCESS
1C82  52E5     MOVF 0xFE5, F, ACCESS
9:             
10:            int __islower_l(int c, locale_t l)
11:            {
12:            	return islower(c);
13:            }
14:            
15:            weak_alias(__islower_l, islower_l);
---  /opt/microchip/xc8/v2.41/pic/sources/c99/common/isalpha.c  -----------------------------------------
1:             #include <ctype.h>
2:             #include "libc.h"
3:             #undef isalpha
4:             
5:             int isalpha(int c)
6:             {
7:             	return ((unsigned)c|32)-'a' < 26;
178E  0EFE     MOVLW 0xFE
1790  0061     MOVFFL PLUSW1, wtemp5
1792  F38C     NOP
1794  F50B     NOP
1796  0EFF     MOVLW 0xFF
1798  0061     MOVFFL PLUSW1, 0x50C
179A  F38C     NOP
179C  F50C     NOP
179E  0E20     MOVLW 0x20
17A0  120B     IORWF 0xB, F, ACCESS
17A2  0E00     MOVLW 0x0
17A4  120C     IORWF 0xC, F, ACCESS
17A6  0E9F     MOVLW 0x9F
17A8  240B     ADDWF 0xB, W, ACCESS
17AA  6E09     MOVWF 0x9, ACCESS
17AC  0EFF     MOVLW 0xFF
17AE  200C     ADDWFC 0xC, W, ACCESS
17B0  6E0A     MOVWF 0xA, ACCESS
17B2  500A     MOVF 0xA, W, ACCESS
17B4  E106     BNZ 0x17C2
17B6  0E1A     MOVLW 0x1A
17B8  5C09     SUBWF 0x9, W, ACCESS
17BA  B0D8     BTFSC 0xFD8, 0, ACCESS
17BC  D002     BRA 0x17C2
17BE  0E01     MOVLW 0x1
17C0  D001     BRA 0x17C4
17C2  0E00     MOVLW 0x0
17C4  6E01     MOVWF __ptext283, ACCESS
17C6  6A02     CLRF ___rparam_used, ACCESS
8:             }
17C8  52E5     MOVF 0xFE5, F, ACCESS
17CA  52E5     MOVF 0xFE5, F, ACCESS
17CA  52E5     MOVF 0xFE5, F, ACCESS
9:             
10:            int __isalpha_l(int c, locale_t l)
11:            {
12:            	return isalpha(c);
13:            }
14:            
15:            weak_alias(__isalpha_l, isalpha_l);
---  /opt/microchip/xc8/v2.41/pic/sources/c99/common/gmtime_r.c  ----------------------------------------
1:             #include "../time_impl.h"
2:             #include <errno.h>
3:             #include "libc.h"
4:             
5:             struct tm *__gmtime_r(const time_t *restrict t, struct tm *restrict tm)
1FAAC  0EFC     MOVLW 0xFC
6:             {
7:             	if (__secs_to_tm(*t, tm) < 0) {
1FAAE  C4E3     MOVFF PLUSW1, POSTINC1
1FAB0  F4E6     NOP
1FAB2  C4E3     MOVFF PLUSW1, POSTINC1
1FAB4  F4E6     NOP
1FAB6  0EFC     MOVLW 0xFC
1FAB8  C4E3     MOVFF PLUSW1, FSR2
1FABA  F4D9     NOP
1FABC  0EFD     MOVLW 0xFD
1FABE  C4E3     MOVFF PLUSW1, FSR2H
1FAC0  F4DA     NOP
1FAC2  C4DE     MOVFF POSTINC2, POSTINC1
1FAC4  F4E6     NOP
1FAC6  C4DE     MOVFF POSTINC2, POSTINC1
1FAC8  F4E6     NOP
1FACA  C4DE     MOVFF POSTINC2, POSTINC1
1FACC  F4E6     NOP
1FACE  C4DE     MOVFF POSTINC2, POSTINC1
1FAD0  F4E6     NOP
1FAD2  EC5F     CALL 0x15CBE, 0
1FAD4  F0AE     NOP
1FAD6  AE02     BTFSS ___rparam_used, 7, ACCESS
1FAD8  D005     BRA 0xFAE4
8:             		errno = EOVERFLOW;
9:             		return 0;
1FADA  0E00     MOVLW 0x0
1FADC  6E01     MOVWF __ptext283, ACCESS
1FADE  0E00     MOVLW 0x0
1FAE0  6E02     MOVWF ___rparam_used, ACCESS
1FAE2  D03C     BRA 0xFB5C
10:            	}
11:            	tm->tm_isdst = 0;
1FAE4  0EFC     MOVLW 0xFC
1FAE6  0061     MOVFFL PLUSW1, wtemp5
1FAE8  F38C     NOP
1FAEA  F50B     NOP
1FAEC  0EFD     MOVLW 0xFD
1FAEE  0061     MOVFFL PLUSW1, 0x50C
1FAF0  F38C     NOP
1FAF2  F50C     NOP
1FAF4  0E10     MOVLW 0x10
1FAF6  240B     ADDWF 0xB, W, ACCESS
1FAF8  6ED9     MOVWF 0xFD9, ACCESS
1FAFA  0E00     MOVLW 0x0
1FAFC  200C     ADDWFC 0xC, W, ACCESS
1FAFE  6EDA     MOVWF __end_of_UART2_tx_vect_isr, ACCESS
1FB00  6ADE     CLRF 0xFDE, ACCESS
1FB02  6ADD     CLRF 0xFDD, ACCESS
12:            	tm->__tm_gmtoff = 0;
1FB04  0EFC     MOVLW 0xFC
1FB06  0061     MOVFFL PLUSW1, wtemp5
1FB08  F38C     NOP
1FB0A  F50B     NOP
1FB0C  0EFD     MOVLW 0xFD
1FB0E  0061     MOVFFL PLUSW1, 0x50C
1FB10  F38C     NOP
1FB12  F50C     NOP
1FB14  0E12     MOVLW 0x12
1FB16  240B     ADDWF 0xB, W, ACCESS
1FB18  6ED9     MOVWF 0xFD9, ACCESS
1FB1A  0E00     MOVLW 0x0
1FB1C  200C     ADDWFC 0xC, W, ACCESS
1FB1E  6EDA     MOVWF __end_of_UART2_tx_vect_isr, ACCESS
1FB20  6ADE     CLRF 0xFDE, ACCESS
1FB22  6ADE     CLRF 0xFDE, ACCESS
1FB24  6ADE     CLRF 0xFDE, ACCESS
1FB26  6ADD     CLRF 0xFDD, ACCESS
13:            	tm->__tm_zone = "GMT";
1FB28  0EFC     MOVLW 0xFC
1FB2A  0061     MOVFFL PLUSW1, wtemp5
1FB2C  F38C     NOP
1FB2E  F50B     NOP
1FB30  0EFD     MOVLW 0xFD
1FB32  0061     MOVFFL PLUSW1, 0x50C
1FB34  F38C     NOP
1FB36  F50C     NOP
1FB38  0E16     MOVLW 0x16
1FB3A  240B     ADDWF 0xB, W, ACCESS
1FB3C  6ED9     MOVWF 0xFD9, ACCESS
1FB3E  0E00     MOVLW 0x0
1FB40  200C     ADDWFC 0xC, W, ACCESS
1FB42  6EDA     MOVWF __end_of_UART2_tx_vect_isr, ACCESS
1FB44  0EF3     MOVLW 0xF3
1FB46  6EDE     MOVWF 0xFDE, ACCESS
1FB48  0EFF     MOVLW 0xFF
1FB4A  6EDD     MOVWF 0xFDD, ACCESS
14:            	return tm;
1FB4C  0EFC     MOVLW 0xFC
1FB4E  0061     MOVFFL PLUSW1, ltemp0
1FB50  F38C     NOP
1FB52  F501     NOP
1FB54  0EFD     MOVLW 0xFD
1FB56  0061     MOVFFL PLUSW1, ttemp5
1FB58  F38C     NOP
1FB5A  F502     NOP
15:            }
1FB5C  52E5     MOVF 0xFE5, F, ACCESS
1FB5E  52E5     MOVF 0xFE5, F, ACCESS
1FB60  52E5     MOVF 0xFE5, F, ACCESS
1FB62  52E5     MOVF 0xFE5, F, ACCESS
1FB62  52E5     MOVF 0xFE5, F, ACCESS
16:            
17:            weak_alias(__gmtime_r, gmtime_r);
---  /opt/microchip/xc8/v2.41/pic/sources/c99/common/fltol.c  -------------------------------------------
1:             /*	Floating point routines.
2:             
3:             	Copyright (c) 2012 Microchip Technology Inc. All rights reserved.
4:             */
5:             
6:             // this is bigendian code right now. Need to parameterise it.
7:             
8:             #include	"flarith.h"
9:             
10:            #define	f1_as_mant1	(*(unsigned long *)&f1)
11:            
12:            // Convert float to long
13:            #ifdef _OLDLIB
14:            long
15:            __fltol(double f1)
16:            {
17:            	unsigned char	sign1, exp1;
18:            	unsigned long	lval;
19:            
20:            	sign1 = __flunpack(&f1_as_mant1, &exp1);
21:            	lval = f1_as_mant1;
22:            	exp1 -= 127+23;
23:            	if((signed char)exp1 < 0) {
24:            		if((signed char)exp1 < -23)
25:            			return 0;
26:            		do
27:            			lval >>= 1;
28:            		while(++exp1 != 0);
29:            	} else {
30:            		if(exp1 >= 32)
31:            			return 00;
32:            		while(exp1 != 0) {
33:            			lval <<= 1;
34:            			exp1--;
35:            		}
36:            	}
37:            	if(sign1)
38:            		lval = -lval;
39:            	return lval;
40:            }
41:            #else
42:            long
43:            __fltol(double f1)
1D3E8  52E6     MOVF 0xFE6, F, ACCESS
1D3EA  52E6     MOVF 0xFE6, F, ACCESS
44:            {
45:            	unsigned char	sign1, exp1;
46:            
47:            	if((exp1 = (unsigned char)(f1_as_mant1 >> 23)) == 0)
1D3EC  0EFA     MOVLW 0xFA
1D3EE  0061     MOVFFL PLUSW1, ltemp2
1D3F0  F38C     NOP
1D3F2  F509     NOP
1D3F4  0EFB     MOVLW 0xFB
1D3F6  0061     MOVFFL PLUSW1, ttemp3
1D3F8  F38C     NOP
1D3FA  F50A     NOP
1D3FC  0EFC     MOVLW 0xFC
1D3FE  0061     MOVFFL PLUSW1, wtemp5
1D400  F38C     NOP
1D402  F50B     NOP
1D404  0EFD     MOVLW 0xFD
1D406  0061     MOVFFL PLUSW1, 0x50C
1D408  F38C     NOP
1D40A  F50C     NOP
1D40C  0E18     MOVLW 0x18
1D40E  D005     BRA 0xD41A
1D410  90D8     BCF 0xFD8, 0, ACCESS
1D412  320C     RRCF 0xC, F, ACCESS
1D414  320B     RRCF 0xB, F, ACCESS
1D416  320A     RRCF 0xA, F, ACCESS
1D418  3209     RRCF 0x9, F, ACCESS
1D41A  2EE8     DECFSZ 0xFE8, F, ACCESS
1D41C  D7F9     BRA 0xD410
1D41E  0EFE     MOVLW 0xFE
1D420  0061     MOVFFL ltemp2, PLUSW1
1D422  F424     NOP
1D424  F4E3     NOP
1D426  0EFE     MOVLW 0xFE
1D428  50E3     MOVF 0xFE3, W, ACCESS
1D42A  A4D8     BTFSS 0xFD8, 2, ACCESS
1D42C  D006     BRA 0xD43A
48:            		return 0;
1D42E  0E00     MOVLW 0x0
1D430  6E01     MOVWF __ptext283, ACCESS
1D432  6A02     CLRF ___rparam_used, ACCESS
1D434  6A03     CLRF __activetblptr, ACCESS
1D436  6A04     CLRF __activetblptr, ACCESS
1D438  D08B     BRA 0xD550
49:            	sign1 = f1_as_mant1 >> 31;
1D43A  0EFA     MOVLW 0xFA
1D43C  0061     MOVFFL PLUSW1, ltemp2
1D43E  F38C     NOP
1D440  F509     NOP
1D442  0EFB     MOVLW 0xFB
1D444  0061     MOVFFL PLUSW1, ttemp3
1D446  F38C     NOP
1D448  F50A     NOP
1D44A  0EFC     MOVLW 0xFC
1D44C  0061     MOVFFL PLUSW1, wtemp5
1D44E  F38C     NOP
1D450  F50B     NOP
1D452  0EFD     MOVLW 0xFD
1D454  0061     MOVFFL PLUSW1, 0x50C
1D456  F38C     NOP
1D458  F50C     NOP
1D45A  0E20     MOVLW 0x20
1D45C  D005     BRA 0xD468
1D45E  90D8     BCF 0xFD8, 0, ACCESS
1D460  320C     RRCF 0xC, F, ACCESS
1D462  320B     RRCF 0xB, F, ACCESS
1D464  320A     RRCF 0xA, F, ACCESS
1D466  3209     RRCF 0x9, F, ACCESS
1D468  2EE8     DECFSZ 0xFE8, F, ACCESS
1D46A  D7F9     BRA 0xD45E
1D46C  0EFF     MOVLW 0xFF
1D46E  0061     MOVFFL ltemp2, PLUSW1
1D470  F424     NOP
1D472  F4E3     NOP
50:            	f1_as_mant1 |= 0x800000UL;
1D474  0EFC     MOVLW 0xFC
1D476  8EE3     BSF 0xFE3, 7, ACCESS
51:            	f1_as_mant1 &= 0xFFFFFFUL;
1D478  50E1     MOVF 0xFE1, W, ACCESS
1D47A  0FFA     ADDLW 0xFA
1D47C  6ED9     MOVWF 0xFD9, ACCESS
1D47E  50E2     MOVF 0xFE2, W, ACCESS
1D480  6EDA     MOVWF __end_of_UART2_tx_vect_isr, ACCESS
1D482  0EFF     MOVLW 0xFF
1D484  22DA     ADDWFC __end_of_UART2_tx_vect_isr, F, ACCESS
1D486  0EFF     MOVLW 0xFF
1D488  16DE     ANDWF 0xFDE, F, ACCESS
1D48A  0EFF     MOVLW 0xFF
1D48C  16DE     ANDWF 0xFDE, F, ACCESS
1D48E  0EFF     MOVLW 0xFF
1D490  16DE     ANDWF 0xFDE, F, ACCESS
1D492  0E00     MOVLW 0x0
1D494  16DE     ANDWF 0xFDE, F, ACCESS
52:            	exp1 -= 127+23;
1D496  0EFE     MOVLW 0xFE
1D498  0061     MOVFFL PLUSW1, ltemp0
1D49A  F38C     NOP
1D49C  F501     NOP
1D49E  0E96     MOVLW 0x96
1D4A0  5E01     SUBWF __ptext283, F, ACCESS
1D4A2  0EFE     MOVLW 0xFE
1D4A4  0061     MOVFFL ltemp0, PLUSW1
1D4A6  F404     NOP
1D4A8  F4E3     NOP
53:            	if((signed char)exp1 < 0) {
1D4AA  0EFE     MOVLW 0xFE
1D4AC  AEE3     BTFSS 0xFE3, 7, ACCESS
1D4AE  D014     BRA 0xD4D8
54:            		if((signed char)exp1 < -23)
1D4B0  0EFE     MOVLW 0xFE
1D4B2  50E3     MOVF 0xFE3, W, ACCESS
1D4B4  0A80     XORLW 0x80
1D4B6  0F97     ADDLW 0x97
1D4B8  A0D8     BTFSS 0xFD8, 0, ACCESS
1D4BA  D7B9     BRA 0xD42E
55:            			return 0;
56:            		do
57:            			f1_as_mant1 >>= 1;
1D4BC  90D8     BCF 0xFD8, 0, ACCESS
1D4BE  0EFD     MOVLW 0xFD
1D4C0  32E3     RRCF 0xFE3, F, ACCESS
1D4C2  0EFC     MOVLW 0xFC
1D4C4  32E3     RRCF 0xFE3, F, ACCESS
1D4C6  0EFB     MOVLW 0xFB
1D4C8  32E3     RRCF 0xFE3, F, ACCESS
1D4CA  0EFA     MOVLW 0xFA
1D4CC  32E3     RRCF 0xFE3, F, ACCESS
1D4CE  0EFE     MOVLW 0xFE
1D4D0  2AE3     INCF 0xFE3, F, ACCESS
1D4D2  B4D8     BTFSC 0xFD8, 2, ACCESS
1D4D4  D018     BRA 0xD506
1D4D6  D7F2     BRA 0xD4BC
58:            		while(++exp1 != 0);
59:            	} else {
60:            		if(exp1 >= 32)
1D4D8  0EFE     MOVLW 0xFE
1D4DA  0061     MOVFFL PLUSW1, ltemp0
1D4DC  F38C     NOP
1D4DE  F501     NOP
1D4E0  0E1F     MOVLW 0x1F
1D4E2  6401     CPFSGT __ptext283, ACCESS
1D4E4  D00C     BRA 0xD4FE
1D4E6  D7A3     BRA 0xD42E
61:            			return 00;
62:            		while(exp1 != 0) {
1D4FE  0EFE     MOVLW 0xFE
1D500  50E3     MOVF 0xFE3, W, ACCESS
1D502  A4D8     BTFSS 0xFD8, 2, ACCESS
1D504  D7F1     BRA 0xD4E8
63:            			f1_as_mant1 <<= 1;
1D4E8  90D8     BCF 0xFD8, 0, ACCESS
1D4EA  0EFA     MOVLW 0xFA
1D4EC  36E3     RLCF 0xFE3, F, ACCESS
1D4EE  0EFB     MOVLW 0xFB
1D4F0  36E3     RLCF 0xFE3, F, ACCESS
1D4F2  0EFC     MOVLW 0xFC
1D4F4  36E3     RLCF 0xFE3, F, ACCESS
1D4F6  0EFD     MOVLW 0xFD
1D4F8  36E3     RLCF 0xFE3, F, ACCESS
64:            			exp1--;
1D4FA  0EFE     MOVLW 0xFE
1D4FC  06E3     DECF 0xFE3, F, ACCESS
65:            		}
66:            	}
67:            	if(sign1)
1D506  0EFF     MOVLW 0xFF
1D508  50E3     MOVF 0xFE3, W, ACCESS
1D50A  B4D8     BTFSC 0xFD8, 2, ACCESS
1D50C  D011     BRA 0xD530
68:            		f1_as_mant1 = -f1_as_mant1;
1D50E  0EFA     MOVLW 0xFA
1D510  6CE3     NEGF 0xFE3, ACCESS
1D512  0EFB     MOVLW 0xFB
1D514  1EE3     COMF 0xFE3, F, ACCESS
1D516  0EFC     MOVLW 0xFC
1D518  1EE3     COMF 0xFE3, F, ACCESS
1D51A  0EFD     MOVLW 0xFD
1D51C  1EE3     COMF 0xFE3, F, ACCESS
1D51E  E308     BNC 0xD530
1D520  0EFB     MOVLW 0xFB
1D522  2AE3     INCF 0xFE3, F, ACCESS
1D524  E305     BNC 0xD530
1D526  0EFC     MOVLW 0xFC
1D528  2AE3     INCF 0xFE3, F, ACCESS
1D52A  E302     BNC 0xD530
1D52C  0EFD     MOVLW 0xFD
1D52E  2AE3     INCF 0xFE3, F, ACCESS
69:            	return (long) f1_as_mant1;
1D530  0EFA     MOVLW 0xFA
1D532  0061     MOVFFL PLUSW1, ltemp0
1D534  F38C     NOP
1D536  F501     NOP
1D538  0EFB     MOVLW 0xFB
1D53A  0061     MOVFFL PLUSW1, ttemp5
1D53C  F38C     NOP
1D53E  F502     NOP
1D540  0EFC     MOVLW 0xFC
1D542  0061     MOVFFL PLUSW1, wtemp1
1D544  F38C     NOP
1D546  F503     NOP
1D548  0EFD     MOVLW 0xFD
1D54A  0061     MOVFFL PLUSW1, ttemp1
1D54C  F38C     NOP
1D54E  F504     NOP
70:            }
1D550  0EFA     MOVLW 0xFA
1D552  26E1     ADDWF 0xFE1, F, ACCESS
1D554  0EFF     MOVLW 0xFF
1D556  22E2     ADDWFC 0xFE2, F, ACCESS
1D556  22E2     ADDWFC 0xFE2, F, ACCESS
71:            #endif
---  /opt/microchip/xc8/v2.41/pic/sources/c99/common/floorf.c  ------------------------------------------
1:             #include "libm.h"
2:             
3:             float floorf(float x)
1A142  0E0A     MOVLW 0xA
1A144  26E1     ADDWF 0xFE1, F, ACCESS
1A146  0E00     MOVLW 0x0
1A148  22E2     ADDWFC 0xFE2, F, ACCESS
4:             {
5:             	union {float f; uint32_t i;} u = {x};
1A14A  0061     MOVFFL F526, ltemp2
1A14C  FC94     NOP
1A14E  F509     NOP
1A150  0061     MOVFFL 0x726, ttemp3
1A152  FC98     NOP
1A154  F50A     NOP
1A156  0061     MOVFFL 0x727, wtemp5
1A158  FC9C     NOP
1A15A  F50B     NOP
1A15C  0061     MOVFFL 0x728, 0x50C
1A15E  FCA0     NOP
1A160  F50C     NOP
1A162  0EF6     MOVLW 0xF6
1A164  0061     MOVFFL ltemp2, PLUSW1
1A166  F424     NOP
1A168  F4E3     NOP
1A16A  0EF7     MOVLW 0xF7
1A16C  0061     MOVFFL ttemp3, PLUSW1
1A16E  F428     NOP
1A170  F4E3     NOP
1A172  0EF8     MOVLW 0xF8
1A174  0061     MOVFFL wtemp5, PLUSW1
1A176  F42C     NOP
1A178  F4E3     NOP
1A17A  0EF9     MOVLW 0xF9
1A17C  0061     MOVFFL 0x50C, PLUSW1
1A17E  F430     NOP
1A180  F4E3     NOP
1A182  0EF2     MOVLW 0xF2
1A184  0061     MOVFFL PLUSW1, ltemp2
1A186  F38C     NOP
1A188  F509     NOP
1A18A  0EF3     MOVLW 0xF3
1A18C  0061     MOVFFL PLUSW1, ttemp3
1A18E  F38C     NOP
1A190  F50A     NOP
1A192  0EF4     MOVLW 0xF4
1A194  0061     MOVFFL PLUSW1, wtemp5
1A196  F38C     NOP
1A198  F50B     NOP
1A19A  0EF5     MOVLW 0xF5
1A19C  0061     MOVFFL PLUSW1, 0x50C
1A19E  F38C     NOP
1A1A0  F50C     NOP
1A1A2  0EF6     MOVLW 0xF6
1A1A4  0061     MOVFFL ltemp2, PLUSW1
1A1A6  F424     NOP
1A1A8  F4E3     NOP
1A1AA  0EF7     MOVLW 0xF7
1A1AC  0061     MOVFFL ttemp3, PLUSW1
1A1AE  F428     NOP
1A1B0  F4E3     NOP
1A1B2  0EF8     MOVLW 0xF8
1A1B4  0061     MOVFFL wtemp5, PLUSW1
1A1B6  F42C     NOP
1A1B8  F4E3     NOP
1A1BA  0EF9     MOVLW 0xF9
1A1BC  0061     MOVFFL 0x50C, PLUSW1
1A1BE  F430     NOP
1A1C0  F4E3     NOP
6:             	int e = (int)(u.i >> 23 & 0xff) - 0x7f;
1A1C2  0E81     MOVLW 0x81
1A1C4  6E0B     MOVWF 0xB, ACCESS
1A1C6  0EFF     MOVLW 0xFF
1A1C8  6E0C     MOVWF 0xC, ACCESS
1A1CA  0EF6     MOVLW 0xF6
1A1CC  0061     MOVFFL PLUSW1, ltemp1
1A1CE  F38C     NOP
1A1D0  F505     NOP
1A1D2  0EF7     MOVLW 0xF7
1A1D4  0061     MOVFFL PLUSW1, 0x506
1A1D6  F38C     NOP
1A1D8  F506     NOP
1A1DA  0EF8     MOVLW 0xF8
1A1DC  0061     MOVFFL PLUSW1, ttemp2
1A1DE  F38C     NOP
1A1E0  F507     NOP
1A1E2  0EF9     MOVLW 0xF9
1A1E4  0061     MOVFFL PLUSW1, 0x508
1A1E6  F38C     NOP
1A1E8  F508     NOP
1A1EA  0E18     MOVLW 0x18
1A1EC  D005     BRA 0xA1F8
1A1EE  90D8     BCF 0xFD8, 0, ACCESS
1A1F0  3208     RRCF 0x8, F, ACCESS
1A1F2  3207     RRCF 0x7, F, ACCESS
1A1F4  3206     RRCF 0x6, F, ACCESS
1A1F6  3205     RRCF 0x5, F, ACCESS
1A1F8  2EE8     DECFSZ 0xFE8, F, ACCESS
1A1FA  D7F9     BRA 0xA1EE
1A1FC  0061     MOVFFL ltemp1, ltemp2
1A1FE  F414     NOP
1A200  F509     NOP
1A202  0061     MOVFFL 0x506, ttemp3
1A204  F418     NOP
1A206  F50A     NOP
1A208  5009     MOVF 0x9, W, ACCESS
1A20A  240B     ADDWF 0xB, W, ACCESS
1A20C  6E09     MOVWF 0x9, ACCESS
1A20E  0E00     MOVLW 0x0
1A210  200C     ADDWFC 0xC, W, ACCESS
1A212  6E0A     MOVWF 0xA, ACCESS
1A214  0EFE     MOVLW 0xFE
1A216  0061     MOVFFL ltemp2, PLUSW1
1A218  F424     NOP
1A21A  F4E3     NOP
1A21C  0EFF     MOVLW 0xFF
1A21E  0061     MOVFFL ttemp3, PLUSW1
1A220  F428     NOP
1A222  F4E3     NOP
7:             	uint32_t m;
8:             
9:             	if (e >= 23)
1A224  0EFF     MOVLW 0xFF
1A226  BEE3     BTFSC 0xFE3, 7, ACCESS
1A228  D019     BRA 0xA25C
1A22A  0EFF     MOVLW 0xFF
1A22C  50E3     MOVF 0xFE3, W, ACCESS
1A22E  E108     BNZ 0xA240
1A230  0EFE     MOVLW 0xFE
1A232  0061     MOVFFL PLUSW1, ltemp0
1A234  F38C     NOP
1A236  F501     NOP
1A238  0E17     MOVLW 0x17
1A23A  5E01     SUBWF __ptext283, F, ACCESS
1A23C  A0D8     BTFSS 0xFD8, 0, ACCESS
1A23E  D00E     BRA 0xA25C
10:            		return x;
1A240  0EF2     MOVLW 0xF2
1A242  0061     MOVFFL PLUSW1, ltemp0
1A244  F38C     NOP
1A246  F501     NOP
1A248  0EF3     MOVLW 0xF3
1A24A  0061     MOVFFL PLUSW1, ttemp5
1A24C  F38C     NOP
1A24E  F502     NOP
1A250  0EF4     MOVLW 0xF4
1A252  0061     MOVFFL PLUSW1, wtemp1
1A254  F38C     NOP
1A256  F503     NOP
1A258  0EF5     MOVLW 0xF5
1A25A  D11F     BRA 0xA49A
11:            	if (e >= 0) {
1A25C  0EFF     MOVLW 0xFF
1A25E  BEE3     BTFSC 0xFE3, 7, ACCESS
1A260  D0B4     BRA 0xA3CA
12:            		m = 0x007fffff >> e;
1A262  0EFE     MOVLW 0xFE
1A264  0061     MOVFFL PLUSW1, 0x50C
1A266  F38C     NOP
1A268  F50C     NOP
1A26A  0EFF     MOVLW 0xFF
1A26C  6E05     MOVWF 0x5, ACCESS
1A26E  0EFF     MOVLW 0xFF
1A270  6E06     MOVWF 0x6, ACCESS
1A272  0E7F     MOVLW 0x7F
1A274  6E07     MOVWF 0x7, ACCESS
1A276  0E00     MOVLW 0x0
1A278  6E08     MOVWF 0x8, ACCESS
1A27A  660C     TSTFSZ 0xC, ACCESS
1A27C  D001     BRA 0xA280
1A27E  D007     BRA 0xA28E
1A280  3408     RLCF 0x8, W, ACCESS
1A282  3208     RRCF 0x8, F, ACCESS
1A284  3207     RRCF 0x7, F, ACCESS
1A286  3206     RRCF 0x6, F, ACCESS
1A288  3205     RRCF 0x5, F, ACCESS
1A28A  2E0C     DECFSZ 0xC, F, ACCESS
1A28C  D7F6     BRA 0xA27A
1A28E  0EFA     MOVLW 0xFA
1A290  0061     MOVFFL ltemp1, PLUSW1
1A292  F414     NOP
1A294  F4E3     NOP
1A296  0EFB     MOVLW 0xFB
1A298  0061     MOVFFL 0x506, PLUSW1
1A29A  F418     NOP
1A29C  F4E3     NOP
1A29E  0EFC     MOVLW 0xFC
1A2A0  0061     MOVFFL ttemp2, PLUSW1
1A2A2  F41C     NOP
1A2A4  F4E3     NOP
1A2A6  0EFD     MOVLW 0xFD
1A2A8  0061     MOVFFL 0x508, PLUSW1
1A2AA  F420     NOP
1A2AC  F4E3     NOP
13:            		if ((u.i & m) == 0)
1A2AE  0EF6     MOVLW 0xF6
1A2B0  0061     MOVFFL PLUSW1, ltemp2
1A2B2  F38C     NOP
1A2B4  F509     NOP
1A2B6  0EF7     MOVLW 0xF7
1A2B8  0061     MOVFFL PLUSW1, ttemp3
1A2BA  F38C     NOP
1A2BC  F50A     NOP
1A2BE  0EF8     MOVLW 0xF8
1A2C0  0061     MOVFFL PLUSW1, wtemp5
1A2C2  F38C     NOP
1A2C4  F50B     NOP
1A2C6  0EF9     MOVLW 0xF9
1A2C8  0061     MOVFFL PLUSW1, 0x50C
1A2CA  F38C     NOP
1A2CC  F50C     NOP
1A2CE  0EFA     MOVLW 0xFA
1A2D0  50E3     MOVF 0xFE3, W, ACCESS
1A2D2  1609     ANDWF 0x9, F, ACCESS
1A2D4  0EFB     MOVLW 0xFB
1A2D6  50E3     MOVF 0xFE3, W, ACCESS
1A2D8  160A     ANDWF 0xA, F, ACCESS
1A2DA  0EFC     MOVLW 0xFC
1A2DC  50E3     MOVF 0xFE3, W, ACCESS
1A2DE  160B     ANDWF 0xB, F, ACCESS
1A2E0  0EFD     MOVLW 0xFD
1A2E2  50E3     MOVF 0xFE3, W, ACCESS
1A2E4  160C     ANDWF 0xC, F, ACCESS
1A2E6  5009     MOVF 0x9, W, ACCESS
1A2E8  100A     IORWF 0xA, W, ACCESS
1A2EA  100B     IORWF 0xB, W, ACCESS
1A2EC  100C     IORWF 0xC, W, ACCESS
1A2EE  B4D8     BTFSC 0xFD8, 2, ACCESS
1A2F0  D7A7     BRA 0xA240
14:            			return x;
15:            		FORCE_EVAL(x + 0x1p120f);
16:            		if (u.i >> 31)
1A2F2  0EF6     MOVLW 0xF6
1A2F4  0061     MOVFFL PLUSW1, ltemp2
1A2F6  F38C     NOP
1A2F8  F509     NOP
1A2FA  0EF7     MOVLW 0xF7
1A2FC  0061     MOVFFL PLUSW1, ttemp3
1A2FE  F38C     NOP
1A300  F50A     NOP
1A302  0EF8     MOVLW 0xF8
1A304  0061     MOVFFL PLUSW1, wtemp5
1A306  F38C     NOP
1A308  F50B     NOP
1A30A  0EF9     MOVLW 0xF9
1A30C  0061     MOVFFL PLUSW1, 0x50C
1A30E  F38C     NOP
1A310  F50C     NOP
1A312  0E20     MOVLW 0x20
1A314  D005     BRA 0xA320
1A316  90D8     BCF 0xFD8, 0, ACCESS
1A318  320C     RRCF 0xC, F, ACCESS
1A31A  320B     RRCF 0xB, F, ACCESS
1A31C  320A     RRCF 0xA, F, ACCESS
1A31E  3209     RRCF 0x9, F, ACCESS
1A320  2EE8     DECFSZ 0xFE8, F, ACCESS
1A322  D7F9     BRA 0xA316
1A324  5009     MOVF 0x9, W, ACCESS
1A326  B4D8     BTFSC 0xFD8, 2, ACCESS
1A328  D028     BRA 0xA37A
17:            			u.i += m;
1A32A  0EF6     MOVLW 0xF6
1A32C  50E3     MOVF 0xFE3, W, ACCESS
1A32E  6E01     MOVWF __ptext283, ACCESS
1A330  0EFA     MOVLW 0xFA
1A332  50E3     MOVF 0xFE3, W, ACCESS
1A334  2601     ADDWF __ptext283, F, ACCESS
1A336  0EF6     MOVLW 0xF6
1A338  0061     MOVFFL ltemp0, PLUSW1
1A33A  F404     NOP
1A33C  F4E3     NOP
1A33E  0EF7     MOVLW 0xF7
1A340  50E3     MOVF 0xFE3, W, ACCESS
1A342  6E01     MOVWF __ptext283, ACCESS
1A344  0EFB     MOVLW 0xFB
1A346  50E3     MOVF 0xFE3, W, ACCESS
1A348  2201     ADDWFC __ptext283, F, ACCESS
1A34A  0EF7     MOVLW 0xF7
1A34C  0061     MOVFFL ltemp0, PLUSW1
1A34E  F404     NOP
1A350  F4E3     NOP
1A352  0EF8     MOVLW 0xF8
1A354  50E3     MOVF 0xFE3, W, ACCESS
1A356  6E01     MOVWF __ptext283, ACCESS
1A358  0EFC     MOVLW 0xFC
1A35A  50E3     MOVF 0xFE3, W, ACCESS
1A35C  2201     ADDWFC __ptext283, F, ACCESS
1A35E  0EF8     MOVLW 0xF8
1A360  0061     MOVFFL ltemp0, PLUSW1
1A362  F404     NOP
1A364  F4E3     NOP
1A366  0EF9     MOVLW 0xF9
1A368  50E3     MOVF 0xFE3, W, ACCESS
1A36A  6E01     MOVWF __ptext283, ACCESS
1A36C  0EFD     MOVLW 0xFD
1A36E  50E3     MOVF 0xFE3, W, ACCESS
1A370  2201     ADDWFC __ptext283, F, ACCESS
1A372  0EF9     MOVLW 0xF9
1A374  0061     MOVFFL ltemp0, PLUSW1
1A376  F404     NOP
1A378  F4E3     NOP
18:            		u.i &= ~m;
1A37A  0EFA     MOVLW 0xFA
1A37C  0061     MOVFFL PLUSW1, ltemp2
1A37E  F38C     NOP
1A380  F509     NOP
1A382  0EFB     MOVLW 0xFB
1A384  0061     MOVFFL PLUSW1, ttemp3
1A386  F38C     NOP
1A388  F50A     NOP
1A38A  0EFC     MOVLW 0xFC
1A38C  0061     MOVFFL PLUSW1, wtemp5
1A38E  F38C     NOP
1A390  F50B     NOP
1A392  0EFD     MOVLW 0xFD
1A394  0061     MOVFFL PLUSW1, 0x50C
1A396  F38C     NOP
1A398  F50C     NOP
1A39A  1C09     COMF 0x9, W, ACCESS
1A39C  6E05     MOVWF 0x5, ACCESS
1A39E  1C0A     COMF 0xA, W, ACCESS
1A3A0  6E06     MOVWF 0x6, ACCESS
1A3A2  1C0B     COMF 0xB, W, ACCESS
1A3A4  6E07     MOVWF 0x7, ACCESS
1A3A6  1C0C     COMF 0xC, W, ACCESS
1A3A8  6E08     MOVWF 0x8, ACCESS
1A3AA  50E1     MOVF 0xFE1, W, ACCESS
1A3AC  0FF6     ADDLW 0xF6
1A3AE  6ED9     MOVWF 0xFD9, ACCESS
1A3B0  50E2     MOVF 0xFE2, W, ACCESS
1A3B2  6EDA     MOVWF __end_of_UART2_tx_vect_isr, ACCESS
1A3B4  0EFF     MOVLW 0xFF
1A3B6  22DA     ADDWFC __end_of_UART2_tx_vect_isr, F, ACCESS
1A3B8  5005     MOVF 0x5, W, ACCESS
1A3BA  16DE     ANDWF 0xFDE, F, ACCESS
1A3BC  5006     MOVF 0x6, W, ACCESS
1A3BE  16DE     ANDWF 0xFDE, F, ACCESS
1A3C0  5007     MOVF 0x7, W, ACCESS
1A3C2  16DE     ANDWF 0xFDE, F, ACCESS
1A3C4  5008     MOVF 0x8, W, ACCESS
1A3C6  16DE     ANDWF 0xFDE, F, ACCESS
19:            	} else {
1A3C8  D05B     BRA 0xA480
20:            		FORCE_EVAL(x + 0x1p120f);
21:            		if (u.i >> 31 == 0)
1A3CA  0EF6     MOVLW 0xF6
1A3CC  0061     MOVFFL PLUSW1, ltemp2
1A3CE  F38C     NOP
1A3D0  F509     NOP
1A3D2  0EF7     MOVLW 0xF7
1A3D4  0061     MOVFFL PLUSW1, ttemp3
1A3D6  F38C     NOP
1A3D8  F50A     NOP
1A3DA  0EF8     MOVLW 0xF8
1A3DC  0061     MOVFFL PLUSW1, wtemp5
1A3DE  F38C     NOP
1A3E0  F50B     NOP
1A3E2  0EF9     MOVLW 0xF9
1A3E4  0061     MOVFFL PLUSW1, 0x50C
1A3E6  F38C     NOP
1A3E8  F50C     NOP
1A3EA  0E20     MOVLW 0x20
1A3EC  D005     BRA 0xA3F8
1A3EE  90D8     BCF 0xFD8, 0, ACCESS
1A3F0  320C     RRCF 0xC, F, ACCESS
1A3F2  320B     RRCF 0xB, F, ACCESS
1A3F4  320A     RRCF 0xA, F, ACCESS
1A3F6  3209     RRCF 0x9, F, ACCESS
1A3F8  2EE8     DECFSZ 0xFE8, F, ACCESS
1A3FA  D7F9     BRA 0xA3EE
1A3FC  6609     TSTFSZ 0x9, ACCESS
1A3FE  D009     BRA 0xA412
22:            			u.i = 0;
1A400  0EF6     MOVLW 0xF6
1A402  6AE3     CLRF 0xFE3, ACCESS
1A404  0EF7     MOVLW 0xF7
1A406  6AE3     CLRF 0xFE3, ACCESS
1A408  0EF8     MOVLW 0xF8
1A40A  6AE3     CLRF 0xFE3, ACCESS
1A40C  0EF9     MOVLW 0xF9
1A40E  6AE3     CLRF 0xFE3, ACCESS
1A410  D037     BRA 0xA480
23:            		else if (u.i << 1)
1A412  0EF6     MOVLW 0xF6
1A414  0061     MOVFFL PLUSW1, ltemp2
1A416  F38C     NOP
1A418  F509     NOP
1A41A  0EF7     MOVLW 0xF7
1A41C  0061     MOVFFL PLUSW1, ttemp3
1A41E  F38C     NOP
1A420  F50A     NOP
1A422  0EF8     MOVLW 0xF8
1A424  0061     MOVFFL PLUSW1, wtemp5
1A426  F38C     NOP
1A428  F50B     NOP
1A42A  0EF9     MOVLW 0xF9
1A42C  0061     MOVFFL PLUSW1, 0x50C
1A42E  F38C     NOP
1A430  F50C     NOP
1A432  90D8     BCF 0xFD8, 0, ACCESS
1A434  3409     RLCF 0x9, W, ACCESS
1A436  6E05     MOVWF 0x5, ACCESS
1A438  340A     RLCF 0xA, W, ACCESS
1A43A  6E06     MOVWF 0x6, ACCESS
1A43C  340B     RLCF 0xB, W, ACCESS
1A43E  6E07     MOVWF 0x7, ACCESS
1A440  340C     RLCF 0xC, W, ACCESS
1A442  6E08     MOVWF 0x8, ACCESS
1A444  5005     MOVF 0x5, W, ACCESS
1A446  1006     IORWF 0x6, W, ACCESS
1A448  1007     IORWF 0x7, W, ACCESS
1A44A  1008     IORWF 0x8, W, ACCESS
1A44C  B4D8     BTFSC 0xFD8, 2, ACCESS
1A44E  D018     BRA 0xA480
24:            			u.f = -1.0;
1A450  0E00     MOVLW 0x0
1A452  6E09     MOVWF 0x9, ACCESS
1A454  0E00     MOVLW 0x0
1A456  6E0A     MOVWF 0xA, ACCESS
1A458  0E80     MOVLW 0x80
1A45A  6E0B     MOVWF 0xB, ACCESS
1A45C  0EBF     MOVLW 0xBF
1A45E  6E0C     MOVWF 0xC, ACCESS
1A460  0EF6     MOVLW 0xF6
1A462  0061     MOVFFL ltemp2, PLUSW1
1A464  F424     NOP
1A466  F4E3     NOP
1A468  0EF7     MOVLW 0xF7
1A46A  0061     MOVFFL ttemp3, PLUSW1
1A46C  F428     NOP
1A46E  F4E3     NOP
1A470  0EF8     MOVLW 0xF8
1A472  0061     MOVFFL wtemp5, PLUSW1
1A474  F42C     NOP
1A476  F4E3     NOP
1A478  0EF9     MOVLW 0xF9
1A47A  0061     MOVFFL 0x50C, PLUSW1
1A47C  F430     NOP
1A47E  F4E3     NOP
25:            	}
26:            	return u.f;
1A480  0EF6     MOVLW 0xF6
1A482  0061     MOVFFL PLUSW1, ltemp0
1A484  F38C     NOP
1A486  F501     NOP
1A488  0EF7     MOVLW 0xF7
1A48A  0061     MOVFFL PLUSW1, ttemp5
1A48C  F38C     NOP
1A48E  F502     NOP
1A490  0EF8     MOVLW 0xF8
1A492  0061     MOVFFL PLUSW1, wtemp1
1A494  F38C     NOP
1A496  F503     NOP
1A498  0EF9     MOVLW 0xF9
1A49A  0061     MOVFFL PLUSW1, ttemp1
1A49C  F38C     NOP
1A49E  F504     NOP
27:            }
1A4A0  0EF2     MOVLW 0xF2
1A4A2  26E1     ADDWF 0xFE1, F, ACCESS
1A4A4  0EFF     MOVLW 0xFF
1A4A6  22E2     ADDWFC 0xFE2, F, ACCESS
1A4A6  22E2     ADDWFC 0xFE2, F, ACCESS
---  /opt/microchip/xc8/v2.41/pic/sources/c99/common/flneg.c  -------------------------------------------
1:             /*	Floating point routines.
2:             
3:             	Copyright (c) 2012 Microchip Technology Inc. All rights reserved.
4:             */
5:             
6:             // this is bigendian code right now. Need to parameterise it.
7:             
8:             #include	"ftarith.h"
9:             
10:            #define	mant1	(*(unsigned long *)&f1)
11:            
12:            // Negate a float
13:            
14:            double
15:            __flneg(double f1)
16:            {
17:            	if(mant1 != 0x0)
144A  0EFC     MOVLW 0xFC
144C  50E3     MOVF 0xFE3, W, ACCESS
144E  E10A     BNZ 0x1464
1450  0EFD     MOVLW 0xFD
1452  50E3     MOVF 0xFE3, W, ACCESS
1454  E107     BNZ 0x1464
1456  0EFE     MOVLW 0xFE
1458  50E3     MOVF 0xFE3, W, ACCESS
145A  E104     BNZ 0x1464
145C  0EFF     MOVLW 0xFF
145E  50E3     MOVF 0xFE3, W, ACCESS
1460  B4D8     BTFSC 0xFD8, 2, ACCESS
1462  D002     BRA 0x1468
18:            		mant1 ^= 0x80000000UL;
1464  0EFF     MOVLW 0xFF
1466  7EE3     BTG 0xFE3, 7, ACCESS
19:            	return f1;
1468  0EFC     MOVLW 0xFC
146A  0061     MOVFFL PLUSW1, ltemp0
146C  F38C     NOP
146E  F501     NOP
1470  0EFD     MOVLW 0xFD
1472  0061     MOVFFL PLUSW1, ttemp5
1474  F38C     NOP
1476  F502     NOP
1478  0EFE     MOVLW 0xFE
147A  0061     MOVFFL PLUSW1, wtemp1
147C  F38C     NOP
147E  F503     NOP
1480  0EFF     MOVLW 0xFF
1482  0061     MOVFFL PLUSW1, ttemp1
1484  F38C     NOP
1486  F504     NOP
20:            }
1488  52E5     MOVF 0xFE5, F, ACCESS
148A  52E5     MOVF 0xFE5, F, ACCESS
148C  52E5     MOVF 0xFE5, F, ACCESS
148E  52E5     MOVF 0xFE5, F, ACCESS
148E  52E5     MOVF 0xFE5, F, ACCESS
---  /opt/microchip/xc8/v2.41/pic/sources/c99/common/flge.c  --------------------------------------------
1:             #define	f1	(*(unsigned long *)&ff1)
2:             #define	f2	(*(unsigned long *)&ff2)
3:             __bit
4:             __flge(double ff1, double ff2)
5:             {
6:                     // flush denorms and zeroes to +ve 0.0
7:                     if((f1 &  0x7F800000UL)== 0)
1D6C0  50E1     MOVF 0xFE1, W, ACCESS
1D6C2  0FFC     ADDLW 0xFC
1D6C4  6ED9     MOVWF 0xFD9, ACCESS
1D6C6  50E2     MOVF 0xFE2, W, ACCESS
1D6C8  6EDA     MOVWF __end_of_UART2_tx_vect_isr, ACCESS
1D6CA  0EFF     MOVLW 0xFF
1D6CC  22DA     ADDWFC __end_of_UART2_tx_vect_isr, F, ACCESS
1D6CE  0E00     MOVLW 0x0
1D6D0  14DE     ANDWF 0xFDE, W, ACCESS
1D6D2  6E09     MOVWF 0x9, ACCESS
1D6D4  0E00     MOVLW 0x0
1D6D6  14DE     ANDWF 0xFDE, W, ACCESS
1D6D8  6E0A     MOVWF 0xA, ACCESS
1D6DA  0E80     MOVLW 0x80
1D6DC  14DE     ANDWF 0xFDE, W, ACCESS
1D6DE  6E0B     MOVWF 0xB, ACCESS
1D6E0  0E7F     MOVLW 0x7F
1D6E2  14DE     ANDWF 0xFDE, W, ACCESS
1D6E4  6E0C     MOVWF 0xC, ACCESS
1D6E6  5009     MOVF 0x9, W, ACCESS
1D6E8  100A     IORWF 0xA, W, ACCESS
1D6EA  100B     IORWF 0xB, W, ACCESS
1D6EC  100C     IORWF 0xC, W, ACCESS
1D6EE  A4D8     BTFSS 0xFD8, 2, ACCESS
1D6F0  D008     BRA 0xD702
8:             		f1 = 0x00000000UL;
1D6F2  0EFC     MOVLW 0xFC
1D6F4  6AE3     CLRF 0xFE3, ACCESS
1D6F6  0EFD     MOVLW 0xFD
1D6F8  6AE3     CLRF 0xFE3, ACCESS
1D6FA  0EFE     MOVLW 0xFE
1D6FC  6AE3     CLRF 0xFE3, ACCESS
1D6FE  0EFF     MOVLW 0xFF
1D700  6AE3     CLRF 0xFE3, ACCESS
9:             	if((f2 &  0x7F800000UL)== 0)
1D702  50E1     MOVF 0xFE1, W, ACCESS
1D704  0FF8     ADDLW 0xF8
1D706  6ED9     MOVWF 0xFD9, ACCESS
1D708  50E2     MOVF 0xFE2, W, ACCESS
1D70A  6EDA     MOVWF __end_of_UART2_tx_vect_isr, ACCESS
1D70C  0EFF     MOVLW 0xFF
1D70E  22DA     ADDWFC __end_of_UART2_tx_vect_isr, F, ACCESS
1D710  0E00     MOVLW 0x0
1D712  14DE     ANDWF 0xFDE, W, ACCESS
1D714  6E09     MOVWF 0x9, ACCESS
1D716  0E00     MOVLW 0x0
1D718  14DE     ANDWF 0xFDE, W, ACCESS
1D71A  6E0A     MOVWF 0xA, ACCESS
1D71C  0E80     MOVLW 0x80
1D71E  14DE     ANDWF 0xFDE, W, ACCESS
1D720  6E0B     MOVWF 0xB, ACCESS
1D722  0E7F     MOVLW 0x7F
1D724  14DE     ANDWF 0xFDE, W, ACCESS
1D726  6E0C     MOVWF 0xC, ACCESS
1D728  5009     MOVF 0x9, W, ACCESS
1D72A  100A     IORWF 0xA, W, ACCESS
1D72C  100B     IORWF 0xB, W, ACCESS
1D72E  100C     IORWF 0xC, W, ACCESS
1D730  A4D8     BTFSS 0xFD8, 2, ACCESS
1D732  D008     BRA 0xD744
10:            	        f2 = 0x00000000UL;
1D734  0EF8     MOVLW 0xF8
1D736  6AE3     CLRF 0xFE3, ACCESS
1D738  0EF9     MOVLW 0xF9
1D73A  6AE3     CLRF 0xFE3, ACCESS
1D73C  0EFA     MOVLW 0xFA
1D73E  6AE3     CLRF 0xFE3, ACCESS
1D740  0EFB     MOVLW 0xFB
1D742  6AE3     CLRF 0xFE3, ACCESS
11:            	// compute >= a clever way
12:            	if(f1 &  0x80000000UL)
1D744  0EFF     MOVLW 0xFF
1D746  AEE3     BTFSS 0xFE3, 7, ACCESS
1D748  D024     BRA 0xD792
13:            		f1 = 0x80000000UL - f1;
1D74A  0E00     MOVLW 0x0
1D74C  6E09     MOVWF 0x9, ACCESS
1D74E  0E00     MOVLW 0x0
1D750  6E0A     MOVWF 0xA, ACCESS
1D752  0E00     MOVLW 0x0
1D754  6E0B     MOVWF 0xB, ACCESS
1D756  0E80     MOVLW 0x80
1D758  6E0C     MOVWF 0xC, ACCESS
1D75A  0EFC     MOVLW 0xFC
1D75C  50E3     MOVF 0xFE3, W, ACCESS
1D75E  5E09     SUBWF 0x9, F, ACCESS
1D760  0EFD     MOVLW 0xFD
1D762  50E3     MOVF 0xFE3, W, ACCESS
1D764  5A0A     SUBWFB 0xA, F, ACCESS
1D766  0EFE     MOVLW 0xFE
1D768  50E3     MOVF 0xFE3, W, ACCESS
1D76A  5A0B     SUBWFB 0xB, F, ACCESS
1D76C  0EFF     MOVLW 0xFF
1D76E  50E3     MOVF 0xFE3, W, ACCESS
1D770  5A0C     SUBWFB 0xC, F, ACCESS
1D772  0EFC     MOVLW 0xFC
1D774  0061     MOVFFL ltemp2, PLUSW1
1D776  F424     NOP
1D778  F4E3     NOP
1D77A  0EFD     MOVLW 0xFD
1D77C  0061     MOVFFL ttemp3, PLUSW1
1D77E  F428     NOP
1D780  F4E3     NOP
1D782  0EFE     MOVLW 0xFE
1D784  0061     MOVFFL wtemp5, PLUSW1
1D786  F42C     NOP
1D788  F4E3     NOP
1D78A  0EFF     MOVLW 0xFF
1D78C  0061     MOVFFL 0x50C, PLUSW1
1D78E  F430     NOP
1D790  F4E3     NOP
14:            	if(f2 &  0x80000000UL)
1D792  0EFB     MOVLW 0xFB
1D794  AEE3     BTFSS 0xFE3, 7, ACCESS
1D796  D024     BRA 0xD7E0
15:            		f2 = 0x80000000UL - f2;
1D798  0E00     MOVLW 0x0
1D79A  6E09     MOVWF 0x9, ACCESS
1D79C  0E00     MOVLW 0x0
1D79E  6E0A     MOVWF 0xA, ACCESS
1D7A0  0E00     MOVLW 0x0
1D7A2  6E0B     MOVWF 0xB, ACCESS
1D7A4  0E80     MOVLW 0x80
1D7A6  6E0C     MOVWF 0xC, ACCESS
1D7A8  0EF8     MOVLW 0xF8
1D7AA  50E3     MOVF 0xFE3, W, ACCESS
1D7AC  5E09     SUBWF 0x9, F, ACCESS
1D7AE  0EF9     MOVLW 0xF9
1D7B0  50E3     MOVF 0xFE3, W, ACCESS
1D7B2  5A0A     SUBWFB 0xA, F, ACCESS
1D7B4  0EFA     MOVLW 0xFA
1D7B6  50E3     MOVF 0xFE3, W, ACCESS
1D7B8  5A0B     SUBWFB 0xB, F, ACCESS
1D7BA  0EFB     MOVLW 0xFB
1D7BC  50E3     MOVF 0xFE3, W, ACCESS
1D7BE  5A0C     SUBWFB 0xC, F, ACCESS
1D7C0  0EF8     MOVLW 0xF8
1D7C2  0061     MOVFFL ltemp2, PLUSW1
1D7C4  F424     NOP
1D7C6  F4E3     NOP
1D7C8  0EF9     MOVLW 0xF9
1D7CA  0061     MOVFFL ttemp3, PLUSW1
1D7CC  F428     NOP
1D7CE  F4E3     NOP
1D7D0  0EFA     MOVLW 0xFA
1D7D2  0061     MOVFFL wtemp5, PLUSW1
1D7D4  F42C     NOP
1D7D6  F4E3     NOP
1D7D8  0EFB     MOVLW 0xFB
1D7DA  0061     MOVFFL 0x50C, PLUSW1
1D7DC  F430     NOP
1D7DE  F4E3     NOP
16:            	f1 ^= 0x80000000UL;
1D7E0  0EFF     MOVLW 0xFF
1D7E2  7EE3     BTG 0xFE3, 7, ACCESS
17:            	f2 ^= 0x80000000UL;
1D7E4  0EFB     MOVLW 0xFB
1D7E6  7EE3     BTG 0xFE3, 7, ACCESS
18:            	return f1 >= f2;
1D7E8  50E1     MOVF 0xFE1, W, ACCESS
1D7EA  0FFC     ADDLW 0xFC
1D7EC  6ED9     MOVWF 0xFD9, ACCESS
1D7EE  50E2     MOVF 0xFE2, W, ACCESS
1D7F0  6EDA     MOVWF __end_of_UART2_tx_vect_isr, ACCESS
1D7F2  0EFF     MOVLW 0xFF
1D7F4  22DA     ADDWFC __end_of_UART2_tx_vect_isr, F, ACCESS
1D7F6  0EF8     MOVLW 0xF8
1D7F8  50E3     MOVF 0xFE3, W, ACCESS
1D7FA  5CDE     SUBWF 0xFDE, W, ACCESS
1D7FC  0EF9     MOVLW 0xF9
1D7FE  50E3     MOVF 0xFE3, W, ACCESS
1D800  58DE     SUBWFB 0xFDE, W, ACCESS
1D802  0EFA     MOVLW 0xFA
1D804  50E3     MOVF 0xFE3, W, ACCESS
1D806  58DE     SUBWFB 0xFDE, W, ACCESS
1D808  0EFB     MOVLW 0xFB
1D80A  50E3     MOVF 0xFE3, W, ACCESS
1D80C  58DE     SUBWFB 0xFDE, W, ACCESS
1D80E  B0D8     BTFSC 0xFD8, 0, ACCESS
1D810  D002     BRA 0xD816
1D812  9001     BCF __ptext283, 0, ACCESS
1D814  D001     BRA 0xD818
1D816  8001     BSF __ptext283, 0, ACCESS
19:            }
1D818  0EF8     MOVLW 0xF8
1D81A  26E1     ADDWF 0xFE1, F, ACCESS
1D81C  0EFF     MOVLW 0xFF
1D81E  22E2     ADDWFC 0xFE2, F, ACCESS
1D81E  22E2     ADDWFC 0xFE2, F, ACCESS
---  /opt/microchip/xc8/v2.41/pic/sources/c99/common/fleq.c  --------------------------------------------
1:             #define	f1	(*(unsigned long *)&ff1)
2:             #define	f2	(*(unsigned long *)&ff2)
3:             __bit
4:             __fleq(double ff1, double ff2)
5:             {
6:                     // flush denorms and zeroes to +ve 0.0
7:                     if((f1 &  0x7F800000UL)== 0)
1F92A  50E1     MOVF 0xFE1, W, ACCESS
1F92C  0FFC     ADDLW 0xFC
1F92E  6ED9     MOVWF 0xFD9, ACCESS
1F930  50E2     MOVF 0xFE2, W, ACCESS
1F932  6EDA     MOVWF __end_of_UART2_tx_vect_isr, ACCESS
1F934  0EFF     MOVLW 0xFF
1F936  22DA     ADDWFC __end_of_UART2_tx_vect_isr, F, ACCESS
1F938  0E00     MOVLW 0x0
1F93A  14DE     ANDWF 0xFDE, W, ACCESS
1F93C  6E09     MOVWF 0x9, ACCESS
1F93E  0E00     MOVLW 0x0
1F940  14DE     ANDWF 0xFDE, W, ACCESS
1F942  6E0A     MOVWF 0xA, ACCESS
1F944  0E80     MOVLW 0x80
1F946  14DE     ANDWF 0xFDE, W, ACCESS
1F948  6E0B     MOVWF 0xB, ACCESS
1F94A  0E7F     MOVLW 0x7F
1F94C  14DE     ANDWF 0xFDE, W, ACCESS
1F94E  6E0C     MOVWF 0xC, ACCESS
1F950  5009     MOVF 0x9, W, ACCESS
1F952  100A     IORWF 0xA, W, ACCESS
1F954  100B     IORWF 0xB, W, ACCESS
1F956  100C     IORWF 0xC, W, ACCESS
1F958  A4D8     BTFSS 0xFD8, 2, ACCESS
1F95A  D008     BRA 0xF96C
8:             		f1 = 0x00000000UL;
1F95C  0EFC     MOVLW 0xFC
1F95E  6AE3     CLRF 0xFE3, ACCESS
1F960  0EFD     MOVLW 0xFD
1F962  6AE3     CLRF 0xFE3, ACCESS
1F964  0EFE     MOVLW 0xFE
1F966  6AE3     CLRF 0xFE3, ACCESS
1F968  0EFF     MOVLW 0xFF
1F96A  6AE3     CLRF 0xFE3, ACCESS
9:             	if((f2 &  0x7F800000UL)== 0)
1F96C  50E1     MOVF 0xFE1, W, ACCESS
1F96E  0FF8     ADDLW 0xF8
1F970  6ED9     MOVWF 0xFD9, ACCESS
1F972  50E2     MOVF 0xFE2, W, ACCESS
1F974  6EDA     MOVWF __end_of_UART2_tx_vect_isr, ACCESS
1F976  0EFF     MOVLW 0xFF
1F978  22DA     ADDWFC __end_of_UART2_tx_vect_isr, F, ACCESS
1F97A  0E00     MOVLW 0x0
1F97C  14DE     ANDWF 0xFDE, W, ACCESS
1F97E  6E09     MOVWF 0x9, ACCESS
1F980  0E00     MOVLW 0x0
1F982  14DE     ANDWF 0xFDE, W, ACCESS
1F984  6E0A     MOVWF 0xA, ACCESS
1F986  0E80     MOVLW 0x80
1F988  14DE     ANDWF 0xFDE, W, ACCESS
1F98A  6E0B     MOVWF 0xB, ACCESS
1F98C  0E7F     MOVLW 0x7F
1F98E  14DE     ANDWF 0xFDE, W, ACCESS
1F990  6E0C     MOVWF 0xC, ACCESS
1F992  5009     MOVF 0x9, W, ACCESS
1F994  100A     IORWF 0xA, W, ACCESS
1F996  100B     IORWF 0xB, W, ACCESS
1F998  100C     IORWF 0xC, W, ACCESS
1F99A  A4D8     BTFSS 0xFD8, 2, ACCESS
1F99C  D008     BRA 0xF9AE
10:            	        f2 = 0x00000000UL;
1F99E  0EF8     MOVLW 0xF8
1F9A0  6AE3     CLRF 0xFE3, ACCESS
1F9A2  0EF9     MOVLW 0xF9
1F9A4  6AE3     CLRF 0xFE3, ACCESS
1F9A6  0EFA     MOVLW 0xFA
1F9A8  6AE3     CLRF 0xFE3, ACCESS
1F9AA  0EFB     MOVLW 0xFB
1F9AC  6AE3     CLRF 0xFE3, ACCESS
11:            	return f1 == f2;
1F9AE  50E1     MOVF 0xFE1, W, ACCESS
1F9B0  0FFC     ADDLW 0xFC
1F9B2  6ED9     MOVWF 0xFD9, ACCESS
1F9B4  50E2     MOVF 0xFE2, W, ACCESS
1F9B6  6EDA     MOVWF __end_of_UART2_tx_vect_isr, ACCESS
1F9B8  0EFF     MOVLW 0xFF
1F9BA  22DA     ADDWFC __end_of_UART2_tx_vect_isr, F, ACCESS
1F9BC  0EF8     MOVLW 0xF8
1F9BE  50E3     MOVF 0xFE3, W, ACCESS
1F9C0  18DE     XORWF 0xFDE, W, ACCESS
1F9C2  E10D     BNZ 0xF9DE
1F9C4  0EF9     MOVLW 0xF9
1F9C6  50E3     MOVF 0xFE3, W, ACCESS
1F9C8  18DE     XORWF 0xFDE, W, ACCESS
1F9CA  E109     BNZ 0xF9DE
1F9CC  0EFA     MOVLW 0xFA
1F9CE  50E3     MOVF 0xFE3, W, ACCESS
1F9D0  18DE     XORWF 0xFDE, W, ACCESS
1F9D2  E105     BNZ 0xF9DE
1F9D4  0EFB     MOVLW 0xFB
1F9D6  50E3     MOVF 0xFE3, W, ACCESS
1F9D8  18DE     XORWF 0xFDE, W, ACCESS
1F9DA  B4D8     BTFSC 0xFD8, 2, ACCESS
1F9DC  D002     BRA 0xF9E2
1F9DE  9001     BCF __ptext283, 0, ACCESS
1F9E0  D001     BRA 0xF9E4
1F9E2  8001     BSF __ptext283, 0, ACCESS
12:            }
1F9E4  0EF8     MOVLW 0xF8
1F9E6  26E1     ADDWF 0xFE1, F, ACCESS
1F9E8  0EFF     MOVLW 0xFF
1F9EA  22E2     ADDWFC 0xFE2, F, ACCESS
1F9EA  22E2     ADDWFC 0xFE2, F, ACCESS
---  /opt/microchip/xc8/v2.41/pic/sources/c99/common/fabsf.c  -------------------------------------------
1:             #include <math.h>
2:             #include <stdint.h>
3:             
4:             float fabsf(float x)
1FC18  52E6     MOVF 0xFE6, F, ACCESS
1FC1A  52E6     MOVF 0xFE6, F, ACCESS
1FC1C  52E6     MOVF 0xFE6, F, ACCESS
1FC1E  52E6     MOVF 0xFE6, F, ACCESS
5:             {
6:             	union {float f; uint32_t i;} u = {x};
1FC20  0061     MOVFFL F465, ltemp2
1FC22  FCB4     NOP
1FC24  F509     NOP
1FC26  0061     MOVFFL 0x72E, ttemp3
1FC28  FCB8     NOP
1FC2A  F50A     NOP
1FC2C  0061     MOVFFL 0x72F, wtemp5
1FC2E  FCBC     NOP
1FC30  F50B     NOP
1FC32  0061     MOVFFL 0x730, 0x50C
1FC34  FCC0     NOP
1FC36  F50C     NOP
1FC38  0EFC     MOVLW 0xFC
1FC3A  0061     MOVFFL ltemp2, PLUSW1
1FC3C  F424     NOP
1FC3E  F4E3     NOP
1FC40  0EFD     MOVLW 0xFD
1FC42  0061     MOVFFL ttemp3, PLUSW1
1FC44  F428     NOP
1FC46  F4E3     NOP
1FC48  0EFE     MOVLW 0xFE
1FC4A  0061     MOVFFL wtemp5, PLUSW1
1FC4C  F42C     NOP
1FC4E  F4E3     NOP
1FC50  0EFF     MOVLW 0xFF
1FC52  0061     MOVFFL 0x50C, PLUSW1
1FC54  F430     NOP
1FC56  F4E3     NOP
1FC58  0EF8     MOVLW 0xF8
1FC5A  0061     MOVFFL PLUSW1, ltemp2
1FC5C  F38C     NOP
1FC5E  F509     NOP
1FC60  0EF9     MOVLW 0xF9
1FC62  0061     MOVFFL PLUSW1, ttemp3
1FC64  F38C     NOP
1FC66  F50A     NOP
1FC68  0EFA     MOVLW 0xFA
1FC6A  0061     MOVFFL PLUSW1, wtemp5
1FC6C  F38C     NOP
1FC6E  F50B     NOP
1FC70  0EFB     MOVLW 0xFB
1FC72  0061     MOVFFL PLUSW1, 0x50C
1FC74  F38C     NOP
1FC76  F50C     NOP
1FC78  0EFC     MOVLW 0xFC
1FC7A  0061     MOVFFL ltemp2, PLUSW1
1FC7C  F424     NOP
1FC7E  F4E3     NOP
1FC80  0EFD     MOVLW 0xFD
1FC82  0061     MOVFFL ttemp3, PLUSW1
1FC84  F428     NOP
1FC86  F4E3     NOP
1FC88  0EFE     MOVLW 0xFE
1FC8A  0061     MOVFFL wtemp5, PLUSW1
1FC8C  F42C     NOP
1FC8E  F4E3     NOP
1FC90  0EFF     MOVLW 0xFF
1FC92  0061     MOVFFL 0x50C, PLUSW1
1FC94  F430     NOP
1FC96  F4E3     NOP
7:             	u.i &= 0x7fffffff;
1FC98  0EFF     MOVLW 0xFF
1FC9A  9EE3     BCF 0xFE3, 7, ACCESS
8:             	return u.f;
1FC9C  0EFC     MOVLW 0xFC
1FC9E  0061     MOVFFL PLUSW1, ltemp0
1FCA0  F38C     NOP
1FCA2  F501     NOP
1FCA4  0EFD     MOVLW 0xFD
1FCA6  0061     MOVFFL PLUSW1, ttemp5
1FCA8  F38C     NOP
1FCAA  F502     NOP
1FCAC  0EFE     MOVLW 0xFE
1FCAE  0061     MOVFFL PLUSW1, wtemp1
1FCB0  F38C     NOP
1FCB2  F503     NOP
1FCB4  0EFF     MOVLW 0xFF
1FCB6  0061     MOVFFL PLUSW1, ttemp1
1FCB8  F38C     NOP
1FCBA  F504     NOP
9:             }
1FCBC  0EF8     MOVLW 0xF8
1FCBE  26E1     ADDWF 0xFE1, F, ACCESS
1FCC0  0EFF     MOVLW 0xFF
1FCC2  22E2     ADDWFC 0xFE2, F, ACCESS
1FCC2  22E2     ADDWFC 0xFE2, F, ACCESS
---  /opt/microchip/xc8/v2.41/pic/sources/c99/common/doprnt.c  ------------------------------------------
1:             /* vfprintf with configurable support for format conversions */
2:             /* This code is specifically for XC8 */
3:             #include <ctype.h>
4:             #include <math.h>
5:             #include <stdarg.h>
6:             #include <stddef.h>
7:             #include <stdint.h>
8:             #include <stdio.h>
9:             #include <stdlib.h>
10:            #include <string.h>
11:            #include <inline.h>
12:            #include <stdbool.h>
13:            
14:            /* Configuration options */
15:            #ifdef _VFPF_ALL
16:            #define _VFPF_CONVERT
17:            #define _VFPF_SPCSIGN
18:            #define _VFPF_MANSIGN
19:            #define _VFPF_FILL
20:            #define _VFPF_LEFT
21:            #define _VFPF_ALTERN
22:            #define _VFPF_WIDTH
23:            #define _VFPF_PRECISION
24:            #define _VFPF_PERC
25:            #define _VFPF_UPCASE
26:            #define _VFPF_RETVALUE
27:            
28:            #define _VFPF_HH
29:            #define _VFPF_H
30:            #define _VFPF_L
31:            #define _VFPF_LL
32:            #define _VFPF_J
33:            #define _VFPF_T
34:            #define _VFPF_Z
35:            
36:            #define _VFPF_A
37:            #define _VFPF_C
38:            #define _VFPF_D
39:            #define _VFPF_E
40:            #define _VFPF_F
41:            #define _VFPF_G
42:            #define _VFPF_O
43:            #define _VFPF_N
44:            #define _VFPF_P
45:            #define _VFPF_S
46:            #define _VFPF_U
47:            #define _VFPF_X
48:            #define _VFPF_x
49:            #endif
50:            
51:            #if defined(_VFPF_SPCSIGN) || defined(_VFPF_MANSIGN) || defined(_VFPF_FILL) || defined(_VFPF_LEFT) || defined(_VFPF_ALTERN)
52:            #define _VFPF_FLAGS
53:            #endif
54:            
55:            #if defined(_VFPF_D)
56:            #define _VFPF_SIGNED_CONV
57:            #define _VFPF_INT_CONV
58:            #endif
59:            
60:            #if defined(_VFPF_X) || defined(_VFPF_x)
61:            #define _VFPF_HEX_CONV
62:            #define _VFPF_INT_CONV
63:            #endif
64:            
65:            #if defined(_VFPF_O) || defined(_VFPF_U) || defined(_VFPF_HEX_CONV)
66:            #define _VFPF_UNSIGNED_CONV
67:            #define _VFPF_INT_CONV
68:            #endif
69:            
70:            #if defined(_VFPF_A) || defined(_VFPF_E) || defined(_VFPF_F) || defined(_VFPF_G)
71:            #define _VFPF_FLOAT_CONV
72:            #endif
73:            
74:            #if defined(_VFPF_H) || defined(_VFPF_HH) || defined(_VFPF_L) || defined(_VFPF_LL) || defined(_VFPF_J) \
75:            	|| defined(_VFPF_T) || defined(_VFPF_Z)
76:            #define _VFPF_LENGTH_MOD
77:            #endif
78:            
79:            // largest integral types needed
80:            #if defined(_VFPF_INT_CONV) || defined(_VFPF_P)
81:            #define _VFPF_INT_LENGTH int
82:            #if defined(_VFPF_P) || defined(_VFPF_L)
83:            #undef _VFPF_INT_LENGTH
84:            #define _VFPF_INT_LENGTH long
85:            #endif
86:            #if defined(_VFPF_LL) || defined(_VFPF_J)
87:            #undef _VFPF_INT_LENGTH
88:            #define _VFPF_INT_LENGTH long long
89:            #endif
90:            typedef signed _VFPF_INT_LENGTH vfpf_sint_t;
91:            typedef unsigned _VFPF_INT_LENGTH vfpf_uint_t;
92:            #endif // _VFPF_INT_CONV || _VFPF_P
93:            
94:            #if !defined(_VFPF_RETVALUE) && (defined(SNPRINTF) || defined(VSNPRINTF) || defined(VSPRINTF))
95:            #define _VFPF_RETVALUE
96:            #endif
97:            #if defined(_VFPF_N) || defined(_VFPF_RETVALUE)
98:            #define _VFPF_COUNT_CHARS
99:            #define _COUNT_TYPE int
100:           #else
101:           #define _COUNT_TYPE	void
102:           #endif
103:           #define _COUNT_CAST	(_COUNT_TYPE)
104:           
105:           #ifndef ARRAYSIZE
106:           #define ARRAYSIZE(a)	(sizeof(a)/sizeof(a[0]))
107:           #endif
108:           #ifndef CSTRLEN
109:           #define CSTRLEN(s)	(ARRAYSIZE(s)-1)
110:           #endif
111:           
112:           /* Flags, precision, width */
113:           #define MINUS_FLAG (1 << 0)
114:           #define ZERO_FLAG (1 << 1)
115:           #define PLUS_FLAG (1 << 2)
116:           #define SPACE_FLAG (1 << 3)
117:           #define POUND_FLAG (1 << 4)
118:           static int prec, width;
119:           static char flags;
120:           
121:           union flui {
122:           	long double	f;
123:           #if __SIZEOF_LONG_DOUBLE__ == 8
124:           	int64_t	u;
125:           #else
126:           	int32_t	u;
127:           #endif
128:           };
129:           #if __SIZEOF_LONG_DOUBLE__ == 8
130:           #define FNEARLYEQ(x,y)	(llabs((x).u-(y).u) <= 1)
131:           #else
132:           #define FNEARLYEQ(x,y)	(labs((x).u-(y).u) <= 1)
133:           #endif
134:           
135:           #ifdef _VFPF_CONVERT
136:           /* This buffer must be at least 32 bytes long for this code to be safe */
137:           /* Output that would exceed buffer capacity is truncated */
138:           #if defined(_VFPF_A) || defined(_VFPF_E) || defined(_VFPF_F) || defined(_VFPF_G)
139:           #define DBLEN 80
140:           #define EXPLEN 5
141:           #else
142:           #define DBLEN 32
143:           #endif
144:           static char dbuf[DBLEN];
145:           
146:           #ifdef _VFPF_COUNT_CHARS
147:           /* Character count */
148:           static _COUNT_TYPE nout;
149:           #endif
150:           
151:           /* Output the string in dbuf, padded on the left or right */
152:           static _INLINE _COUNT_TYPE pad(FILE *fp, char *buf, int p)
1EF46  52E6     MOVF 0xFE6, F, ACCESS
1EF48  52E6     MOVF 0xFE6, F, ACCESS
1EF4A  52E6     MOVF 0xFE6, F, ACCESS
1EF4C  52E6     MOVF 0xFE6, F, ACCESS
153:           {
154:               int i, w;
155:           
156:           #if defined(_VFPF_LEFT) || defined(_VFPF_WIDTH)
157:               /* Left justify ? Put out string */
158:               if (flags & MINUS_FLAG) {
1EF4E  A027     BTFSS 0x27, 0, ACCESS
1EF50  D00C     BRA 0xEF6A
159:                   fputs((const char *)buf, fp);
1EF52  0EFA     MOVLW 0xFA
1EF54  C4E3     MOVFF PLUSW1, POSTINC1
1EF56  F4E6     NOP
1EF58  C4E3     MOVFF PLUSW1, POSTINC1
1EF5A  F4E6     NOP
1EF5C  0EF6     MOVLW 0xF6
1EF5E  C4E3     MOVFF PLUSW1, POSTINC1
1EF60  F4E6     NOP
1EF62  C4E3     MOVFF PLUSW1, POSTINC1
1EF64  F4E6     NOP
1EF66  EC0F     CALL 0x41E, 0
1EF68  F002     NOP
160:               }
161:           #endif
162:           
163:               /* Put out padding */
164:               w = (p < 0) ? 0 : p;
1EF6A  0EF7     MOVLW 0xF7
1EF6C  BEE3     BTFSC 0xFE3, 7, ACCESS
1EF6E  D011     BRA 0xEF92
1EF70  0EF6     MOVLW 0xF6
1EF72  0061     MOVFFL PLUSW1, ltemp0
1EF74  F38C     NOP
1EF76  F501     NOP
1EF78  0EFC     MOVLW 0xFC
1EF7A  0061     MOVFFL ltemp0, PLUSW1
1EF7C  F404     NOP
1EF7E  F4E3     NOP
1EF80  0EF7     MOVLW 0xF7
1EF82  0061     MOVFFL PLUSW1, ltemp0
1EF84  F38C     NOP
1EF86  F501     NOP
1EF88  0EFD     MOVLW 0xFD
1EF8A  0061     MOVFFL ltemp0, PLUSW1
1EF8C  F404     NOP
1EF8E  F4E3     NOP
1EF90  D004     BRA 0xEF9A
1EF92  0EFC     MOVLW 0xFC
1EF94  6AE3     CLRF 0xFE3, ACCESS
1EF96  0EFD     MOVLW 0xFD
1EF98  6AE3     CLRF 0xFE3, ACCESS
165:               i = 0;
1EF9A  0EFE     MOVLW 0xFE
1EF9C  6AE3     CLRF 0xFE3, ACCESS
1EF9E  0EFF     MOVLW 0xFF
1EFA0  6AE3     CLRF 0xFE3, ACCESS
166:               while (i < w) {
1EFA2  D01C     BRA 0xEFDC
1EFDC  50E1     MOVF 0xFE1, W, ACCESS
1EFDE  0FFE     ADDLW 0xFE
1EFE0  6ED9     MOVWF 0xFD9, ACCESS
1EFE2  50E2     MOVF 0xFE2, W, ACCESS
1EFE4  6EDA     MOVWF __end_of_UART2_tx_vect_isr, ACCESS
1EFE6  0EFF     MOVLW 0xFF
1EFE8  22DA     ADDWFC __end_of_UART2_tx_vect_isr, F, ACCESS
1EFEA  0EFC     MOVLW 0xFC
1EFEC  50E3     MOVF 0xFE3, W, ACCESS
1EFEE  5CDE     SUBWF 0xFDE, W, ACCESS
1EFF0  50DE     MOVF 0xFDE, W, ACCESS
1EFF2  0A80     XORLW 0x80
1EFF4  6E01     MOVWF __ptext283, ACCESS
1EFF6  0EFD     MOVLW 0xFD
1EFF8  50E3     MOVF 0xFE3, W, ACCESS
1EFFA  0A80     XORLW 0x80
1EFFC  5801     SUBWFB __ptext283, W, ACCESS
1EFFE  A0D8     BTFSS 0xFD8, 0, ACCESS
1F000  D7D1     BRA 0xEFA4
167:                   fputc(' ', fp);
1EFA4  0EFA     MOVLW 0xFA
1EFA6  C4E3     MOVFF PLUSW1, POSTINC1
1EFA8  F4E6     NOP
1EFAA  C4E3     MOVFF PLUSW1, POSTINC1
1EFAC  F4E6     NOP
1EFAE  0E20     MOVLW 0x20
1EFB0  6EE6     MOVWF 0xFE6, ACCESS
1EFB2  0E00     MOVLW 0x0
1EFB4  6EE6     MOVWF 0xFE6, ACCESS
1EFB6  ECCB     CALL 0x1DF96, 0
1EFB8  F0EF     NOP
168:                   ++i;
1EFBA  0EFE     MOVLW 0xFE
1EFBC  50E3     MOVF 0xFE3, W, ACCESS
1EFBE  0F01     ADDLW 0x1
1EFC0  6E01     MOVWF __ptext283, ACCESS
1EFC2  0EFE     MOVLW 0xFE
1EFC4  0061     MOVFFL ltemp0, PLUSW1
1EFC6  F404     NOP
1EFC8  F4E3     NOP
1EFCA  6A01     CLRF __ptext283, ACCESS
1EFCC  0EFF     MOVLW 0xFF
1EFCE  50E3     MOVF 0xFE3, W, ACCESS
1EFD0  2001     ADDWFC __ptext283, W, ACCESS
1EFD2  6E01     MOVWF __ptext283, ACCESS
1EFD4  0EFF     MOVLW 0xFF
1EFD6  0061     MOVFFL ltemp0, PLUSW1
1EFD8  F404     NOP
1EFDA  F4E3     NOP
169:               }
170:           
171:               /* Right justify ? Put out string */
172:           #if defined(_VFPF_LEFT) || defined(_VFPF_WIDTH)
173:               if (!(flags & MINUS_FLAG)) {
1F002  B027     BTFSC 0x27, 0, ACCESS
1F004  D00C     BRA 0xF01E
174:           #endif
175:                   fputs((const char *)buf, fp);
1F006  0EFA     MOVLW 0xFA
1F008  C4E3     MOVFF PLUSW1, POSTINC1
1F00A  F4E6     NOP
1F00C  C4E3     MOVFF PLUSW1, POSTINC1
1F00E  F4E6     NOP
1F010  0EF6     MOVLW 0xF6
1F012  C4E3     MOVFF PLUSW1, POSTINC1
1F014  F4E6     NOP
1F016  C4E3     MOVFF PLUSW1, POSTINC1
1F018  F4E6     NOP
1F01A  EC0F     CALL 0x41E, 0
1F01C  F002     NOP
176:           #if defined(_VFPF_LEFT) || defined(_VFPF_WIDTH)
177:               }
178:           #endif
179:           
180:           #ifdef _VFPF_COUNT_CHARS
181:               return (int)(strlen(buf) + (size_t)w);
1F01E  0EF8     MOVLW 0xF8
1F020  C4E3     MOVFF PLUSW1, POSTINC1
1F022  F4E6     NOP
1F024  C4E3     MOVFF PLUSW1, POSTINC1
1F026  F4E6     NOP
1F028  ECC2     CALL 0x384, 0
1F02A  F001     NOP
1F02C  0EFC     MOVLW 0xFC
1F02E  50E3     MOVF 0xFE3, W, ACCESS
1F030  2601     ADDWF __ptext283, F, ACCESS
1F032  0EFD     MOVLW 0xFD
1F034  50E3     MOVF 0xFE3, W, ACCESS
1F036  2202     ADDWFC ___rparam_used, F, ACCESS
182:           #endif
183:           }
1F038  0EF6     MOVLW 0xF6
1F038  0EF6     MOVLW 0xF6
1F038  0EF6     MOVLW 0xF6
1F038  0EF6     MOVLW 0xF6
1F038  0EF6     MOVLW 0xF6
184:           #endif
185:           
186:           #ifdef _VFPF_A
187:           #ifdef _VFPF_UPCASE
188:           static _INLINE _COUNT_TYPE atoa(FILE *fp, long double f, char c)
11482  0E31     MOVLW 0x31
11484  26E1     ADDWF 0xFE1, F, ACCESS
11486  0E00     MOVLW 0x0
11488  22E2     ADDWFC 0xFE2, F, ACCESS
189:           #define _ATOA(fp,f,c)	atoa(fp,f,c)
190:           #else
191:           static _INLINE _COUNT_TYPE atoa(FILE *fp, long double f)
192:           #define _ATOA(fp,f,c)	atoa(fp,f)
193:           #endif
194:           {
195:               char pp, sign, esign;
196:               int d, e, i, m, n, ne, p, t, w;
197:               long double g, h, l, ou, u;
198:           
199:           	/* Record if it's %A or %a */
200:           #ifdef _VFPF_UPCASE
201:           	c = isupper(c) ? 1 : 0;
1148A  0EC8     MOVLW 0xC8
1148C  0061     MOVFFL PLUSW1, 0x50C
1148E  F38C     NOP
11490  F50C     NOP
11492  0EBF     MOVLW 0xBF
11494  240C     ADDWF 0xC, W, ACCESS
11496  6E09     MOVWF 0x9, ACCESS
11498  6A0A     CLRF 0xA, ACCESS
1149A  0EFF     MOVLW 0xFF
1149C  220A     ADDWFC 0xA, F, ACCESS
1149E  500A     MOVF 0xA, W, ACCESS
114A0  E107     BNZ 0x14B0
114A2  0E1A     MOVLW 0x1A
114A4  5C09     SUBWF 0x9, W, ACCESS
114A6  B0D8     BTFSC 0xFD8, 0, ACCESS
114A8  D003     BRA 0x14B0
114AA  6A0C     CLRF 0xC, ACCESS
114AC  2A0C     INCF 0xC, F, ACCESS
114AE  D001     BRA 0x14B2
114B0  6A0C     CLRF 0xC, ACCESS
114B2  0EC8     MOVLW 0xC8
114B4  0061     MOVFFL 0x50C, PLUSW1
114B6  F430     NOP
114B8  F4E3     NOP
202:           #endif
203:               /* Record sign, get absolute value */
204:               sign = 0;
114BA  0EFD     MOVLW 0xFD
114BC  6AE3     CLRF 0xFE3, ACCESS
205:               g = f;
114BE  0EC9     MOVLW 0xC9
114C0  0061     MOVFFL PLUSW1, ltemp2
114C2  F38C     NOP
114C4  F509     NOP
114C6  0ECA     MOVLW 0xCA
114C8  0061     MOVFFL PLUSW1, ttemp3
114CA  F38C     NOP
114CC  F50A     NOP
114CE  0ECB     MOVLW 0xCB
114D0  0061     MOVFFL PLUSW1, wtemp5
114D2  F38C     NOP
114D4  F50B     NOP
114D6  0ECC     MOVLW 0xCC
114D8  0061     MOVFFL PLUSW1, 0x50C
114DA  F38C     NOP
114DC  F50C     NOP
114DE  0EDB     MOVLW 0xDB
114E0  0061     MOVFFL ltemp2, PLUSW1
114E2  F424     NOP
114E4  F4E3     NOP
114E6  0EDC     MOVLW 0xDC
114E8  0061     MOVFFL ttemp3, PLUSW1
114EA  F428     NOP
114EC  F4E3     NOP
114EE  0EDD     MOVLW 0xDD
114F0  0061     MOVFFL wtemp5, PLUSW1
114F2  F42C     NOP
114F4  F4E3     NOP
114F6  0EDE     MOVLW 0xDE
114F8  0061     MOVFFL 0x50C, PLUSW1
114FA  F430     NOP
114FC  F4E3     NOP
206:               if (g < 0.0) {
114FE  0EDE     MOVLW 0xDE
11500  AEE3     BTFSS 0xFE3, 7, ACCESS
11502  D01E     BRA 0x1540
207:                   sign = 1;
11504  0EFD     MOVLW 0xFD
11506  6AE3     CLRF 0xFE3, ACCESS
11508  2AE3     INCF 0xFE3, F, ACCESS
208:                   g = -g;
1150A  0EDB     MOVLW 0xDB
1150C  C4E3     MOVFF PLUSW1, POSTINC1
1150E  F4E6     NOP
11510  C4E3     MOVFF PLUSW1, POSTINC1
11512  F4E6     NOP
11514  C4E3     MOVFF PLUSW1, POSTINC1
11516  F4E6     NOP
11518  C4E3     MOVFF PLUSW1, POSTINC1
1151A  F4E6     NOP
1151C  EC25     CALL 0x144A, 0
1151E  F00A     NOP
11520  0EDB     MOVLW 0xDB
11522  0061     MOVFFL ltemp0, PLUSW1
11524  F404     NOP
11526  F4E3     NOP
11528  0EDC     MOVLW 0xDC
1152A  0061     MOVFFL ttemp5, PLUSW1
1152C  F408     NOP
1152E  F4E3     NOP
11530  0EDD     MOVLW 0xDD
11532  0061     MOVFFL wtemp1, PLUSW1
11534  F40C     NOP
11536  F4E3     NOP
11538  0EDE     MOVLW 0xDE
1153A  0061     MOVFFL ttemp1, PLUSW1
1153C  F410     NOP
1153E  F4E3     NOP
209:               }
210:           
211:               /* Print sign, prefix */
212:               n = 0;
11540  0EEB     MOVLW 0xEB
11542  6AE3     CLRF 0xFE3, ACCESS
11544  0EEC     MOVLW 0xEC
11546  6AE3     CLRF 0xFE3, ACCESS
213:               w = width;
11548  0EF1     MOVLW 0xF1
1154A  C521     MOVFF width, PLUSW1
1154C  F4E3     NOP
1154E  0EF2     MOVLW 0xF2
11550  C522     MOVFF 0x522, PLUSW1
11552  F4E3     NOP
214:               if (sign
11554  0EFD     MOVLW 0xFD
11556  50E3     MOVF 0xFE3, W, ACCESS
11558  A4D8     BTFSS 0xFD8, 2, ACCESS
1155A  D002     BRA 0x1560
1155C  A427     BTFSS 0x27, 2, ACCESS
1155E  D01B     BRA 0x1596
215:           #ifdef _VFPF_MANSIGN
216:           			|| (flags & PLUS_FLAG)
217:           #endif
218:           			) {
219:           		sign = sign ? '-' : '+';
11560  0EFD     MOVLW 0xFD
11562  50E3     MOVF 0xFE3, W, ACCESS
11564  A4D8     BTFSS 0xFD8, 2, ACCESS
11566  D002     BRA abs
11568  0E2B     MOVLW 0x2B
1156A  D001     BRA 0x156E
1156C  0E2D     MOVLW 0x2D
1156E  6E0B     MOVWF 0xB, ACCESS
11570  0E00     MOVLW 0x0
11572  6E0C     MOVWF 0xC, ACCESS
11574  0ECF     MOVLW 0xCF
11576  0061     MOVFFL wtemp5, PLUSW1
11578  F42C     NOP
1157A  F4E3     NOP
1157C  0ED0     MOVLW 0xD0
1157E  0061     MOVFFL 0x50C, PLUSW1
11580  F430     NOP
11582  F4E3     NOP
11584  0ECF     MOVLW 0xCF
11586  0061     MOVFFL PLUSW1, ltemp0
11588  F38C     NOP
1158A  F501     NOP
1158C  0EFD     MOVLW 0xFD
1158E  0061     MOVFFL ltemp0, PLUSW1
11590  F404     NOP
11592  F4E3     NOP
220:               }
11594  D005     BRA 0x15A0
221:           #if defined(_VFPF_SPCSIGN)
222:           	else if (flags & SPACE_FLAG) {
11596  A627     BTFSS 0x27, 3, ACCESS
11598  D003     BRA 0x15A0
223:           		sign = ' ';
1159A  0EFD     MOVLW 0xFD
1159C  6AE3     CLRF 0xFE3, ACCESS
1159E  8AE3     BSF 0xFE3, 5, ACCESS
224:           	}
225:           #endif
226:               /* Catch infinities, NaNs here */
227:               if (isinf(g)) {
115A0  0EDB     MOVLW 0xDB
115A2  C4E3     MOVFF PLUSW1, POSTINC1
115A4  F4E6     NOP
115A6  C4E3     MOVFF PLUSW1, POSTINC1
115A8  F4E6     NOP
115AA  C4E3     MOVFF PLUSW1, POSTINC1
115AC  F4E6     NOP
115AE  C4E3     MOVFF PLUSW1, POSTINC1
115B0  F4E6     NOP
115B2  EC5F     CALL 0x1D0BE, 0
115B4  F0E8     NOP
115B6  0401     DECF __ptext283, W, ACCESS
115B8  1002     IORWF ___rparam_used, W, ACCESS
115BA  A4D8     BTFSS 0xFD8, 2, ACCESS
115BC  D06B     BRA 0x1694
228:           		if (sign) {
115BE  0EFD     MOVLW 0xFD
115C0  50E3     MOVF 0xFE3, W, ACCESS
115C2  B4D8     BTFSC 0xFD8, 2, ACCESS
115C4  D019     BRA SYSTEM_Initialize
229:           			dbuf[0] = sign;
115C6  0EFD     MOVLW 0xFD
115C8  C4E3     MOVFF PLUSW1, dbuf
115CA  F8A5     NOP
230:           			n = 1;
115CC  0E01     MOVLW 0x1
115CE  6E0B     MOVWF 0xB, ACCESS
115D0  0E00     MOVLW 0x0
115D2  6E0C     MOVWF 0xC, ACCESS
115D4  0EEB     MOVLW 0xEB
115D6  0061     MOVFFL wtemp5, PLUSW1
115D8  F42C     NOP
115DA  F4E3     NOP
115DC  0EEC     MOVLW 0xEC
115DE  0061     MOVFFL 0x50C, PLUSW1
115E0  F430     NOP
115E2  F4E3     NOP
231:           			w--;
115E4  50E1     MOVF 0xFE1, W, ACCESS
115E6  0FF1     ADDLW 0xF1
115E8  6ED9     MOVWF 0xFD9, ACCESS
115EA  50E2     MOVF 0xFE2, W, ACCESS
115EC  6EDA     MOVWF __end_of_UART2_tx_vect_isr, ACCESS
115EE  0EFF     MOVLW 0xFF
115F0  22DA     ADDWFC __end_of_UART2_tx_vect_isr, F, ACCESS
115F2  06DE     DECF 0xFDE, F, ACCESS
115F4  0E00     MOVLW 0x0
115F6  5ADD     SUBWFB 0xFDD, F, ACCESS
232:           		}
233:           #ifdef _VFPF_UPCASE
234:                   if (c) {
115F8  0EC8     MOVLW 0xC8
115FA  50E3     MOVF 0xFE3, W, ACCESS
115FC  B4D8     BTFSC 0xFD8, 2, ACCESS
115FE  D017     BRA 0x162E
235:                       strcpy(&dbuf[n], "INF");
11600  0EDF     MOVLW 0xDF
11602  6EE6     MOVWF 0xFE6, ACCESS
11604  0EFF     MOVLW 0xFF
11606  6EE6     MOVWF 0xFE6, ACCESS
11608  0EA5     MOVLW 0xA5
1160A  6E0B     MOVWF 0xB, ACCESS
1160C  0E08     MOVLW 0x8
1160E  6E0C     MOVWF 0xC, ACCESS
11610  0EE9     MOVLW 0xE9
11612  50E3     MOVF 0xFE3, W, ACCESS
11614  260B     ADDWF 0xB, F, ACCESS
11616  0EEA     MOVLW 0xEA
11618  50E3     MOVF 0xFE3, W, ACCESS
1161A  220C     ADDWFC 0xC, F, ACCESS
1161C  0061     MOVFFL wtemp5, POSTINC1
1161E  F42C     NOP
11620  F4E6     NOP
11622  0061     MOVFFL 0x50C, POSTINC1
11624  F430     NOP
11626  F4E6     NOP
11628  ECF7     CALL 0x1F9EE, 0
1162A  F0FC     NOP
236:                   }
1162C  D016     BRA 0x165A
237:           		else
238:           #endif
239:           		{
240:                       strcpy(&dbuf[n], "inf");
1162E  0EE7     MOVLW 0xE7
11630  6EE6     MOVWF 0xFE6, ACCESS
11632  0EFF     MOVLW 0xFF
11634  6EE6     MOVWF 0xFE6, ACCESS
11636  0EA5     MOVLW 0xA5
11638  6E0B     MOVWF 0xB, ACCESS
1163A  0E08     MOVLW 0x8
1163C  6E0C     MOVWF 0xC, ACCESS
1163E  0EE9     MOVLW 0xE9
11640  50E3     MOVF 0xFE3, W, ACCESS
11642  260B     ADDWF 0xB, F, ACCESS
11644  0EEA     MOVLW 0xEA
11646  50E3     MOVF 0xFE3, W, ACCESS
11648  220C     ADDWFC 0xC, F, ACCESS
1164A  0061     MOVFFL wtemp5, POSTINC1
1164C  F42C     NOP
1164E  F4E6     NOP
11650  0061     MOVFFL 0x50C, POSTINC1
11652  F430     NOP
11654  F4E6     NOP
11656  ECF7     CALL 0x1F9EE, 0
11658  F0FC     NOP
241:                   }
242:                   w -= CSTRLEN("inf");
1165A  50E1     MOVF 0xFE1, W, ACCESS
1165C  0FF1     ADDLW 0xF1
1165E  6ED9     MOVWF 0xFD9, ACCESS
11660  50E2     MOVF 0xFE2, W, ACCESS
11662  6EDA     MOVWF __end_of_UART2_tx_vect_isr, ACCESS
11664  0EFF     MOVLW 0xFF
11666  22DA     ADDWFC __end_of_UART2_tx_vect_isr, F, ACCESS
11668  0EFD     MOVLW 0xFD
1166A  26DE     ADDWF 0xFDE, F, ACCESS
1166C  0EFF     MOVLW 0xFF
1166E  22DD     ADDWFC 0xFDD, F, ACCESS
243:                   return _COUNT_CAST pad(fp, &dbuf[0], w);
11670  0EF1     MOVLW 0xF1
11672  C4E3     MOVFF PLUSW1, POSTINC1
11674  F4E6     NOP
11676  C4E3     MOVFF PLUSW1, POSTINC1
11678  F4E6     NOP
1167A  0EA5     MOVLW 0xA5
1167C  6EE6     MOVWF 0xFE6, ACCESS
1167E  0E08     MOVLW 0x8
11680  6EE6     MOVWF 0xFE6, ACCESS
11682  0EC9     MOVLW 0xC9
11684  C4E3     MOVFF PLUSW1, POSTINC1
11686  F4E6     NOP
11688  C4E3     MOVFF PLUSW1, POSTINC1
1168A  F4E6     NOP
1168C  ECA3     CALL 0x1EF46, 0
1168E  F0F7     NOP
11690  EF6E     GOTO 0x126DC
11692  F093     NOP
244:               }
245:               if (isnan(g)) {
11694  0EDB     MOVLW 0xDB
11696  C4E3     MOVFF PLUSW1, POSTINC1
11698  F4E6     NOP
1169A  C4E3     MOVFF PLUSW1, POSTINC1
1169C  F4E6     NOP
1169E  C4E3     MOVFF PLUSW1, POSTINC1
116A0  F4E6     NOP
116A2  C4E3     MOVFF PLUSW1, POSTINC1
116A4  F4E6     NOP
116A6  EC5F     CALL 0x1D0BE, 0
116A8  F0E8     NOP
116AA  5001     MOVF __ptext283, W, ACCESS
116AC  1002     IORWF ___rparam_used, W, ACCESS
116AE  A4D8     BTFSS 0xFD8, 2, ACCESS
116B0  D04F     BRA 0x1750
246:           		if (sign) {
116B2  0EFD     MOVLW 0xFD
116B4  50E3     MOVF 0xFE3, W, ACCESS
116B6  B4D8     BTFSC 0xFD8, 2, ACCESS
116B8  D019     BRA 0x16EC
247:           			dbuf[0] = sign;
116BA  0EFD     MOVLW 0xFD
116BC  C4E3     MOVFF PLUSW1, dbuf
116BE  F8A5     NOP
248:           			n = 1;
116C0  0E01     MOVLW 0x1
116C2  6E0B     MOVWF 0xB, ACCESS
116C4  0E00     MOVLW 0x0
116C6  6E0C     MOVWF 0xC, ACCESS
116C8  0EEB     MOVLW 0xEB
116CA  0061     MOVFFL wtemp5, PLUSW1
116CC  F42C     NOP
116CE  F4E3     NOP
116D0  0EEC     MOVLW 0xEC
116D2  0061     MOVFFL 0x50C, PLUSW1
116D4  F430     NOP
116D6  F4E3     NOP
249:           			w--;
116D8  50E1     MOVF 0xFE1, W, ACCESS
116DA  0FF1     ADDLW 0xF1
116DC  6ED9     MOVWF 0xFD9, ACCESS
116DE  50E2     MOVF 0xFE2, W, ACCESS
116E0  6EDA     MOVWF __end_of_UART2_tx_vect_isr, ACCESS
116E2  0EFF     MOVLW 0xFF
116E4  22DA     ADDWFC __end_of_UART2_tx_vect_isr, F, ACCESS
116E6  06DE     DECF 0xFDE, F, ACCESS
116E8  0E00     MOVLW 0x0
116EA  5ADD     SUBWFB 0xFDD, F, ACCESS
250:           		}
251:           #ifdef _VFPF_UPCASE
252:                   if (c) {
116EC  0EC8     MOVLW 0xC8
116EE  50E3     MOVF 0xFE3, W, ACCESS
116F0  B4D8     BTFSC 0xFD8, 2, ACCESS
116F2  D017     BRA 0x1722
253:                       strcpy(&dbuf[n], "NAN");
116F4  0EE3     MOVLW 0xE3
116F6  6EE6     MOVWF 0xFE6, ACCESS
116F8  0EFF     MOVLW 0xFF
116FA  6EE6     MOVWF 0xFE6, ACCESS
116FC  0EA5     MOVLW 0xA5
116FE  6E0B     MOVWF 0xB, ACCESS
11700  0E08     MOVLW 0x8
11702  6E0C     MOVWF 0xC, ACCESS
11704  0EE9     MOVLW 0xE9
11706  50E3     MOVF 0xFE3, W, ACCESS
11708  260B     ADDWF 0xB, F, ACCESS
1170A  0EEA     MOVLW 0xEA
1170C  50E3     MOVF 0xFE3, W, ACCESS
1170E  220C     ADDWFC 0xC, F, ACCESS
11710  0061     MOVFFL wtemp5, POSTINC1
11712  F42C     NOP
11714  F4E6     NOP
11716  0061     MOVFFL 0x50C, POSTINC1
11718  F430     NOP
1171A  F4E6     NOP
1171C  ECF7     CALL 0x1F9EE, 0
1171E  F0FC     NOP
254:                   }
11720  D79C     BRA 0x165A
255:           		else
256:           #endif
257:           		{
258:                       strcpy(&dbuf[n], "nan");
11722  0EEB     MOVLW 0xEB
11724  6EE6     MOVWF 0xFE6, ACCESS
11726  0EFF     MOVLW 0xFF
11728  6EE6     MOVWF 0xFE6, ACCESS
1172A  0EA5     MOVLW 0xA5
1172C  6E0B     MOVWF 0xB, ACCESS
1172E  0E08     MOVLW 0x8
11730  6E0C     MOVWF 0xC, ACCESS
11732  0EE9     MOVLW 0xE9
11734  50E3     MOVF 0xFE3, W, ACCESS
11736  260B     ADDWF 0xB, F, ACCESS
11738  0EEA     MOVLW 0xEA
1173A  50E3     MOVF 0xFE3, W, ACCESS
1173C  220C     ADDWFC 0xC, F, ACCESS
1173E  0061     MOVFFL wtemp5, POSTINC1
11740  F42C     NOP
11742  F4E6     NOP
11744  0061     MOVFFL 0x50C, POSTINC1
11746  F430     NOP
11748  F4E6     NOP
1174A  ECF7     CALL 0x1F9EE, 0
1174C  F0FC     NOP
1174E  D785     BRA 0x165A
259:                   }
260:                   w -= CSTRLEN("nan");
261:                   return _COUNT_CAST pad(fp, &dbuf[0], w);
262:               }
263:           
264:               /* First find the largest power of 2 not larger than number to print */
265:               u = 1.0;
11750  0E00     MOVLW 0x0
11752  6E09     MOVWF 0x9, ACCESS
11754  0E00     MOVLW 0x0
11756  6E0A     MOVWF 0xA, ACCESS
11758  0E80     MOVLW 0x80
1175A  6E0B     MOVWF 0xB, ACCESS
1175C  0E3F     MOVLW 0x3F
1175E  6E0C     MOVWF 0xC, ACCESS
11760  0ED7     MOVLW 0xD7
11762  0061     MOVFFL ltemp2, PLUSW1
11764  F424     NOP
11766  F4E3     NOP
11768  0ED8     MOVLW 0xD8
1176A  0061     MOVFFL ttemp3, PLUSW1
1176C  F428     NOP
1176E  F4E3     NOP
11770  0ED9     MOVLW 0xD9
11772  0061     MOVFFL wtemp5, PLUSW1
11774  F42C     NOP
11776  F4E3     NOP
11778  0EDA     MOVLW 0xDA
1177A  0061     MOVFFL 0x50C, PLUSW1
1177C  F430     NOP
1177E  F4E3     NOP
266:               e = 0;
11780  0EF3     MOVLW 0xF3
11782  6AE3     CLRF 0xFE3, ACCESS
11784  0EF4     MOVLW 0xF4
11786  6AE3     CLRF 0xFE3, ACCESS
267:               if (!(g == 0.0)) {
11788  0E00     MOVLW 0x0
1178A  6EE6     MOVWF 0xFE6, ACCESS
1178C  0E00     MOVLW 0x0
1178E  6EE6     MOVWF 0xFE6, ACCESS
11790  0E00     MOVLW 0x0
11792  6EE6     MOVWF 0xFE6, ACCESS
11794  0E00     MOVLW 0x0
11796  6EE6     MOVWF 0xFE6, ACCESS
11798  0ED7     MOVLW 0xD7
1179A  C4E3     MOVFF PLUSW1, POSTINC1
1179C  F4E6     NOP
1179E  C4E3     MOVFF PLUSW1, POSTINC1
117A0  F4E6     NOP
117A2  C4E3     MOVFF PLUSW1, POSTINC1
117A4  F4E6     NOP
117A6  C4E3     MOVFF PLUSW1, POSTINC1
117A8  F4E6     NOP
117AA  EC95     CALL 0x1F92A, 0
117AC  F0FC     NOP
117AE  A001     BTFSS __ptext283, 0, ACCESS
117B0  D035     BRA 0x181C
117B2  D0A4     BRA 0x18FC
268:                   while (!(g < (u*2.0))) {
1181C  0E00     MOVLW 0x0
1181E  6EE6     MOVWF 0xFE6, ACCESS
11820  0E00     MOVLW 0x0
11822  6EE6     MOVWF 0xFE6, ACCESS
11824  0E00     MOVLW 0x0
11826  6EE6     MOVWF 0xFE6, ACCESS
11828  0E40     MOVLW 0x40
1182A  6EE6     MOVWF 0xFE6, ACCESS
1182C  0ED3     MOVLW 0xD3
1182E  C4E3     MOVFF PLUSW1, POSTINC1
11830  F4E6     NOP
11832  C4E3     MOVFF PLUSW1, POSTINC1
11834  F4E6     NOP
11836  C4E3     MOVFF PLUSW1, POSTINC1
11838  F4E6     NOP
1183A  C4E3     MOVFF PLUSW1, POSTINC1
1183C  F4E6     NOP
1183E  EC2F     CALL 0x1705E, 0
11840  F0B8     NOP
11842  0061     MOVFFL ltemp0, POSTINC1
11844  F404     NOP
11846  F4E6     NOP
11848  0061     MOVFFL ttemp5, POSTINC1
1184A  F408     NOP
1184C  F4E6     NOP
1184E  0061     MOVFFL wtemp1, POSTINC1
11850  F40C     NOP
11852  F4E6     NOP
11854  0061     MOVFFL ttemp1, POSTINC1
11856  F410     NOP
11858  F4E6     NOP
1185A  0ED7     MOVLW 0xD7
1185C  C4E3     MOVFF PLUSW1, POSTINC1
1185E  F4E6     NOP
11860  C4E3     MOVFF PLUSW1, POSTINC1
11862  F4E6     NOP
11864  C4E3     MOVFF PLUSW1, POSTINC1
11866  F4E6     NOP
11868  C4E3     MOVFF PLUSW1, POSTINC1
1186A  F4E6     NOP
1186C  EC60     CALL 0x1D6C0, 0
1186E  F0EB     NOP
11870  A001     BTFSS __ptext283, 0, ACCESS
11872  D02E     BRA 0x18D0
11874  D79F     BRA 0x17B4
269:                       u = u*2.0;
117B4  0E00     MOVLW 0x0
117B6  6EE6     MOVWF 0xFE6, ACCESS
117B8  0E00     MOVLW 0x0
117BA  6EE6     MOVWF 0xFE6, ACCESS
117BC  0E00     MOVLW 0x0
117BE  6EE6     MOVWF 0xFE6, ACCESS
117C0  0E40     MOVLW 0x40
117C2  6EE6     MOVWF 0xFE6, ACCESS
117C4  0ED3     MOVLW 0xD3
117C6  C4E3     MOVFF PLUSW1, POSTINC1
117C8  F4E6     NOP
117CA  C4E3     MOVFF PLUSW1, POSTINC1
117CC  F4E6     NOP
117CE  C4E3     MOVFF PLUSW1, POSTINC1
117D0  F4E6     NOP
117D2  C4E3     MOVFF PLUSW1, POSTINC1
117D4  F4E6     NOP
117D6  EC2F     CALL 0x1705E, 0
117D8  F0B8     NOP
117DA  0ED7     MOVLW 0xD7
117DC  0061     MOVFFL ltemp0, PLUSW1
117DE  F404     NOP
117E0  F4E3     NOP
117E2  0ED8     MOVLW 0xD8
117E4  0061     MOVFFL ttemp5, PLUSW1
117E6  F408     NOP
117E8  F4E3     NOP
117EA  0ED9     MOVLW 0xD9
117EC  0061     MOVFFL wtemp1, PLUSW1
117EE  F40C     NOP
117F0  F4E3     NOP
117F2  0EDA     MOVLW 0xDA
117F4  0061     MOVFFL ttemp1, PLUSW1
117F6  F410     NOP
117F8  F4E3     NOP
270:                       ++e;
117FA  0EF3     MOVLW 0xF3
117FC  50E3     MOVF 0xFE3, W, ACCESS
117FE  0F01     ADDLW 0x1
11800  6E01     MOVWF __ptext283, ACCESS
11802  0EF3     MOVLW 0xF3
11804  0061     MOVFFL ltemp0, PLUSW1
11806  F404     NOP
11808  F4E3     NOP
1180A  6A01     CLRF __ptext283, ACCESS
1180C  0EF4     MOVLW 0xF4
1180E  50E3     MOVF 0xFE3, W, ACCESS
11810  2001     ADDWFC __ptext283, W, ACCESS
11812  6E01     MOVWF __ptext283, ACCESS
11814  0EF4     MOVLW 0xF4
11816  0061     MOVFFL ltemp0, PLUSW1
11818  F404     NOP
1181A  F4E3     NOP
271:                   }
272:                   while (g < u) {
118D0  0ED7     MOVLW 0xD7
118D2  C4E3     MOVFF PLUSW1, POSTINC1
118D4  F4E6     NOP
118D6  C4E3     MOVFF PLUSW1, POSTINC1
118D8  F4E6     NOP
118DA  C4E3     MOVFF PLUSW1, POSTINC1
118DC  F4E6     NOP
118DE  C4E3     MOVFF PLUSW1, POSTINC1
118E0  F4E6     NOP
118E2  0ED7     MOVLW 0xD7
118E4  C4E3     MOVFF PLUSW1, POSTINC1
118E6  F4E6     NOP
118E8  C4E3     MOVFF PLUSW1, POSTINC1
118EA  F4E6     NOP
118EC  C4E3     MOVFF PLUSW1, POSTINC1
118EE  F4E6     NOP
118F0  C4E3     MOVFF PLUSW1, POSTINC1
118F2  F4E6     NOP
118F4  EC60     CALL 0x1D6C0, 0
118F6  F0EB     NOP
118F8  A001     BTFSS __ptext283, 0, ACCESS
118FA  D7BD     BRA 0x1876
273:                       u = u/2.0;
11876  0E00     MOVLW 0x0
11878  6EE6     MOVWF 0xFE6, ACCESS
1187A  0E00     MOVLW 0x0
1187C  6EE6     MOVWF 0xFE6, ACCESS
1187E  0E00     MOVLW 0x0
11880  6EE6     MOVWF 0xFE6, ACCESS
11882  0E40     MOVLW 0x40
11884  6EE6     MOVWF 0xFE6, ACCESS
11886  0ED3     MOVLW 0xD3
11888  C4E3     MOVFF PLUSW1, POSTINC1
1188A  F4E6     NOP
1188C  C4E3     MOVFF PLUSW1, POSTINC1
1188E  F4E6     NOP
11890  C4E3     MOVFF PLUSW1, POSTINC1
11892  F4E6     NOP
11894  C4E3     MOVFF PLUSW1, POSTINC1
11896  F4E6     NOP
11898  ECD2     CALL 0x187A4, 0
1189A  F0C3     NOP
1189C  0ED7     MOVLW 0xD7
1189E  0061     MOVFFL ltemp0, PLUSW1
118A0  F404     NOP
118A2  F4E3     NOP
118A4  0ED8     MOVLW 0xD8
118A6  0061     MOVFFL ttemp5, PLUSW1
118A8  F408     NOP
118AA  F4E3     NOP
118AC  0ED9     MOVLW 0xD9
118AE  0061     MOVFFL wtemp1, PLUSW1
118B0  F40C     NOP
118B2  F4E3     NOP
118B4  0EDA     MOVLW 0xDA
118B6  0061     MOVFFL ttemp1, PLUSW1
118B8  F410     NOP
118BA  F4E3     NOP
274:                       --e;
118BC  50E1     MOVF 0xFE1, W, ACCESS
118BE  0FF3     ADDLW 0xF3
118C0  6ED9     MOVWF 0xFD9, ACCESS
118C2  50E2     MOVF 0xFE2, W, ACCESS
118C4  6EDA     MOVWF __end_of_UART2_tx_vect_isr, ACCESS
118C6  0EFF     MOVLW 0xFF
118C8  22DA     ADDWFC __end_of_UART2_tx_vect_isr, F, ACCESS
118CA  06DE     DECF 0xFDE, F, ACCESS
118CC  0E00     MOVLW 0x0
118CE  5ADD     SUBWFB 0xFDD, F, ACCESS
275:                   }
276:               }
277:           
278:               /* Get precision */
279:               p = (prec < 0) ? (DBLEN-EXPLEN-1) : prec;
118FC  BE24     BTFSC 0x24, 7, ACCESS
118FE  D007     BRA 0x190E
11900  0EF7     MOVLW 0xF7
11902  C523     MOVFF prec, PLUSW1
11904  F4E3     NOP
11906  0EF8     MOVLW 0xF8
11908  C524     MOVFF 0x524, PLUSW1
1190A  F4E3     NOP
1190C  D00C     BRA 0x1926
1190E  0E4A     MOVLW 0x4A
11910  6E0B     MOVWF 0xB, ACCESS
11912  0E00     MOVLW 0x0
11914  6E0C     MOVWF 0xC, ACCESS
11916  0EF7     MOVLW 0xF7
11918  0061     MOVFFL wtemp5, PLUSW1
1191A  F42C     NOP
1191C  F4E3     NOP
1191E  0EF8     MOVLW 0xF8
11920  0061     MOVFFL 0x50C, PLUSW1
11922  F430     NOP
11924  F4E3     NOP
280:           
281:               /* Hex places, total */
282:               m = p + 1;
11926  0EF7     MOVLW 0xF7
11928  50E3     MOVF 0xFE3, W, ACCESS
1192A  0F01     ADDLW 0x1
1192C  6E0B     MOVWF 0xB, ACCESS
1192E  0EF8     MOVLW 0xF8
11930  0061     MOVFFL PLUSW1, 0x50C
11932  F38C     NOP
11934  F50C     NOP
11936  0E00     MOVLW 0x0
11938  220C     ADDWFC 0xC, F, ACCESS
1193A  0EFB     MOVLW 0xFB
1193C  0061     MOVFFL wtemp5, PLUSW1
1193E  F42C     NOP
11940  F4E3     NOP
11942  0EFC     MOVLW 0xFC
11944  0061     MOVFFL 0x50C, PLUSW1
11946  F430     NOP
11948  F4E3     NOP
283:           
284:               /* Go through the conversion once to get to the rounding step */
285:               i = 0;
1194A  0EED     MOVLW 0xED
1194C  6AE3     CLRF 0xFE3, ACCESS
1194E  0EEE     MOVLW 0xEE
11950  6AE3     CLRF 0xFE3, ACCESS
286:               h = g;
11952  0EDB     MOVLW 0xDB
11954  0061     MOVFFL PLUSW1, ltemp2
11956  F38C     NOP
11958  F509     NOP
1195A  0EDC     MOVLW 0xDC
1195C  0061     MOVFFL PLUSW1, ttemp3
1195E  F38C     NOP
11960  F50A     NOP
11962  0EDD     MOVLW 0xDD
11964  0061     MOVFFL PLUSW1, wtemp5
11966  F38C     NOP
11968  F50B     NOP
1196A  0EDE     MOVLW 0xDE
1196C  0061     MOVFFL PLUSW1, 0x50C
1196E  F38C     NOP
11970  F50C     NOP
11972  0EE3     MOVLW 0xE3
11974  0061     MOVFFL ltemp2, PLUSW1
11976  F424     NOP
11978  F4E3     NOP
1197A  0EE4     MOVLW 0xE4
1197C  0061     MOVFFL ttemp3, PLUSW1
1197E  F428     NOP
11980  F4E3     NOP
11982  0EE5     MOVLW 0xE5
11984  0061     MOVFFL wtemp5, PLUSW1
11986  F42C     NOP
11988  F4E3     NOP
1198A  0EE6     MOVLW 0xE6
1198C  0061     MOVFFL 0x50C, PLUSW1
1198E  F430     NOP
11990  F4E3     NOP
287:               ou = u;
11992  0ED7     MOVLW 0xD7
11994  0061     MOVFFL PLUSW1, ltemp2
11996  F38C     NOP
11998  F509     NOP
1199A  0ED8     MOVLW 0xD8
1199C  0061     MOVFFL PLUSW1, ttemp3
1199E  F38C     NOP
119A0  F50A     NOP
119A2  0ED9     MOVLW 0xD9
119A4  0061     MOVFFL PLUSW1, wtemp5
119A6  F38C     NOP
119A8  F50B     NOP
119AA  0EDA     MOVLW 0xDA
119AC  0061     MOVFFL PLUSW1, 0x50C
119AE  F38C     NOP
119B0  F50C     NOP
119B2  0EE7     MOVLW 0xE7
119B4  0061     MOVFFL ltemp2, PLUSW1
119B6  F424     NOP
119B8  F4E3     NOP
119BA  0EE8     MOVLW 0xE8
119BC  0061     MOVFFL ttemp3, PLUSW1
119BE  F428     NOP
119C0  F4E3     NOP
119C2  0EE9     MOVLW 0xE9
119C4  0061     MOVFFL wtemp5, PLUSW1
119C6  F42C     NOP
119C8  F4E3     NOP
119CA  0EEA     MOVLW 0xEA
119CC  0061     MOVFFL 0x50C, PLUSW1
119CE  F430     NOP
119D0  F4E3     NOP
288:               while (i < m) {
119D2  D0BA     BRA 0x1B48
11B48  50E1     MOVF 0xFE1, W, ACCESS
11B4A  0FED     ADDLW 0xED
11B4C  6ED9     MOVWF 0xFD9, ACCESS
11B4E  50E2     MOVF 0xFE2, W, ACCESS
11B50  6EDA     MOVWF __end_of_UART2_tx_vect_isr, ACCESS
11B52  0EFF     MOVLW 0xFF
11B54  22DA     ADDWFC __end_of_UART2_tx_vect_isr, F, ACCESS
11B56  0EFB     MOVLW 0xFB
11B58  50E3     MOVF 0xFE3, W, ACCESS
11B5A  5CDE     SUBWF 0xFDE, W, ACCESS
11B5C  50DE     MOVF 0xFDE, W, ACCESS
11B5E  0A80     XORLW 0x80
11B60  6E01     MOVWF __ptext283, ACCESS
11B62  0EFC     MOVLW 0xFC
11B64  50E3     MOVF 0xFE3, W, ACCESS
11B66  0A80     XORLW 0x80
11B68  5801     SUBWFB __ptext283, W, ACCESS
11B6A  A0D8     BTFSS 0xFD8, 0, ACCESS
11B6C  D733     BRA 0x19D4
289:                   l = floor(h/u);
119D4  0ED7     MOVLW 0xD7
119D6  C4E3     MOVFF PLUSW1, POSTINC1
119D8  F4E6     NOP
119DA  C4E3     MOVFF PLUSW1, POSTINC1
119DC  F4E6     NOP
119DE  C4E3     MOVFF PLUSW1, POSTINC1
119E0  F4E6     NOP
119E2  C4E3     MOVFF PLUSW1, POSTINC1
119E4  F4E6     NOP
119E6  0EDF     MOVLW 0xDF
119E8  C4E3     MOVFF PLUSW1, POSTINC1
119EA  F4E6     NOP
119EC  C4E3     MOVFF PLUSW1, POSTINC1
119EE  F4E6     NOP
119F0  C4E3     MOVFF PLUSW1, POSTINC1
119F2  F4E6     NOP
119F4  C4E3     MOVFF PLUSW1, POSTINC1
119F6  F4E6     NOP
119F8  ECD2     CALL 0x187A4, 0
119FA  F0C3     NOP
119FC  0061     MOVFFL ltemp0, POSTINC1
119FE  F404     NOP
11A00  F4E6     NOP
11A02  0061     MOVFFL ttemp5, POSTINC1
11A04  F408     NOP
11A06  F4E6     NOP
11A08  0061     MOVFFL wtemp1, POSTINC1
11A0A  F40C     NOP
11A0C  F4E6     NOP
11A0E  0061     MOVFFL ttemp1, POSTINC1
11A10  F410     NOP
11A12  F4E6     NOP
11A14  ECA1     CALL 0x1A142, 0
11A16  F0D0     NOP
11A18  0EDF     MOVLW 0xDF
11A1A  0061     MOVFFL ltemp0, PLUSW1
11A1C  F404     NOP
11A1E  F4E3     NOP
11A20  0EE0     MOVLW 0xE0
11A22  0061     MOVFFL ttemp5, PLUSW1
11A24  F408     NOP
11A26  F4E3     NOP
11A28  0EE1     MOVLW 0xE1
11A2A  0061     MOVFFL wtemp1, PLUSW1
11A2C  F40C     NOP
11A2E  F4E3     NOP
11A30  0EE2     MOVLW 0xE2
11A32  0061     MOVFFL ttemp1, PLUSW1
11A34  F410     NOP
11A36  F4E3     NOP
290:                   d = (int)l;
11A38  0EDF     MOVLW 0xDF
11A3A  C4E3     MOVFF PLUSW1, POSTINC1
11A3C  F4E6     NOP
11A3E  C4E3     MOVFF PLUSW1, POSTINC1
11A40  F4E6     NOP
11A42  C4E3     MOVFF PLUSW1, POSTINC1
11A44  F4E6     NOP
11A46  C4E3     MOVFF PLUSW1, POSTINC1
11A48  F4E6     NOP
11A4A  ECF4     CALL 0x1D3E8, 0
11A4C  F0E9     NOP
11A4E  0061     MOVFFL ltemp0, wtemp5
11A50  F404     NOP
11A52  F50B     NOP
11A54  0061     MOVFFL ttemp5, 0x50C
11A56  F408     NOP
11A58  F50C     NOP
11A5A  0EEF     MOVLW 0xEF
11A5C  0061     MOVFFL wtemp5, PLUSW1
11A5E  F42C     NOP
11A60  F4E3     NOP
11A62  0EF0     MOVLW 0xF0
11A64  0061     MOVFFL 0x50C, PLUSW1
11A66  F430     NOP
11A68  F4E3     NOP
291:                   h -= l*u;
11A6A  0ED7     MOVLW 0xD7
11A6C  C4E3     MOVFF PLUSW1, POSTINC1
11A6E  F4E6     NOP
11A70  C4E3     MOVFF PLUSW1, POSTINC1
11A72  F4E6     NOP
11A74  C4E3     MOVFF PLUSW1, POSTINC1
11A76  F4E6     NOP
11A78  C4E3     MOVFF PLUSW1, POSTINC1
11A7A  F4E6     NOP
11A7C  0EDB     MOVLW 0xDB
11A7E  C4E3     MOVFF PLUSW1, POSTINC1
11A80  F4E6     NOP
11A82  C4E3     MOVFF PLUSW1, POSTINC1
11A84  F4E6     NOP
11A86  C4E3     MOVFF PLUSW1, POSTINC1
11A88  F4E6     NOP
11A8A  C4E3     MOVFF PLUSW1, POSTINC1
11A8C  F4E6     NOP
11A8E  EC2F     CALL 0x1705E, 0
11A90  F0B8     NOP
11A92  0061     MOVFFL ltemp0, POSTINC1
11A94  F404     NOP
11A96  F4E6     NOP
11A98  0061     MOVFFL ttemp5, POSTINC1
11A9A  F408     NOP
11A9C  F4E6     NOP
11A9E  0061     MOVFFL wtemp1, POSTINC1
11AA0  F40C     NOP
11AA2  F4E6     NOP
11AA4  0061     MOVFFL ttemp1, POSTINC1
11AA6  F410     NOP
11AA8  F4E6     NOP
11AAA  0EDF     MOVLW 0xDF
11AAC  C4E3     MOVFF PLUSW1, POSTINC1
11AAE  F4E6     NOP
11AB0  C4E3     MOVFF PLUSW1, POSTINC1
11AB2  F4E6     NOP
11AB4  C4E3     MOVFF PLUSW1, POSTINC1
11AB6  F4E6     NOP
11AB8  C4E3     MOVFF PLUSW1, POSTINC1
11ABA  F4E6     NOP
11ABC  ECC0     CALL 0x1B80, 0
11ABE  F00D     NOP
11AC0  0EE3     MOVLW 0xE3
11AC2  0061     MOVFFL ltemp0, PLUSW1
11AC4  F404     NOP
11AC6  F4E3     NOP
11AC8  0EE4     MOVLW 0xE4
11ACA  0061     MOVFFL ttemp5, PLUSW1
11ACC  F408     NOP
11ACE  F4E3     NOP
11AD0  0EE5     MOVLW 0xE5
11AD2  0061     MOVFFL wtemp1, PLUSW1
11AD4  F40C     NOP
11AD6  F4E3     NOP
11AD8  0EE6     MOVLW 0xE6
11ADA  0061     MOVFFL ttemp1, PLUSW1
11ADC  F410     NOP
11ADE  F4E3     NOP
292:                   u = u/16.0;
11AE0  0E00     MOVLW 0x0
11AE2  6EE6     MOVWF 0xFE6, ACCESS
11AE4  0E00     MOVLW 0x0
11AE6  6EE6     MOVWF 0xFE6, ACCESS
11AE8  0E80     MOVLW 0x80
11AEA  6EE6     MOVWF 0xFE6, ACCESS
11AEC  0E41     MOVLW 0x41
11AEE  6EE6     MOVWF 0xFE6, ACCESS
11AF0  0ED3     MOVLW 0xD3
11AF2  C4E3     MOVFF PLUSW1, POSTINC1
11AF4  F4E6     NOP
11AF6  C4E3     MOVFF PLUSW1, POSTINC1
11AF8  F4E6     NOP
11AFA  C4E3     MOVFF PLUSW1, POSTINC1
11AFC  F4E6     NOP
11AFE  C4E3     MOVFF PLUSW1, POSTINC1
11B00  F4E6     NOP
11B02  ECD2     CALL 0x187A4, 0
11B04  F0C3     NOP
11B06  0ED7     MOVLW 0xD7
11B08  0061     MOVFFL ltemp0, PLUSW1
11B0A  F404     NOP
11B0C  F4E3     NOP
11B0E  0ED8     MOVLW 0xD8
11B10  0061     MOVFFL ttemp5, PLUSW1
11B12  F408     NOP
11B14  F4E3     NOP
11B16  0ED9     MOVLW 0xD9
11B18  0061     MOVFFL wtemp1, PLUSW1
11B1A  F40C     NOP
11B1C  F4E3     NOP
11B1E  0EDA     MOVLW 0xDA
11B20  0061     MOVFFL ttemp1, PLUSW1
11B22  F410     NOP
11B24  F4E3     NOP
293:                   ++i;
11B26  0EED     MOVLW 0xED
11B28  50E3     MOVF 0xFE3, W, ACCESS
11B2A  0F01     ADDLW 0x1
11B2C  6E01     MOVWF __ptext283, ACCESS
11B2E  0EED     MOVLW 0xED
11B30  0061     MOVFFL ltemp0, PLUSW1
11B32  F404     NOP
11B34  F4E3     NOP
11B36  6A01     CLRF __ptext283, ACCESS
11B38  0EEE     MOVLW 0xEE
11B3A  50E3     MOVF 0xFE3, W, ACCESS
11B3C  2001     ADDWFC __ptext283, W, ACCESS
11B3E  6E01     MOVWF __ptext283, ACCESS
11B40  0EEE     MOVLW 0xEE
11B42  0061     MOVFFL ltemp0, PLUSW1
11B44  F404     NOP
11B46  F4E3     NOP
294:               }
295:               
296:               /* Remainder >= halfway ? */
297:               l = u*8.0;
11B6E  0E00     MOVLW 0x0
11B70  6EE6     MOVWF 0xFE6, ACCESS
11B72  0E00     MOVLW 0x0
11B74  6EE6     MOVWF 0xFE6, ACCESS
11B76  0E00     MOVLW 0x0
11B78  6EE6     MOVWF 0xFE6, ACCESS
11B7A  0E41     MOVLW 0x41
11B7C  6EE6     MOVWF 0xFE6, ACCESS
11B7E  0ED3     MOVLW 0xD3
11B80  C4E3     MOVFF PLUSW1, POSTINC1
11B82  F4E6     NOP
11B84  C4E3     MOVFF PLUSW1, POSTINC1
11B86  F4E6     NOP
11B88  C4E3     MOVFF PLUSW1, POSTINC1
11B8A  F4E6     NOP
11B8C  C4E3     MOVFF PLUSW1, POSTINC1
11B8E  F4E6     NOP
11B90  EC2F     CALL 0x1705E, 0
11B92  F0B8     NOP
11B94  0EDF     MOVLW 0xDF
11B96  0061     MOVFFL ltemp0, PLUSW1
11B98  F404     NOP
11B9A  F4E3     NOP
11B9C  0EE0     MOVLW 0xE0
11B9E  0061     MOVFFL ttemp5, PLUSW1
11BA0  F408     NOP
11BA2  F4E3     NOP
11BA4  0EE1     MOVLW 0xE1
11BA6  0061     MOVFFL wtemp1, PLUSW1
11BA8  F40C     NOP
11BAA  F4E3     NOP
11BAC  0EE2     MOVLW 0xE2
11BAE  0061     MOVFFL ttemp1, PLUSW1
11BB0  F410     NOP
11BB2  F4E3     NOP
298:               if (h < l) {
11BB4  0EDF     MOVLW 0xDF
11BB6  C4E3     MOVFF PLUSW1, POSTINC1
11BB8  F4E6     NOP
11BBA  C4E3     MOVFF PLUSW1, POSTINC1
11BBC  F4E6     NOP
11BBE  C4E3     MOVFF PLUSW1, POSTINC1
11BC0  F4E6     NOP
11BC2  C4E3     MOVFF PLUSW1, POSTINC1
11BC4  F4E6     NOP
11BC6  0EDF     MOVLW 0xDF
11BC8  C4E3     MOVFF PLUSW1, POSTINC1
11BCA  F4E6     NOP
11BCC  C4E3     MOVFF PLUSW1, POSTINC1
11BCE  F4E6     NOP
11BD0  C4E3     MOVFF PLUSW1, POSTINC1
11BD2  F4E6     NOP
11BD4  C4E3     MOVFF PLUSW1, POSTINC1
11BD6  F4E6     NOP
11BD8  EC60     CALL 0x1D6C0, 0
11BDA  F0EB     NOP
11BDC  A001     BTFSS __ptext283, 0, ACCESS
299:                   l = 0.0;
11BDE  D019     BRA 0x1C12
300:               } else {
301:                   /* On tie choose even number */
302:                   if ((h == l) && !(d % 2)) {
11BE0  0EDF     MOVLW 0xDF
11BE2  C4E3     MOVFF PLUSW1, POSTINC1
11BE4  F4E6     NOP
11BE6  C4E3     MOVFF PLUSW1, POSTINC1
11BE8  F4E6     NOP
11BEA  C4E3     MOVFF PLUSW1, POSTINC1
11BEC  F4E6     NOP
11BEE  C4E3     MOVFF PLUSW1, POSTINC1
11BF0  F4E6     NOP
11BF2  0EDF     MOVLW 0xDF
11BF4  C4E3     MOVFF PLUSW1, POSTINC1
11BF6  F4E6     NOP
11BF8  C4E3     MOVFF PLUSW1, POSTINC1
11BFA  F4E6     NOP
11BFC  C4E3     MOVFF PLUSW1, POSTINC1
11BFE  F4E6     NOP
11C00  C4E3     MOVFF PLUSW1, POSTINC1
11C02  F4E6     NOP
11C04  EC95     CALL 0x1F92A, 0
11C06  F0FC     NOP
11C08  A001     BTFSS __ptext283, 0, ACCESS
11C0A  D01B     BRA 0x1C42
11C0C  0EEF     MOVLW 0xEF
11C0E  B0E3     BTFSC 0xFE3, 0, ACCESS
11C10  D018     BRA 0x1C42
303:                       l = 0.0;
11C12  0E00     MOVLW 0x0
11C14  6E09     MOVWF 0x9, ACCESS
11C16  0E00     MOVLW 0x0
11C18  6E0A     MOVWF 0xA, ACCESS
11C1A  0E00     MOVLW 0x0
11C1C  6E0B     MOVWF 0xB, ACCESS
11C1E  0E00     MOVLW 0x0
11C20  6E0C     MOVWF 0xC, ACCESS
11C22  0EDF     MOVLW 0xDF
11C24  0061     MOVFFL ltemp2, PLUSW1
11C26  F424     NOP
11C28  F4E3     NOP
11C2A  0EE0     MOVLW 0xE0
11C2C  0061     MOVFFL ttemp3, PLUSW1
11C2E  F428     NOP
11C30  F4E3     NOP
11C32  0EE1     MOVLW 0xE1
11C34  0061     MOVFFL wtemp5, PLUSW1
11C36  F42C     NOP
11C38  F4E3     NOP
11C3A  0EE2     MOVLW 0xE2
11C3C  0061     MOVFFL 0x50C, PLUSW1
11C3E  F430     NOP
11C40  F4E3     NOP
304:                   }
305:               }
306:           
307:               /* Round */
308:               h = g + l;
11C42  0EDF     MOVLW 0xDF
11C44  C4E3     MOVFF PLUSW1, POSTINC1
11C46  F4E6     NOP
11C48  C4E3     MOVFF PLUSW1, POSTINC1
11C4A  F4E6     NOP
11C4C  C4E3     MOVFF PLUSW1, POSTINC1
11C4E  F4E6     NOP
11C50  C4E3     MOVFF PLUSW1, POSTINC1
11C52  F4E6     NOP
11C54  0ED7     MOVLW 0xD7
11C56  C4E3     MOVFF PLUSW1, POSTINC1
11C58  F4E6     NOP
11C5A  C4E3     MOVFF PLUSW1, POSTINC1
11C5C  F4E6     NOP
11C5E  C4E3     MOVFF PLUSW1, POSTINC1
11C60  F4E6     NOP
11C62  C4E3     MOVFF PLUSW1, POSTINC1
11C64  F4E6     NOP
11C66  EC30     CALL 0x17860, 0
11C68  F0BC     NOP
11C6A  0EE3     MOVLW 0xE3
11C6C  0061     MOVFFL ltemp0, PLUSW1
11C6E  F404     NOP
11C70  F4E3     NOP
11C72  0EE4     MOVLW 0xE4
11C74  0061     MOVFFL ttemp5, PLUSW1
11C76  F408     NOP
11C78  F4E3     NOP
11C7A  0EE5     MOVLW 0xE5
11C7C  0061     MOVFFL wtemp1, PLUSW1
11C7E  F40C     NOP
11C80  F4E3     NOP
11C82  0EE6     MOVLW 0xE6
11C84  0061     MOVFFL ttemp1, PLUSW1
11C86  F410     NOP
11C88  F4E3     NOP
309:               
310:               /* Convert again, after rounding */
311:               u = ou;
11C8A  0EE7     MOVLW 0xE7
11C8C  0061     MOVFFL PLUSW1, ltemp2
11C8E  F38C     NOP
11C90  F509     NOP
11C92  0EE8     MOVLW 0xE8
11C94  0061     MOVFFL PLUSW1, ttemp3
11C96  F38C     NOP
11C98  F50A     NOP
11C9A  0EE9     MOVLW 0xE9
11C9C  0061     MOVFFL PLUSW1, wtemp5
11C9E  F38C     NOP
11CA0  F50B     NOP
11CA2  0EEA     MOVLW 0xEA
11CA4  0061     MOVFFL PLUSW1, 0x50C
11CA6  F38C     NOP
11CA8  F50C     NOP
11CAA  0ED7     MOVLW 0xD7
11CAC  0061     MOVFFL ltemp2, PLUSW1
11CAE  F424     NOP
11CB0  F4E3     NOP
11CB2  0ED8     MOVLW 0xD8
11CB4  0061     MOVFFL ttemp3, PLUSW1
11CB6  F428     NOP
11CB8  F4E3     NOP
11CBA  0ED9     MOVLW 0xD9
11CBC  0061     MOVFFL wtemp5, PLUSW1
11CBE  F42C     NOP
11CC0  F4E3     NOP
11CC2  0EDA     MOVLW 0xDA
11CC4  0061     MOVFFL 0x50C, PLUSW1
11CC6  F430     NOP
11CC8  F4E3     NOP
312:               ne = 0;
11CCA  0EF9     MOVLW 0xF9
11CCC  6AE3     CLRF 0xFE3, ACCESS
11CCE  0EFA     MOVLW 0xFA
11CD0  6AE3     CLRF 0xFE3, ACCESS
313:               pp = 0;
11CD2  0EFE     MOVLW 0xFE
11CD4  6AE3     CLRF 0xFE3, ACCESS
314:               t = 0;
11CD6  0EF5     MOVLW 0xF5
11CD8  6AE3     CLRF 0xFE3, ACCESS
11CDA  0EF6     MOVLW 0xF6
11CDC  6AE3     CLRF 0xFE3, ACCESS
315:               i = 0;
11CDE  0EED     MOVLW 0xED
11CE0  6AE3     CLRF 0xFE3, ACCESS
11CE2  0EEE     MOVLW 0xEE
11CE4  6AE3     CLRF 0xFE3, ACCESS
316:               while ((i < m) && (n < (DBLEN - EXPLEN))) {
11CE6  D1E8     BRA 0x20B8
120B8  50E1     MOVF 0xFE1, W, ACCESS
120BA  0FED     ADDLW 0xED
120BC  6ED9     MOVWF 0xFD9, ACCESS
120BE  50E2     MOVF 0xFE2, W, ACCESS
120C0  6EDA     MOVWF __end_of_UART2_tx_vect_isr, ACCESS
120C2  0EFF     MOVLW 0xFF
120C4  22DA     ADDWFC __end_of_UART2_tx_vect_isr, F, ACCESS
120C6  0EFB     MOVLW 0xFB
120C8  50E3     MOVF 0xFE3, W, ACCESS
120CA  5CDE     SUBWF 0xFDE, W, ACCESS
120CC  50DE     MOVF 0xFDE, W, ACCESS
120CE  0A80     XORLW 0x80
120D0  6E01     MOVWF __ptext283, ACCESS
120D2  0EFC     MOVLW 0xFC
120D4  50E3     MOVF 0xFE3, W, ACCESS
120D6  0A80     XORLW 0x80
120D8  5801     SUBWFB __ptext283, W, ACCESS
120DA  B0D8     BTFSC 0xFD8, 0, ACCESS
120DC  D00E     BRA UART2_SetTxInterruptHandler
120DE  0EEC     MOVLW 0xEC
120E0  BEE3     BTFSC 0xFE3, 7, ACCESS
120E2  D602     BRA 0x1CE8
120E4  0EEC     MOVLW 0xEC
120E6  50E3     MOVF 0xFE3, W, ACCESS
120E8  E108     BNZ UART2_SetTxInterruptHandler
120EA  0EEB     MOVLW 0xEB
120EC  0061     MOVFFL PLUSW1, ltemp0
120EE  F38C     NOP
120F0  F501     NOP
120F2  0E4B     MOVLW 0x4B
120F4  5E01     SUBWF __ptext283, F, ACCESS
120F6  A0D8     BTFSS 0xFD8, 0, ACCESS
120F8  D5F7     BRA 0x1CE8
317:                   l = floor(h/u);
11CE8  0ED7     MOVLW 0xD7
11CEA  C4E3     MOVFF PLUSW1, POSTINC1
11CEC  F4E6     NOP
11CEE  C4E3     MOVFF PLUSW1, POSTINC1
11CF0  F4E6     NOP
11CF2  C4E3     MOVFF PLUSW1, POSTINC1
11CF4  F4E6     NOP
11CF6  C4E3     MOVFF PLUSW1, POSTINC1
11CF8  F4E6     NOP
11CFA  0EDF     MOVLW 0xDF
11CFC  C4E3     MOVFF PLUSW1, POSTINC1
11CFE  F4E6     NOP
11D00  C4E3     MOVFF PLUSW1, POSTINC1
11D02  F4E6     NOP
11D04  C4E3     MOVFF PLUSW1, POSTINC1
11D06  F4E6     NOP
11D08  C4E3     MOVFF PLUSW1, POSTINC1
11D0A  F4E6     NOP
11D0C  ECD2     CALL 0x187A4, 0
11D0E  F0C3     NOP
11D10  0061     MOVFFL ltemp0, POSTINC1
11D12  F404     NOP
11D14  F4E6     NOP
11D16  0061     MOVFFL ttemp5, POSTINC1
11D18  F408     NOP
11D1A  F4E6     NOP
11D1C  0061     MOVFFL wtemp1, POSTINC1
11D1E  F40C     NOP
11D20  F4E6     NOP
11D22  0061     MOVFFL ttemp1, POSTINC1
11D24  F410     NOP
11D26  F4E6     NOP
11D28  ECA1     CALL 0x1A142, 0
11D2A  F0D0     NOP
11D2C  0EDF     MOVLW 0xDF
11D2E  0061     MOVFFL ltemp0, PLUSW1
11D30  F404     NOP
11D32  F4E3     NOP
11D34  0EE0     MOVLW 0xE0
11D36  0061     MOVFFL ttemp5, PLUSW1
11D38  F408     NOP
11D3A  F4E3     NOP
11D3C  0EE1     MOVLW 0xE1
11D3E  0061     MOVFFL wtemp1, PLUSW1
11D40  F40C     NOP
11D42  F4E3     NOP
11D44  0EE2     MOVLW 0xE2
11D46  0061     MOVFFL ttemp1, PLUSW1
11D48  F410     NOP
11D4A  F4E3     NOP
318:                   d = (int)l;
11D4C  0EDF     MOVLW 0xDF
11D4E  C4E3     MOVFF PLUSW1, POSTINC1
11D50  F4E6     NOP
11D52  C4E3     MOVFF PLUSW1, POSTINC1
11D54  F4E6     NOP
11D56  C4E3     MOVFF PLUSW1, POSTINC1
11D58  F4E6     NOP
11D5A  C4E3     MOVFF PLUSW1, POSTINC1
11D5C  F4E6     NOP
11D5E  ECF4     CALL 0x1D3E8, 0
11D60  F0E9     NOP
11D62  0061     MOVFFL ltemp0, wtemp5
11D64  F404     NOP
11D66  F50B     NOP
11D68  0061     MOVFFL ttemp5, 0x50C
11D6A  F408     NOP
11D6C  F50C     NOP
11D6E  0EEF     MOVLW 0xEF
11D70  0061     MOVFFL wtemp5, PLUSW1
11D72  F42C     NOP
11D74  F4E3     NOP
11D76  0EF0     MOVLW 0xF0
11D78  0061     MOVFFL 0x50C, PLUSW1
11D7A  F430     NOP
11D7C  F4E3     NOP
319:                   if (!d && (ne < 0)
11D7E  0EEF     MOVLW 0xEF
11D80  0061     MOVFFL PLUSW1, ltemp0
11D82  F38C     NOP
11D84  F501     NOP
11D86  0EF0     MOVLW 0xF0
11D88  50E3     MOVF 0xFE3, W, ACCESS
11D8A  1001     IORWF __ptext283, W, ACCESS
11D8C  A4D8     BTFSS 0xFD8, 2, ACCESS
11D8E  D016     BRA 0x1DBC
11D90  0EFA     MOVLW 0xFA
11D92  BEE3     BTFSC 0xFE3, 7, ACCESS
11D94  B827     BTFSC 0x27, 4, ACCESS
11D96  D012     BRA 0x1DBC
320:           #ifdef _VFPF_ALTERN
321:           				&& !(flags & POUND_FLAG)
322:           #endif
323:           				) {
324:                       ++t;
11D98  0EF5     MOVLW 0xF5
11D9A  50E3     MOVF 0xFE3, W, ACCESS
11D9C  0F01     ADDLW 0x1
11D9E  6E01     MOVWF __ptext283, ACCESS
11DA0  0EF5     MOVLW 0xF5
11DA2  0061     MOVFFL ltemp0, PLUSW1
11DA4  F404     NOP
11DA6  F4E3     NOP
11DA8  6A01     CLRF __ptext283, ACCESS
11DAA  0EF6     MOVLW 0xF6
11DAC  50E3     MOVF 0xFE3, W, ACCESS
11DAE  2001     ADDWFC __ptext283, W, ACCESS
11DB0  6E01     MOVWF __ptext283, ACCESS
11DB2  0EF6     MOVLW 0xF6
11DB4  0061     MOVFFL ltemp0, PLUSW1
11DB6  F404     NOP
11DB8  F4E3     NOP
325:                   } else {
11DBA  D0EE     BRA 0x1F98
326:                       if (!pp && (ne < 0)) {
11DBC  0EFE     MOVLW 0xFE
11DBE  50E3     MOVF 0xFE3, W, ACCESS
11DC0  A4D8     BTFSS 0xFD8, 2, ACCESS
11DC2  D067     BRA 0x1E92
11DC4  0EFA     MOVLW 0xFA
11DC6  AEE3     BTFSS 0xFE3, 7, ACCESS
11DC8  D064     BRA 0x1E92
327:                           dbuf[n++] = '.';
11DCA  0EEB     MOVLW 0xEB
11DCC  0061     MOVFFL PLUSW1, wtemp5
11DCE  F38C     NOP
11DD0  F50B     NOP
11DD2  0EEC     MOVLW 0xEC
11DD4  0061     MOVFFL PLUSW1, 0x50C
11DD6  F38C     NOP
11DD8  F50C     NOP
11DDA  0EA5     MOVLW 0xA5
11DDC  240B     ADDWF 0xB, W, ACCESS
11DDE  6ED9     MOVWF 0xFD9, ACCESS
11DE0  0E08     MOVLW 0x8
11DE2  200C     ADDWFC 0xC, W, ACCESS
11DE4  6EDA     MOVWF __end_of_UART2_tx_vect_isr, ACCESS
11DE6  0E2E     MOVLW 0x2E
11DE8  6EDF     MOVWF 0xFDF, ACCESS
11DEA  0EEB     MOVLW 0xEB
11DEC  50E3     MOVF 0xFE3, W, ACCESS
11DEE  0F01     ADDLW 0x1
11DF0  6E01     MOVWF __ptext283, ACCESS
11DF2  0EEB     MOVLW 0xEB
11DF4  0061     MOVFFL ltemp0, PLUSW1
11DF6  F404     NOP
11DF8  F4E3     NOP
11DFA  6A01     CLRF __ptext283, ACCESS
11DFC  0EEC     MOVLW 0xEC
11DFE  50E3     MOVF 0xFE3, W, ACCESS
11E00  2001     ADDWFC __ptext283, W, ACCESS
11E02  6E01     MOVWF __ptext283, ACCESS
11E04  0EEC     MOVLW 0xEC
11E06  0061     MOVFFL ltemp0, PLUSW1
11E08  F404     NOP
11E0A  F4E3     NOP
328:                           --w;
11E0C  50E1     MOVF 0xFE1, W, ACCESS
11E0E  0FF1     ADDLW 0xF1
11E10  6ED9     MOVWF 0xFD9, ACCESS
11E12  50E2     MOVF 0xFE2, W, ACCESS
11E14  6EDA     MOVWF __end_of_UART2_tx_vect_isr, ACCESS
11E16  0EFF     MOVLW 0xFF
11E18  22DA     ADDWFC __end_of_UART2_tx_vect_isr, F, ACCESS
11E1A  06DE     DECF 0xFDE, F, ACCESS
11E1C  0E00     MOVLW 0x0
11E1E  5ADD     SUBWFB 0xFDD, F, ACCESS
329:                           pp = 1;
11E20  0EFE     MOVLW 0xFE
11E22  6AE3     CLRF 0xFE3, ACCESS
11E24  2AE3     INCF 0xFE3, F, ACCESS
11E26  D035     BRA 0x1E92
330:                       }
331:                       while (t) {
11E92  0EF5     MOVLW 0xF5
11E94  0061     MOVFFL PLUSW1, ltemp0
11E96  F38C     NOP
11E98  F501     NOP
11E9A  0EF6     MOVLW 0xF6
11E9C  50E3     MOVF 0xFE3, W, ACCESS
11E9E  1001     IORWF __ptext283, W, ACCESS
11EA0  A4D8     BTFSS 0xFD8, 2, ACCESS
11EA2  D7C2     BRA 0x1E28
332:                           dbuf[n++] = '0';
11E28  0EEB     MOVLW 0xEB
11E2A  0061     MOVFFL PLUSW1, wtemp5
11E2C  F38C     NOP
11E2E  F50B     NOP
11E30  0EEC     MOVLW 0xEC
11E32  0061     MOVFFL PLUSW1, 0x50C
11E34  F38C     NOP
11E36  F50C     NOP
11E38  0EA5     MOVLW 0xA5
11E3A  240B     ADDWF 0xB, W, ACCESS
11E3C  6ED9     MOVWF 0xFD9, ACCESS
11E3E  0E08     MOVLW 0x8
11E40  200C     ADDWFC 0xC, W, ACCESS
11E42  6EDA     MOVWF __end_of_UART2_tx_vect_isr, ACCESS
11E44  0E30     MOVLW 0x30
11E46  6EDF     MOVWF 0xFDF, ACCESS
11E48  0EEB     MOVLW 0xEB
11E4A  50E3     MOVF 0xFE3, W, ACCESS
11E4C  0F01     ADDLW 0x1
11E4E  6E01     MOVWF __ptext283, ACCESS
11E50  0EEB     MOVLW 0xEB
11E52  0061     MOVFFL ltemp0, PLUSW1
11E54  F404     NOP
11E56  F4E3     NOP
11E58  6A01     CLRF __ptext283, ACCESS
11E5A  0EEC     MOVLW 0xEC
11E5C  50E3     MOVF 0xFE3, W, ACCESS
11E5E  2001     ADDWFC __ptext283, W, ACCESS
11E60  6E01     MOVWF __ptext283, ACCESS
11E62  0EEC     MOVLW 0xEC
11E64  0061     MOVFFL ltemp0, PLUSW1
11E66  F404     NOP
11E68  F4E3     NOP
333:                           --w;
11E6A  50E1     MOVF 0xFE1, W, ACCESS
11E6C  0FF1     ADDLW 0xF1
11E6E  6ED9     MOVWF 0xFD9, ACCESS
11E70  50E2     MOVF 0xFE2, W, ACCESS
11E72  6EDA     MOVWF __end_of_UART2_tx_vect_isr, ACCESS
11E74  0EFF     MOVLW 0xFF
11E76  22DA     ADDWFC __end_of_UART2_tx_vect_isr, F, ACCESS
11E78  06DE     DECF 0xFDE, F, ACCESS
11E7A  0E00     MOVLW 0x0
11E7C  5ADD     SUBWFB 0xFDD, F, ACCESS
334:                           --t;
11E7E  50E1     MOVF 0xFE1, W, ACCESS
11E80  0FF5     ADDLW 0xF5
11E82  6ED9     MOVWF 0xFD9, ACCESS
11E84  50E2     MOVF 0xFE2, W, ACCESS
11E86  6EDA     MOVWF __end_of_UART2_tx_vect_isr, ACCESS
11E88  0EFF     MOVLW 0xFF
11E8A  22DA     ADDWFC __end_of_UART2_tx_vect_isr, F, ACCESS
11E8C  06DE     DECF 0xFDE, F, ACCESS
11E8E  0E00     MOVLW 0x0
11E90  5ADD     SUBWFB 0xFDD, F, ACCESS
335:                       }
336:                       d = (d < 10) ? (int)'0' + d : (int)'a' + (d - 10);
11EA4  0EF0     MOVLW 0xF0
11EA6  BEE3     BTFSC 0xFE3, 7, ACCESS
11EA8  D00F     BRA UART2_Transmit_ISR
11EAA  0EF0     MOVLW 0xF0
11EAC  50E3     MOVF 0xFE3, W, ACCESS
11EAE  E108     BNZ 0x1EC0
11EB0  0EEF     MOVLW 0xEF
11EB2  0061     MOVFFL PLUSW1, ltemp0
11EB4  F38C     NOP
11EB6  F501     NOP
11EB8  0E0A     MOVLW 0xA
11EBA  5E01     SUBWF __ptext283, F, ACCESS
11EBC  A0D8     BTFSS 0xFD8, 0, ACCESS
11EBE  D004     BRA UART2_Transmit_ISR
11EC0  0EEF     MOVLW 0xEF
11EC2  50E3     MOVF 0xFE3, W, ACCESS
11EC4  0F57     ADDLW 0x57
11EC6  D003     BRA 0x1ECE
11EC8  0EEF     MOVLW 0xEF
11ECA  50E3     MOVF 0xFE3, W, ACCESS
11ECC  0F30     ADDLW 0x30
11ECE  6E01     MOVWF __ptext283, ACCESS
11ED0  0EEF     MOVLW 0xEF
11ED2  0061     MOVFFL ltemp0, PLUSW1
11ED4  F404     NOP
11ED6  F4E3     NOP
11ED8  6A01     CLRF __ptext283, ACCESS
11EDA  0EF0     MOVLW 0xF0
11EDC  50E3     MOVF 0xFE3, W, ACCESS
11EDE  2001     ADDWFC __ptext283, W, ACCESS
11EE0  6E01     MOVWF __ptext283, ACCESS
11EE2  0EF0     MOVLW 0xF0
11EE4  0061     MOVFFL ltemp0, PLUSW1
11EE6  F404     NOP
11EE8  F4E3     NOP
337:           #ifdef _VFPF_UPCASE
338:                       if (c && isalpha(d)) {
11EEA  0EC8     MOVLW 0xC8
11EEC  50E3     MOVF 0xFE3, W, ACCESS
11EEE  B4D8     BTFSC 0xFD8, 2, ACCESS
11EF0  D027     BRA 0x1F40
11EF2  0EEF     MOVLW 0xEF
11EF4  0061     MOVFFL PLUSW1, wtemp5
11EF6  F38C     NOP
11EF8  F50B     NOP
11EFA  0EF0     MOVLW 0xF0
11EFC  0061     MOVFFL PLUSW1, 0x50C
11EFE  F38C     NOP
11F00  F50C     NOP
11F02  0E20     MOVLW 0x20
11F04  120B     IORWF 0xB, F, ACCESS
11F06  0E00     MOVLW 0x0
11F08  120C     IORWF 0xC, F, ACCESS
11F0A  0E9F     MOVLW 0x9F
11F0C  240B     ADDWF 0xB, W, ACCESS
11F0E  6E09     MOVWF 0x9, ACCESS
11F10  0EFF     MOVLW 0xFF
11F12  200C     ADDWFC 0xC, W, ACCESS
11F14  6E0A     MOVWF 0xA, ACCESS
11F16  500A     MOVF 0xA, W, ACCESS
11F18  E113     BNZ 0x1F40
11F1A  0E1A     MOVLW 0x1A
11F1C  5C09     SUBWF 0x9, W, ACCESS
11F1E  B0D8     BTFSC 0xFD8, 0, ACCESS
11F20  D00F     BRA 0x1F40
339:                           d = toupper(d);
11F22  0EEF     MOVLW 0xEF
11F24  C4E3     MOVFF PLUSW1, POSTINC1
11F26  F4E6     NOP
11F28  C4E3     MOVFF PLUSW1, POSTINC1
11F2A  F4E6     NOP
11F2C  ECC5     CALL 0x118A, 0
11F2E  F008     NOP
11F30  0EEF     MOVLW 0xEF
11F32  0061     MOVFFL ltemp0, PLUSW1
11F34  F404     NOP
11F36  F4E3     NOP
11F38  0EF0     MOVLW 0xF0
11F3A  0061     MOVFFL ttemp5, PLUSW1
11F3C  F408     NOP
11F3E  F4E3     NOP
340:                       }
341:           #endif
342:                       dbuf[n++] = (char)d;
11F40  0EEB     MOVLW 0xEB
11F42  0061     MOVFFL PLUSW1, wtemp5
11F44  F38C     NOP
11F46  F50B     NOP
11F48  0EEC     MOVLW 0xEC
11F4A  0061     MOVFFL PLUSW1, 0x50C
11F4C  F38C     NOP
11F4E  F50C     NOP
11F50  0EA5     MOVLW 0xA5
11F52  240B     ADDWF 0xB, W, ACCESS
11F54  6ED9     MOVWF 0xFD9, ACCESS
11F56  0E08     MOVLW 0x8
11F58  200C     ADDWFC 0xC, W, ACCESS
11F5A  6EDA     MOVWF __end_of_UART2_tx_vect_isr, ACCESS
11F5C  0EEF     MOVLW 0xEF
11F5E  C4E3     MOVFF PLUSW1, INDF2
11F60  F4DF     NOP
11F62  0EEB     MOVLW 0xEB
11F64  50E3     MOVF 0xFE3, W, ACCESS
11F66  0F01     ADDLW 0x1
11F68  6E01     MOVWF __ptext283, ACCESS
11F6A  0EEB     MOVLW 0xEB
11F6C  0061     MOVFFL ltemp0, PLUSW1
11F6E  F404     NOP
11F70  F4E3     NOP
11F72  6A01     CLRF __ptext283, ACCESS
11F74  0EEC     MOVLW 0xEC
11F76  50E3     MOVF 0xFE3, W, ACCESS
11F78  2001     ADDWFC __ptext283, W, ACCESS
11F7A  6E01     MOVWF __ptext283, ACCESS
11F7C  0EEC     MOVLW 0xEC
11F7E  0061     MOVFFL ltemp0, PLUSW1
11F80  F404     NOP
11F82  F4E3     NOP
343:                       --w;
11F84  50E1     MOVF 0xFE1, W, ACCESS
11F86  0FF1     ADDLW 0xF1
11F88  6ED9     MOVWF 0xFD9, ACCESS
11F8A  50E2     MOVF 0xFE2, W, ACCESS
11F8C  6EDA     MOVWF __end_of_UART2_tx_vect_isr, ACCESS
11F8E  0EFF     MOVLW 0xFF
11F90  22DA     ADDWFC __end_of_UART2_tx_vect_isr, F, ACCESS
11F92  06DE     DECF 0xFDE, F, ACCESS
11F94  0E00     MOVLW 0x0
11F96  5ADD     SUBWFB 0xFDD, F, ACCESS
344:                   }
345:                   h -= l*u;
11F98  0ED7     MOVLW 0xD7
11F9A  C4E3     MOVFF PLUSW1, POSTINC1
11F9C  F4E6     NOP
11F9E  C4E3     MOVFF PLUSW1, POSTINC1
11FA0  F4E6     NOP
11FA2  C4E3     MOVFF PLUSW1, POSTINC1
11FA4  F4E6     NOP
11FA6  C4E3     MOVFF PLUSW1, POSTINC1
11FA8  F4E6     NOP
11FAA  0EDB     MOVLW 0xDB
11FAC  C4E3     MOVFF PLUSW1, POSTINC1
11FAE  F4E6     NOP
11FB0  C4E3     MOVFF PLUSW1, POSTINC1
11FB2  F4E6     NOP
11FB4  C4E3     MOVFF PLUSW1, POSTINC1
11FB6  F4E6     NOP
11FB8  C4E3     MOVFF PLUSW1, POSTINC1
11FBA  F4E6     NOP
11FBC  EC2F     CALL 0x1705E, 0
11FBE  F0B8     NOP
11FC0  0061     MOVFFL ltemp0, POSTINC1
11FC2  F404     NOP
11FC4  F4E6     NOP
11FC6  0061     MOVFFL ttemp5, POSTINC1
11FC8  F408     NOP
11FCA  F4E6     NOP
11FCC  0061     MOVFFL wtemp1, POSTINC1
11FCE  F40C     NOP
11FD0  F4E6     NOP
11FD2  0061     MOVFFL ttemp1, POSTINC1
11FD4  F410     NOP
11FD6  F4E6     NOP
11FD8  0EDF     MOVLW 0xDF
11FDA  C4E3     MOVFF PLUSW1, POSTINC1
11FDC  F4E6     NOP
11FDE  C4E3     MOVFF PLUSW1, POSTINC1
11FE0  F4E6     NOP
11FE2  C4E3     MOVFF PLUSW1, POSTINC1
11FE4  F4E6     NOP
11FE6  C4E3     MOVFF PLUSW1, POSTINC1
11FE8  F4E6     NOP
11FEA  ECC0     CALL 0x1B80, 0
11FEC  F00D     NOP
11FEE  0EE3     MOVLW 0xE3
11FF0  0061     MOVFFL ltemp0, PLUSW1
11FF2  F404     NOP
11FF4  F4E3     NOP
11FF6  0EE4     MOVLW 0xE4
11FF8  0061     MOVFFL ttemp5, PLUSW1
11FFA  F408     NOP
11FFC  F4E3     NOP
11FFE  0EE5     MOVLW 0xE5
12000  0061     MOVFFL wtemp1, PLUSW1
12002  F40C     NOP
12004  F4E3     NOP
12006  0EE6     MOVLW 0xE6
12008  0061     MOVFFL ttemp1, PLUSW1
1200A  F410     NOP
1200C  F4E3     NOP
346:                   u = u/16.0;
1200E  0E00     MOVLW 0x0
12010  6EE6     MOVWF 0xFE6, ACCESS
12012  0E00     MOVLW 0x0
12014  6EE6     MOVWF 0xFE6, ACCESS
12016  0E80     MOVLW 0x80
12018  6EE6     MOVWF 0xFE6, ACCESS
1201A  0E41     MOVLW 0x41
1201C  6EE6     MOVWF 0xFE6, ACCESS
1201E  0ED3     MOVLW 0xD3
12020  C4E3     MOVFF PLUSW1, POSTINC1
12022  F4E6     NOP
12024  C4E3     MOVFF PLUSW1, POSTINC1
12026  F4E6     NOP
12028  C4E3     MOVFF PLUSW1, POSTINC1
1202A  F4E6     NOP
1202C  C4E3     MOVFF PLUSW1, POSTINC1
1202E  F4E6     NOP
12030  ECD2     CALL 0x187A4, 0
12032  F0C3     NOP
12034  0ED7     MOVLW 0xD7
12036  0061     MOVFFL ltemp0, PLUSW1
12038  F404     NOP
1203A  F4E3     NOP
1203C  0ED8     MOVLW 0xD8
1203E  0061     MOVFFL ttemp5, PLUSW1
12040  F408     NOP
12042  F4E3     NOP
12044  0ED9     MOVLW 0xD9
12046  0061     MOVFFL wtemp1, PLUSW1
12048  F40C     NOP
1204A  F4E3     NOP
1204C  0EDA     MOVLW 0xDA
1204E  0061     MOVFFL ttemp1, PLUSW1
12050  F410     NOP
12052  F4E3     NOP
347:                   --ne;
12054  50E1     MOVF 0xFE1, W, ACCESS
12056  0FF9     ADDLW 0xF9
12058  6ED9     MOVWF 0xFD9, ACCESS
1205A  50E2     MOVF 0xFE2, W, ACCESS
1205C  6EDA     MOVWF __end_of_UART2_tx_vect_isr, ACCESS
1205E  0EFF     MOVLW 0xFF
12060  22DA     ADDWFC __end_of_UART2_tx_vect_isr, F, ACCESS
12062  06DE     DECF 0xFDE, F, ACCESS
12064  0E00     MOVLW 0x0
12066  5ADD     SUBWFB 0xFDD, F, ACCESS
348:                   ++i;
12068  0EED     MOVLW 0xED
1206A  50E3     MOVF 0xFE3, W, ACCESS
1206C  0F01     ADDLW 0x1
1206E  6E01     MOVWF __ptext283, ACCESS
12070  0EED     MOVLW 0xED
12072  0061     MOVFFL ltemp0, PLUSW1
12074  F404     NOP
12076  F4E3     NOP
12078  6A01     CLRF __ptext283, ACCESS
1207A  0EEE     MOVLW 0xEE
1207C  50E3     MOVF 0xFE3, W, ACCESS
1207E  2001     ADDWFC __ptext283, W, ACCESS
12080  6E01     MOVWF __ptext283, ACCESS
12082  0EEE     MOVLW 0xEE
12084  0061     MOVFFL ltemp0, PLUSW1
12086  F404     NOP
12088  F4E3     NOP
349:           		if (prec < 0 && h == 0) {
1208A  AE24     BTFSS 0x24, 7, ACCESS
1208C  D015     BRA 0x20B8
1208E  0E00     MOVLW 0x0
12090  6EE6     MOVWF 0xFE6, ACCESS
12092  0E00     MOVLW 0x0
12094  6EE6     MOVWF 0xFE6, ACCESS
12096  0E00     MOVLW 0x0
12098  6EE6     MOVWF 0xFE6, ACCESS
1209A  0E00     MOVLW 0x0
1209C  6EE6     MOVWF 0xFE6, ACCESS
1209E  0EDF     MOVLW 0xDF
120A0  C4E3     MOVFF PLUSW1, POSTINC1
120A2  F4E6     NOP
120A4  C4E3     MOVFF PLUSW1, POSTINC1
120A6  F4E6     NOP
120A8  C4E3     MOVFF PLUSW1, POSTINC1
120AA  F4E6     NOP
120AC  C4E3     MOVFF PLUSW1, POSTINC1
120AE  F4E6     NOP
120B0  EC95     CALL 0x1F92A, 0
120B2  F0FC     NOP
120B4  B001     BTFSC __ptext283, 0, ACCESS
120B6  D021     BRA UART2_SetTxInterruptHandler
350:           			break;
351:           		}
352:               }
353:               /* the above code defers writing zeros and the decimal point after the decimal
354:                  place until a non-zero digit is seen, which fails to handle
355:                  explicit precision modifiers correctly. rectify that here. */
356:           	if (!pp && t != 0 && prec > 0 && (n < (DBLEN - EXPLEN))) {
120FA  0EFE     MOVLW 0xFE
120FC  50E3     MOVF 0xFE3, W, ACCESS
120FE  A4D8     BTFSS 0xFD8, 2, ACCESS
12100  D079     BRA 0x21F4
12102  0EF5     MOVLW 0xF5
12104  0061     MOVFFL PLUSW1, ltemp0
12106  F38C     NOP
12108  F501     NOP
1210A  0EF6     MOVLW 0xF6
1210C  50E3     MOVF 0xFE3, W, ACCESS
1210E  1001     IORWF __ptext283, W, ACCESS
12110  A4D8     BTFSS 0xFD8, 2, ACCESS
12112  BE24     BTFSC 0x24, 7, ACCESS
12114  D06F     BRA 0x21F4
12116  5024     MOVF 0x24, W, ACCESS
12118  E103     BNZ 0x2120
1211A  0423     DECF 0x23, W, ACCESS
1211C  A0D8     BTFSS 0xFD8, 0, ACCESS
1211E  D06A     BRA 0x21F4
12120  0EEC     MOVLW 0xEC
12122  BEE3     BTFSC 0xFE3, 7, ACCESS
12124  D00B     BRA 0x213C
12126  0EEC     MOVLW 0xEC
12128  50E3     MOVF 0xFE3, W, ACCESS
1212A  E164     BNZ 0x21F4
1212C  0EEB     MOVLW 0xEB
1212E  0061     MOVFFL PLUSW1, ltemp0
12130  F38C     NOP
12132  F501     NOP
12134  0E4B     MOVLW 0x4B
12136  5E01     SUBWF __ptext283, F, ACCESS
12138  B0D8     BTFSC 0xFD8, 0, ACCESS
1213A  D05C     BRA 0x21F4
357:           		pp = 1;
1213C  0EFE     MOVLW 0xFE
1213E  6AE3     CLRF 0xFE3, ACCESS
12140  2AE3     INCF 0xFE3, F, ACCESS
358:           		dbuf[n++] = '.';
12142  0EEB     MOVLW 0xEB
12144  0061     MOVFFL PLUSW1, wtemp5
12146  F38C     NOP
12148  F50B     NOP
1214A  0EEC     MOVLW 0xEC
1214C  0061     MOVFFL PLUSW1, 0x50C
1214E  F38C     NOP
12150  F50C     NOP
12152  0EA5     MOVLW 0xA5
12154  240B     ADDWF 0xB, W, ACCESS
12156  6ED9     MOVWF 0xFD9, ACCESS
12158  0E08     MOVLW 0x8
1215A  200C     ADDWFC 0xC, W, ACCESS
1215C  6EDA     MOVWF __end_of_UART2_tx_vect_isr, ACCESS
1215E  0E2E     MOVLW 0x2E
12160  6EDF     MOVWF 0xFDF, ACCESS
12162  0EEB     MOVLW 0xEB
12164  50E3     MOVF 0xFE3, W, ACCESS
12166  0F01     ADDLW 0x1
12168  6E01     MOVWF __ptext283, ACCESS
1216A  0EEB     MOVLW 0xEB
1216C  0061     MOVFFL ltemp0, PLUSW1
1216E  F404     NOP
12170  F4E3     NOP
12172  6A01     CLRF __ptext283, ACCESS
12174  0EEC     MOVLW 0xEC
12176  50E3     MOVF 0xFE3, W, ACCESS
12178  2001     ADDWFC __ptext283, W, ACCESS
1217A  6E01     MOVWF __ptext283, ACCESS
1217C  0EEC     MOVLW 0xEC
1217E  0061     MOVFFL ltemp0, PLUSW1
12180  F404     NOP
12182  F4E3     NOP
359:           		--w;
12184  50E1     MOVF 0xFE1, W, ACCESS
12186  0FF1     ADDLW 0xF1
12188  D02D     BRA 0x21E4
360:           	}
361:           	/* printf trailing zeros */
362:           	while ((t != 0) && (n < (DBLEN - EXPLEN))) {
121F4  0EF5     MOVLW 0xF5
121F6  0061     MOVFFL PLUSW1, ltemp0
121F8  F38C     NOP
121FA  F501     NOP
121FC  0EF6     MOVLW 0xF6
121FE  50E3     MOVF 0xFE3, W, ACCESS
12200  1001     IORWF __ptext283, W, ACCESS
12202  B4D8     BTFSC 0xFD8, 2, ACCESS
12204  D00E     BRA 0x2222
12206  0EEC     MOVLW 0xEC
12208  BEE3     BTFSC 0xFE3, 7, ACCESS
1220A  D7BF     BRA 0x218A
1220C  0EEC     MOVLW 0xEC
1220E  50E3     MOVF 0xFE3, W, ACCESS
12210  E108     BNZ 0x2222
12212  0EEB     MOVLW 0xEB
12214  0061     MOVFFL PLUSW1, ltemp0
12216  F38C     NOP
12218  F501     NOP
1221A  0E4B     MOVLW 0x4B
1221C  5E01     SUBWF __ptext283, F, ACCESS
1221E  A0D8     BTFSS 0xFD8, 0, ACCESS
12220  D7B4     BRA 0x218A
363:           		dbuf[n++] = '0';
1218A  0EEB     MOVLW 0xEB
1218C  0061     MOVFFL PLUSW1, wtemp5
1218E  F38C     NOP
12190  F50B     NOP
12192  0EEC     MOVLW 0xEC
12194  0061     MOVFFL PLUSW1, 0x50C
12196  F38C     NOP
12198  F50C     NOP
1219A  0EA5     MOVLW 0xA5
1219C  240B     ADDWF 0xB, W, ACCESS
1219E  6ED9     MOVWF 0xFD9, ACCESS
121A0  0E08     MOVLW 0x8
121A2  200C     ADDWFC 0xC, W, ACCESS
121A4  6EDA     MOVWF __end_of_UART2_tx_vect_isr, ACCESS
121A6  0E30     MOVLW 0x30
121A8  6EDF     MOVWF 0xFDF, ACCESS
121AA  0EEB     MOVLW 0xEB
121AC  50E3     MOVF 0xFE3, W, ACCESS
121AE  0F01     ADDLW 0x1
121B0  6E01     MOVWF __ptext283, ACCESS
121B2  0EEB     MOVLW 0xEB
121B4  0061     MOVFFL ltemp0, PLUSW1
121B6  F404     NOP
121B8  F4E3     NOP
121BA  6A01     CLRF __ptext283, ACCESS
121BC  0EEC     MOVLW 0xEC
121BE  50E3     MOVF 0xFE3, W, ACCESS
121C0  2001     ADDWFC __ptext283, W, ACCESS
121C2  6E01     MOVWF __ptext283, ACCESS
121C4  0EEC     MOVLW 0xEC
121C6  0061     MOVFFL ltemp0, PLUSW1
121C8  F404     NOP
121CA  F4E3     NOP
364:           		--w;
121CC  50E1     MOVF 0xFE1, W, ACCESS
121CE  0FF1     ADDLW 0xF1
121D0  6ED9     MOVWF 0xFD9, ACCESS
121D2  50E2     MOVF 0xFE2, W, ACCESS
121D4  6EDA     MOVWF __end_of_UART2_tx_vect_isr, ACCESS
121D6  0EFF     MOVLW 0xFF
121D8  22DA     ADDWFC __end_of_UART2_tx_vect_isr, F, ACCESS
121DA  06DE     DECF 0xFDE, F, ACCESS
121DC  0E00     MOVLW 0x0
121DE  5ADD     SUBWFB 0xFDD, F, ACCESS
365:           		--t;
121E0  50E1     MOVF 0xFE1, W, ACCESS
121E2  0FF5     ADDLW 0xF5
121E4  6ED9     MOVWF 0xFD9, ACCESS
121E6  50E2     MOVF 0xFE2, W, ACCESS
121E8  6EDA     MOVWF __end_of_UART2_tx_vect_isr, ACCESS
121EA  0EFF     MOVLW 0xFF
121EC  22DA     ADDWFC __end_of_UART2_tx_vect_isr, F, ACCESS
121EE  06DE     DECF 0xFDE, F, ACCESS
121F0  0E00     MOVLW 0x0
121F2  5ADD     SUBWFB 0xFDD, F, ACCESS
366:           	}
367:           #ifdef _VFPF_ALTERN
368:               if (!pp && (flags & POUND_FLAG)) {
12222  0EFE     MOVLW 0xFE
12224  50E3     MOVF 0xFE3, W, ACCESS
12226  B4D8     BTFSC 0xFD8, 2, ACCESS
12228  A827     BTFSS 0x27, 4, ACCESS
1222A  D021     BRA 0x226E
369:                   dbuf[n++] = '.';
1222C  0EEB     MOVLW 0xEB
1222E  0061     MOVFFL PLUSW1, wtemp5
12230  F38C     NOP
12232  F50B     NOP
12234  0EEC     MOVLW 0xEC
12236  0061     MOVFFL PLUSW1, 0x50C
12238  F38C     NOP
1223A  F50C     NOP
1223C  0EA5     MOVLW 0xA5
1223E  240B     ADDWF 0xB, W, ACCESS
12240  6ED9     MOVWF 0xFD9, ACCESS
12242  0E08     MOVLW 0x8
12244  200C     ADDWFC 0xC, W, ACCESS
12246  6EDA     MOVWF __end_of_UART2_tx_vect_isr, ACCESS
12248  0E2E     MOVLW 0x2E
1224A  6EDF     MOVWF 0xFDF, ACCESS
1224C  0EEB     MOVLW 0xEB
1224E  50E3     MOVF 0xFE3, W, ACCESS
12250  0F01     ADDLW 0x1
12252  6E01     MOVWF __ptext283, ACCESS
12254  0EEB     MOVLW 0xEB
12256  0061     MOVFFL ltemp0, PLUSW1
12258  F404     NOP
1225A  F4E3     NOP
1225C  6A01     CLRF __ptext283, ACCESS
1225E  0EEC     MOVLW 0xEC
12260  50E3     MOVF 0xFE3, W, ACCESS
12262  2001     ADDWFC __ptext283, W, ACCESS
12264  6E01     MOVWF __ptext283, ACCESS
12266  0EEC     MOVLW 0xEC
12268  0061     MOVFFL ltemp0, PLUSW1
1226A  F404     NOP
1226C  F4E3     NOP
370:               }
371:           #endif
372:               dbuf[n] = '\0';
1226E  0EEB     MOVLW 0xEB
12270  0061     MOVFFL PLUSW1, wtemp5
12272  F38C     NOP
12274  F50B     NOP
12276  0EEC     MOVLW 0xEC
12278  0061     MOVFFL PLUSW1, 0x50C
1227A  F38C     NOP
1227C  F50C     NOP
1227E  0EA5     MOVLW 0xA5
12280  240B     ADDWF 0xB, W, ACCESS
12282  6ED9     MOVWF 0xFD9, ACCESS
12284  0E08     MOVLW 0x8
12286  200C     ADDWFC 0xC, W, ACCESS
12288  6EDA     MOVWF __end_of_UART2_tx_vect_isr, ACCESS
1228A  6ADF     CLRF 0xFDF, ACCESS
373:           
374:               /* Convert exponent */
375:               i = sizeof(dbuf) - 1;
1228C  0E4F     MOVLW 0x4F
1228E  6E0B     MOVWF 0xB, ACCESS
12290  0E00     MOVLW 0x0
12292  6E0C     MOVWF 0xC, ACCESS
12294  0EED     MOVLW 0xED
12296  0061     MOVFFL wtemp5, PLUSW1
12298  F42C     NOP
1229A  F4E3     NOP
1229C  0EEE     MOVLW 0xEE
1229E  0061     MOVFFL 0x50C, PLUSW1
122A0  F430     NOP
122A2  F4E3     NOP
376:               dbuf[i] = '\0';
122A4  0EED     MOVLW 0xED
122A6  0061     MOVFFL PLUSW1, wtemp5
122A8  F38C     NOP
122AA  F50B     NOP
122AC  0EEE     MOVLW 0xEE
122AE  0061     MOVFFL PLUSW1, 0x50C
122B0  F38C     NOP
122B2  F50C     NOP
122B4  0EA5     MOVLW 0xA5
122B6  240B     ADDWF 0xB, W, ACCESS
122B8  6ED9     MOVWF 0xFD9, ACCESS
122BA  0E08     MOVLW 0x8
122BC  200C     ADDWFC 0xC, W, ACCESS
122BE  6EDA     MOVWF __end_of_UART2_tx_vect_isr, ACCESS
122C0  6ADF     CLRF 0xFDF, ACCESS
377:               esign = 0;
122C2  0EFF     MOVLW 0xFF
122C4  6AE3     CLRF 0xFE3, ACCESS
378:               if (e < 0) {
122C6  0EF4     MOVLW 0xF4
122C8  AEE3     BTFSS 0xFE3, 7, ACCESS
122CA  D009     BRA 0x22DE
379:                   esign = 1;
122CC  0EFF     MOVLW 0xFF
122CE  6AE3     CLRF 0xFE3, ACCESS
122D0  2AE3     INCF 0xFE3, F, ACCESS
380:                   e = -e;
122D2  0EF3     MOVLW 0xF3
122D4  6CE3     NEGF 0xFE3, ACCESS
122D6  0EF4     MOVLW 0xF4
122D8  1EE3     COMF 0xFE3, F, ACCESS
122DA  B0D8     BTFSC 0xFD8, 0, ACCESS
122DC  2AE3     INCF 0xFE3, F, ACCESS
381:               }
382:               p = 1;
122DE  0E01     MOVLW 0x1
122E0  6E0B     MOVWF 0xB, ACCESS
122E2  0E00     MOVLW 0x0
122E4  6E0C     MOVWF 0xC, ACCESS
122E6  0EF7     MOVLW 0xF7
122E8  0061     MOVFFL wtemp5, PLUSW1
122EA  F42C     NOP
122EC  F4E3     NOP
122EE  0EF8     MOVLW 0xF8
122F0  0061     MOVFFL 0x50C, PLUSW1
122F2  F430     NOP
122F4  F4E3     NOP
383:               while (e || (0 < p)) {
122F6  D04D     BRA 0x2392
12392  0EF3     MOVLW 0xF3
12394  0061     MOVFFL PLUSW1, ltemp0
12396  F38C     NOP
12398  F501     NOP
1239A  0EF4     MOVLW 0xF4
1239C  50E3     MOVF 0xFE3, W, ACCESS
1239E  1001     IORWF __ptext283, W, ACCESS
123A0  A4D8     BTFSS 0xFD8, 2, ACCESS
123A2  D7AA     BRA CAN1_SetTxAttemptInterruptHandler
123A4  0EF8     MOVLW 0xF8
123A6  BEE3     BTFSC 0xFE3, 7, ACCESS
123A8  D007     BRA 0x23B8
123AA  0EF8     MOVLW 0xF8
123AC  50E3     MOVF 0xFE3, W, ACCESS
123AE  E1A4     BNZ CAN1_SetTxAttemptInterruptHandler
123B0  0EF7     MOVLW 0xF7
123B2  04E3     DECF 0xFE3, W, ACCESS
123B4  B0D8     BTFSC 0xFD8, 0, ACCESS
123B6  D7A0     BRA CAN1_SetTxAttemptInterruptHandler
384:                   --i;
122F8  50E1     MOVF 0xFE1, W, ACCESS
122FA  0FED     ADDLW 0xED
122FC  6ED9     MOVWF 0xFD9, ACCESS
122FE  50E2     MOVF 0xFE2, W, ACCESS
12300  6EDA     MOVWF __end_of_UART2_tx_vect_isr, ACCESS
12302  0EFF     MOVLW 0xFF
12304  22DA     ADDWFC __end_of_UART2_tx_vect_isr, F, ACCESS
12306  06DE     DECF 0xFDE, F, ACCESS
12308  0E00     MOVLW 0x0
1230A  5ADD     SUBWFB 0xFDD, F, ACCESS
385:                   dbuf[i] = '0' + (e % 10);
1230C  0EED     MOVLW 0xED
1230E  0061     MOVFFL PLUSW1, wtemp5
12310  F38C     NOP
12312  F50B     NOP
12314  0EEE     MOVLW 0xEE
12316  0061     MOVFFL PLUSW1, 0x50C
12318  F38C     NOP
1231A  F50C     NOP
1231C  0EA5     MOVLW 0xA5
1231E  240B     ADDWF 0xB, W, ACCESS
12320  6ED9     MOVWF 0xFD9, ACCESS
12322  0E08     MOVLW 0x8
12324  200C     ADDWFC 0xC, W, ACCESS
12326  6EDA     MOVWF __end_of_UART2_tx_vect_isr, ACCESS
12328  0E0A     MOVLW 0xA
1232A  6EE6     MOVWF 0xFE6, ACCESS
1232C  0E00     MOVLW 0x0
1232E  6EE6     MOVWF 0xFE6, ACCESS
12330  0EF1     MOVLW 0xF1
12332  C4E3     MOVFF PLUSW1, POSTINC1
12334  F4E6     NOP
12336  C4E3     MOVFF PLUSW1, POSTINC1
12338  F4E6     NOP
1233A  EC5A     CALL 0x1E0B4, 0
1233C  F0F0     NOP
1233E  5001     MOVF __ptext283, W, ACCESS
12340  0F30     ADDLW 0x30
12342  6EDF     MOVWF 0xFDF, ACCESS
386:                   e = e / 10;
12344  0E0A     MOVLW 0xA
12346  6EE6     MOVWF 0xFE6, ACCESS
12348  0E00     MOVLW 0x0
1234A  6EE6     MOVWF 0xFE6, ACCESS
1234C  0EF1     MOVLW 0xF1
1234E  C4E3     MOVFF PLUSW1, POSTINC1
12350  F4E6     NOP
12352  C4E3     MOVFF PLUSW1, POSTINC1
12354  F4E6     NOP
12356  ECB9     CALL 0x1D972, 0
12358  F0EC     NOP
1235A  0EF3     MOVLW 0xF3
1235C  0061     MOVFFL ltemp0, PLUSW1
1235E  F404     NOP
12360  F4E3     NOP
12362  0EF4     MOVLW 0xF4
12364  0061     MOVFFL ttemp5, PLUSW1
12366  F408     NOP
12368  F4E3     NOP
387:                   --p;
1236A  50E1     MOVF 0xFE1, W, ACCESS
1236C  0FF7     ADDLW 0xF7
1236E  6ED9     MOVWF 0xFD9, ACCESS
12370  50E2     MOVF 0xFE2, W, ACCESS
12372  6EDA     MOVWF __end_of_UART2_tx_vect_isr, ACCESS
12374  0EFF     MOVLW 0xFF
12376  22DA     ADDWFC __end_of_UART2_tx_vect_isr, F, ACCESS
12378  06DE     DECF 0xFDE, F, ACCESS
1237A  0E00     MOVLW 0x0
1237C  5ADD     SUBWFB 0xFDD, F, ACCESS
388:                   --w;
1237E  50E1     MOVF 0xFE1, W, ACCESS
12380  0FF1     ADDLW 0xF1
12382  6ED9     MOVWF 0xFD9, ACCESS
12384  50E2     MOVF 0xFE2, W, ACCESS
12386  6EDA     MOVWF __end_of_UART2_tx_vect_isr, ACCESS
12388  0EFF     MOVLW 0xFF
1238A  22DA     ADDWFC __end_of_UART2_tx_vect_isr, F, ACCESS
1238C  06DE     DECF 0xFDE, F, ACCESS
1238E  0E00     MOVLW 0x0
12390  5ADD     SUBWFB 0xFDD, F, ACCESS
389:               }
390:               --i;
123B8  50E1     MOVF 0xFE1, W, ACCESS
123BA  0FED     ADDLW 0xED
123BC  6ED9     MOVWF 0xFD9, ACCESS
123BE  50E2     MOVF 0xFE2, W, ACCESS
123C0  6EDA     MOVWF __end_of_UART2_tx_vect_isr, ACCESS
123C2  0EFF     MOVLW 0xFF
123C4  22DA     ADDWFC __end_of_UART2_tx_vect_isr, F, ACCESS
123C6  06DE     DECF 0xFDE, F, ACCESS
123C8  0E00     MOVLW 0x0
123CA  5ADD     SUBWFB 0xFDD, F, ACCESS
391:               dbuf[i] = esign ? '-' : '+';
123CC  0EFF     MOVLW 0xFF
123CE  50E3     MOVF 0xFE3, W, ACCESS
123D0  A4D8     BTFSS 0xFD8, 2, ACCESS
123D2  D002     BRA 0x23D8
123D4  0E2B     MOVLW 0x2B
123D6  D001     BRA 0x23DA
123D8  0E2D     MOVLW 0x2D
123DA  6E0B     MOVWF 0xB, ACCESS
123DC  0E00     MOVLW 0x0
123DE  6E0C     MOVWF 0xC, ACCESS
123E0  0ED5     MOVLW 0xD5
123E2  0061     MOVFFL wtemp5, PLUSW1
123E4  F42C     NOP
123E6  F4E3     NOP
123E8  0ED6     MOVLW 0xD6
123EA  0061     MOVFFL 0x50C, PLUSW1
123EC  F430     NOP
123EE  F4E3     NOP
123F0  0EED     MOVLW 0xED
123F2  0061     MOVFFL PLUSW1, wtemp5
123F4  F38C     NOP
123F6  F50B     NOP
123F8  0EEE     MOVLW 0xEE
123FA  0061     MOVFFL PLUSW1, 0x50C
123FC  F38C     NOP
123FE  F50C     NOP
12400  0EA5     MOVLW 0xA5
12402  240B     ADDWF 0xB, W, ACCESS
12404  6ED9     MOVWF 0xFD9, ACCESS
12406  0E08     MOVLW 0x8
12408  200C     ADDWFC 0xC, W, ACCESS
1240A  6EDA     MOVWF __end_of_UART2_tx_vect_isr, ACCESS
1240C  0ED5     MOVLW 0xD5
1240E  C4E3     MOVFF PLUSW1, INDF2
12410  F4DF     NOP
392:               --w;
12412  50E1     MOVF 0xFE1, W, ACCESS
12414  0FF1     ADDLW 0xF1
12416  6ED9     MOVWF 0xFD9, ACCESS
12418  50E2     MOVF 0xFE2, W, ACCESS
1241A  6EDA     MOVWF __end_of_UART2_tx_vect_isr, ACCESS
1241C  0EFF     MOVLW 0xFF
1241E  22DA     ADDWFC __end_of_UART2_tx_vect_isr, F, ACCESS
12420  06DE     DECF 0xFDE, F, ACCESS
12422  0E00     MOVLW 0x0
12424  5ADD     SUBWFB 0xFDD, F, ACCESS
393:               --i;
12426  50E1     MOVF 0xFE1, W, ACCESS
12428  0FED     ADDLW 0xED
1242A  6ED9     MOVWF 0xFD9, ACCESS
1242C  50E2     MOVF 0xFE2, W, ACCESS
1242E  6EDA     MOVWF __end_of_UART2_tx_vect_isr, ACCESS
12430  0EFF     MOVLW 0xFF
12432  22DA     ADDWFC __end_of_UART2_tx_vect_isr, F, ACCESS
12434  06DE     DECF 0xFDE, F, ACCESS
12436  0E00     MOVLW 0x0
12438  5ADD     SUBWFB 0xFDD, F, ACCESS
394:           #ifdef _VFPF_UPCASE
395:               dbuf[i] = c ? 'P' : 'p';
1243A  0EC8     MOVLW 0xC8
1243C  50E3     MOVF 0xFE3, W, ACCESS
1243E  A4D8     BTFSS 0xFD8, 2, ACCESS
12440  D002     BRA 0x2446
12442  0E70     MOVLW 0x70
12444  D001     BRA 0x2448
12446  0E50     MOVLW 0x50
12448  6E0B     MOVWF 0xB, ACCESS
1244A  0E00     MOVLW 0x0
1244C  6E0C     MOVWF 0xC, ACCESS
1244E  0ED3     MOVLW 0xD3
12450  0061     MOVFFL wtemp5, PLUSW1
12452  F42C     NOP
12454  F4E3     NOP
12456  0ED4     MOVLW 0xD4
12458  0061     MOVFFL 0x50C, PLUSW1
1245A  F430     NOP
1245C  F4E3     NOP
1245E  0EED     MOVLW 0xED
12460  0061     MOVFFL PLUSW1, wtemp5
12462  F38C     NOP
12464  F50B     NOP
12466  0EEE     MOVLW 0xEE
12468  0061     MOVFFL PLUSW1, 0x50C
1246A  F38C     NOP
1246C  F50C     NOP
1246E  0EA5     MOVLW 0xA5
12470  240B     ADDWF 0xB, W, ACCESS
12472  6ED9     MOVWF 0xFD9, ACCESS
12474  0E08     MOVLW 0x8
12476  200C     ADDWFC 0xC, W, ACCESS
12478  6EDA     MOVWF __end_of_UART2_tx_vect_isr, ACCESS
1247A  0ED3     MOVLW 0xD3
1247C  C4E3     MOVFF PLUSW1, INDF2
1247E  F4DF     NOP
396:           #else
397:               dbuf[i] = 'p';
398:           #endif
399:               --w;
12480  50E1     MOVF 0xFE1, W, ACCESS
12482  0FF1     ADDLW 0xF1
12484  6ED9     MOVWF 0xFD9, ACCESS
12486  50E2     MOVF 0xFE2, W, ACCESS
12488  6EDA     MOVWF __end_of_UART2_tx_vect_isr, ACCESS
1248A  0EFF     MOVLW 0xFF
1248C  22DA     ADDWFC __end_of_UART2_tx_vect_isr, F, ACCESS
1248E  06DE     DECF 0xFDE, F, ACCESS
12490  0E00     MOVLW 0x0
12492  5ADD     SUBWFB 0xFDD, F, ACCESS
400:           
401:           	// Attach mantissa to exponent
402:               memcpy(&dbuf[i-n], &dbuf[0], (size_t)n);
12494  0EEB     MOVLW 0xEB
12496  C4E3     MOVFF PLUSW1, POSTINC1
12498  F4E6     NOP
1249A  C4E3     MOVFF PLUSW1, POSTINC1
1249C  F4E6     NOP
1249E  0EA5     MOVLW 0xA5
124A0  6EE6     MOVWF 0xFE6, ACCESS
124A2  0E08     MOVLW 0x8
124A4  6EE6     MOVWF 0xFE6, ACCESS
124A6  0EA5     MOVLW 0xA5
124A8  6E0B     MOVWF 0xB, ACCESS
124AA  0E08     MOVLW 0x8
124AC  6E0C     MOVWF 0xC, ACCESS
124AE  0EE7     MOVLW 0xE7
124B0  50E3     MOVF 0xFE3, W, ACCESS
124B2  5E0B     SUBWF 0xB, F, ACCESS
124B4  0EE8     MOVLW 0xE8
124B6  50E3     MOVF 0xFE3, W, ACCESS
124B8  5A0C     SUBWFB 0xC, F, ACCESS
124BA  0EE9     MOVLW 0xE9
124BC  50E3     MOVF 0xFE3, W, ACCESS
124BE  260B     ADDWF 0xB, F, ACCESS
124C0  0EEA     MOVLW 0xEA
124C2  50E3     MOVF 0xFE3, W, ACCESS
124C4  220C     ADDWFC 0xC, F, ACCESS
124C6  0061     MOVFFL wtemp5, POSTINC1
124C8  F42C     NOP
124CA  F4E6     NOP
124CC  0061     MOVFFL 0x50C, POSTINC1
124CE  F430     NOP
124D0  F4E6     NOP
124D2  EC81     CALL 0x1E502, 0
124D4  F0F2     NOP
403:           	n = i-n;
124D6  0EED     MOVLW 0xED
124D8  0061     MOVFFL PLUSW1, wtemp5
124DA  F38C     NOP
124DC  F50B     NOP
124DE  0EEE     MOVLW 0xEE
124E0  0061     MOVFFL PLUSW1, 0x50C
124E2  F38C     NOP
124E4  F50C     NOP
124E6  0EEB     MOVLW 0xEB
124E8  50E3     MOVF 0xFE3, W, ACCESS
124EA  5E0B     SUBWF 0xB, F, ACCESS
124EC  0EEC     MOVLW 0xEC
124EE  50E3     MOVF 0xFE3, W, ACCESS
124F0  5A0C     SUBWFB 0xC, F, ACCESS
124F2  0EEB     MOVLW 0xEB
124F4  0061     MOVFFL wtemp5, PLUSW1
124F6  F42C     NOP
124F8  F4E3     NOP
124FA  0EEC     MOVLW 0xEC
124FC  0061     MOVFFL 0x50C, PLUSW1
124FE  F430     NOP
12500  F4E3     NOP
404:           	i = sign ? 3 /* sign and 0x chars */: 2 /* 0x chars */;
12502  0EFD     MOVLW 0xFD
12504  50E3     MOVF 0xFE3, W, ACCESS
12506  A4D8     BTFSS 0xFD8, 2, ACCESS
12508  D002     BRA 0x250E
1250A  0E02     MOVLW 0x2
1250C  D001     BRA 0x2510
1250E  0E03     MOVLW 0x3
12510  6E0B     MOVWF 0xB, ACCESS
12512  0E00     MOVLW 0x0
12514  6E0C     MOVWF 0xC, ACCESS
12516  0EED     MOVLW 0xED
12518  0061     MOVFFL wtemp5, PLUSW1
1251A  F42C     NOP
1251C  F4E3     NOP
1251E  0EEE     MOVLW 0xEE
12520  0061     MOVFFL 0x50C, PLUSW1
12522  F430     NOP
12524  F4E3     NOP
405:           #ifdef _VFPF_FILL
406:           	// fill with zeros before 0x
407:           	if (flags & ZERO_FLAG) {
12526  B227     BTFSC 0x27, 1, ACCESS
12528  D023     BRA 0x2570
1252A  D048     BRA 0x25BC
408:           		while (w > i && n > i) {
12570  50E1     MOVF 0xFE1, W, ACCESS
12572  0FED     ADDLW 0xED
12574  6ED9     MOVWF 0xFD9, ACCESS
12576  50E2     MOVF 0xFE2, W, ACCESS
12578  6EDA     MOVWF __end_of_UART2_tx_vect_isr, ACCESS
1257A  0EFF     MOVLW 0xFF
1257C  22DA     ADDWFC __end_of_UART2_tx_vect_isr, F, ACCESS
1257E  0EF1     MOVLW 0xF1
12580  50E3     MOVF 0xFE3, W, ACCESS
12582  5CDE     SUBWF 0xFDE, W, ACCESS
12584  50DE     MOVF 0xFDE, W, ACCESS
12586  0A80     XORLW 0x80
12588  6E01     MOVWF __ptext283, ACCESS
1258A  0EF2     MOVLW 0xF2
1258C  50E3     MOVF 0xFE3, W, ACCESS
1258E  0A80     XORLW 0x80
12590  5801     SUBWFB __ptext283, W, ACCESS
12592  B0D8     BTFSC 0xFD8, 0, ACCESS
12594  D013     BRA 0x25BC
12596  50E1     MOVF 0xFE1, W, ACCESS
12598  0FED     ADDLW 0xED
1259A  6ED9     MOVWF 0xFD9, ACCESS
1259C  50E2     MOVF 0xFE2, W, ACCESS
1259E  6EDA     MOVWF __end_of_UART2_tx_vect_isr, ACCESS
125A0  0EFF     MOVLW 0xFF
125A2  22DA     ADDWFC __end_of_UART2_tx_vect_isr, F, ACCESS
125A4  0EEB     MOVLW 0xEB
125A6  50E3     MOVF 0xFE3, W, ACCESS
125A8  5CDE     SUBWF 0xFDE, W, ACCESS
125AA  50DE     MOVF 0xFDE, W, ACCESS
125AC  0A80     XORLW 0x80
125AE  6E01     MOVWF __ptext283, ACCESS
125B0  0EEC     MOVLW 0xEC
125B2  50E3     MOVF 0xFE3, W, ACCESS
125B4  0A80     XORLW 0x80
125B6  5801     SUBWFB __ptext283, W, ACCESS
125B8  A0D8     BTFSS 0xFD8, 0, ACCESS
125BA  D7B8     BRA 0x252C
409:           			dbuf[--n] = '0';
1252C  50E1     MOVF 0xFE1, W, ACCESS
1252E  0FEB     ADDLW 0xEB
12530  6ED9     MOVWF 0xFD9, ACCESS
12532  50E2     MOVF 0xFE2, W, ACCESS
12534  6EDA     MOVWF __end_of_UART2_tx_vect_isr, ACCESS
12536  0EFF     MOVLW 0xFF
12538  22DA     ADDWFC __end_of_UART2_tx_vect_isr, F, ACCESS
1253A  06DE     DECF 0xFDE, F, ACCESS
1253C  0E00     MOVLW 0x0
1253E  5ADD     SUBWFB 0xFDD, F, ACCESS
12540  0061     MOVFFL POSTINC2, wtemp5
12542  F378     NOP
12544  F50B     NOP
12546  0061     MOVFFL POSTDEC2, 0x50C
12548  F374     NOP
1254A  F50C     NOP
1254C  0EA5     MOVLW 0xA5
1254E  240B     ADDWF 0xB, W, ACCESS
12550  6ED9     MOVWF 0xFD9, ACCESS
12552  0E08     MOVLW 0x8
12554  200C     ADDWFC 0xC, W, ACCESS
12556  6EDA     MOVWF __end_of_UART2_tx_vect_isr, ACCESS
12558  0E30     MOVLW 0x30
1255A  6EDF     MOVWF 0xFDF, ACCESS
410:           			w--;
1255C  50E1     MOVF 0xFE1, W, ACCESS
1255E  0FF1     ADDLW 0xF1
12560  6ED9     MOVWF 0xFD9, ACCESS
12562  50E2     MOVF 0xFE2, W, ACCESS
12564  6EDA     MOVWF __end_of_UART2_tx_vect_isr, ACCESS
12566  0EFF     MOVLW 0xFF
12568  22DA     ADDWFC __end_of_UART2_tx_vect_isr, F, ACCESS
1256A  06DE     DECF 0xFDE, F, ACCESS
1256C  0E00     MOVLW 0x0
1256E  5ADD     SUBWFB 0xFDD, F, ACCESS
411:           		}
412:           	}
413:           #endif
414:           	// add hex prefix
415:           #ifdef _VFPF_UPCASE
416:               dbuf[--n] = c ? 'X' : 'x';
125BC  0EC8     MOVLW 0xC8
125BE  50E3     MOVF 0xFE3, W, ACCESS
125C0  A4D8     BTFSS 0xFD8, 2, ACCESS
125C2  D002     BRA 0x25C8
125C4  0E78     MOVLW 0x78
125C6  D001     BRA 0x25CA
125C8  0E58     MOVLW 0x58
125CA  6E0B     MOVWF 0xB, ACCESS
125CC  0E00     MOVLW 0x0
125CE  6E0C     MOVWF 0xC, ACCESS
125D0  0ED1     MOVLW 0xD1
125D2  0061     MOVFFL wtemp5, PLUSW1
125D4  F42C     NOP
125D6  F4E3     NOP
125D8  0ED2     MOVLW 0xD2
125DA  0061     MOVFFL 0x50C, PLUSW1
125DC  F430     NOP
125DE  F4E3     NOP
125E0  50E1     MOVF 0xFE1, W, ACCESS
125E2  0FEB     ADDLW 0xEB
125E4  6ED9     MOVWF 0xFD9, ACCESS
125E6  50E2     MOVF 0xFE2, W, ACCESS
125E8  6EDA     MOVWF __end_of_UART2_tx_vect_isr, ACCESS
125EA  0EFF     MOVLW 0xFF
125EC  22DA     ADDWFC __end_of_UART2_tx_vect_isr, F, ACCESS
125EE  06DE     DECF 0xFDE, F, ACCESS
125F0  0E00     MOVLW 0x0
125F2  5ADD     SUBWFB 0xFDD, F, ACCESS
125F4  0061     MOVFFL POSTINC2, wtemp5
125F6  F378     NOP
125F8  F50B     NOP
125FA  0061     MOVFFL POSTDEC2, 0x50C
125FC  F374     NOP
125FE  F50C     NOP
12600  0EA5     MOVLW 0xA5
12602  240B     ADDWF 0xB, W, ACCESS
12604  6ED9     MOVWF 0xFD9, ACCESS
12606  0E08     MOVLW 0x8
12608  200C     ADDWFC 0xC, W, ACCESS
1260A  6EDA     MOVWF __end_of_UART2_tx_vect_isr, ACCESS
1260C  0ED1     MOVLW 0xD1
1260E  C4E3     MOVFF PLUSW1, INDF2
12610  F4DF     NOP
417:           #else
418:               dbuf[--n] = 'x';
419:           #endif
420:               dbuf[--n] = '0';
12612  50E1     MOVF 0xFE1, W, ACCESS
12614  0FEB     ADDLW 0xEB
12616  6ED9     MOVWF 0xFD9, ACCESS
12618  50E2     MOVF 0xFE2, W, ACCESS
1261A  6EDA     MOVWF __end_of_UART2_tx_vect_isr, ACCESS
1261C  0EFF     MOVLW 0xFF
1261E  22DA     ADDWFC __end_of_UART2_tx_vect_isr, F, ACCESS
12620  06DE     DECF 0xFDE, F, ACCESS
12622  0E00     MOVLW 0x0
12624  5ADD     SUBWFB 0xFDD, F, ACCESS
12626  0061     MOVFFL POSTINC2, wtemp5
12628  F378     NOP
1262A  F50B     NOP
1262C  0061     MOVFFL POSTDEC2, 0x50C
1262E  F374     NOP
12630  F50C     NOP
12632  0EA5     MOVLW 0xA5
12634  240B     ADDWF 0xB, W, ACCESS
12636  6ED9     MOVWF 0xFD9, ACCESS
12638  0E08     MOVLW 0x8
1263A  200C     ADDWFC 0xC, W, ACCESS
1263C  6EDA     MOVWF __end_of_UART2_tx_vect_isr, ACCESS
1263E  0E30     MOVLW 0x30
12640  6EDF     MOVWF 0xFDF, ACCESS
421:           	// put on the sign
422:           	if (sign) {
12642  0EFD     MOVLW 0xFD
12644  50E3     MOVF 0xFE3, W, ACCESS
12646  B4D8     BTFSC 0xFD8, 2, ACCESS
12648  D019     BRA 0x267C
423:           		dbuf[--n] = sign;
1264A  50E1     MOVF 0xFE1, W, ACCESS
1264C  0FEB     ADDLW 0xEB
1264E  6ED9     MOVWF 0xFD9, ACCESS
12650  50E2     MOVF 0xFE2, W, ACCESS
12652  6EDA     MOVWF __end_of_UART2_tx_vect_isr, ACCESS
12654  0EFF     MOVLW 0xFF
12656  22DA     ADDWFC __end_of_UART2_tx_vect_isr, F, ACCESS
12658  06DE     DECF 0xFDE, F, ACCESS
1265A  0E00     MOVLW 0x0
1265C  5ADD     SUBWFB 0xFDD, F, ACCESS
1265E  0061     MOVFFL POSTINC2, wtemp5
12660  F378     NOP
12662  F50B     NOP
12664  0061     MOVFFL POSTDEC2, 0x50C
12666  F374     NOP
12668  F50C     NOP
1266A  0EA5     MOVLW 0xA5
1266C  240B     ADDWF 0xB, W, ACCESS
1266E  6ED9     MOVWF 0xFD9, ACCESS
12670  0E08     MOVLW 0x8
12672  200C     ADDWFC 0xC, W, ACCESS
12674  6EDA     MOVWF __end_of_UART2_tx_vect_isr, ACCESS
12676  0EFD     MOVLW 0xFD
12678  C4E3     MOVFF PLUSW1, INDF2
1267A  F4DF     NOP
424:           	}
425:           	w -= i;
1267C  0EF1     MOVLW 0xF1
1267E  50E3     MOVF 0xFE3, W, ACCESS
12680  6E01     MOVWF __ptext283, ACCESS
12682  0EED     MOVLW 0xED
12684  50E3     MOVF 0xFE3, W, ACCESS
12686  5E01     SUBWF __ptext283, F, ACCESS
12688  0EF1     MOVLW 0xF1
1268A  0061     MOVFFL ltemp0, PLUSW1
1268C  F404     NOP
1268E  F4E3     NOP
12690  0EF2     MOVLW 0xF2
12692  50E3     MOVF 0xFE3, W, ACCESS
12694  6E01     MOVWF __ptext283, ACCESS
12696  0EEE     MOVLW 0xEE
12698  50E3     MOVF 0xFE3, W, ACCESS
1269A  5A01     SUBWFB __ptext283, F, ACCESS
1269C  0EF2     MOVLW 0xF2
1269E  0061     MOVFFL ltemp0, PLUSW1
126A0  F404     NOP
126A2  F4E3     NOP
426:           
427:               /* Put out padded string */
428:               return _COUNT_CAST pad(fp, &dbuf[n], w);
126A4  0EF1     MOVLW 0xF1
126A6  C4E3     MOVFF PLUSW1, POSTINC1
126A8  F4E6     NOP
126AA  C4E3     MOVFF PLUSW1, POSTINC1
126AC  F4E6     NOP
126AE  0EA5     MOVLW 0xA5
126B0  6E0B     MOVWF 0xB, ACCESS
126B2  0E08     MOVLW 0x8
126B4  6E0C     MOVWF 0xC, ACCESS
126B6  0EE9     MOVLW 0xE9
126B8  50E3     MOVF 0xFE3, W, ACCESS
126BA  260B     ADDWF 0xB, F, ACCESS
126BC  0EEA     MOVLW 0xEA
126BE  50E3     MOVF 0xFE3, W, ACCESS
126C0  220C     ADDWFC 0xC, F, ACCESS
126C2  0061     MOVFFL wtemp5, POSTINC1
126C4  F42C     NOP
126C6  F4E6     NOP
126C8  0061     MOVFFL 0x50C, POSTINC1
126CA  F430     NOP
126CC  F4E6     NOP
126CE  0EC9     MOVLW 0xC9
126D0  C4E3     MOVFF PLUSW1, POSTINC1
126D2  F4E6     NOP
126D4  C4E3     MOVFF PLUSW1, POSTINC1
126D6  F4E6     NOP
126D8  ECA3     CALL 0x1EF46, 0
126DA  F0F7     NOP
429:           }
126DC  0EC8     MOVLW 0xC8
126DC  0EC8     MOVLW 0xC8
126DC  0EC8     MOVLW 0xC8
126DC  0EC8     MOVLW 0xC8
126DC  0EC8     MOVLW 0xC8
430:           #endif
431:           
432:           #ifdef _VFPF_C
433:           static _INLINE _COUNT_TYPE ctoa(FILE *fp, char c)
1E1CC  52E6     MOVF 0xFE6, F, ACCESS
1E1CE  52E6     MOVF 0xFE6, F, ACCESS
1E1D0  52E6     MOVF 0xFE6, F, ACCESS
1E1D2  52E6     MOVF 0xFE6, F, ACCESS
434:           {
435:               int l,w;
436:           
437:               /* Get width */
438:               w = width ? width - 1 : width;
1E1D4  5021     MOVF 0x21, W, ACCESS
1E1D6  1022     IORWF 0x22, W, ACCESS
1E1D8  A4D8     BTFSS 0xFD8, 2, ACCESS
1E1DA  D007     BRA 0xE1EA
1E1DC  0EFC     MOVLW 0xFC
1E1DE  C521     MOVFF width, PLUSW1
1E1E0  F4E3     NOP
1E1E2  0EFD     MOVLW 0xFD
1E1E4  C522     MOVFF 0x522, PLUSW1
1E1E6  F4E3     NOP
1E1E8  D014     BRA 0xE212
1E1EA  0061     MOVFFL width, wtemp5
1E1EC  F484     NOP
1E1EE  F50B     NOP
1E1F0  0061     MOVFFL 0x522, 0x50C
1E1F2  F488     NOP
1E1F4  F50C     NOP
1E1F6  0EFF     MOVLW 0xFF
1E1F8  240B     ADDWF 0xB, W, ACCESS
1E1FA  6E09     MOVWF 0x9, ACCESS
1E1FC  0EFF     MOVLW 0xFF
1E1FE  200C     ADDWFC 0xC, W, ACCESS
1E200  6E0A     MOVWF 0xA, ACCESS
1E202  0EFC     MOVLW 0xFC
1E204  0061     MOVFFL ltemp2, PLUSW1
1E206  F424     NOP
1E208  F4E3     NOP
1E20A  0EFD     MOVLW 0xFD
1E20C  0061     MOVFFL ttemp3, PLUSW1
1E20E  F428     NOP
1E210  F4E3     NOP
439:           
440:           #if defined(_VFPF_LEFT) || defined(_VFPF_WIDTH)
441:               /* Left justify ? Put out character */
442:               if (flags & MINUS_FLAG) {
1E212  A027     BTFSS 0x27, 0, ACCESS
1E214  D00C     BRA 0xE22E
443:                   fputc(c, fp);
1E216  0EFA     MOVLW 0xFA
1E218  C4E3     MOVFF PLUSW1, POSTINC1
1E21A  F4E6     NOP
1E21C  C4E3     MOVFF PLUSW1, POSTINC1
1E21E  F4E6     NOP
1E220  0EF7     MOVLW 0xF7
1E222  50E3     MOVF 0xFE3, W, ACCESS
1E224  6EE6     MOVWF 0xFE6, ACCESS
1E226  0E00     MOVLW 0x0
1E228  6EE6     MOVWF 0xFE6, ACCESS
1E22A  ECCB     CALL 0x1DF96, 0
1E22C  F0EF     NOP
444:               }
445:           #endif
446:           
447:               /* Put out padding */
448:               w = (w < 0) ? 0 : w;
1E22E  0EFD     MOVLW 0xFD
1E230  AEE3     BTFSS 0xFE3, 7, ACCESS
1E232  D004     BRA 0xE23C
1E234  0EFC     MOVLW 0xFC
1E236  6AE3     CLRF 0xFE3, ACCESS
1E238  0EFD     MOVLW 0xFD
1E23A  6AE3     CLRF 0xFE3, ACCESS
449:               l = 0;
1E23C  0EFE     MOVLW 0xFE
1E23E  6AE3     CLRF 0xFE3, ACCESS
1E240  0EFF     MOVLW 0xFF
1E242  6AE3     CLRF 0xFE3, ACCESS
450:               while (l < w) {
1E244  D01C     BRA 0xE27E
1E27E  50E1     MOVF 0xFE1, W, ACCESS
1E280  0FFE     ADDLW 0xFE
1E282  6ED9     MOVWF 0xFD9, ACCESS
1E284  50E2     MOVF 0xFE2, W, ACCESS
1E286  6EDA     MOVWF __end_of_UART2_tx_vect_isr, ACCESS
1E288  0EFF     MOVLW 0xFF
1E28A  22DA     ADDWFC __end_of_UART2_tx_vect_isr, F, ACCESS
1E28C  0EFC     MOVLW 0xFC
1E28E  50E3     MOVF 0xFE3, W, ACCESS
1E290  5CDE     SUBWF 0xFDE, W, ACCESS
1E292  50DE     MOVF 0xFDE, W, ACCESS
1E294  0A80     XORLW 0x80
1E296  6E01     MOVWF __ptext283, ACCESS
1E298  0EFD     MOVLW 0xFD
1E29A  50E3     MOVF 0xFE3, W, ACCESS
1E29C  0A80     XORLW 0x80
1E29E  5801     SUBWFB __ptext283, W, ACCESS
1E2A0  A0D8     BTFSS 0xFD8, 0, ACCESS
1E2A2  D7D1     BRA 0xE246
451:                   fputc(' ', fp);
1E246  0EFA     MOVLW 0xFA
1E248  C4E3     MOVFF PLUSW1, POSTINC1
1E24A  F4E6     NOP
1E24C  C4E3     MOVFF PLUSW1, POSTINC1
1E24E  F4E6     NOP
1E250  0E20     MOVLW 0x20
1E252  6EE6     MOVWF 0xFE6, ACCESS
1E254  0E00     MOVLW 0x0
1E256  6EE6     MOVWF 0xFE6, ACCESS
1E258  ECCB     CALL 0x1DF96, 0
1E25A  F0EF     NOP
452:                   ++l;
1E25C  0EFE     MOVLW 0xFE
1E25E  50E3     MOVF 0xFE3, W, ACCESS
1E260  0F01     ADDLW 0x1
1E262  6E01     MOVWF __ptext283, ACCESS
1E264  0EFE     MOVLW 0xFE
1E266  0061     MOVFFL ltemp0, PLUSW1
1E268  F404     NOP
1E26A  F4E3     NOP
1E26C  6A01     CLRF __ptext283, ACCESS
1E26E  0EFF     MOVLW 0xFF
1E270  50E3     MOVF 0xFE3, W, ACCESS
1E272  2001     ADDWFC __ptext283, W, ACCESS
1E274  6E01     MOVWF __ptext283, ACCESS
1E276  0EFF     MOVLW 0xFF
1E278  0061     MOVFFL ltemp0, PLUSW1
1E27A  F404     NOP
1E27C  F4E3     NOP
453:               }
454:               /* Right justify ? Put out string */
455:           #if defined(_VFPF_LEFT) || defined(_VFPF_WIDTH)
456:               if (!(flags & MINUS_FLAG)) {
1E2A4  B027     BTFSC 0x27, 0, ACCESS
1E2A6  D00C     BRA 0xE2C0
457:           #endif
458:                   fputc(c, fp);
1E2A8  0EFA     MOVLW 0xFA
1E2AA  C4E3     MOVFF PLUSW1, POSTINC1
1E2AC  F4E6     NOP
1E2AE  C4E3     MOVFF PLUSW1, POSTINC1
1E2B0  F4E6     NOP
1E2B2  0EF7     MOVLW 0xF7
1E2B4  50E3     MOVF 0xFE3, W, ACCESS
1E2B6  6EE6     MOVWF 0xFE6, ACCESS
1E2B8  0E00     MOVLW 0x0
1E2BA  6EE6     MOVWF 0xFE6, ACCESS
1E2BC  ECCB     CALL 0x1DF96, 0
1E2BE  F0EF     NOP
459:           #if defined(_VFPF_LEFT) || defined(_VFPF_WIDTH)
460:               }
461:           #endif
462:           
463:           #ifdef _VFPF_COUNT_CHARS
464:               return l+1;
1E2C0  0EFE     MOVLW 0xFE
1E2C2  50E3     MOVF 0xFE3, W, ACCESS
1E2C4  0F01     ADDLW 0x1
1E2C6  6E01     MOVWF __ptext283, ACCESS
1E2C8  0EFF     MOVLW 0xFF
1E2CA  0061     MOVFFL PLUSW1, ttemp5
1E2CC  F38C     NOP
1E2CE  F502     NOP
1E2D0  0E00     MOVLW 0x0
1E2D2  2202     ADDWFC ___rparam_used, F, ACCESS
465:           #endif
466:           }
1E2D4  0EF9     MOVLW 0xF9
1E2D4  0EF9     MOVLW 0xF9
1E2D4  0EF9     MOVLW 0xF9
1E2D4  0EF9     MOVLW 0xF9
1E2D4  0EF9     MOVLW 0xF9
467:           #endif
468:           
469:           #ifdef _VFPF_D
470:           static _INLINE _COUNT_TYPE dtoa(FILE *fp, vfpf_sint_t d)
1AD7A  0E09     MOVLW 0x9
1AD7C  26E1     ADDWF 0xFE1, F, ACCESS
1AD7E  0E00     MOVLW 0x0
1AD80  22E2     ADDWFC 0xFE2, F, ACCESS
471:           {
472:           	char s;
473:               int i, p, w;
474:           
475:               /* Record sign, get absolute value */
476:               s = d < 0 ? 1 : 0;
1AD82  0EF4     MOVLW 0xF4
1AD84  AEE3     BTFSS 0xFE3, 7, ACCESS
1AD86  D003     BRA 0xAD8E
1AD88  6A0C     CLRF 0xC, ACCESS
1AD8A  2A0C     INCF 0xC, F, ACCESS
1AD8C  D001     BRA 0xAD90
1AD8E  6A0C     CLRF 0xC, ACCESS
1AD90  0EFF     MOVLW 0xFF
1AD92  0061     MOVFFL 0x50C, PLUSW1
1AD94  F430     NOP
1AD96  F4E3     NOP
477:               if (s) {
1AD98  0EFF     MOVLW 0xFF
1AD9A  50E3     MOVF 0xFE3, W, ACCESS
1AD9C  B4D8     BTFSC 0xFD8, 2, ACCESS
1AD9E  D011     BRA 0xADC2
478:                   d = -d;
1ADA0  0EF1     MOVLW 0xF1
1ADA2  6CE3     NEGF 0xFE3, ACCESS
1ADA4  0EF2     MOVLW 0xF2
1ADA6  1EE3     COMF 0xFE3, F, ACCESS
1ADA8  0EF3     MOVLW 0xF3
1ADAA  1EE3     COMF 0xFE3, F, ACCESS
1ADAC  0EF4     MOVLW 0xF4
1ADAE  1EE3     COMF 0xFE3, F, ACCESS
1ADB0  E308     BNC 0xADC2
1ADB2  0EF2     MOVLW 0xF2
1ADB4  2AE3     INCF 0xFE3, F, ACCESS
1ADB6  E305     BNC 0xADC2
1ADB8  0EF3     MOVLW 0xF3
1ADBA  2AE3     INCF 0xFE3, F, ACCESS
1ADBC  E302     BNC 0xADC2
1ADBE  0EF4     MOVLW 0xF4
1ADC0  2AE3     INCF 0xFE3, F, ACCESS
479:               }
480:           
481:           #ifdef _VFPF_FILL
482:               /* Adjust flags, precision, width */
483:               if (!(prec < 0)) {
1ADC2  AE24     BTFSS 0x24, 7, ACCESS
484:                   flags &= ~ZERO_FLAG;
1ADC4  9227     BCF 0x27, 1, ACCESS
485:               }
486:           #endif
487:               p = (0 <= prec) ? prec : 1;
1ADC6  AE24     BTFSS 0x24, 7, ACCESS
1ADC8  D00D     BRA 0xADE4
1ADCA  0E01     MOVLW 0x1
1ADCC  6E0B     MOVWF 0xB, ACCESS
1ADCE  0E00     MOVLW 0x0
1ADD0  6E0C     MOVWF 0xC, ACCESS
1ADD2  0EFD     MOVLW 0xFD
1ADD4  0061     MOVFFL wtemp5, PLUSW1
1ADD6  F42C     NOP
1ADD8  F4E3     NOP
1ADDA  0EFE     MOVLW 0xFE
1ADDC  0061     MOVFFL 0x50C, PLUSW1
1ADDE  F430     NOP
1ADE0  F4E3     NOP
1ADE2  D006     BRA 0xADF0
1ADE4  0EFD     MOVLW 0xFD
1ADE6  C523     MOVFF prec, PLUSW1
1ADE8  F4E3     NOP
1ADEA  0EFE     MOVLW 0xFE
1ADEC  C524     MOVFF 0x524, PLUSW1
1ADEE  F4E3     NOP
488:               w = width;
1ADF0  0EFB     MOVLW 0xFB
1ADF2  C521     MOVFF width, PLUSW1
1ADF4  F4E3     NOP
1ADF6  0EFC     MOVLW 0xFC
1ADF8  C522     MOVFF 0x522, PLUSW1
1ADFA  F4E3     NOP
489:               if (s
1ADFC  0EFF     MOVLW 0xFF
1ADFE  50E3     MOVF 0xFE3, W, ACCESS
1AE00  A4D8     BTFSS 0xFD8, 2, ACCESS
1AE02  D002     BRA 0xAE08
1AE04  A427     BTFSS 0x27, 2, ACCESS
1AE06  D025     BRA 0xAE52
490:           #ifdef _VFPF_MANSIGN
491:           			|| (flags & PLUS_FLAG)
492:           #endif
493:           	   ) {
494:                   --w;
1AE08  50E1     MOVF 0xFE1, W, ACCESS
1AE0A  0FFB     ADDLW 0xFB
1AE0C  6ED9     MOVWF 0xFD9, ACCESS
1AE0E  50E2     MOVF 0xFE2, W, ACCESS
1AE10  6EDA     MOVWF __end_of_UART2_tx_vect_isr, ACCESS
1AE12  0EFF     MOVLW 0xFF
1AE14  22DA     ADDWFC __end_of_UART2_tx_vect_isr, F, ACCESS
1AE16  06DE     DECF 0xFDE, F, ACCESS
1AE18  0E00     MOVLW 0x0
1AE1A  5ADD     SUBWFB 0xFDD, F, ACCESS
495:           		s = s ? '-' : '+';
1AE1C  0EFF     MOVLW 0xFF
1AE1E  50E3     MOVF 0xFE3, W, ACCESS
1AE20  A4D8     BTFSS 0xFD8, 2, ACCESS
1AE22  D002     BRA 0xAE28
1AE24  0E2B     MOVLW 0x2B
1AE26  D001     BRA 0xAE2A
1AE28  0E2D     MOVLW 0x2D
1AE2A  6E0B     MOVWF 0xB, ACCESS
1AE2C  0E00     MOVLW 0x0
1AE2E  6E0C     MOVWF 0xC, ACCESS
1AE30  0EF7     MOVLW 0xF7
1AE32  0061     MOVFFL wtemp5, PLUSW1
1AE34  F42C     NOP
1AE36  F4E3     NOP
1AE38  0EF8     MOVLW 0xF8
1AE3A  0061     MOVFFL 0x50C, PLUSW1
1AE3C  F430     NOP
1AE3E  F4E3     NOP
1AE40  0EF7     MOVLW 0xF7
1AE42  0061     MOVFFL PLUSW1, ltemp0
1AE44  F38C     NOP
1AE46  F501     NOP
1AE48  0EFF     MOVLW 0xFF
1AE4A  0061     MOVFFL ltemp0, PLUSW1
1AE4C  F404     NOP
1AE4E  F4E3     NOP
496:               }
1AE50  D00F     BRA 0xAE70
497:           #if defined(_VFPF_SPCSIGN)
498:           	else if (flags & SPACE_FLAG) {
1AE52  A627     BTFSS 0x27, 3, ACCESS
1AE54  D00D     BRA 0xAE70
499:                   --w;
1AE56  50E1     MOVF 0xFE1, W, ACCESS
1AE58  0FFB     ADDLW 0xFB
1AE5A  6ED9     MOVWF 0xFD9, ACCESS
1AE5C  50E2     MOVF 0xFE2, W, ACCESS
1AE5E  6EDA     MOVWF __end_of_UART2_tx_vect_isr, ACCESS
1AE60  0EFF     MOVLW 0xFF
1AE62  22DA     ADDWFC __end_of_UART2_tx_vect_isr, F, ACCESS
1AE64  06DE     DECF 0xFDE, F, ACCESS
1AE66  0E00     MOVLW 0x0
1AE68  5ADD     SUBWFB 0xFDD, F, ACCESS
500:           		s = ' ';
1AE6A  0EFF     MOVLW 0xFF
1AE6C  6AE3     CLRF 0xFE3, ACCESS
1AE6E  8AE3     BSF 0xFE3, 5, ACCESS
501:           	}
502:           #endif
503:           
504:               /* Convert to decimal, possibly filling on the left with zeroes */
505:               i = sizeof(dbuf) - 1;
1AE70  0E4F     MOVLW 0x4F
1AE72  6E0B     MOVWF 0xB, ACCESS
1AE74  0E00     MOVLW 0x0
1AE76  6E0C     MOVWF 0xC, ACCESS
1AE78  0EF9     MOVLW 0xF9
1AE7A  0061     MOVFFL wtemp5, PLUSW1
1AE7C  F42C     NOP
1AE7E  F4E3     NOP
1AE80  0EFA     MOVLW 0xFA
1AE82  0061     MOVFFL 0x50C, PLUSW1
1AE84  F430     NOP
1AE86  F4E3     NOP
506:               dbuf[i] = '\0';
1AE88  0108     MOVLB 0x8
1AE8A  6BF4     CLRF DMAnSPTR, BANKED
507:               while (!(i < 1) && (d || (0 < p)
1AE8C  D075     BRA 0xAF78
1AF78  0EFA     MOVLW 0xFA
1AF7A  BEE3     BTFSC 0xFE3, 7, ACCESS
1AF7C  D02A     BRA 0xAFD2
1AF7E  0EFA     MOVLW 0xFA
1AF80  50E3     MOVF 0xFE3, W, ACCESS
1AF82  E104     BNZ 0xAF8C
1AF84  0EF9     MOVLW 0xF9
1AF86  04E3     DECF 0xFE3, W, ACCESS
1AF88  A0D8     BTFSS 0xFD8, 0, ACCESS
1AF8A  D023     BRA 0xAFD2
1AF8C  0EF1     MOVLW 0xF1
1AF8E  50E3     MOVF 0xFE3, W, ACCESS
1AF90  E109     BNZ 0xAFA4
1AF92  0EF2     MOVLW 0xF2
1AF94  50E3     MOVF 0xFE3, W, ACCESS
1AF96  E106     BNZ 0xAFA4
1AF98  0EF3     MOVLW 0xF3
1AF9A  50E3     MOVF 0xFE3, W, ACCESS
1AF9C  E103     BNZ 0xAFA4
1AF9E  0EF4     MOVLW 0xF4
1AFA0  50E3     MOVF 0xFE3, W, ACCESS
1AFA2  A4D8     BTFSS 0xFD8, 2, ACCESS
1AFA4  D774     BRA 0xAE8E
1AFA6  0EFE     MOVLW 0xFE
1AFA8  BEE3     BTFSC 0xFE3, 7, ACCESS
1AFAA  D007     BRA 0xAFBA
1AFAC  0EFE     MOVLW 0xFE
1AFAE  50E3     MOVF 0xFE3, W, ACCESS
1AFB0  E103     BNZ 0xAFB8
1AFB2  0EFD     MOVLW 0xFD
1AFB4  04E3     DECF 0xFE3, W, ACCESS
1AFB6  B0D8     BTFSC 0xFD8, 0, ACCESS
1AFB8  D76A     BRA 0xAE8E
1AFBA  0EFC     MOVLW 0xFC
1AFBC  BEE3     BTFSC 0xFE3, 7, ACCESS
1AFBE  D009     BRA 0xAFD2
1AFC0  0EFC     MOVLW 0xFC
1AFC2  50E3     MOVF 0xFE3, W, ACCESS
1AFC4  E104     BNZ 0xAFCE
1AFC6  0EFB     MOVLW 0xFB
1AFC8  04E3     DECF 0xFE3, W, ACCESS
1AFCA  A0D8     BTFSS 0xFD8, 0, ACCESS
1AFCC  D002     BRA 0xAFD2
1AFCE  B227     BTFSC 0x27, 1, ACCESS
1AFD0  D75E     BRA 0xAE8E
508:           #ifdef _VFPF_FILL
509:           				|| ((0 < w) && (flags & ZERO_FLAG))
510:           #endif
511:           				)) {
512:                   --i;
1AE8E  50E1     MOVF 0xFE1, W, ACCESS
1AE90  0FF9     ADDLW 0xF9
1AE92  6ED9     MOVWF 0xFD9, ACCESS
1AE94  50E2     MOVF 0xFE2, W, ACCESS
1AE96  6EDA     MOVWF __end_of_UART2_tx_vect_isr, ACCESS
1AE98  0EFF     MOVLW 0xFF
1AE9A  22DA     ADDWFC __end_of_UART2_tx_vect_isr, F, ACCESS
1AE9C  06DE     DECF 0xFDE, F, ACCESS
1AE9E  0E00     MOVLW 0x0
1AEA0  5ADD     SUBWFB 0xFDD, F, ACCESS
513:                   dbuf[i] = (char)((int)'0' + abs(d % 10));
1AEA2  0E0A     MOVLW 0xA
1AEA4  6EE6     MOVWF 0xFE6, ACCESS
1AEA6  0E00     MOVLW 0x0
1AEA8  6EE6     MOVWF 0xFE6, ACCESS
1AEAA  0E00     MOVLW 0x0
1AEAC  6EE6     MOVWF 0xFE6, ACCESS
1AEAE  0E00     MOVLW 0x0
1AEB0  6EE6     MOVWF 0xFE6, ACCESS
1AEB2  0EED     MOVLW 0xED
1AEB4  C4E3     MOVFF PLUSW1, POSTINC1
1AEB6  F4E6     NOP
1AEB8  C4E3     MOVFF PLUSW1, POSTINC1
1AEBA  F4E6     NOP
1AEBC  C4E3     MOVFF PLUSW1, POSTINC1
1AEBE  F4E6     NOP
1AEC0  C4E3     MOVFF PLUSW1, POSTINC1
1AEC2  F4E6     NOP
1AEC4  ECAD     CALL 0x1D55A, 0
1AEC6  F0EA     NOP
1AEC8  0061     MOVFFL ltemp0, wtemp5
1AECA  F404     NOP
1AECC  F50B     NOP
1AECE  0061     MOVFFL ttemp5, 0x50C
1AED0  F408     NOP
1AED2  F50C     NOP
1AED4  0061     MOVFFL wtemp5, POSTINC1
1AED6  F42C     NOP
1AED8  F4E6     NOP
1AEDA  0061     MOVFFL 0x50C, POSTINC1
1AEDC  F430     NOP
1AEDE  F4E6     NOP
1AEE0  ECB6     CALL 0x156C, 0
1AEE2  F00A     NOP
1AEE4  0E30     MOVLW 0x30
1AEE6  2601     ADDWF __ptext283, F, ACCESS
1AEE8  0EF9     MOVLW 0xF9
1AEEA  0061     MOVFFL PLUSW1, wtemp5
1AEEC  F38C     NOP
1AEEE  F50B     NOP
1AEF0  0EFA     MOVLW 0xFA
1AEF2  0061     MOVFFL PLUSW1, 0x50C
1AEF4  F38C     NOP
1AEF6  F50C     NOP
1AEF8  0EA5     MOVLW 0xA5
1AEFA  240B     ADDWF 0xB, W, ACCESS
1AEFC  6ED9     MOVWF 0xFD9, ACCESS
1AEFE  0E08     MOVLW 0x8
1AF00  200C     ADDWFC 0xC, W, ACCESS
1AF02  6EDA     MOVWF __end_of_UART2_tx_vect_isr, ACCESS
1AF04  0061     MOVFFL ltemp0, INDF2
1AF06  F404     NOP
1AF08  F4DF     NOP
514:                   --p;
1AF0A  50E1     MOVF 0xFE1, W, ACCESS
1AF0C  0FFD     ADDLW 0xFD
1AF0E  6ED9     MOVWF 0xFD9, ACCESS
1AF10  50E2     MOVF 0xFE2, W, ACCESS
1AF12  6EDA     MOVWF __end_of_UART2_tx_vect_isr, ACCESS
1AF14  0EFF     MOVLW 0xFF
1AF16  22DA     ADDWFC __end_of_UART2_tx_vect_isr, F, ACCESS
1AF18  06DE     DECF 0xFDE, F, ACCESS
1AF1A  0E00     MOVLW 0x0
1AF1C  5ADD     SUBWFB 0xFDD, F, ACCESS
515:                   --w;
1AF1E  50E1     MOVF 0xFE1, W, ACCESS
1AF20  0FFB     ADDLW 0xFB
1AF22  6ED9     MOVWF 0xFD9, ACCESS
1AF24  50E2     MOVF 0xFE2, W, ACCESS
1AF26  6EDA     MOVWF __end_of_UART2_tx_vect_isr, ACCESS
1AF28  0EFF     MOVLW 0xFF
1AF2A  22DA     ADDWFC __end_of_UART2_tx_vect_isr, F, ACCESS
1AF2C  06DE     DECF 0xFDE, F, ACCESS
1AF2E  0E00     MOVLW 0x0
1AF30  5ADD     SUBWFB 0xFDD, F, ACCESS
516:                   d = d / 10;
1AF32  0E0A     MOVLW 0xA
1AF34  6EE6     MOVWF 0xFE6, ACCESS
1AF36  0E00     MOVLW 0x0
1AF38  6EE6     MOVWF 0xFE6, ACCESS
1AF3A  0E00     MOVLW 0x0
1AF3C  6EE6     MOVWF 0xFE6, ACCESS
1AF3E  0E00     MOVLW 0x0
1AF40  6EE6     MOVWF 0xFE6, ACCESS
1AF42  0EED     MOVLW 0xED
1AF44  C4E3     MOVFF PLUSW1, POSTINC1
1AF46  F4E6     NOP
1AF48  C4E3     MOVFF PLUSW1, POSTINC1
1AF4A  F4E6     NOP
1AF4C  C4E3     MOVFF PLUSW1, POSTINC1
1AF4E  F4E6     NOP
1AF50  C4E3     MOVFF PLUSW1, POSTINC1
1AF52  F4E6     NOP
1AF54  EC2A     CALL 0x1D254, 0
1AF56  F0E9     NOP
1AF58  0EF1     MOVLW 0xF1
1AF5A  0061     MOVFFL ltemp0, PLUSW1
1AF5C  F404     NOP
1AF5E  F4E3     NOP
1AF60  0EF2     MOVLW 0xF2
1AF62  0061     MOVFFL ttemp5, PLUSW1
1AF64  F408     NOP
1AF66  F4E3     NOP
1AF68  0EF3     MOVLW 0xF3
1AF6A  0061     MOVFFL wtemp1, PLUSW1
1AF6C  F40C     NOP
1AF6E  F4E3     NOP
1AF70  0EF4     MOVLW 0xF4
1AF72  0061     MOVFFL ttemp1, PLUSW1
1AF74  F410     NOP
1AF76  F4E3     NOP
517:               }
518:           
519:               /* Display sign if required */
520:               if (s != 0) {
1AFD2  0EFF     MOVLW 0xFF
1AFD4  50E3     MOVF 0xFE3, W, ACCESS
1AFD6  B4D8     BTFSC 0xFD8, 2, ACCESS
1AFD8  D01B     BRA 0xB010
521:                   --i;
1AFDA  50E1     MOVF 0xFE1, W, ACCESS
1AFDC  0FF9     ADDLW 0xF9
1AFDE  6ED9     MOVWF 0xFD9, ACCESS
1AFE0  50E2     MOVF 0xFE2, W, ACCESS
1AFE2  6EDA     MOVWF __end_of_UART2_tx_vect_isr, ACCESS
1AFE4  0EFF     MOVLW 0xFF
1AFE6  22DA     ADDWFC __end_of_UART2_tx_vect_isr, F, ACCESS
1AFE8  06DE     DECF 0xFDE, F, ACCESS
1AFEA  0E00     MOVLW 0x0
1AFEC  5ADD     SUBWFB 0xFDD, F, ACCESS
522:                   dbuf[i] = s;
1AFEE  0EF9     MOVLW 0xF9
1AFF0  0061     MOVFFL PLUSW1, wtemp5
1AFF2  F38C     NOP
1AFF4  F50B     NOP
1AFF6  0EFA     MOVLW 0xFA
1AFF8  0061     MOVFFL PLUSW1, 0x50C
1AFFA  F38C     NOP
1AFFC  F50C     NOP
1AFFE  0EA5     MOVLW 0xA5
1B000  240B     ADDWF 0xB, W, ACCESS
1B002  6ED9     MOVWF 0xFD9, ACCESS
1B004  0E08     MOVLW 0x8
1B006  200C     ADDWFC 0xC, W, ACCESS
1B008  6EDA     MOVWF __end_of_UART2_tx_vect_isr, ACCESS
1B00A  0EFF     MOVLW 0xFF
1B00C  C4E3     MOVFF PLUSW1, INDF2
1B00E  F4DF     NOP
523:               }
524:           
525:               /* Put out padded string */
526:               return _COUNT_CAST pad(fp, &dbuf[i], w);
1B010  0EFB     MOVLW 0xFB
1B012  C4E3     MOVFF PLUSW1, POSTINC1
1B014  F4E6     NOP
1B016  C4E3     MOVFF PLUSW1, POSTINC1
1B018  F4E6     NOP
1B01A  0EA5     MOVLW 0xA5
1B01C  6E0B     MOVWF 0xB, ACCESS
1B01E  0E08     MOVLW 0x8
1B020  6E0C     MOVWF 0xC, ACCESS
1B022  0EF7     MOVLW 0xF7
1B024  50E3     MOVF 0xFE3, W, ACCESS
1B026  260B     ADDWF 0xB, F, ACCESS
1B028  0EF8     MOVLW 0xF8
1B02A  50E3     MOVF 0xFE3, W, ACCESS
1B02C  220C     ADDWFC 0xC, F, ACCESS
1B02E  0061     MOVFFL wtemp5, POSTINC1
1B030  F42C     NOP
1B032  F4E6     NOP
1B034  0061     MOVFFL 0x50C, POSTINC1
1B036  F430     NOP
1B038  F4E6     NOP
1B03A  0EF1     MOVLW 0xF1
1B03C  C4E3     MOVFF PLUSW1, POSTINC1
1B03E  F4E6     NOP
1B040  C4E3     MOVFF PLUSW1, POSTINC1
1B042  F4E6     NOP
1B044  ECA3     CALL 0x1EF46, 0
1B046  F0F7     NOP
527:           }
1B048  0EF1     MOVLW 0xF1
1B048  0EF1     MOVLW 0xF1
1B048  0EF1     MOVLW 0xF1
1B048  0EF1     MOVLW 0xF1
1B048  0EF1     MOVLW 0xF1
528:           #endif
529:           
530:           #if defined(_VFPF_E) || defined(_VFPF_F) || defined(_VFPF_G)
531:           static _INLINE _COUNT_TYPE efgtoa(FILE *fp, long double f, char c)
10000  0E31     MOVLW 0x31
10002  26E1     ADDWF 0xFE1, F, ACCESS
10004  0E00     MOVLW 0x0
10006  22E2     ADDWFC 0xFE2, F, ACCESS
532:           {
533:               char mode, nmode, pp, sign, esign;
534:               int d, e, i, m, n, ne, p, t, w;
535:               long double h, l;
536:           	union flui g, u, ou;
537:           
538:               /* Record sign, get absolute value */
539:               sign = 0;
10008  0EFB     MOVLW 0xFB
1000A  6AE3     CLRF 0xFE3, ACCESS
540:               g.f = f;
1000C  0EC9     MOVLW 0xC9
1000E  0061     MOVFFL PLUSW1, ltemp2
10010  F38C     NOP
10012  F509     NOP
10014  0ECA     MOVLW 0xCA
10016  0061     MOVFFL PLUSW1, ttemp3
10018  F38C     NOP
1001A  F50A     NOP
1001C  0ECB     MOVLW 0xCB
1001E  0061     MOVFFL PLUSW1, wtemp5
10020  F38C     NOP
10022  F50B     NOP
10024  0ECC     MOVLW 0xCC
10026  0061     MOVFFL PLUSW1, 0x50C
10028  F38C     NOP
1002A  F50C     NOP
1002C  0ED9     MOVLW 0xD9
1002E  0061     MOVFFL ltemp2, PLUSW1
10030  F424     NOP
10032  F4E3     NOP
10034  0EDA     MOVLW 0xDA
10036  0061     MOVFFL ttemp3, PLUSW1
10038  F428     NOP
1003A  F4E3     NOP
1003C  0EDB     MOVLW 0xDB
1003E  0061     MOVFFL wtemp5, PLUSW1
10040  F42C     NOP
10042  F4E3     NOP
10044  0EDC     MOVLW 0xDC
10046  0061     MOVFFL 0x50C, PLUSW1
10048  F430     NOP
1004A  F4E3     NOP
541:               if (g.f < 0.0) {
1004C  0EDC     MOVLW 0xDC
1004E  AEE3     BTFSS 0xFE3, 7, ACCESS
10050  D01E     BRA 0x8E
542:                   sign = 1;
10052  0EFB     MOVLW 0xFB
10054  6AE3     CLRF 0xFE3, ACCESS
10056  2AE3     INCF 0xFE3, F, ACCESS
543:                   g.f = -g.f;
10058  0ED9     MOVLW 0xD9
1005A  C4E3     MOVFF PLUSW1, POSTINC1
1005C  F4E6     NOP
1005E  C4E3     MOVFF PLUSW1, POSTINC1
10060  F4E6     NOP
10062  C4E3     MOVFF PLUSW1, POSTINC1
10064  F4E6     NOP
10066  C4E3     MOVFF PLUSW1, POSTINC1
10068  F4E6     NOP
1006A  EC25     CALL 0x144A, 0
1006C  F00A     NOP
1006E  0ED9     MOVLW 0xD9
10070  0061     MOVFFL ltemp0, PLUSW1
10072  F404     NOP
10074  F4E3     NOP
10076  0EDA     MOVLW 0xDA
10078  0061     MOVFFL ttemp5, PLUSW1
1007A  F408     NOP
1007C  F4E3     NOP
1007E  0EDB     MOVLW 0xDB
10080  0061     MOVFFL wtemp1, PLUSW1
10082  F40C     NOP
10084  F4E3     NOP
10086  0EDC     MOVLW 0xDC
10088  0061     MOVFFL ttemp1, PLUSW1
1008A  F410     NOP
1008C  F4E3     NOP
544:               }
545:           
546:               /* Print sign */
547:               n = 0;
1008E  0EE9     MOVLW 0xE9
10090  6AE3     CLRF 0xFE3, ACCESS
10092  0EEA     MOVLW 0xEA
10094  6AE3     CLRF 0xFE3, ACCESS
548:               w = width;
10096  0EEF     MOVLW 0xEF
10098  C521     MOVFF width, PLUSW1
1009A  F4E3     NOP
1009C  0EF0     MOVLW 0xF0
1009E  C522     MOVFF 0x522, PLUSW1
100A0  F4E3     NOP
549:               if (sign
100A2  0EFB     MOVLW 0xFB
100A4  50E3     MOVF 0xFE3, W, ACCESS
100A6  A4D8     BTFSS 0xFD8, 2, ACCESS
100A8  D002     BRA 0xAE
100AA  A427     BTFSS 0x27, 2, ACCESS
100AC  D01B     BRA 0xE4
550:           #ifdef _VFPF_MANSIGN
551:           			|| (flags & PLUS_FLAG)
552:           #endif
553:           			) {
554:           		sign = sign ? '-' : '+';
100AE  0EFB     MOVLW 0xFB
100B0  50E3     MOVF 0xFE3, W, ACCESS
100B2  A4D8     BTFSS 0xFD8, 2, ACCESS
100B4  D002     BRA 0xBA
100B6  0E2B     MOVLW 0x2B
100B8  D001     BRA 0xBC
100BA  0E2D     MOVLW 0x2D
100BC  6E0B     MOVWF 0xB, ACCESS
100BE  0E00     MOVLW 0x0
100C0  6E0C     MOVWF 0xC, ACCESS
100C2  0ED3     MOVLW 0xD3
100C4  0061     MOVFFL wtemp5, PLUSW1
100C6  F42C     NOP
100C8  F4E3     NOP
100CA  0ED4     MOVLW 0xD4
100CC  0061     MOVFFL 0x50C, PLUSW1
100CE  F430     NOP
100D0  F4E3     NOP
100D2  0ED3     MOVLW 0xD3
100D4  0061     MOVFFL PLUSW1, ltemp0
100D6  F38C     NOP
100D8  F501     NOP
100DA  0EFB     MOVLW 0xFB
100DC  0061     MOVFFL ltemp0, PLUSW1
100DE  F404     NOP
100E0  F4E3     NOP
555:               }
100E2  D005     BRA 0xEE
556:           #if defined(_VFPF_SPCSIGN)
557:           	else if (flags & SPACE_FLAG) {
100E4  A627     BTFSS 0x27, 3, ACCESS
100E6  D003     BRA 0xEE
558:           		sign = ' ';
100E8  0EFB     MOVLW 0xFB
100EA  6AE3     CLRF 0xFE3, ACCESS
100EC  8AE3     BSF 0xFE3, 5, ACCESS
559:           	}
560:           #endif
561:           
562:               /* Catch infinities, NaNs here */
563:               if (isinf(g.f)) {
100EE  0ED9     MOVLW 0xD9
100F0  C4E3     MOVFF PLUSW1, POSTINC1
100F2  F4E6     NOP
100F4  C4E3     MOVFF PLUSW1, POSTINC1
100F6  F4E6     NOP
100F8  C4E3     MOVFF PLUSW1, POSTINC1
100FA  F4E6     NOP
100FC  C4E3     MOVFF PLUSW1, POSTINC1
100FE  F4E6     NOP
10100  EC5F     CALL 0x1D0BE, 0
10102  F0E8     NOP
10104  0401     DECF __ptext283, W, ACCESS
10106  1002     IORWF ___rparam_used, W, ACCESS
10108  A4D8     BTFSS 0xFD8, 2, ACCESS
1010A  D077     BRA 0x1FA
564:           		if (sign) {
1010C  0EFB     MOVLW 0xFB
1010E  50E3     MOVF 0xFE3, W, ACCESS
10110  B4D8     BTFSC 0xFD8, 2, ACCESS
10112  D019     BRA 0x146
565:           			dbuf[0] = sign;
10114  0EFB     MOVLW 0xFB
10116  C4E3     MOVFF PLUSW1, dbuf
10118  F8A5     NOP
566:           			w--;
1011A  50E1     MOVF 0xFE1, W, ACCESS
1011C  0FEF     ADDLW 0xEF
1011E  6ED9     MOVWF 0xFD9, ACCESS
10120  50E2     MOVF 0xFE2, W, ACCESS
10122  6EDA     MOVWF __end_of_UART2_tx_vect_isr, ACCESS
10124  0EFF     MOVLW 0xFF
10126  22DA     ADDWFC __end_of_UART2_tx_vect_isr, F, ACCESS
10128  06DE     DECF 0xFDE, F, ACCESS
1012A  0E00     MOVLW 0x0
1012C  5ADD     SUBWFB 0xFDD, F, ACCESS
567:           			n = 1;
1012E  0E01     MOVLW 0x1
10130  6E0B     MOVWF 0xB, ACCESS
10132  0E00     MOVLW 0x0
10134  6E0C     MOVWF 0xC, ACCESS
10136  0EE9     MOVLW 0xE9
10138  0061     MOVFFL wtemp5, PLUSW1
1013A  F42C     NOP
1013C  F4E3     NOP
1013E  0EEA     MOVLW 0xEA
10140  0061     MOVFFL 0x50C, PLUSW1
10142  F430     NOP
10144  F4E3     NOP
568:           		}
569:           #ifdef _VFPF_UPCASE
570:                   if (isupper((int)c)) {
10146  0EC8     MOVLW 0xC8
10148  0061     MOVFFL PLUSW1, 0x50C
1014A  F38C     NOP
1014C  F50C     NOP
1014E  0EBF     MOVLW 0xBF
10150  240C     ADDWF 0xC, W, ACCESS
10152  6E09     MOVWF 0x9, ACCESS
10154  6A0A     CLRF 0xA, ACCESS
10156  0EFF     MOVLW 0xFF
10158  220A     ADDWFC 0xA, F, ACCESS
1015A  500A     MOVF 0xA, W, ACCESS
1015C  E11B     BNZ 0x194
1015E  0E1A     MOVLW 0x1A
10160  5C09     SUBWF 0x9, W, ACCESS
10162  B0D8     BTFSC 0xFD8, 0, ACCESS
10164  D017     BRA 0x194
571:                       strcpy(&dbuf[n], "INF");
10166  0EDF     MOVLW 0xDF
10168  6EE6     MOVWF 0xFE6, ACCESS
1016A  0EFF     MOVLW 0xFF
1016C  6EE6     MOVWF 0xFE6, ACCESS
1016E  0EA5     MOVLW 0xA5
10170  6E0B     MOVWF 0xB, ACCESS
10172  0E08     MOVLW 0x8
10174  6E0C     MOVWF 0xC, ACCESS
10176  0EE7     MOVLW 0xE7
10178  50E3     MOVF 0xFE3, W, ACCESS
1017A  260B     ADDWF 0xB, F, ACCESS
1017C  0EE8     MOVLW 0xE8
1017E  50E3     MOVF 0xFE3, W, ACCESS
10180  220C     ADDWFC 0xC, F, ACCESS
10182  0061     MOVFFL wtemp5, POSTINC1
10184  F42C     NOP
10186  F4E6     NOP
10188  0061     MOVFFL 0x50C, POSTINC1
1018A  F430     NOP
1018C  F4E6     NOP
1018E  ECF7     CALL 0x1F9EE, 0
10190  F0FC     NOP
572:                   }
10192  D016     BRA 0x1C0
573:           		else
574:           #endif
575:           		{
576:                       strcpy(&dbuf[n], "inf");
10194  0EE7     MOVLW 0xE7
10196  6EE6     MOVWF 0xFE6, ACCESS
10198  0EFF     MOVLW 0xFF
1019A  6EE6     MOVWF 0xFE6, ACCESS
1019C  0EA5     MOVLW 0xA5
1019E  6E0B     MOVWF 0xB, ACCESS
101A0  0E08     MOVLW 0x8
101A2  6E0C     MOVWF 0xC, ACCESS
101A4  0EE7     MOVLW 0xE7
101A6  50E3     MOVF 0xFE3, W, ACCESS
101A8  260B     ADDWF 0xB, F, ACCESS
101AA  0EE8     MOVLW 0xE8
101AC  50E3     MOVF 0xFE3, W, ACCESS
101AE  220C     ADDWFC 0xC, F, ACCESS
101B0  0061     MOVFFL wtemp5, POSTINC1
101B2  F42C     NOP
101B4  F4E6     NOP
101B6  0061     MOVFFL 0x50C, POSTINC1
101B8  F430     NOP
101BA  F4E6     NOP
101BC  ECF7     CALL 0x1F9EE, 0
101BE  F0FC     NOP
577:                   }
578:                   w -= CSTRLEN("inf");
101C0  50E1     MOVF 0xFE1, W, ACCESS
101C2  0FEF     ADDLW 0xEF
101C4  6ED9     MOVWF 0xFD9, ACCESS
101C6  50E2     MOVF 0xFE2, W, ACCESS
101C8  6EDA     MOVWF __end_of_UART2_tx_vect_isr, ACCESS
101CA  0EFF     MOVLW 0xFF
101CC  22DA     ADDWFC __end_of_UART2_tx_vect_isr, F, ACCESS
101CE  0EFD     MOVLW 0xFD
101D0  26DE     ADDWF 0xFDE, F, ACCESS
101D2  0EFF     MOVLW 0xFF
101D4  22DD     ADDWFC 0xFDD, F, ACCESS
579:                   return _COUNT_CAST pad(fp, &dbuf[0], w);
101D6  0EEF     MOVLW 0xEF
101D8  C4E3     MOVFF PLUSW1, POSTINC1
101DA  F4E6     NOP
101DC  C4E3     MOVFF PLUSW1, POSTINC1
101DE  F4E6     NOP
101E0  0EA5     MOVLW 0xA5
101E2  6EE6     MOVWF 0xFE6, ACCESS
101E4  0E08     MOVLW 0x8
101E6  6EE6     MOVWF 0xFE6, ACCESS
101E8  0EC9     MOVLW 0xC9
101EA  C4E3     MOVFF PLUSW1, POSTINC1
101EC  F4E6     NOP
101EE  C4E3     MOVFF PLUSW1, POSTINC1
101F0  F4E6     NOP
101F2  ECA3     CALL 0x1EF46, 0
101F4  F0F7     NOP
101F6  EF3C     GOTO 0x11478
101F8  F08A     NOP
580:               }
581:               if (isnan(g.f)) {
101FA  0ED9     MOVLW 0xD9
101FC  C4E3     MOVFF PLUSW1, POSTINC1
101FE  F4E6     NOP
10200  C4E3     MOVFF PLUSW1, POSTINC1
10202  F4E6     NOP
10204  C4E3     MOVFF PLUSW1, POSTINC1
10206  F4E6     NOP
10208  C4E3     MOVFF PLUSW1, POSTINC1
1020A  F4E6     NOP
1020C  EC5F     CALL 0x1D0BE, 0
1020E  F0E8     NOP
10210  5001     MOVF __ptext283, W, ACCESS
10212  1002     IORWF ___rparam_used, W, ACCESS
10214  A4D8     BTFSS 0xFD8, 2, ACCESS
10216  D05B     BRA 0x2CE
582:           		if (sign) {
10218  0EFB     MOVLW 0xFB
1021A  50E3     MOVF 0xFE3, W, ACCESS
1021C  B4D8     BTFSC 0xFD8, 2, ACCESS
1021E  D019     BRA 0x252
583:           			dbuf[0] = sign;
10220  0EFB     MOVLW 0xFB
10222  C4E3     MOVFF PLUSW1, dbuf
10224  F8A5     NOP
584:           			w--;
10226  50E1     MOVF 0xFE1, W, ACCESS
10228  0FEF     ADDLW 0xEF
1022A  6ED9     MOVWF 0xFD9, ACCESS
1022C  50E2     MOVF 0xFE2, W, ACCESS
1022E  6EDA     MOVWF __end_of_UART2_tx_vect_isr, ACCESS
10230  0EFF     MOVLW 0xFF
10232  22DA     ADDWFC __end_of_UART2_tx_vect_isr, F, ACCESS
10234  06DE     DECF 0xFDE, F, ACCESS
10236  0E00     MOVLW 0x0
10238  5ADD     SUBWFB 0xFDD, F, ACCESS
585:           			n = 1;
1023A  0E01     MOVLW 0x1
1023C  6E0B     MOVWF 0xB, ACCESS
1023E  0E00     MOVLW 0x0
10240  6E0C     MOVWF 0xC, ACCESS
10242  0EE9     MOVLW 0xE9
10244  0061     MOVFFL wtemp5, PLUSW1
10246  F42C     NOP
10248  F4E3     NOP
1024A  0EEA     MOVLW 0xEA
1024C  0061     MOVFFL 0x50C, PLUSW1
1024E  F430     NOP
10250  F4E3     NOP
586:           		}
587:           #ifdef _VFPF_UPCASE
588:                   if (isupper((int)c)) {
10252  0EC8     MOVLW 0xC8
10254  0061     MOVFFL PLUSW1, 0x50C
10256  F38C     NOP
10258  F50C     NOP
1025A  0EBF     MOVLW 0xBF
1025C  240C     ADDWF 0xC, W, ACCESS
1025E  6E09     MOVWF 0x9, ACCESS
10260  6A0A     CLRF 0xA, ACCESS
10262  0EFF     MOVLW 0xFF
10264  220A     ADDWFC 0xA, F, ACCESS
10266  500A     MOVF 0xA, W, ACCESS
10268  E11B     BNZ 0x2A0
1026A  0E1A     MOVLW 0x1A
1026C  5C09     SUBWF 0x9, W, ACCESS
1026E  B0D8     BTFSC 0xFD8, 0, ACCESS
10270  D017     BRA 0x2A0
589:                       strcpy(&dbuf[n], "NAN");
10272  0EE3     MOVLW 0xE3
10274  6EE6     MOVWF 0xFE6, ACCESS
10276  0EFF     MOVLW 0xFF
10278  6EE6     MOVWF 0xFE6, ACCESS
1027A  0EA5     MOVLW 0xA5
1027C  6E0B     MOVWF 0xB, ACCESS
1027E  0E08     MOVLW 0x8
10280  6E0C     MOVWF 0xC, ACCESS
10282  0EE7     MOVLW 0xE7
10284  50E3     MOVF 0xFE3, W, ACCESS
10286  260B     ADDWF 0xB, F, ACCESS
10288  0EE8     MOVLW 0xE8
1028A  50E3     MOVF 0xFE3, W, ACCESS
1028C  220C     ADDWFC 0xC, F, ACCESS
1028E  0061     MOVFFL wtemp5, POSTINC1
10290  F42C     NOP
10292  F4E6     NOP
10294  0061     MOVFFL 0x50C, POSTINC1
10296  F430     NOP
10298  F4E6     NOP
1029A  ECF7     CALL 0x1F9EE, 0
1029C  F0FC     NOP
590:                   }
1029E  D790     BRA 0x1C0
591:           		else
592:           #endif
593:           		{
594:                       strcpy(&dbuf[n], "nan");
102A0  0EEB     MOVLW 0xEB
102A2  6EE6     MOVWF 0xFE6, ACCESS
102A4  0EFF     MOVLW 0xFF
102A6  6EE6     MOVWF 0xFE6, ACCESS
102A8  0EA5     MOVLW 0xA5
102AA  6E0B     MOVWF 0xB, ACCESS
102AC  0E08     MOVLW 0x8
102AE  6E0C     MOVWF 0xC, ACCESS
102B0  0EE7     MOVLW 0xE7
102B2  50E3     MOVF 0xFE3, W, ACCESS
102B4  260B     ADDWF 0xB, F, ACCESS
102B6  0EE8     MOVLW 0xE8
102B8  50E3     MOVF 0xFE3, W, ACCESS
102BA  220C     ADDWFC 0xC, F, ACCESS
102BC  0061     MOVFFL wtemp5, POSTINC1
102BE  F42C     NOP
102C0  F4E6     NOP
102C2  0061     MOVFFL 0x50C, POSTINC1
102C4  F430     NOP
102C6  F4E6     NOP
102C8  ECF7     CALL 0x1F9EE, 0
102CA  F0FC     NOP
102CC  D779     BRA 0x1C0
595:                   }
596:                   w -= CSTRLEN("nan");
597:                   return _COUNT_CAST pad(fp, &dbuf[0], w);
598:               }
599:           
600:               /* First find the largest power of 10 not larger than number to print */
601:               u.f = 1.0;
102CE  0E00     MOVLW 0x0
102D0  6E09     MOVWF 0x9, ACCESS
102D2  0E00     MOVLW 0x0
102D4  6E0A     MOVWF 0xA, ACCESS
102D6  0E80     MOVLW 0x80
102D8  6E0B     MOVWF 0xB, ACCESS
102DA  0E3F     MOVLW 0x3F
102DC  6E0C     MOVWF 0xC, ACCESS
102DE  0ED5     MOVLW 0xD5
102E0  0061     MOVFFL ltemp2, PLUSW1
102E2  F424     NOP
102E4  F4E3     NOP
102E6  0ED6     MOVLW 0xD6
102E8  0061     MOVFFL ttemp3, PLUSW1
102EA  F428     NOP
102EC  F4E3     NOP
102EE  0ED7     MOVLW 0xD7
102F0  0061     MOVFFL wtemp5, PLUSW1
102F2  F42C     NOP
102F4  F4E3     NOP
102F6  0ED8     MOVLW 0xD8
102F8  0061     MOVFFL 0x50C, PLUSW1
102FA  F430     NOP
102FC  F4E3     NOP
602:               e = 0;
102FE  0EED     MOVLW 0xED
10300  6AE3     CLRF 0xFE3, ACCESS
10302  0EEE     MOVLW 0xEE
10304  6AE3     CLRF 0xFE3, ACCESS
603:           	if (!(g.f == 0.0)) {
10306  0E00     MOVLW 0x0
10308  6EE6     MOVWF 0xFE6, ACCESS
1030A  0E00     MOVLW 0x0
1030C  6EE6     MOVWF 0xFE6, ACCESS
1030E  0E00     MOVLW 0x0
10310  6EE6     MOVWF 0xFE6, ACCESS
10312  0E00     MOVLW 0x0
10314  6EE6     MOVWF 0xFE6, ACCESS
10316  0ED5     MOVLW 0xD5
10318  C4E3     MOVFF PLUSW1, POSTINC1
1031A  F4E6     NOP
1031C  C4E3     MOVFF PLUSW1, POSTINC1
1031E  F4E6     NOP
10320  C4E3     MOVFF PLUSW1, POSTINC1
10322  F4E6     NOP
10324  C4E3     MOVFF PLUSW1, POSTINC1
10326  F4E6     NOP
10328  EC95     CALL 0x1F92A, 0
1032A  F0FC     NOP
1032C  A001     BTFSS __ptext283, 0, ACCESS
1032E  D032     BRA 0x394
10330  D16A     BRA 0x606
604:           		while (FNEARLYEQ(g,(ou.f = u.f*10.0,ou)) || g.f > ou.f) {
10394  0E00     MOVLW 0x0
10396  6EE6     MOVWF 0xFE6, ACCESS
10398  0E00     MOVLW 0x0
1039A  6EE6     MOVWF 0xFE6, ACCESS
1039C  0E20     MOVLW 0x20
1039E  6EE6     MOVWF 0xFE6, ACCESS
103A0  0E41     MOVLW 0x41
103A2  6EE6     MOVWF 0xFE6, ACCESS
103A4  0ED1     MOVLW 0xD1
103A6  C4E3     MOVFF PLUSW1, POSTINC1
103A8  F4E6     NOP
103AA  C4E3     MOVFF PLUSW1, POSTINC1
103AC  F4E6     NOP
103AE  C4E3     MOVFF PLUSW1, POSTINC1
103B0  F4E6     NOP
103B2  C4E3     MOVFF PLUSW1, POSTINC1
103B4  F4E6     NOP
103B6  EC2F     CALL 0x1705E, 0
103B8  F0B8     NOP
103BA  0EE5     MOVLW 0xE5
103BC  0061     MOVFFL ltemp0, PLUSW1
103BE  F404     NOP
103C0  F4E3     NOP
103C2  0EE6     MOVLW 0xE6
103C4  0061     MOVFFL ttemp5, PLUSW1
103C6  F408     NOP
103C8  F4E3     NOP
103CA  0EE7     MOVLW 0xE7
103CC  0061     MOVFFL wtemp1, PLUSW1
103CE  F40C     NOP
103D0  F4E3     NOP
103D2  0EE8     MOVLW 0xE8
103D4  0061     MOVFFL ttemp1, PLUSW1
103D6  F410     NOP
103D8  F4E3     NOP
103DA  0ED9     MOVLW 0xD9
103DC  0061     MOVFFL PLUSW1, ltemp2
103DE  F38C     NOP
103E0  F509     NOP
103E2  0EDA     MOVLW 0xDA
103E4  0061     MOVFFL PLUSW1, ttemp3
103E6  F38C     NOP
103E8  F50A     NOP
103EA  0EDB     MOVLW 0xDB
103EC  0061     MOVFFL PLUSW1, wtemp5
103EE  F38C     NOP
103F0  F50B     NOP
103F2  0EDC     MOVLW 0xDC
103F4  0061     MOVFFL PLUSW1, 0x50C
103F6  F38C     NOP
103F8  F50C     NOP
103FA  0EE5     MOVLW 0xE5
103FC  50E3     MOVF 0xFE3, W, ACCESS
103FE  5E09     SUBWF 0x9, F, ACCESS
10400  0EE6     MOVLW 0xE6
10402  50E3     MOVF 0xFE3, W, ACCESS
10404  5A0A     SUBWFB 0xA, F, ACCESS
10406  0EE7     MOVLW 0xE7
10408  50E3     MOVF 0xFE3, W, ACCESS
1040A  5A0B     SUBWFB 0xB, F, ACCESS
1040C  0EE8     MOVLW 0xE8
1040E  50E3     MOVF 0xFE3, W, ACCESS
10410  5A0C     SUBWFB 0xC, F, ACCESS
10412  0061     MOVFFL ltemp2, POSTINC1
10414  F424     NOP
10416  F4E6     NOP
10418  0061     MOVFFL ttemp3, POSTINC1
1041A  F428     NOP
1041C  F4E6     NOP
1041E  0061     MOVFFL wtemp5, POSTINC1
10420  F42C     NOP
10422  F4E6     NOP
10424  0061     MOVFFL 0x50C, POSTINC1
10426  F430     NOP
10428  F4E6     NOP
1042A  EC7A     CALL 0x8F4, 0
1042C  F004     NOP
1042E  BE04     BTFSC __activetblptr, 7, ACCESS
10430  D780     BRA 0x332
10432  5004     MOVF __activetblptr, W, ACCESS
10434  1003     IORWF __activetblptr, W, ACCESS
10436  1002     IORWF ___rparam_used, W, ACCESS
10438  E104     BNZ 0x442
1043A  0E02     MOVLW 0x2
1043C  5C01     SUBWF __ptext283, W, ACCESS
1043E  A0D8     BTFSS 0xFD8, 0, ACCESS
10440  D778     BRA 0x332
10442  0ED9     MOVLW 0xD9
10444  C4E3     MOVFF PLUSW1, POSTINC1
10446  F4E6     NOP
10448  C4E3     MOVFF PLUSW1, POSTINC1
1044A  F4E6     NOP
1044C  C4E3     MOVFF PLUSW1, POSTINC1
1044E  F4E6     NOP
10450  C4E3     MOVFF PLUSW1, POSTINC1
10452  F4E6     NOP
10454  0EE1     MOVLW 0xE1
10456  C4E3     MOVFF PLUSW1, POSTINC1
10458  F4E6     NOP
1045A  C4E3     MOVFF PLUSW1, POSTINC1
1045C  F4E6     NOP
1045E  C4E3     MOVFF PLUSW1, POSTINC1
10460  F4E6     NOP
10462  C4E3     MOVFF PLUSW1, POSTINC1
10464  F4E6     NOP
10466  EC60     CALL 0x1D6C0, 0
10468  F0EB     NOP
1046A  A001     BTFSS __ptext283, 0, ACCESS
1046C  D762     BRA 0x332
605:           			u = ou;
10332  0EE5     MOVLW 0xE5
10334  0061     MOVFFL PLUSW1, ltemp2
10336  F38C     NOP
10338  F509     NOP
1033A  0EE6     MOVLW 0xE6
1033C  0061     MOVFFL PLUSW1, ttemp3
1033E  F38C     NOP
10340  F50A     NOP
10342  0EE7     MOVLW 0xE7
10344  0061     MOVFFL PLUSW1, wtemp5
10346  F38C     NOP
10348  F50B     NOP
1034A  0EE8     MOVLW 0xE8
1034C  0061     MOVFFL PLUSW1, 0x50C
1034E  F38C     NOP
10350  F50C     NOP
10352  0ED5     MOVLW 0xD5
10354  0061     MOVFFL ltemp2, PLUSW1
10356  F424     NOP
10358  F4E3     NOP
1035A  0ED6     MOVLW 0xD6
1035C  0061     MOVFFL ttemp3, PLUSW1
1035E  F428     NOP
10360  F4E3     NOP
10362  0ED7     MOVLW 0xD7
10364  0061     MOVFFL wtemp5, PLUSW1
10366  F42C     NOP
10368  F4E3     NOP
1036A  0ED8     MOVLW 0xD8
1036C  0061     MOVFFL 0x50C, PLUSW1
1036E  F430     NOP
10370  F4E3     NOP
606:           			++e;
10372  0EED     MOVLW 0xED
10374  50E3     MOVF 0xFE3, W, ACCESS
10376  0F01     ADDLW 0x1
10378  6E01     MOVWF __ptext283, ACCESS
1037A  0EED     MOVLW 0xED
1037C  0061     MOVFFL ltemp0, PLUSW1
1037E  F404     NOP
10380  F4E3     NOP
10382  6A01     CLRF __ptext283, ACCESS
10384  0EEE     MOVLW 0xEE
10386  50E3     MOVF 0xFE3, W, ACCESS
10388  2001     ADDWFC __ptext283, W, ACCESS
1038A  6E01     MOVWF __ptext283, ACCESS
1038C  0EEE     MOVLW 0xEE
1038E  0061     MOVFFL ltemp0, PLUSW1
10390  F404     NOP
10392  F4E3     NOP
607:           		}
608:           		if (FNEARLYEQ(g,u)) {
1046E  0ED9     MOVLW 0xD9
10470  0061     MOVFFL PLUSW1, ltemp2
10472  F38C     NOP
10474  F509     NOP
10476  0EDA     MOVLW 0xDA
10478  0061     MOVFFL PLUSW1, ttemp3
1047A  F38C     NOP
1047C  F50A     NOP
1047E  0EDB     MOVLW 0xDB
10480  0061     MOVFFL PLUSW1, wtemp5
10482  F38C     NOP
10484  F50B     NOP
10486  0EDC     MOVLW 0xDC
10488  0061     MOVFFL PLUSW1, 0x50C
1048A  F38C     NOP
1048C  F50C     NOP
1048E  0ED5     MOVLW 0xD5
10490  50E3     MOVF 0xFE3, W, ACCESS
10492  5E09     SUBWF 0x9, F, ACCESS
10494  0ED6     MOVLW 0xD6
10496  50E3     MOVF 0xFE3, W, ACCESS
10498  5A0A     SUBWFB 0xA, F, ACCESS
1049A  0ED7     MOVLW 0xD7
1049C  50E3     MOVF 0xFE3, W, ACCESS
1049E  5A0B     SUBWFB 0xB, F, ACCESS
104A0  0ED8     MOVLW 0xD8
104A2  50E3     MOVF 0xFE3, W, ACCESS
104A4  5A0C     SUBWFB 0xC, F, ACCESS
104A6  0061     MOVFFL ltemp2, POSTINC1
104A8  F424     NOP
104AA  F4E6     NOP
104AC  0061     MOVFFL ttemp3, POSTINC1
104AE  F428     NOP
104B0  F4E6     NOP
104B2  0061     MOVFFL wtemp5, POSTINC1
104B4  F42C     NOP
104B6  F4E6     NOP
104B8  0061     MOVFFL 0x50C, POSTINC1
104BA  F430     NOP
104BC  F4E6     NOP
104BE  EC7A     CALL 0x8F4, 0
104C0  F004     NOP
104C2  BE04     BTFSC __activetblptr, 7, ACCESS
104C4  D008     BRA 0x4D6
104C6  5004     MOVF __activetblptr, W, ACCESS
104C8  1003     IORWF __activetblptr, W, ACCESS
104CA  1002     IORWF ___rparam_used, W, ACCESS
104CC  E103     BNZ 0x4D4
104CE  0E02     MOVLW 0x2
104D0  5C01     SUBWF __ptext283, W, ACCESS
104D2  B0D8     BTFSC 0xFD8, 0, ACCESS
104D4  D082     BRA 0x5DA
609:           			g = u;
104D6  0ED5     MOVLW 0xD5
104D8  0061     MOVFFL PLUSW1, ltemp2
104DA  F38C     NOP
104DC  F509     NOP
104DE  0ED6     MOVLW 0xD6
104E0  0061     MOVFFL PLUSW1, ttemp3
104E2  F38C     NOP
104E4  F50A     NOP
104E6  0ED7     MOVLW 0xD7
104E8  0061     MOVFFL PLUSW1, wtemp5
104EA  F38C     NOP
104EC  F50B     NOP
104EE  0ED8     MOVLW 0xD8
104F0  0061     MOVFFL PLUSW1, 0x50C
104F2  F38C     NOP
104F4  F50C     NOP
104F6  0ED9     MOVLW 0xD9
104F8  0061     MOVFFL ltemp2, PLUSW1
104FA  F424     NOP
104FC  F4E3     NOP
104FE  0EDA     MOVLW 0xDA
10500  0061     MOVFFL ttemp3, PLUSW1
10502  F428     NOP
10504  F4E3     NOP
10506  0EDB     MOVLW 0xDB
10508  0061     MOVFFL wtemp5, PLUSW1
1050A  F42C     NOP
1050C  F4E3     NOP
1050E  0EDC     MOVLW 0xDC
10510  0061     MOVFFL 0x50C, PLUSW1
10512  F430     NOP
10514  F4E3     NOP
610:           		}
10516  D077     BRA 0x606
611:           		else {
612:           			while (g.f < u.f) {
105DA  0ED5     MOVLW 0xD5
105DC  C4E3     MOVFF PLUSW1, POSTINC1
105DE  F4E6     NOP
105E0  C4E3     MOVFF PLUSW1, POSTINC1
105E2  F4E6     NOP
105E4  C4E3     MOVFF PLUSW1, POSTINC1
105E6  F4E6     NOP
105E8  C4E3     MOVFF PLUSW1, POSTINC1
105EA  F4E6     NOP
105EC  0ED5     MOVLW 0xD5
105EE  C4E3     MOVFF PLUSW1, POSTINC1
105F0  F4E6     NOP
105F2  C4E3     MOVFF PLUSW1, POSTINC1
105F4  F4E6     NOP
105F6  C4E3     MOVFF PLUSW1, POSTINC1
105F8  F4E6     NOP
105FA  C4E3     MOVFF PLUSW1, POSTINC1
105FC  F4E6     NOP
105FE  EC60     CALL 0x1D6C0, 0
10600  F0EB     NOP
10602  A001     BTFSS __ptext283, 0, ACCESS
10604  D789     BRA 0x518
613:           				u.f = u.f/10.0;
10518  0E00     MOVLW 0x0
1051A  6EE6     MOVWF 0xFE6, ACCESS
1051C  0E00     MOVLW 0x0
1051E  6EE6     MOVWF 0xFE6, ACCESS
10520  0E20     MOVLW 0x20
10522  6EE6     MOVWF 0xFE6, ACCESS
10524  0E41     MOVLW 0x41
10526  6EE6     MOVWF 0xFE6, ACCESS
10528  0ED1     MOVLW 0xD1
1052A  C4E3     MOVFF PLUSW1, POSTINC1
1052C  F4E6     NOP
1052E  C4E3     MOVFF PLUSW1, POSTINC1
10530  F4E6     NOP
10532  C4E3     MOVFF PLUSW1, POSTINC1
10534  F4E6     NOP
10536  C4E3     MOVFF PLUSW1, POSTINC1
10538  F4E6     NOP
1053A  ECD2     CALL 0x187A4, 0
1053C  F0C3     NOP
1053E  0ED5     MOVLW 0xD5
10540  0061     MOVFFL ltemp0, PLUSW1
10542  F404     NOP
10544  F4E3     NOP
10546  0ED6     MOVLW 0xD6
10548  0061     MOVFFL ttemp5, PLUSW1
1054A  F408     NOP
1054C  F4E3     NOP
1054E  0ED7     MOVLW 0xD7
10550  0061     MOVFFL wtemp1, PLUSW1
10552  F40C     NOP
10554  F4E3     NOP
10556  0ED8     MOVLW 0xD8
10558  0061     MOVFFL ttemp1, PLUSW1
1055A  F410     NOP
1055C  F4E3     NOP
614:           				--e;
1055E  50E1     MOVF 0xFE1, W, ACCESS
10560  0FED     ADDLW 0xED
10562  6ED9     MOVWF 0xFD9, ACCESS
10564  50E2     MOVF 0xFE2, W, ACCESS
10566  6EDA     MOVWF __end_of_UART2_tx_vect_isr, ACCESS
10568  0EFF     MOVLW 0xFF
1056A  22DA     ADDWFC __end_of_UART2_tx_vect_isr, F, ACCESS
1056C  06DE     DECF 0xFDE, F, ACCESS
1056E  0E00     MOVLW 0x0
10570  5ADD     SUBWFB 0xFDD, F, ACCESS
615:           				if (FNEARLYEQ(g,u)) {
10572  0ED9     MOVLW 0xD9
10574  0061     MOVFFL PLUSW1, ltemp2
10576  F38C     NOP
10578  F509     NOP
1057A  0EDA     MOVLW 0xDA
1057C  0061     MOVFFL PLUSW1, ttemp3
1057E  F38C     NOP
10580  F50A     NOP
10582  0EDB     MOVLW 0xDB
10584  0061     MOVFFL PLUSW1, wtemp5
10586  F38C     NOP
10588  F50B     NOP
1058A  0EDC     MOVLW 0xDC
1058C  0061     MOVFFL PLUSW1, 0x50C
1058E  F38C     NOP
10590  F50C     NOP
10592  0ED5     MOVLW 0xD5
10594  50E3     MOVF 0xFE3, W, ACCESS
10596  5E09     SUBWF 0x9, F, ACCESS
10598  0ED6     MOVLW 0xD6
1059A  50E3     MOVF 0xFE3, W, ACCESS
1059C  5A0A     SUBWFB 0xA, F, ACCESS
1059E  0ED7     MOVLW 0xD7
105A0  50E3     MOVF 0xFE3, W, ACCESS
105A2  5A0B     SUBWFB 0xB, F, ACCESS
105A4  0ED8     MOVLW 0xD8
105A6  50E3     MOVF 0xFE3, W, ACCESS
105A8  5A0C     SUBWFB 0xC, F, ACCESS
105AA  0061     MOVFFL ltemp2, POSTINC1
105AC  F424     NOP
105AE  F4E6     NOP
105B0  0061     MOVFFL ttemp3, POSTINC1
105B2  F428     NOP
105B4  F4E6     NOP
105B6  0061     MOVFFL wtemp5, POSTINC1
105B8  F42C     NOP
105BA  F4E6     NOP
105BC  0061     MOVFFL 0x50C, POSTINC1
105BE  F430     NOP
105C0  F4E6     NOP
105C2  EC7A     CALL 0x8F4, 0
105C4  F004     NOP
105C6  BE04     BTFSC __activetblptr, 7, ACCESS
105C8  D786     BRA 0x4D6
105CA  5004     MOVF __activetblptr, W, ACCESS
105CC  1003     IORWF __activetblptr, W, ACCESS
105CE  1002     IORWF ___rparam_used, W, ACCESS
105D0  E104     BNZ 0x5DA
105D2  0E02     MOVLW 0x2
105D4  5C01     SUBWF __ptext283, W, ACCESS
105D6  A0D8     BTFSS 0xFD8, 0, ACCESS
105D8  D77E     BRA 0x4D6
616:           					g = u;
617:           					break;
618:           				}
619:           			}
620:           		}
621:               }
622:           
623:               /* Get mode, precision */
624:           #ifdef _VFPF_UPCASE
625:               mode = (char)tolower((int)c);
10606  0EC8     MOVLW 0xC8
10608  50E3     MOVF 0xFE3, W, ACCESS
1060A  6EE6     MOVWF 0xFE6, ACCESS
1060C  0E00     MOVLW 0x0
1060E  6EE6     MOVWF 0xFE6, ACCESS
10610  EC9D     CALL 0x113A, 0
10612  F008     NOP
10614  0EFC     MOVLW 0xFC
10616  0061     MOVFFL ltemp0, PLUSW1
10618  F404     NOP
1061A  F4E3     NOP
626:           #else
627:           	mode = c;
628:           #endif
629:               nmode = mode;
1061C  0EFC     MOVLW 0xFC
1061E  0061     MOVFFL PLUSW1, ltemp0
10620  F38C     NOP
10622  F501     NOP
10624  0EFD     MOVLW 0xFD
10626  0061     MOVFFL ltemp0, PLUSW1
10628  F404     NOP
1062A  F4E3     NOP
630:           #ifdef _VFPF_G
631:               if (mode == 'g') {
1062C  0EFC     MOVLW 0xFC
1062E  0061     MOVFFL PLUSW1, ltemp0
10630  F38C     NOP
10632  F501     NOP
10634  0E67     MOVLW 0x67
10636  1801     XORWF __ptext283, W, ACCESS
10638  A4D8     BTFSS 0xFD8, 2, ACCESS
1063A  D023     BRA 0x682
632:           		if (prec == 0) {
1063C  5023     MOVF 0x23, W, ACCESS
1063E  1024     IORWF 0x24, W, ACCESS
10640  A4D8     BTFSS 0xFD8, 2, ACCESS
10642  D004     BRA 0x64C
633:           			prec = 1;
10644  0E00     MOVLW 0x0
10646  6E24     MOVWF 0x24, ACCESS
10648  0E01     MOVLW 0x1
1064A  6E23     MOVWF 0x23, ACCESS
634:           		}
635:                   p = (0 < prec) ? prec : 6;
1064C  BE24     BTFSC 0x24, 7, ACCESS
1064E  D005     BRA 0x65A
10650  5024     MOVF 0x24, W, ACCESS
10652  E110     BNZ 0x674
10654  0423     DECF 0x23, W, ACCESS
10656  B0D8     BTFSC 0xFD8, 0, ACCESS
10658  D00D     BRA 0x674
1065A  0E06     MOVLW 0x6
1065C  6E0B     MOVWF 0xB, ACCESS
1065E  0E00     MOVLW 0x0
10660  6E0C     MOVWF 0xC, ACCESS
10662  0EF1     MOVLW 0xF1
10664  0061     MOVFFL wtemp5, PLUSW1
10666  F42C     NOP
10668  F4E3     NOP
1066A  0EF2     MOVLW 0xF2
1066C  0061     MOVFFL 0x50C, PLUSW1
1066E  F430     NOP
10670  F4E3     NOP
10672  D00A     BRA 0x688
10674  0EF1     MOVLW 0xF1
10676  C523     MOVFF prec, PLUSW1
10678  F4E3     NOP
1067A  0EF2     MOVLW 0xF2
1067C  C524     MOVFF 0x524, PLUSW1
1067E  F4E3     NOP
10680  D003     BRA 0x688
636:               }
637:           	else
638:           #endif
639:           	{
640:                   p = (prec < 0) ? 6 : prec;
10682  AE24     BTFSS 0x24, 7, ACCESS
10684  D7F7     BRA 0x674
10686  D7E9     BRA 0x65A
641:               }
642:           
643:           #ifdef _VFPF_G
644:               /* Choose e or f mode from g mode */
645:               if (mode == 'g') {
10688  0EFC     MOVLW 0xFC
1068A  0061     MOVFFL PLUSW1, ltemp0
1068C  F38C     NOP
1068E  F501     NOP
10690  0E67     MOVLW 0x67
10692  1801     XORWF __ptext283, W, ACCESS
10694  A4D8     BTFSS 0xFD8, 2, ACCESS
10696  D02F     BRA 0x6F6
646:                   if (!(e < -4) && !((p - 1) < e)) {
10698  0EEE     MOVLW 0xEE
1069A  AEE3     BTFSS 0xFE3, 7, ACCESS
1069C  D00E     BRA 0x6BA
1069E  0EED     MOVLW 0xED
106A0  0061     MOVFFL PLUSW1, ltemp0
106A2  F38C     NOP
106A4  F501     NOP
106A6  0EFC     MOVLW 0xFC
106A8  5E01     SUBWF __ptext283, F, ACCESS
106AA  0EEE     MOVLW 0xEE
106AC  0061     MOVFFL PLUSW1, ltemp0
106AE  F38C     NOP
106B0  F501     NOP
106B2  0EFF     MOVLW 0xFF
106B4  5A01     SUBWFB __ptext283, F, ACCESS
106B6  A0D8     BTFSS 0xFD8, 0, ACCESS
106B8  D018     BRA 0x6EA
106BA  0EF1     MOVLW 0xF1
106BC  50E3     MOVF 0xFE3, W, ACCESS
106BE  0FFF     ADDLW 0xFF
106C0  6E0B     MOVWF 0xB, ACCESS
106C2  0EF2     MOVLW 0xF2
106C4  0061     MOVFFL PLUSW1, 0x50C
106C6  F38C     NOP
106C8  F50C     NOP
106CA  0EFF     MOVLW 0xFF
106CC  220C     ADDWFC 0xC, F, ACCESS
106CE  0EED     MOVLW 0xED
106D0  50E3     MOVF 0xFE3, W, ACCESS
106D2  5C0B     SUBWF 0xB, W, ACCESS
106D4  500C     MOVF 0xC, W, ACCESS
106D6  0A80     XORLW 0x80
106D8  6E01     MOVWF __ptext283, ACCESS
106DA  0EEE     MOVLW 0xEE
106DC  50E3     MOVF 0xFE3, W, ACCESS
106DE  0A80     XORLW 0x80
106E0  5801     SUBWFB __ptext283, W, ACCESS
106E2  A0D8     BTFSS 0xFD8, 0, ACCESS
106E4  D002     BRA 0x6EA
647:                       nmode = 'f';
106E6  0E66     MOVLW 0x66
106E8  D001     BRA 0x6EC
648:                   } else {
649:                       nmode = 'e';
106EA  0E65     MOVLW 0x65
106EC  6E0C     MOVWF 0xC, ACCESS
106EE  0EFD     MOVLW 0xFD
106F0  0061     MOVFFL 0x50C, PLUSW1
106F2  F430     NOP
106F4  F4E3     NOP
650:                   }
651:               }
652:           #endif
653:           
654:               /* Decimal places or significant digits */
655:               m = p;
106F6  0EF1     MOVLW 0xF1
106F8  0061     MOVFFL PLUSW1, ltemp0
106FA  F38C     NOP
106FC  F501     NOP
106FE  0EF5     MOVLW 0xF5
10700  0061     MOVFFL ltemp0, PLUSW1
10702  F404     NOP
10704  F4E3     NOP
10706  0EF2     MOVLW 0xF2
10708  0061     MOVFFL PLUSW1, ltemp0
1070A  F38C     NOP
1070C  F501     NOP
1070E  0EF6     MOVLW 0xF6
10710  0061     MOVFFL ltemp0, PLUSW1
10712  F404     NOP
10714  F4E3     NOP
656:           #ifdef _VFPF_G
657:               if (!(mode == 'g') || ((nmode == 'f') && (e < 0)))
10716  0EFC     MOVLW 0xFC
10718  0061     MOVFFL PLUSW1, ltemp0
1071A  F38C     NOP
1071C  F501     NOP
1071E  0E67     MOVLW 0x67
10720  1801     XORWF __ptext283, W, ACCESS
10722  A4D8     BTFSS 0xFD8, 2, ACCESS
10724  D00B     BRA 0x73C
10726  0EFD     MOVLW 0xFD
10728  0061     MOVFFL PLUSW1, ltemp0
1072A  F38C     NOP
1072C  F501     NOP
1072E  0E66     MOVLW 0x66
10730  1801     XORWF __ptext283, W, ACCESS
10732  A4D8     BTFSS 0xFD8, 2, ACCESS
10734  D014     BRA 0x75E
10736  0EEE     MOVLW 0xEE
10738  AEE3     BTFSS 0xFE3, 7, ACCESS
1073A  D011     BRA 0x75E
658:           #endif
659:           	{
660:                   ++m;
1073C  0EF5     MOVLW 0xF5
1073E  50E3     MOVF 0xFE3, W, ACCESS
10740  0F01     ADDLW 0x1
10742  6E01     MOVWF __ptext283, ACCESS
10744  0EF5     MOVLW 0xF5
10746  0061     MOVFFL ltemp0, PLUSW1
10748  F404     NOP
1074A  F4E3     NOP
1074C  6A01     CLRF __ptext283, ACCESS
1074E  0EF6     MOVLW 0xF6
10750  50E3     MOVF 0xFE3, W, ACCESS
10752  2001     ADDWFC __ptext283, W, ACCESS
10754  6E01     MOVWF __ptext283, ACCESS
10756  0EF6     MOVLW 0xF6
10758  0061     MOVFFL ltemp0, PLUSW1
1075A  F404     NOP
1075C  F4E3     NOP
661:               }
662:           
663:               /* Adjust starting exponent, string length for 'f' conversions */
664:           #if defined(_VFPF_F) || defined(_VFPF_G)
665:               if (nmode == 'f') {
1075E  0EFD     MOVLW 0xFD
10760  0061     MOVFFL PLUSW1, ltemp0
10762  F38C     NOP
10764  F501     NOP
10766  0E66     MOVLW 0x66
10768  1801     XORWF __ptext283, W, ACCESS
1076A  A4D8     BTFSS 0xFD8, 2, ACCESS
1076C  D03B     BRA 0x7E4
666:                   if (e < 0) {
1076E  0EEE     MOVLW 0xEE
10770  AEE3     BTFSS 0xFE3, 7, ACCESS
10772  D01C     BRA 0x7AC
667:                       u.f = 1.0;
10774  0E00     MOVLW 0x0
10776  6E09     MOVWF 0x9, ACCESS
10778  0E00     MOVLW 0x0
1077A  6E0A     MOVWF 0xA, ACCESS
1077C  0E80     MOVLW 0x80
1077E  6E0B     MOVWF 0xB, ACCESS
10780  0E3F     MOVLW 0x3F
10782  6E0C     MOVWF 0xC, ACCESS
10784  0ED5     MOVLW 0xD5
10786  0061     MOVFFL ltemp2, PLUSW1
10788  F424     NOP
1078A  F4E3     NOP
1078C  0ED6     MOVLW 0xD6
1078E  0061     MOVFFL ttemp3, PLUSW1
10790  F428     NOP
10792  F4E3     NOP
10794  0ED7     MOVLW 0xD7
10796  0061     MOVFFL wtemp5, PLUSW1
10798  F42C     NOP
1079A  F4E3     NOP
1079C  0ED8     MOVLW 0xD8
1079E  0061     MOVFFL 0x50C, PLUSW1
107A0  F430     NOP
107A2  F4E3     NOP
668:                       e = 0;
107A4  0EED     MOVLW 0xED
107A6  6AE3     CLRF 0xFE3, ACCESS
107A8  0EEE     MOVLW 0xEE
107AA  6AE3     CLRF 0xFE3, ACCESS
669:                   }
670:                   if (!(mode == 'g')) {
107AC  0EFC     MOVLW 0xFC
107AE  0061     MOVFFL PLUSW1, ltemp0
107B0  F38C     NOP
107B2  F501     NOP
107B4  0E67     MOVLW 0x67
107B6  1801     XORWF __ptext283, W, ACCESS
107B8  B4D8     BTFSC 0xFD8, 2, ACCESS
107BA  D014     BRA 0x7E4
671:                       m += e;
107BC  0EF5     MOVLW 0xF5
107BE  50E3     MOVF 0xFE3, W, ACCESS
107C0  6E01     MOVWF __ptext283, ACCESS
107C2  0EED     MOVLW 0xED
107C4  50E3     MOVF 0xFE3, W, ACCESS
107C6  2601     ADDWF __ptext283, F, ACCESS
107C8  0EF5     MOVLW 0xF5
107CA  0061     MOVFFL ltemp0, PLUSW1
107CC  F404     NOP
107CE  F4E3     NOP
107D0  0EF6     MOVLW 0xF6
107D2  50E3     MOVF 0xFE3, W, ACCESS
107D4  6E01     MOVWF __ptext283, ACCESS
107D6  0EEE     MOVLW 0xEE
107D8  50E3     MOVF 0xFE3, W, ACCESS
107DA  2201     ADDWFC __ptext283, F, ACCESS
107DC  0EF6     MOVLW 0xF6
107DE  0061     MOVFFL ltemp0, PLUSW1
107E0  F404     NOP
107E2  F4E3     NOP
672:                   }
673:               }
674:           #endif
675:           
676:               /* Go through the conversion once to get to the rounding step */
677:               i = 0;
107E4  0EEB     MOVLW 0xEB
107E6  6AE3     CLRF 0xFE3, ACCESS
107E8  0EEC     MOVLW 0xEC
107EA  6AE3     CLRF 0xFE3, ACCESS
678:               h = g.f;
107EC  0ED9     MOVLW 0xD9
107EE  0061     MOVFFL PLUSW1, ltemp2
107F0  F38C     NOP
107F2  F509     NOP
107F4  0EDA     MOVLW 0xDA
107F6  0061     MOVFFL PLUSW1, ttemp3
107F8  F38C     NOP
107FA  F50A     NOP
107FC  0EDB     MOVLW 0xDB
107FE  0061     MOVFFL PLUSW1, wtemp5
10800  F38C     NOP
10802  F50B     NOP
10804  0EDC     MOVLW 0xDC
10806  0061     MOVFFL PLUSW1, 0x50C
10808  F38C     NOP
1080A  F50C     NOP
1080C  0EE1     MOVLW 0xE1
1080E  0061     MOVFFL ltemp2, PLUSW1
10810  F424     NOP
10812  F4E3     NOP
10814  0EE2     MOVLW 0xE2
10816  0061     MOVFFL ttemp3, PLUSW1
10818  F428     NOP
1081A  F4E3     NOP
1081C  0EE3     MOVLW 0xE3
1081E  0061     MOVFFL wtemp5, PLUSW1
10820  F42C     NOP
10822  F4E3     NOP
10824  0EE4     MOVLW 0xE4
10826  0061     MOVFFL 0x50C, PLUSW1
10828  F430     NOP
1082A  F4E3     NOP
679:               ou = u;
1082C  0ED5     MOVLW 0xD5
1082E  0061     MOVFFL PLUSW1, ltemp2
10830  F38C     NOP
10832  F509     NOP
10834  0ED6     MOVLW 0xD6
10836  0061     MOVFFL PLUSW1, ttemp3
10838  F38C     NOP
1083A  F50A     NOP
1083C  0ED7     MOVLW 0xD7
1083E  0061     MOVFFL PLUSW1, wtemp5
10840  F38C     NOP
10842  F50B     NOP
10844  0ED8     MOVLW 0xD8
10846  0061     MOVFFL PLUSW1, 0x50C
10848  F38C     NOP
1084A  F50C     NOP
1084C  0EE5     MOVLW 0xE5
1084E  0061     MOVFFL ltemp2, PLUSW1
10850  F424     NOP
10852  F4E3     NOP
10854  0EE6     MOVLW 0xE6
10856  0061     MOVFFL ttemp3, PLUSW1
10858  F428     NOP
1085A  F4E3     NOP
1085C  0EE7     MOVLW 0xE7
1085E  0061     MOVFFL wtemp5, PLUSW1
10860  F42C     NOP
10862  F4E3     NOP
10864  0EE8     MOVLW 0xE8
10866  0061     MOVFFL 0x50C, PLUSW1
10868  F430     NOP
1086A  F4E3     NOP
680:               while (i < m) {
1086C  D0BA     BRA 0x9E2
109E2  50E1     MOVF 0xFE1, W, ACCESS
109E4  0FEB     ADDLW 0xEB
109E6  6ED9     MOVWF 0xFD9, ACCESS
109E8  50E2     MOVF 0xFE2, W, ACCESS
109EA  6EDA     MOVWF __end_of_UART2_tx_vect_isr, ACCESS
109EC  0EFF     MOVLW 0xFF
109EE  22DA     ADDWFC __end_of_UART2_tx_vect_isr, F, ACCESS
109F0  0EF5     MOVLW 0xF5
109F2  50E3     MOVF 0xFE3, W, ACCESS
109F4  5CDE     SUBWF 0xFDE, W, ACCESS
109F6  50DE     MOVF 0xFDE, W, ACCESS
109F8  0A80     XORLW 0x80
109FA  6E01     MOVWF __ptext283, ACCESS
109FC  0EF6     MOVLW 0xF6
109FE  50E3     MOVF 0xFE3, W, ACCESS
10A00  0A80     XORLW 0x80
10A02  5801     SUBWFB __ptext283, W, ACCESS
10A04  A0D8     BTFSS 0xFD8, 0, ACCESS
10A06  D733     BRA 0x86E
681:                   l = floor(h/u.f);
1086E  0ED5     MOVLW 0xD5
10870  C4E3     MOVFF PLUSW1, POSTINC1
10872  F4E6     NOP
10874  C4E3     MOVFF PLUSW1, POSTINC1
10876  F4E6     NOP
10878  C4E3     MOVFF PLUSW1, POSTINC1
1087A  F4E6     NOP
1087C  C4E3     MOVFF PLUSW1, POSTINC1
1087E  F4E6     NOP
10880  0EDD     MOVLW 0xDD
10882  C4E3     MOVFF PLUSW1, POSTINC1
10884  F4E6     NOP
10886  C4E3     MOVFF PLUSW1, POSTINC1
10888  F4E6     NOP
1088A  C4E3     MOVFF PLUSW1, POSTINC1
1088C  F4E6     NOP
1088E  C4E3     MOVFF PLUSW1, POSTINC1
10890  F4E6     NOP
10892  ECD2     CALL 0x187A4, 0
10894  F0C3     NOP
10896  0061     MOVFFL ltemp0, POSTINC1
10898  F404     NOP
1089A  F4E6     NOP
1089C  0061     MOVFFL ttemp5, POSTINC1
1089E  F408     NOP
108A0  F4E6     NOP
108A2  0061     MOVFFL wtemp1, POSTINC1
108A4  F40C     NOP
108A6  F4E6     NOP
108A8  0061     MOVFFL ttemp1, POSTINC1
108AA  F410     NOP
108AC  F4E6     NOP
108AE  ECA1     CALL 0x1A142, 0
108B0  F0D0     NOP
108B2  0EDD     MOVLW 0xDD
108B4  0061     MOVFFL ltemp0, PLUSW1
108B6  F404     NOP
108B8  F4E3     NOP
108BA  0EDE     MOVLW 0xDE
108BC  0061     MOVFFL ttemp5, PLUSW1
108BE  F408     NOP
108C0  F4E3     NOP
108C2  0EDF     MOVLW 0xDF
108C4  0061     MOVFFL wtemp1, PLUSW1
108C6  F40C     NOP
108C8  F4E3     NOP
108CA  0EE0     MOVLW 0xE0
108CC  0061     MOVFFL ttemp1, PLUSW1
108CE  F410     NOP
108D0  F4E3     NOP
682:                   d = (int)l;
108D2  0EDD     MOVLW 0xDD
108D4  C4E3     MOVFF PLUSW1, POSTINC1
108D6  F4E6     NOP
108D8  C4E3     MOVFF PLUSW1, POSTINC1
108DA  F4E6     NOP
108DC  C4E3     MOVFF PLUSW1, POSTINC1
108DE  F4E6     NOP
108E0  C4E3     MOVFF PLUSW1, POSTINC1
108E2  F4E6     NOP
108E4  ECF4     CALL 0x1D3E8, 0
108E6  F0E9     NOP
108E8  0061     MOVFFL ltemp0, wtemp5
108EA  F404     NOP
108EC  F50B     NOP
108EE  0061     MOVFFL ttemp5, 0x50C
108F0  F408     NOP
108F2  F50C     NOP
108F4  0EF3     MOVLW 0xF3
108F6  0061     MOVFFL wtemp5, PLUSW1
108F8  F42C     NOP
108FA  F4E3     NOP
108FC  0EF4     MOVLW 0xF4
108FE  0061     MOVFFL 0x50C, PLUSW1
10900  F430     NOP
10902  F4E3     NOP
683:                   h -= l*u.f;
10904  0EDD     MOVLW 0xDD
10906  C4E3     MOVFF PLUSW1, POSTINC1
10908  F4E6     NOP
1090A  C4E3     MOVFF PLUSW1, POSTINC1
1090C  F4E6     NOP
1090E  C4E3     MOVFF PLUSW1, POSTINC1
10910  F4E6     NOP
10912  C4E3     MOVFF PLUSW1, POSTINC1
10914  F4E6     NOP
10916  0ED1     MOVLW 0xD1
10918  C4E3     MOVFF PLUSW1, POSTINC1
1091A  F4E6     NOP
1091C  C4E3     MOVFF PLUSW1, POSTINC1
1091E  F4E6     NOP
10920  C4E3     MOVFF PLUSW1, POSTINC1
10922  F4E6     NOP
10924  C4E3     MOVFF PLUSW1, POSTINC1
10926  F4E6     NOP
10928  EC2F     CALL 0x1705E, 0
1092A  F0B8     NOP
1092C  0061     MOVFFL ltemp0, POSTINC1
1092E  F404     NOP
10930  F4E6     NOP
10932  0061     MOVFFL ttemp5, POSTINC1
10934  F408     NOP
10936  F4E6     NOP
10938  0061     MOVFFL wtemp1, POSTINC1
1093A  F40C     NOP
1093C  F4E6     NOP
1093E  0061     MOVFFL ttemp1, POSTINC1
10940  F410     NOP
10942  F4E6     NOP
10944  0EDD     MOVLW 0xDD
10946  C4E3     MOVFF PLUSW1, POSTINC1
10948  F4E6     NOP
1094A  C4E3     MOVFF PLUSW1, POSTINC1
1094C  F4E6     NOP
1094E  C4E3     MOVFF PLUSW1, POSTINC1
10950  F4E6     NOP
10952  C4E3     MOVFF PLUSW1, POSTINC1
10954  F4E6     NOP
10956  ECC0     CALL 0x1B80, 0
10958  F00D     NOP
1095A  0EE1     MOVLW 0xE1
1095C  0061     MOVFFL ltemp0, PLUSW1
1095E  F404     NOP
10960  F4E3     NOP
10962  0EE2     MOVLW 0xE2
10964  0061     MOVFFL ttemp5, PLUSW1
10966  F408     NOP
10968  F4E3     NOP
1096A  0EE3     MOVLW 0xE3
1096C  0061     MOVFFL wtemp1, PLUSW1
1096E  F40C     NOP
10970  F4E3     NOP
10972  0EE4     MOVLW 0xE4
10974  0061     MOVFFL ttemp1, PLUSW1
10976  F410     NOP
10978  F4E3     NOP
684:                   u.f = u.f/10.0;
1097A  0E00     MOVLW 0x0
1097C  6EE6     MOVWF 0xFE6, ACCESS
1097E  0E00     MOVLW 0x0
10980  6EE6     MOVWF 0xFE6, ACCESS
10982  0E20     MOVLW 0x20
10984  6EE6     MOVWF 0xFE6, ACCESS
10986  0E41     MOVLW 0x41
10988  6EE6     MOVWF 0xFE6, ACCESS
1098A  0ED1     MOVLW 0xD1
1098C  C4E3     MOVFF PLUSW1, POSTINC1
1098E  F4E6     NOP
10990  C4E3     MOVFF PLUSW1, POSTINC1
10992  F4E6     NOP
10994  C4E3     MOVFF PLUSW1, POSTINC1
10996  F4E6     NOP
10998  C4E3     MOVFF PLUSW1, POSTINC1
1099A  F4E6     NOP
1099C  ECD2     CALL 0x187A4, 0
1099E  F0C3     NOP
109A0  0ED5     MOVLW 0xD5
109A2  0061     MOVFFL ltemp0, PLUSW1
109A4  F404     NOP
109A6  F4E3     NOP
109A8  0ED6     MOVLW 0xD6
109AA  0061     MOVFFL ttemp5, PLUSW1
109AC  F408     NOP
109AE  F4E3     NOP
109B0  0ED7     MOVLW 0xD7
109B2  0061     MOVFFL wtemp1, PLUSW1
109B4  F40C     NOP
109B6  F4E3     NOP
109B8  0ED8     MOVLW 0xD8
109BA  0061     MOVFFL ttemp1, PLUSW1
109BC  F410     NOP
109BE  F4E3     NOP
685:                   ++i;
109C0  0EEB     MOVLW 0xEB
109C2  50E3     MOVF 0xFE3, W, ACCESS
109C4  0F01     ADDLW 0x1
109C6  6E01     MOVWF __ptext283, ACCESS
109C8  0EEB     MOVLW 0xEB
109CA  0061     MOVFFL ltemp0, PLUSW1
109CC  F404     NOP
109CE  F4E3     NOP
109D0  6A01     CLRF __ptext283, ACCESS
109D2  0EEC     MOVLW 0xEC
109D4  50E3     MOVF 0xFE3, W, ACCESS
109D6  2001     ADDWFC __ptext283, W, ACCESS
109D8  6E01     MOVWF __ptext283, ACCESS
109DA  0EEC     MOVLW 0xEC
109DC  0061     MOVFFL ltemp0, PLUSW1
109DE  F404     NOP
109E0  F4E3     NOP
686:               }
687:               
688:               /* Remainder >= halfway ? */
689:               l = u.f*5.0;
10A08  0E00     MOVLW 0x0
10A0A  6EE6     MOVWF 0xFE6, ACCESS
10A0C  0E00     MOVLW 0x0
10A0E  6EE6     MOVWF 0xFE6, ACCESS
10A10  0EA0     MOVLW 0xA0
10A12  6EE6     MOVWF 0xFE6, ACCESS
10A14  0E40     MOVLW 0x40
10A16  6EE6     MOVWF 0xFE6, ACCESS
10A18  0ED1     MOVLW 0xD1
10A1A  C4E3     MOVFF PLUSW1, POSTINC1
10A1C  F4E6     NOP
10A1E  C4E3     MOVFF PLUSW1, POSTINC1
10A20  F4E6     NOP
10A22  C4E3     MOVFF PLUSW1, POSTINC1
10A24  F4E6     NOP
10A26  C4E3     MOVFF PLUSW1, POSTINC1
10A28  F4E6     NOP
10A2A  EC2F     CALL 0x1705E, 0
10A2C  F0B8     NOP
10A2E  0EDD     MOVLW 0xDD
10A30  0061     MOVFFL ltemp0, PLUSW1
10A32  F404     NOP
10A34  F4E3     NOP
10A36  0EDE     MOVLW 0xDE
10A38  0061     MOVFFL ttemp5, PLUSW1
10A3A  F408     NOP
10A3C  F4E3     NOP
10A3E  0EDF     MOVLW 0xDF
10A40  0061     MOVFFL wtemp1, PLUSW1
10A42  F40C     NOP
10A44  F4E3     NOP
10A46  0EE0     MOVLW 0xE0
10A48  0061     MOVFFL ttemp1, PLUSW1
10A4A  F410     NOP
10A4C  F4E3     NOP
690:               if (h < l) {
10A4E  0EDD     MOVLW 0xDD
10A50  C4E3     MOVFF PLUSW1, POSTINC1
10A52  F4E6     NOP
10A54  C4E3     MOVFF PLUSW1, POSTINC1
10A56  F4E6     NOP
10A58  C4E3     MOVFF PLUSW1, POSTINC1
10A5A  F4E6     NOP
10A5C  C4E3     MOVFF PLUSW1, POSTINC1
10A5E  F4E6     NOP
10A60  0EDD     MOVLW 0xDD
10A62  C4E3     MOVFF PLUSW1, POSTINC1
10A64  F4E6     NOP
10A66  C4E3     MOVFF PLUSW1, POSTINC1
10A68  F4E6     NOP
10A6A  C4E3     MOVFF PLUSW1, POSTINC1
10A6C  F4E6     NOP
10A6E  C4E3     MOVFF PLUSW1, POSTINC1
10A70  F4E6     NOP
10A72  EC60     CALL 0x1D6C0, 0
10A74  F0EB     NOP
10A76  A001     BTFSS __ptext283, 0, ACCESS
691:                   l = 0.0;
10A78  D019     BRA 0xAAC
692:               } else {
693:                   /* On tie choose even number */
694:                   if ((h == l) && !(d % 2)) {
10A7A  0EDD     MOVLW 0xDD
10A7C  C4E3     MOVFF PLUSW1, POSTINC1
10A7E  F4E6     NOP
10A80  C4E3     MOVFF PLUSW1, POSTINC1
10A82  F4E6     NOP
10A84  C4E3     MOVFF PLUSW1, POSTINC1
10A86  F4E6     NOP
10A88  C4E3     MOVFF PLUSW1, POSTINC1
10A8A  F4E6     NOP
10A8C  0EDD     MOVLW 0xDD
10A8E  C4E3     MOVFF PLUSW1, POSTINC1
10A90  F4E6     NOP
10A92  C4E3     MOVFF PLUSW1, POSTINC1
10A94  F4E6     NOP
10A96  C4E3     MOVFF PLUSW1, POSTINC1
10A98  F4E6     NOP
10A9A  C4E3     MOVFF PLUSW1, POSTINC1
10A9C  F4E6     NOP
10A9E  EC95     CALL 0x1F92A, 0
10AA0  F0FC     NOP
10AA2  A001     BTFSS __ptext283, 0, ACCESS
10AA4  D01B     BRA 0xADC
10AA6  0EF3     MOVLW 0xF3
10AA8  B0E3     BTFSC 0xFE3, 0, ACCESS
10AAA  D018     BRA 0xADC
695:                       l = 0.0;
10AAC  0E00     MOVLW 0x0
10AAE  6E09     MOVWF 0x9, ACCESS
10AB0  0E00     MOVLW 0x0
10AB2  6E0A     MOVWF 0xA, ACCESS
10AB4  0E00     MOVLW 0x0
10AB6  6E0B     MOVWF 0xB, ACCESS
10AB8  0E00     MOVLW 0x0
10ABA  6E0C     MOVWF 0xC, ACCESS
10ABC  0EDD     MOVLW 0xDD
10ABE  0061     MOVFFL ltemp2, PLUSW1
10AC0  F424     NOP
10AC2  F4E3     NOP
10AC4  0EDE     MOVLW 0xDE
10AC6  0061     MOVFFL ttemp3, PLUSW1
10AC8  F428     NOP
10ACA  F4E3     NOP
10ACC  0EDF     MOVLW 0xDF
10ACE  0061     MOVFFL wtemp5, PLUSW1
10AD0  F42C     NOP
10AD2  F4E3     NOP
10AD4  0EE0     MOVLW 0xE0
10AD6  0061     MOVFFL 0x50C, PLUSW1
10AD8  F430     NOP
10ADA  F4E3     NOP
696:                   }
697:               }
698:           
699:               /* Round */
700:               h = g.f + l;
10ADC  0EDD     MOVLW 0xDD
10ADE  C4E3     MOVFF PLUSW1, POSTINC1
10AE0  F4E6     NOP
10AE2  C4E3     MOVFF PLUSW1, POSTINC1
10AE4  F4E6     NOP
10AE6  C4E3     MOVFF PLUSW1, POSTINC1
10AE8  F4E6     NOP
10AEA  C4E3     MOVFF PLUSW1, POSTINC1
10AEC  F4E6     NOP
10AEE  0ED5     MOVLW 0xD5
10AF0  C4E3     MOVFF PLUSW1, POSTINC1
10AF2  F4E6     NOP
10AF4  C4E3     MOVFF PLUSW1, POSTINC1
10AF6  F4E6     NOP
10AF8  C4E3     MOVFF PLUSW1, POSTINC1
10AFA  F4E6     NOP
10AFC  C4E3     MOVFF PLUSW1, POSTINC1
10AFE  F4E6     NOP
10B00  EC30     CALL 0x17860, 0
10B02  F0BC     NOP
10B04  0EE1     MOVLW 0xE1
10B06  0061     MOVFFL ltemp0, PLUSW1
10B08  F404     NOP
10B0A  F4E3     NOP
10B0C  0EE2     MOVLW 0xE2
10B0E  0061     MOVFFL ttemp5, PLUSW1
10B10  F408     NOP
10B12  F4E3     NOP
10B14  0EE3     MOVLW 0xE3
10B16  0061     MOVFFL wtemp1, PLUSW1
10B18  F40C     NOP
10B1A  F4E3     NOP
10B1C  0EE4     MOVLW 0xE4
10B1E  0061     MOVFFL ttemp1, PLUSW1
10B20  F410     NOP
10B22  F4E3     NOP
701:               /* Has rounding increased the power above 10^0? */
702:           	if (h >= (ou.f*10.0)) {
10B24  0E00     MOVLW 0x0
10B26  6EE6     MOVWF 0xFE6, ACCESS
10B28  0E00     MOVLW 0x0
10B2A  6EE6     MOVWF 0xFE6, ACCESS
10B2C  0E20     MOVLW 0x20
10B2E  6EE6     MOVWF 0xFE6, ACCESS
10B30  0E41     MOVLW 0x41
10B32  6EE6     MOVWF 0xFE6, ACCESS
10B34  0EE1     MOVLW 0xE1
10B36  C4E3     MOVFF PLUSW1, POSTINC1
10B38  F4E6     NOP
10B3A  C4E3     MOVFF PLUSW1, POSTINC1
10B3C  F4E6     NOP
10B3E  C4E3     MOVFF PLUSW1, POSTINC1
10B40  F4E6     NOP
10B42  C4E3     MOVFF PLUSW1, POSTINC1
10B44  F4E6     NOP
10B46  EC2F     CALL 0x1705E, 0
10B48  F0B8     NOP
10B4A  0061     MOVFFL ltemp0, POSTINC1
10B4C  F404     NOP
10B4E  F4E6     NOP
10B50  0061     MOVFFL ttemp5, POSTINC1
10B52  F408     NOP
10B54  F4E6     NOP
10B56  0061     MOVFFL wtemp1, POSTINC1
10B58  F40C     NOP
10B5A  F4E6     NOP
10B5C  0061     MOVFFL ttemp1, POSTINC1
10B5E  F410     NOP
10B60  F4E6     NOP
10B62  0EDD     MOVLW 0xDD
10B64  C4E3     MOVFF PLUSW1, POSTINC1
10B66  F4E6     NOP
10B68  C4E3     MOVFF PLUSW1, POSTINC1
10B6A  F4E6     NOP
10B6C  C4E3     MOVFF PLUSW1, POSTINC1
10B6E  F4E6     NOP
10B70  C4E3     MOVFF PLUSW1, POSTINC1
10B72  F4E6     NOP
10B74  EC60     CALL 0x1D6C0, 0
10B76  F0EB     NOP
10B78  A001     BTFSS __ptext283, 0, ACCESS
10B7A  D04D     BRA 0xC16
703:           		e++;
10B7C  0EED     MOVLW 0xED
10B7E  50E3     MOVF 0xFE3, W, ACCESS
10B80  0F01     ADDLW 0x1
10B82  6E01     MOVWF __ptext283, ACCESS
10B84  0EED     MOVLW 0xED
10B86  0061     MOVFFL ltemp0, PLUSW1
10B88  F404     NOP
10B8A  F4E3     NOP
10B8C  6A01     CLRF __ptext283, ACCESS
10B8E  0EEE     MOVLW 0xEE
10B90  50E3     MOVF 0xFE3, W, ACCESS
10B92  2001     ADDWFC __ptext283, W, ACCESS
10B94  6E01     MOVWF __ptext283, ACCESS
10B96  0EEE     MOVLW 0xEE
10B98  0061     MOVFFL ltemp0, PLUSW1
10B9A  F404     NOP
10B9C  F4E3     NOP
704:           		ou.f *= 10.0;
10B9E  0E00     MOVLW 0x0
10BA0  6EE6     MOVWF 0xFE6, ACCESS
10BA2  0E00     MOVLW 0x0
10BA4  6EE6     MOVWF 0xFE6, ACCESS
10BA6  0E20     MOVLW 0x20
10BA8  6EE6     MOVWF 0xFE6, ACCESS
10BAA  0E41     MOVLW 0x41
10BAC  6EE6     MOVWF 0xFE6, ACCESS
10BAE  0EE1     MOVLW 0xE1
10BB0  C4E3     MOVFF PLUSW1, POSTINC1
10BB2  F4E6     NOP
10BB4  C4E3     MOVFF PLUSW1, POSTINC1
10BB6  F4E6     NOP
10BB8  C4E3     MOVFF PLUSW1, POSTINC1
10BBA  F4E6     NOP
10BBC  C4E3     MOVFF PLUSW1, POSTINC1
10BBE  F4E6     NOP
10BC0  EC2F     CALL 0x1705E, 0
10BC2  F0B8     NOP
10BC4  0EE5     MOVLW 0xE5
10BC6  0061     MOVFFL ltemp0, PLUSW1
10BC8  F404     NOP
10BCA  F4E3     NOP
10BCC  0EE6     MOVLW 0xE6
10BCE  0061     MOVFFL ttemp5, PLUSW1
10BD0  F408     NOP
10BD2  F4E3     NOP
10BD4  0EE7     MOVLW 0xE7
10BD6  0061     MOVFFL wtemp1, PLUSW1
10BD8  F40C     NOP
10BDA  F4E3     NOP
10BDC  0EE8     MOVLW 0xE8
10BDE  0061     MOVFFL ttemp1, PLUSW1
10BE0  F410     NOP
10BE2  F4E3     NOP
705:           #if defined(_VFPF_F) || defined(_VFPF_G)
706:           		if (nmode == 'f') {
10BE4  0EFD     MOVLW 0xFD
10BE6  0061     MOVFFL PLUSW1, ltemp0
10BE8  F38C     NOP
10BEA  F501     NOP
10BEC  0E66     MOVLW 0x66
10BEE  1801     XORWF __ptext283, W, ACCESS
10BF0  A4D8     BTFSS 0xFD8, 2, ACCESS
10BF2  D011     BRA 0xC16
707:           			// the increase in power will only affect the number of digits in 'f' mode
708:           			m++;
10BF4  0EF5     MOVLW 0xF5
10BF6  50E3     MOVF 0xFE3, W, ACCESS
10BF8  0F01     ADDLW 0x1
10BFA  6E01     MOVWF __ptext283, ACCESS
10BFC  0EF5     MOVLW 0xF5
10BFE  0061     MOVFFL ltemp0, PLUSW1
10C00  F404     NOP
10C02  F4E3     NOP
10C04  6A01     CLRF __ptext283, ACCESS
10C06  0EF6     MOVLW 0xF6
10C08  50E3     MOVF 0xFE3, W, ACCESS
10C0A  2001     ADDWFC __ptext283, W, ACCESS
10C0C  6E01     MOVWF __ptext283, ACCESS
10C0E  0EF6     MOVLW 0xF6
10C10  0061     MOVFFL ltemp0, PLUSW1
10C12  F404     NOP
10C14  F4E3     NOP
709:           		}
710:           #endif
711:           	}
712:               
713:               /* Convert again, after rounding */
714:               u = ou;
10C16  0EE5     MOVLW 0xE5
10C18  0061     MOVFFL PLUSW1, ltemp2
10C1A  F38C     NOP
10C1C  F509     NOP
10C1E  0EE6     MOVLW 0xE6
10C20  0061     MOVFFL PLUSW1, ttemp3
10C22  F38C     NOP
10C24  F50A     NOP
10C26  0EE7     MOVLW 0xE7
10C28  0061     MOVFFL PLUSW1, wtemp5
10C2A  F38C     NOP
10C2C  F50B     NOP
10C2E  0EE8     MOVLW 0xE8
10C30  0061     MOVFFL PLUSW1, 0x50C
10C32  F38C     NOP
10C34  F50C     NOP
10C36  0ED5     MOVLW 0xD5
10C38  0061     MOVFFL ltemp2, PLUSW1
10C3A  F424     NOP
10C3C  F4E3     NOP
10C3E  0ED6     MOVLW 0xD6
10C40  0061     MOVFFL ttemp3, PLUSW1
10C42  F428     NOP
10C44  F4E3     NOP
10C46  0ED7     MOVLW 0xD7
10C48  0061     MOVFFL wtemp5, PLUSW1
10C4A  F42C     NOP
10C4C  F4E3     NOP
10C4E  0ED8     MOVLW 0xD8
10C50  0061     MOVFFL 0x50C, PLUSW1
10C52  F430     NOP
10C54  F4E3     NOP
715:           #if defined(_VFPF_G) || defined(_VFPF_E)
716:               ne = (nmode == 'e') ? 0 : e;
10C56  0EFD     MOVLW 0xFD
10C58  0061     MOVFFL PLUSW1, ltemp0
10C5A  F38C     NOP
10C5C  F501     NOP
10C5E  0E65     MOVLW 0x65
10C60  1801     XORWF __ptext283, W, ACCESS
10C62  B4D8     BTFSC 0xFD8, 2, ACCESS
10C64  D011     BRA 0xC88
10C66  0EED     MOVLW 0xED
10C68  0061     MOVFFL PLUSW1, ltemp0
10C6A  F38C     NOP
10C6C  F501     NOP
10C6E  0EF7     MOVLW 0xF7
10C70  0061     MOVFFL ltemp0, PLUSW1
10C72  F404     NOP
10C74  F4E3     NOP
10C76  0EEE     MOVLW 0xEE
10C78  0061     MOVFFL PLUSW1, ltemp0
10C7A  F38C     NOP
10C7C  F501     NOP
10C7E  0EF8     MOVLW 0xF8
10C80  0061     MOVFFL ltemp0, PLUSW1
10C82  F404     NOP
10C84  F4E3     NOP
10C86  D004     BRA 0xC90
10C88  0EF7     MOVLW 0xF7
10C8A  6AE3     CLRF 0xFE3, ACCESS
10C8C  0EF8     MOVLW 0xF8
10C8E  6AE3     CLRF 0xFE3, ACCESS
717:           #else
718:           	ne = e;
719:           #endif
720:               pp = 0;
10C90  0EFE     MOVLW 0xFE
10C92  6AE3     CLRF 0xFE3, ACCESS
721:               t = 0;
10C94  0EF9     MOVLW 0xF9
10C96  6AE3     CLRF 0xFE3, ACCESS
10C98  0EFA     MOVLW 0xFA
10C9A  6AE3     CLRF 0xFE3, ACCESS
722:               i = 0;
10C9C  0EEB     MOVLW 0xEB
10C9E  6AE3     CLRF 0xFE3, ACCESS
10CA0  0EEC     MOVLW 0xEC
10CA2  6AE3     CLRF 0xFE3, ACCESS
723:               while ((i < m) && (n < (DBLEN - EXPLEN))) {
10CA4  D1AA     BRA 0xFFA
10FFA  50E1     MOVF 0xFE1, W, ACCESS
10FFC  0FEB     ADDLW 0xEB
10FFE  6ED9     MOVWF 0xFD9, ACCESS
11000  50E2     MOVF 0xFE2, W, ACCESS
11002  6EDA     MOVWF __end_of_UART2_tx_vect_isr, ACCESS
11004  0EFF     MOVLW 0xFF
11006  22DA     ADDWFC __end_of_UART2_tx_vect_isr, F, ACCESS
11008  0EF5     MOVLW 0xF5
1100A  50E3     MOVF 0xFE3, W, ACCESS
1100C  5CDE     SUBWF 0xFDE, W, ACCESS
1100E  50DE     MOVF 0xFDE, W, ACCESS
11010  0A80     XORLW 0x80
11012  6E01     MOVWF __ptext283, ACCESS
11014  0EF6     MOVLW 0xF6
11016  50E3     MOVF 0xFE3, W, ACCESS
11018  0A80     XORLW 0x80
1101A  5801     SUBWFB __ptext283, W, ACCESS
1101C  B0D8     BTFSC 0xFD8, 0, ACCESS
1101E  D00E     BRA 0x103C
11020  0EEA     MOVLW 0xEA
11022  BEE3     BTFSC 0xFE3, 7, ACCESS
11024  D640     BRA 0xCA6
11026  0EEA     MOVLW 0xEA
11028  50E3     MOVF 0xFE3, W, ACCESS
1102A  E108     BNZ 0x103C
1102C  0EE9     MOVLW 0xE9
1102E  0061     MOVFFL PLUSW1, ltemp0
11030  F38C     NOP
11032  F501     NOP
11034  0E4B     MOVLW 0x4B
11036  5E01     SUBWF __ptext283, F, ACCESS
11038  A0D8     BTFSS 0xFD8, 0, ACCESS
1103A  D635     BRA 0xCA6
724:                   l = floor(h/u.f);
10CA6  0ED5     MOVLW 0xD5
10CA8  C4E3     MOVFF PLUSW1, POSTINC1
10CAA  F4E6     NOP
10CAC  C4E3     MOVFF PLUSW1, POSTINC1
10CAE  F4E6     NOP
10CB0  C4E3     MOVFF PLUSW1, POSTINC1
10CB2  F4E6     NOP
10CB4  C4E3     MOVFF PLUSW1, POSTINC1
10CB6  F4E6     NOP
10CB8  0EDD     MOVLW 0xDD
10CBA  C4E3     MOVFF PLUSW1, POSTINC1
10CBC  F4E6     NOP
10CBE  C4E3     MOVFF PLUSW1, POSTINC1
10CC0  F4E6     NOP
10CC2  C4E3     MOVFF PLUSW1, POSTINC1
10CC4  F4E6     NOP
10CC6  C4E3     MOVFF PLUSW1, POSTINC1
10CC8  F4E6     NOP
10CCA  ECD2     CALL 0x187A4, 0
10CCC  F0C3     NOP
10CCE  0061     MOVFFL ltemp0, POSTINC1
10CD0  F404     NOP
10CD2  F4E6     NOP
10CD4  0061     MOVFFL ttemp5, POSTINC1
10CD6  F408     NOP
10CD8  F4E6     NOP
10CDA  0061     MOVFFL wtemp1, POSTINC1
10CDC  F40C     NOP
10CDE  F4E6     NOP
10CE0  0061     MOVFFL ttemp1, POSTINC1
10CE2  F410     NOP
10CE4  F4E6     NOP
10CE6  ECA1     CALL 0x1A142, 0
10CE8  F0D0     NOP
10CEA  0EDD     MOVLW 0xDD
10CEC  0061     MOVFFL ltemp0, PLUSW1
10CEE  F404     NOP
10CF0  F4E3     NOP
10CF2  0EDE     MOVLW 0xDE
10CF4  0061     MOVFFL ttemp5, PLUSW1
10CF6  F408     NOP
10CF8  F4E3     NOP
10CFA  0EDF     MOVLW 0xDF
10CFC  0061     MOVFFL wtemp1, PLUSW1
10CFE  F40C     NOP
10D00  F4E3     NOP
10D02  0EE0     MOVLW 0xE0
10D04  0061     MOVFFL ttemp1, PLUSW1
10D06  F410     NOP
10D08  F4E3     NOP
725:                   d = (int)l > 9 ? 9 : (int)l;
10D0A  0EDD     MOVLW 0xDD
10D0C  C4E3     MOVFF PLUSW1, POSTINC1
10D0E  F4E6     NOP
10D10  C4E3     MOVFF PLUSW1, POSTINC1
10D12  F4E6     NOP
10D14  C4E3     MOVFF PLUSW1, POSTINC1
10D16  F4E6     NOP
10D18  C4E3     MOVFF PLUSW1, POSTINC1
10D1A  F4E6     NOP
10D1C  ECF4     CALL 0x1D3E8, 0
10D1E  F0E9     NOP
10D20  0061     MOVFFL ltemp0, wtemp5
10D22  F404     NOP
10D24  F50B     NOP
10D26  0061     MOVFFL ttemp5, 0x50C
10D28  F408     NOP
10D2A  F50C     NOP
10D2C  BE0C     BTFSC 0xC, 7, ACCESS
10D2E  D006     BRA 0xD3C
10D30  500C     MOVF 0xC, W, ACCESS
10D32  E116     BNZ 0xD60
10D34  0E0A     MOVLW 0xA
10D36  5C0B     SUBWF 0xB, W, ACCESS
10D38  B0D8     BTFSC 0xFD8, 0, ACCESS
10D3A  D012     BRA 0xD60
10D3C  0EDD     MOVLW 0xDD
10D3E  C4E3     MOVFF PLUSW1, POSTINC1
10D40  F4E6     NOP
10D42  C4E3     MOVFF PLUSW1, POSTINC1
10D44  F4E6     NOP
10D46  C4E3     MOVFF PLUSW1, POSTINC1
10D48  F4E6     NOP
10D4A  C4E3     MOVFF PLUSW1, POSTINC1
10D4C  F4E6     NOP
10D4E  ECF4     CALL 0x1D3E8, 0
10D50  F0E9     NOP
10D52  0061     MOVFFL ltemp0, wtemp5
10D54  F404     NOP
10D56  F50B     NOP
10D58  0061     MOVFFL ttemp5, 0x50C
10D5A  F408     NOP
10D5C  F50C     NOP
10D5E  D004     BRA 0xD68
10D60  0E09     MOVLW 0x9
10D62  6E0B     MOVWF 0xB, ACCESS
10D64  0E00     MOVLW 0x0
10D66  6E0C     MOVWF 0xC, ACCESS
10D68  0EF3     MOVLW 0xF3
10D6A  0061     MOVFFL wtemp5, PLUSW1
10D6C  F42C     NOP
10D6E  F4E3     NOP
10D70  0EF4     MOVLW 0xF4
10D72  0061     MOVFFL 0x50C, PLUSW1
10D74  F430     NOP
10D76  F4E3     NOP
726:           #ifdef _VFPF_G
727:                   if (!d && (mode == 'g') && (ne < 0)
10D78  0EF3     MOVLW 0xF3
10D7A  0061     MOVFFL PLUSW1, ltemp0
10D7C  F38C     NOP
10D7E  F501     NOP
10D80  0EF4     MOVLW 0xF4
10D82  50E3     MOVF 0xFE3, W, ACCESS
10D84  1001     IORWF __ptext283, W, ACCESS
10D86  A4D8     BTFSS 0xFD8, 2, ACCESS
10D88  D01E     BRA 0xDC6
10D8A  0EFC     MOVLW 0xFC
10D8C  0061     MOVFFL PLUSW1, ltemp0
10D8E  F38C     NOP
10D90  F501     NOP
10D92  0E67     MOVLW 0x67
10D94  1801     XORWF __ptext283, W, ACCESS
10D96  A4D8     BTFSS 0xFD8, 2, ACCESS
10D98  D016     BRA 0xDC6
10D9A  0EF8     MOVLW 0xF8
10D9C  BEE3     BTFSC 0xFE3, 7, ACCESS
10D9E  B827     BTFSC 0x27, 4, ACCESS
10DA0  D012     BRA 0xDC6
728:           #ifdef _VFPF_ALTERN
729:           				&& !(flags & POUND_FLAG)
730:           #endif
731:           				) {
732:                       ++t;
10DA2  0EF9     MOVLW 0xF9
10DA4  50E3     MOVF 0xFE3, W, ACCESS
10DA6  0F01     ADDLW 0x1
10DA8  6E01     MOVWF __ptext283, ACCESS
10DAA  0EF9     MOVLW 0xF9
10DAC  0061     MOVFFL ltemp0, PLUSW1
10DAE  F404     NOP
10DB0  F4E3     NOP
10DB2  6A01     CLRF __ptext283, ACCESS
10DB4  0EFA     MOVLW 0xFA
10DB6  50E3     MOVF 0xFE3, W, ACCESS
10DB8  2001     ADDWFC __ptext283, W, ACCESS
10DBA  6E01     MOVWF __ptext283, ACCESS
10DBC  0EFA     MOVLW 0xFA
10DBE  0061     MOVFFL ltemp0, PLUSW1
10DC0  F404     NOP
10DC2  F4E3     NOP
733:                   }
10DC4  D0A1     BRA 0xF08
734:           		else
735:           #endif
736:           		{
737:                       if (!pp && (ne < 0)) {
10DC6  0EFE     MOVLW 0xFE
10DC8  50E3     MOVF 0xFE3, W, ACCESS
10DCA  A4D8     BTFSS 0xFD8, 2, ACCESS
10DCC  D067     BRA 0xE9C
10DCE  0EF8     MOVLW 0xF8
10DD0  AEE3     BTFSS 0xFE3, 7, ACCESS
10DD2  D064     BRA 0xE9C
738:                           dbuf[n++] = '.';
10DD4  0EE9     MOVLW 0xE9
10DD6  0061     MOVFFL PLUSW1, wtemp5
10DD8  F38C     NOP
10DDA  F50B     NOP
10DDC  0EEA     MOVLW 0xEA
10DDE  0061     MOVFFL PLUSW1, 0x50C
10DE0  F38C     NOP
10DE2  F50C     NOP
10DE4  0EA5     MOVLW 0xA5
10DE6  240B     ADDWF 0xB, W, ACCESS
10DE8  6ED9     MOVWF 0xFD9, ACCESS
10DEA  0E08     MOVLW 0x8
10DEC  200C     ADDWFC 0xC, W, ACCESS
10DEE  6EDA     MOVWF __end_of_UART2_tx_vect_isr, ACCESS
10DF0  0E2E     MOVLW 0x2E
10DF2  6EDF     MOVWF 0xFDF, ACCESS
10DF4  0EE9     MOVLW 0xE9
10DF6  50E3     MOVF 0xFE3, W, ACCESS
10DF8  0F01     ADDLW 0x1
10DFA  6E01     MOVWF __ptext283, ACCESS
10DFC  0EE9     MOVLW 0xE9
10DFE  0061     MOVFFL ltemp0, PLUSW1
10E00  F404     NOP
10E02  F4E3     NOP
10E04  6A01     CLRF __ptext283, ACCESS
10E06  0EEA     MOVLW 0xEA
10E08  50E3     MOVF 0xFE3, W, ACCESS
10E0A  2001     ADDWFC __ptext283, W, ACCESS
10E0C  6E01     MOVWF __ptext283, ACCESS
10E0E  0EEA     MOVLW 0xEA
10E10  0061     MOVFFL ltemp0, PLUSW1
10E12  F404     NOP
10E14  F4E3     NOP
739:                           --w;
10E16  50E1     MOVF 0xFE1, W, ACCESS
10E18  0FEF     ADDLW 0xEF
10E1A  6ED9     MOVWF 0xFD9, ACCESS
10E1C  50E2     MOVF 0xFE2, W, ACCESS
10E1E  6EDA     MOVWF __end_of_UART2_tx_vect_isr, ACCESS
10E20  0EFF     MOVLW 0xFF
10E22  22DA     ADDWFC __end_of_UART2_tx_vect_isr, F, ACCESS
10E24  06DE     DECF 0xFDE, F, ACCESS
10E26  0E00     MOVLW 0x0
10E28  5ADD     SUBWFB 0xFDD, F, ACCESS
740:                           pp = 1;
10E2A  0EFE     MOVLW 0xFE
10E2C  6AE3     CLRF 0xFE3, ACCESS
10E2E  2AE3     INCF 0xFE3, F, ACCESS
10E30  D035     BRA 0xE9C
741:                       }
742:                       while (t) {
10E9C  0EF9     MOVLW 0xF9
10E9E  0061     MOVFFL PLUSW1, ltemp0
10EA0  F38C     NOP
10EA2  F501     NOP
10EA4  0EFA     MOVLW 0xFA
10EA6  50E3     MOVF 0xFE3, W, ACCESS
10EA8  1001     IORWF __ptext283, W, ACCESS
10EAA  A4D8     BTFSS 0xFD8, 2, ACCESS
10EAC  D7C2     BRA 0xE32
743:                           dbuf[n++] = '0';
10E32  0EE9     MOVLW 0xE9
10E34  0061     MOVFFL PLUSW1, wtemp5
10E36  F38C     NOP
10E38  F50B     NOP
10E3A  0EEA     MOVLW 0xEA
10E3C  0061     MOVFFL PLUSW1, 0x50C
10E3E  F38C     NOP
10E40  F50C     NOP
10E42  0EA5     MOVLW 0xA5
10E44  240B     ADDWF 0xB, W, ACCESS
10E46  6ED9     MOVWF 0xFD9, ACCESS
10E48  0E08     MOVLW 0x8
10E4A  200C     ADDWFC 0xC, W, ACCESS
10E4C  6EDA     MOVWF __end_of_UART2_tx_vect_isr, ACCESS
10E4E  0E30     MOVLW 0x30
10E50  6EDF     MOVWF 0xFDF, ACCESS
10E52  0EE9     MOVLW 0xE9
10E54  50E3     MOVF 0xFE3, W, ACCESS
10E56  0F01     ADDLW 0x1
10E58  6E01     MOVWF __ptext283, ACCESS
10E5A  0EE9     MOVLW 0xE9
10E5C  0061     MOVFFL ltemp0, PLUSW1
10E5E  F404     NOP
10E60  F4E3     NOP
10E62  6A01     CLRF __ptext283, ACCESS
10E64  0EEA     MOVLW 0xEA
10E66  50E3     MOVF 0xFE3, W, ACCESS
10E68  2001     ADDWFC __ptext283, W, ACCESS
10E6A  6E01     MOVWF __ptext283, ACCESS
10E6C  0EEA     MOVLW 0xEA
10E6E  0061     MOVFFL ltemp0, PLUSW1
10E70  F404     NOP
10E72  F4E3     NOP
744:                           --w;
10E74  50E1     MOVF 0xFE1, W, ACCESS
10E76  0FEF     ADDLW 0xEF
10E78  6ED9     MOVWF 0xFD9, ACCESS
10E7A  50E2     MOVF 0xFE2, W, ACCESS
10E7C  6EDA     MOVWF __end_of_UART2_tx_vect_isr, ACCESS
10E7E  0EFF     MOVLW 0xFF
10E80  22DA     ADDWFC __end_of_UART2_tx_vect_isr, F, ACCESS
10E82  06DE     DECF 0xFDE, F, ACCESS
10E84  0E00     MOVLW 0x0
10E86  5ADD     SUBWFB 0xFDD, F, ACCESS
745:                           --t;
10E88  50E1     MOVF 0xFE1, W, ACCESS
10E8A  0FF9     ADDLW 0xF9
10E8C  6ED9     MOVWF 0xFD9, ACCESS
10E8E  50E2     MOVF 0xFE2, W, ACCESS
10E90  6EDA     MOVWF __end_of_UART2_tx_vect_isr, ACCESS
10E92  0EFF     MOVLW 0xFF
10E94  22DA     ADDWFC __end_of_UART2_tx_vect_isr, F, ACCESS
10E96  06DE     DECF 0xFDE, F, ACCESS
10E98  0E00     MOVLW 0x0
10E9A  5ADD     SUBWFB 0xFDD, F, ACCESS
746:                       }
747:                       dbuf[n++] = (char)((int)'0' + d);
10EAE  0EE9     MOVLW 0xE9
10EB0  0061     MOVFFL PLUSW1, wtemp5
10EB2  F38C     NOP
10EB4  F50B     NOP
10EB6  0EEA     MOVLW 0xEA
10EB8  0061     MOVFFL PLUSW1, 0x50C
10EBA  F38C     NOP
10EBC  F50C     NOP
10EBE  0EA5     MOVLW 0xA5
10EC0  240B     ADDWF 0xB, W, ACCESS
10EC2  6ED9     MOVWF 0xFD9, ACCESS
10EC4  0E08     MOVLW 0x8
10EC6  200C     ADDWFC 0xC, W, ACCESS
10EC8  6EDA     MOVWF __end_of_UART2_tx_vect_isr, ACCESS
10ECA  0EF3     MOVLW 0xF3
10ECC  50E3     MOVF 0xFE3, W, ACCESS
10ECE  0F30     ADDLW 0x30
10ED0  6EDF     MOVWF 0xFDF, ACCESS
10ED2  0EE9     MOVLW 0xE9
10ED4  50E3     MOVF 0xFE3, W, ACCESS
10ED6  0F01     ADDLW 0x1
10ED8  6E01     MOVWF __ptext283, ACCESS
10EDA  0EE9     MOVLW 0xE9
10EDC  0061     MOVFFL ltemp0, PLUSW1
10EDE  F404     NOP
10EE0  F4E3     NOP
10EE2  6A01     CLRF __ptext283, ACCESS
10EE4  0EEA     MOVLW 0xEA
10EE6  50E3     MOVF 0xFE3, W, ACCESS
10EE8  2001     ADDWFC __ptext283, W, ACCESS
10EEA  6E01     MOVWF __ptext283, ACCESS
10EEC  0EEA     MOVLW 0xEA
10EEE  0061     MOVFFL ltemp0, PLUSW1
10EF0  F404     NOP
10EF2  F4E3     NOP
748:                       --w;
10EF4  50E1     MOVF 0xFE1, W, ACCESS
10EF6  0FEF     ADDLW 0xEF
10EF8  6ED9     MOVWF 0xFD9, ACCESS
10EFA  50E2     MOVF 0xFE2, W, ACCESS
10EFC  6EDA     MOVWF __end_of_UART2_tx_vect_isr, ACCESS
10EFE  0EFF     MOVLW 0xFF
10F00  22DA     ADDWFC __end_of_UART2_tx_vect_isr, F, ACCESS
10F02  06DE     DECF 0xFDE, F, ACCESS
10F04  0E00     MOVLW 0x0
10F06  5ADD     SUBWFB 0xFDD, F, ACCESS
749:                   }
750:                   h -= l*u.f;
10F08  0EDD     MOVLW 0xDD
10F0A  C4E3     MOVFF PLUSW1, POSTINC1
10F0C  F4E6     NOP
10F0E  C4E3     MOVFF PLUSW1, POSTINC1
10F10  F4E6     NOP
10F12  C4E3     MOVFF PLUSW1, POSTINC1
10F14  F4E6     NOP
10F16  C4E3     MOVFF PLUSW1, POSTINC1
10F18  F4E6     NOP
10F1A  0ED1     MOVLW 0xD1
10F1C  C4E3     MOVFF PLUSW1, POSTINC1
10F1E  F4E6     NOP
10F20  C4E3     MOVFF PLUSW1, POSTINC1
10F22  F4E6     NOP
10F24  C4E3     MOVFF PLUSW1, POSTINC1
10F26  F4E6     NOP
10F28  C4E3     MOVFF PLUSW1, POSTINC1
10F2A  F4E6     NOP
10F2C  EC2F     CALL 0x1705E, 0
10F2E  F0B8     NOP
10F30  0061     MOVFFL ltemp0, POSTINC1
10F32  F404     NOP
10F34  F4E6     NOP
10F36  0061     MOVFFL ttemp5, POSTINC1
10F38  F408     NOP
10F3A  F4E6     NOP
10F3C  0061     MOVFFL wtemp1, POSTINC1
10F3E  F40C     NOP
10F40  F4E6     NOP
10F42  0061     MOVFFL ttemp1, POSTINC1
10F44  F410     NOP
10F46  F4E6     NOP
10F48  0EDD     MOVLW 0xDD
10F4A  C4E3     MOVFF PLUSW1, POSTINC1
10F4C  F4E6     NOP
10F4E  C4E3     MOVFF PLUSW1, POSTINC1
10F50  F4E6     NOP
10F52  C4E3     MOVFF PLUSW1, POSTINC1
10F54  F4E6     NOP
10F56  C4E3     MOVFF PLUSW1, POSTINC1
10F58  F4E6     NOP
10F5A  ECC0     CALL 0x1B80, 0
10F5C  F00D     NOP
10F5E  0EE1     MOVLW 0xE1
10F60  0061     MOVFFL ltemp0, PLUSW1
10F62  F404     NOP
10F64  F4E3     NOP
10F66  0EE2     MOVLW 0xE2
10F68  0061     MOVFFL ttemp5, PLUSW1
10F6A  F408     NOP
10F6C  F4E3     NOP
10F6E  0EE3     MOVLW 0xE3
10F70  0061     MOVFFL wtemp1, PLUSW1
10F72  F40C     NOP
10F74  F4E3     NOP
10F76  0EE4     MOVLW 0xE4
10F78  0061     MOVFFL ttemp1, PLUSW1
10F7A  F410     NOP
10F7C  F4E3     NOP
751:                   u.f = u.f/10.0;
10F7E  0E00     MOVLW 0x0
10F80  6EE6     MOVWF 0xFE6, ACCESS
10F82  0E00     MOVLW 0x0
10F84  6EE6     MOVWF 0xFE6, ACCESS
10F86  0E20     MOVLW 0x20
10F88  6EE6     MOVWF 0xFE6, ACCESS
10F8A  0E41     MOVLW 0x41
10F8C  6EE6     MOVWF 0xFE6, ACCESS
10F8E  0ED1     MOVLW 0xD1
10F90  C4E3     MOVFF PLUSW1, POSTINC1
10F92  F4E6     NOP
10F94  C4E3     MOVFF PLUSW1, POSTINC1
10F96  F4E6     NOP
10F98  C4E3     MOVFF PLUSW1, POSTINC1
10F9A  F4E6     NOP
10F9C  C4E3     MOVFF PLUSW1, POSTINC1
10F9E  F4E6     NOP
10FA0  ECD2     CALL 0x187A4, 0
10FA2  F0C3     NOP
10FA4  0ED5     MOVLW 0xD5
10FA6  0061     MOVFFL ltemp0, PLUSW1
10FA8  F404     NOP
10FAA  F4E3     NOP
10FAC  0ED6     MOVLW 0xD6
10FAE  0061     MOVFFL ttemp5, PLUSW1
10FB0  F408     NOP
10FB2  F4E3     NOP
10FB4  0ED7     MOVLW 0xD7
10FB6  0061     MOVFFL wtemp1, PLUSW1
10FB8  F40C     NOP
10FBA  F4E3     NOP
10FBC  0ED8     MOVLW 0xD8
10FBE  0061     MOVFFL ttemp1, PLUSW1
10FC0  F410     NOP
10FC2  F4E3     NOP
752:                   --ne;
10FC4  50E1     MOVF 0xFE1, W, ACCESS
10FC6  0FF7     ADDLW 0xF7
10FC8  6ED9     MOVWF 0xFD9, ACCESS
10FCA  50E2     MOVF 0xFE2, W, ACCESS
10FCC  6EDA     MOVWF __end_of_UART2_tx_vect_isr, ACCESS
10FCE  0EFF     MOVLW 0xFF
10FD0  22DA     ADDWFC __end_of_UART2_tx_vect_isr, F, ACCESS
10FD2  06DE     DECF 0xFDE, F, ACCESS
10FD4  0E00     MOVLW 0x0
10FD6  5ADD     SUBWFB 0xFDD, F, ACCESS
753:                   ++i;
10FD8  0EEB     MOVLW 0xEB
10FDA  50E3     MOVF 0xFE3, W, ACCESS
10FDC  0F01     ADDLW 0x1
10FDE  6E01     MOVWF __ptext283, ACCESS
10FE0  0EEB     MOVLW 0xEB
10FE2  0061     MOVFFL ltemp0, PLUSW1
10FE4  F404     NOP
10FE6  F4E3     NOP
10FE8  6A01     CLRF __ptext283, ACCESS
10FEA  0EEC     MOVLW 0xEC
10FEC  50E3     MOVF 0xFE3, W, ACCESS
10FEE  2001     ADDWFC __ptext283, W, ACCESS
10FF0  6E01     MOVWF __ptext283, ACCESS
10FF2  0EEC     MOVLW 0xEC
10FF4  0061     MOVFFL ltemp0, PLUSW1
10FF6  F404     NOP
10FF8  F4E3     NOP
754:               }
755:           #ifdef _VFPF_ALTERN
756:               if (!pp && (flags & POUND_FLAG)) {
1103C  0EFE     MOVLW 0xFE
1103E  50E3     MOVF 0xFE3, W, ACCESS
11040  B4D8     BTFSC 0xFD8, 2, ACCESS
11042  A827     BTFSS 0x27, 4, ACCESS
11044  D021     BRA 0x1088
757:                   dbuf[n++] = '.';
11046  0EE9     MOVLW 0xE9
11048  0061     MOVFFL PLUSW1, wtemp5
1104A  F38C     NOP
1104C  F50B     NOP
1104E  0EEA     MOVLW 0xEA
11050  0061     MOVFFL PLUSW1, 0x50C
11052  F38C     NOP
11054  F50C     NOP
11056  0EA5     MOVLW 0xA5
11058  240B     ADDWF 0xB, W, ACCESS
1105A  6ED9     MOVWF 0xFD9, ACCESS
1105C  0E08     MOVLW 0x8
1105E  200C     ADDWFC 0xC, W, ACCESS
11060  6EDA     MOVWF __end_of_UART2_tx_vect_isr, ACCESS
11062  0E2E     MOVLW 0x2E
11064  6EDF     MOVWF 0xFDF, ACCESS
11066  0EE9     MOVLW 0xE9
11068  50E3     MOVF 0xFE3, W, ACCESS
1106A  0F01     ADDLW 0x1
1106C  6E01     MOVWF __ptext283, ACCESS
1106E  0EE9     MOVLW 0xE9
11070  0061     MOVFFL ltemp0, PLUSW1
11072  F404     NOP
11074  F4E3     NOP
11076  6A01     CLRF __ptext283, ACCESS
11078  0EEA     MOVLW 0xEA
1107A  50E3     MOVF 0xFE3, W, ACCESS
1107C  2001     ADDWFC __ptext283, W, ACCESS
1107E  6E01     MOVWF __ptext283, ACCESS
11080  0EEA     MOVLW 0xEA
11082  0061     MOVFFL ltemp0, PLUSW1
11084  F404     NOP
11086  F4E3     NOP
758:               }
759:           #endif
760:           	i = sizeof(dbuf) - 1;
11088  0E4F     MOVLW 0x4F
1108A  6E0B     MOVWF 0xB, ACCESS
1108C  0E00     MOVLW 0x0
1108E  6E0C     MOVWF 0xC, ACCESS
11090  0EEB     MOVLW 0xEB
11092  0061     MOVFFL wtemp5, PLUSW1
11094  F42C     NOP
11096  F4E3     NOP
11098  0EEC     MOVLW 0xEC
1109A  0061     MOVFFL 0x50C, PLUSW1
1109C  F430     NOP
1109E  F4E3     NOP
761:               dbuf[i] = '\0';
110A0  0EEB     MOVLW 0xEB
110A2  0061     MOVFFL PLUSW1, wtemp5
110A4  F38C     NOP
110A6  F50B     NOP
110A8  0EEC     MOVLW 0xEC
110AA  0061     MOVFFL PLUSW1, 0x50C
110AC  F38C     NOP
110AE  F50C     NOP
110B0  0EA5     MOVLW 0xA5
110B2  240B     ADDWF 0xB, W, ACCESS
110B4  6ED9     MOVWF 0xFD9, ACCESS
110B6  0E08     MOVLW 0x8
110B8  200C     ADDWFC 0xC, W, ACCESS
110BA  6EDA     MOVWF __end_of_UART2_tx_vect_isr, ACCESS
110BC  6ADF     CLRF 0xFDF, ACCESS
762:           
763:               /* Convert exponent */
764:           #if defined(_VFPF_G) || defined(_VFPF_E)
765:               if (nmode == 'e') {
110BE  0EFD     MOVLW 0xFD
110C0  0061     MOVFFL PLUSW1, ltemp0
110C2  F38C     NOP
110C4  F501     NOP
110C6  0E65     MOVLW 0x65
110C8  1801     XORWF __ptext283, W, ACCESS
110CA  A4D8     BTFSS 0xFD8, 2, ACCESS
110CC  D0F5     BRA 0x12B8
766:                   esign = 0;
110CE  0EFF     MOVLW 0xFF
110D0  6AE3     CLRF 0xFE3, ACCESS
767:                   if (e < 0) {
110D2  0EEE     MOVLW 0xEE
110D4  AEE3     BTFSS 0xFE3, 7, ACCESS
110D6  D009     BRA __pidataBANK5
768:                       esign = 1;
110D8  0EFF     MOVLW 0xFF
110DA  6AE3     CLRF 0xFE3, ACCESS
110DC  2AE3     INCF 0xFE3, F, ACCESS
769:                       e = -e;
110DE  0EED     MOVLW 0xED
110E0  6CE3     NEGF 0xFE3, ACCESS
110E2  0EEE     MOVLW 0xEE
110E4  1EE3     COMF 0xFE3, F, ACCESS
110E6  B0D8     BTFSC 0xFD8, 0, ACCESS
110E8  2AE3     INCF 0xFE3, F, ACCESS
770:                   }
771:                   p = 2;
110EA  0E02     MOVLW 0x2
110EC  6E0B     MOVWF 0xB, ACCESS
110EE  0E00     MOVLW 0x0
110F0  6E0C     MOVWF 0xC, ACCESS
110F2  0EF1     MOVLW 0xF1
110F4  0061     MOVFFL wtemp5, PLUSW1
110F6  F42C     NOP
110F8  F4E3     NOP
110FA  0EF2     MOVLW 0xF2
110FC  0061     MOVFFL 0x50C, PLUSW1
110FE  F430     NOP
11100  F4E3     NOP
772:                   while (e || (0 < p)) {
11102  D04D     BRA 0x119E
1119E  0EED     MOVLW 0xED
111A0  0061     MOVFFL PLUSW1, ltemp0
111A2  F38C     NOP
111A4  F501     NOP
111A6  0EEE     MOVLW 0xEE
111A8  50E3     MOVF 0xFE3, W, ACCESS
111AA  1001     IORWF __ptext283, W, ACCESS
111AC  A4D8     BTFSS 0xFD8, 2, ACCESS
111AE  D7AA     BRA 0x1104
111B0  0EF2     MOVLW 0xF2
111B2  BEE3     BTFSC 0xFE3, 7, ACCESS
111B4  D007     BRA 0x11C4
111B6  0EF2     MOVLW 0xF2
111B8  50E3     MOVF 0xFE3, W, ACCESS
111BA  E1A4     BNZ 0x1104
111BC  0EF1     MOVLW 0xF1
111BE  04E3     DECF 0xFE3, W, ACCESS
111C0  B0D8     BTFSC 0xFD8, 0, ACCESS
111C2  D7A0     BRA 0x1104
773:                       --i;
11104  50E1     MOVF 0xFE1, W, ACCESS
11106  0FEB     ADDLW 0xEB
11108  6ED9     MOVWF 0xFD9, ACCESS
1110A  50E2     MOVF 0xFE2, W, ACCESS
1110C  6EDA     MOVWF __end_of_UART2_tx_vect_isr, ACCESS
1110E  0EFF     MOVLW 0xFF
11110  22DA     ADDWFC __end_of_UART2_tx_vect_isr, F, ACCESS
11112  06DE     DECF 0xFDE, F, ACCESS
11114  0E00     MOVLW 0x0
11116  5ADD     SUBWFB 0xFDD, F, ACCESS
774:                       dbuf[i] = '0' + (e % 10);
11118  0EEB     MOVLW 0xEB
1111A  0061     MOVFFL PLUSW1, wtemp5
1111C  F38C     NOP
1111E  F50B     NOP
11120  0EEC     MOVLW 0xEC
11122  0061     MOVFFL PLUSW1, 0x50C
11124  F38C     NOP
11126  F50C     NOP
11128  0EA5     MOVLW 0xA5
1112A  240B     ADDWF 0xB, W, ACCESS
1112C  6ED9     MOVWF 0xFD9, ACCESS
1112E  0E08     MOVLW 0x8
11130  200C     ADDWFC 0xC, W, ACCESS
11132  6EDA     MOVWF __end_of_UART2_tx_vect_isr, ACCESS
11134  0E0A     MOVLW 0xA
11136  6EE6     MOVWF 0xFE6, ACCESS
11138  0E00     MOVLW 0x0
1113A  6EE6     MOVWF 0xFE6, ACCESS
1113C  0EEB     MOVLW 0xEB
1113E  C4E3     MOVFF PLUSW1, POSTINC1
11140  F4E6     NOP
11142  C4E3     MOVFF PLUSW1, POSTINC1
11144  F4E6     NOP
11146  EC5A     CALL 0x1E0B4, 0
11148  F0F0     NOP
1114A  5001     MOVF __ptext283, W, ACCESS
1114C  0F30     ADDLW 0x30
1114E  6EDF     MOVWF 0xFDF, ACCESS
775:                       e = e / 10;
11150  0E0A     MOVLW 0xA
11152  6EE6     MOVWF 0xFE6, ACCESS
11154  0E00     MOVLW 0x0
11156  6EE6     MOVWF 0xFE6, ACCESS
11158  0EEB     MOVLW 0xEB
1115A  C4E3     MOVFF PLUSW1, POSTINC1
1115C  F4E6     NOP
1115E  C4E3     MOVFF PLUSW1, POSTINC1
11160  F4E6     NOP
11162  ECB9     CALL 0x1D972, 0
11164  F0EC     NOP
11166  0EED     MOVLW 0xED
11168  0061     MOVFFL ltemp0, PLUSW1
1116A  F404     NOP
1116C  F4E3     NOP
1116E  0EEE     MOVLW 0xEE
11170  0061     MOVFFL ttemp5, PLUSW1
11172  F408     NOP
11174  F4E3     NOP
776:                       --p;
11176  50E1     MOVF 0xFE1, W, ACCESS
11178  0FF1     ADDLW 0xF1
1117A  6ED9     MOVWF 0xFD9, ACCESS
1117C  50E2     MOVF 0xFE2, W, ACCESS
1117E  6EDA     MOVWF __end_of_UART2_tx_vect_isr, ACCESS
11180  0EFF     MOVLW 0xFF
11182  22DA     ADDWFC __end_of_UART2_tx_vect_isr, F, ACCESS
11184  06DE     DECF 0xFDE, F, ACCESS
11186  0E00     MOVLW 0x0
11188  5ADD     SUBWFB 0xFDD, F, ACCESS
777:                       --w;
1118A  50E1     MOVF 0xFE1, W, ACCESS
1118C  0FEF     ADDLW 0xEF
1118E  6ED9     MOVWF 0xFD9, ACCESS
11190  50E2     MOVF 0xFE2, W, ACCESS
11192  6EDA     MOVWF __end_of_UART2_tx_vect_isr, ACCESS
11194  0EFF     MOVLW 0xFF
11196  22DA     ADDWFC __end_of_UART2_tx_vect_isr, F, ACCESS
11198  06DE     DECF 0xFDE, F, ACCESS
1119A  0E00     MOVLW 0x0
1119C  5ADD     SUBWFB 0xFDD, F, ACCESS
778:                   }
779:                   --i;
111C4  50E1     MOVF 0xFE1, W, ACCESS
111C6  0FEB     ADDLW 0xEB
111C8  6ED9     MOVWF 0xFD9, ACCESS
111CA  50E2     MOVF 0xFE2, W, ACCESS
111CC  6EDA     MOVWF __end_of_UART2_tx_vect_isr, ACCESS
111CE  0EFF     MOVLW 0xFF
111D0  22DA     ADDWFC __end_of_UART2_tx_vect_isr, F, ACCESS
111D2  06DE     DECF 0xFDE, F, ACCESS
111D4  0E00     MOVLW 0x0
111D6  5ADD     SUBWFB 0xFDD, F, ACCESS
780:                   dbuf[i] = esign ? '-' : '+';
111D8  0EFF     MOVLW 0xFF
111DA  50E3     MOVF 0xFE3, W, ACCESS
111DC  A4D8     BTFSS 0xFD8, 2, ACCESS
111DE  D002     BRA 0x11E4
111E0  0E2B     MOVLW 0x2B
111E2  D001     BRA 0x11E6
111E4  0E2D     MOVLW 0x2D
111E6  6E0B     MOVWF 0xB, ACCESS
111E8  0E00     MOVLW 0x0
111EA  6E0C     MOVWF 0xC, ACCESS
111EC  0ED1     MOVLW 0xD1
111EE  0061     MOVFFL wtemp5, PLUSW1
111F0  F42C     NOP
111F2  F4E3     NOP
111F4  0ED2     MOVLW 0xD2
111F6  0061     MOVFFL 0x50C, PLUSW1
111F8  F430     NOP
111FA  F4E3     NOP
111FC  0EEB     MOVLW 0xEB
111FE  0061     MOVFFL PLUSW1, wtemp5
11200  F38C     NOP
11202  F50B     NOP
11204  0EEC     MOVLW 0xEC
11206  0061     MOVFFL PLUSW1, 0x50C
11208  F38C     NOP
1120A  F50C     NOP
1120C  0EA5     MOVLW 0xA5
1120E  240B     ADDWF 0xB, W, ACCESS
11210  6ED9     MOVWF 0xFD9, ACCESS
11212  0E08     MOVLW 0x8
11214  200C     ADDWFC 0xC, W, ACCESS
11216  6EDA     MOVWF __end_of_UART2_tx_vect_isr, ACCESS
11218  0ED1     MOVLW 0xD1
1121A  C4E3     MOVFF PLUSW1, INDF2
1121C  F4DF     NOP
781:                   --w;
1121E  50E1     MOVF 0xFE1, W, ACCESS
11220  0FEF     ADDLW 0xEF
11222  6ED9     MOVWF 0xFD9, ACCESS
11224  50E2     MOVF 0xFE2, W, ACCESS
11226  6EDA     MOVWF __end_of_UART2_tx_vect_isr, ACCESS
11228  0EFF     MOVLW 0xFF
1122A  22DA     ADDWFC __end_of_UART2_tx_vect_isr, F, ACCESS
1122C  06DE     DECF 0xFDE, F, ACCESS
1122E  0E00     MOVLW 0x0
11230  5ADD     SUBWFB 0xFDD, F, ACCESS
782:                   --i;
11232  50E1     MOVF 0xFE1, W, ACCESS
11234  0FEB     ADDLW 0xEB
11236  6ED9     MOVWF 0xFD9, ACCESS
11238  50E2     MOVF 0xFE2, W, ACCESS
1123A  6EDA     MOVWF __end_of_UART2_tx_vect_isr, ACCESS
1123C  0EFF     MOVLW 0xFF
1123E  22DA     ADDWFC __end_of_UART2_tx_vect_isr, F, ACCESS
11240  06DE     DECF 0xFDE, F, ACCESS
11242  0E00     MOVLW 0x0
11244  5ADD     SUBWFB 0xFDD, F, ACCESS
783:           #ifdef _VFPF_UPCASE
784:                   dbuf[i] = isupper((int)c) ? 'E' : 'e';
11246  0EC8     MOVLW 0xC8
11248  0061     MOVFFL PLUSW1, 0x50C
1124A  F38C     NOP
1124C  F50C     NOP
1124E  0EBF     MOVLW 0xBF
11250  240C     ADDWF 0xC, W, ACCESS
11252  6E09     MOVWF 0x9, ACCESS
11254  6A0A     CLRF 0xA, ACCESS
11256  0EFF     MOVLW 0xFF
11258  220A     ADDWFC 0xA, F, ACCESS
1125A  500A     MOVF 0xA, W, ACCESS
1125C  E104     BNZ 0x1266
1125E  0E1A     MOVLW 0x1A
11260  5C09     SUBWF 0x9, W, ACCESS
11262  A0D8     BTFSS 0xFD8, 0, ACCESS
11264  D002     BRA 0x126A
11266  0E65     MOVLW 0x65
11268  D001     BRA 0x126C
1126A  0E45     MOVLW 0x45
1126C  6E0B     MOVWF 0xB, ACCESS
1126E  0E00     MOVLW 0x0
11270  6E0C     MOVWF 0xC, ACCESS
11272  0ECF     MOVLW 0xCF
11274  0061     MOVFFL wtemp5, PLUSW1
11276  F42C     NOP
11278  F4E3     NOP
1127A  0ED0     MOVLW 0xD0
1127C  0061     MOVFFL 0x50C, PLUSW1
1127E  F430     NOP
11280  F4E3     NOP
11282  0EEB     MOVLW 0xEB
11284  0061     MOVFFL PLUSW1, wtemp5
11286  F38C     NOP
11288  F50B     NOP
1128A  0EEC     MOVLW 0xEC
1128C  0061     MOVFFL PLUSW1, 0x50C
1128E  F38C     NOP
11290  F50C     NOP
11292  0EA5     MOVLW 0xA5
11294  240B     ADDWF 0xB, W, ACCESS
11296  6ED9     MOVWF 0xFD9, ACCESS
11298  0E08     MOVLW 0x8
1129A  200C     ADDWFC 0xC, W, ACCESS
1129C  6EDA     MOVWF __end_of_UART2_tx_vect_isr, ACCESS
1129E  0ECF     MOVLW 0xCF
112A0  C4E3     MOVFF PLUSW1, INDF2
112A2  F4DF     NOP
785:           #else
786:           		dbuf[i] = 'e';
787:           #endif
788:                   --w;
112A4  50E1     MOVF 0xFE1, W, ACCESS
112A6  0FEF     ADDLW 0xEF
112A8  6ED9     MOVWF 0xFD9, ACCESS
112AA  50E2     MOVF 0xFE2, W, ACCESS
112AC  6EDA     MOVWF __end_of_UART2_tx_vect_isr, ACCESS
112AE  0EFF     MOVLW 0xFF
112B0  22DA     ADDWFC __end_of_UART2_tx_vect_isr, F, ACCESS
112B2  06DE     DECF 0xFDE, F, ACCESS
112B4  0E00     MOVLW 0x0
112B6  5ADD     SUBWFB 0xFDD, F, ACCESS
789:               }
790:           #endif
791:           	// Attach mantissa to exponent (if any)
792:           	memcpy(&dbuf[i-n], &dbuf[0], (size_t)n);
112B8  0EE9     MOVLW 0xE9
112BA  C4E3     MOVFF PLUSW1, POSTINC1
112BC  F4E6     NOP
112BE  C4E3     MOVFF PLUSW1, POSTINC1
112C0  F4E6     NOP
112C2  0EA5     MOVLW 0xA5
112C4  6EE6     MOVWF 0xFE6, ACCESS
112C6  0E08     MOVLW 0x8
112C8  6EE6     MOVWF 0xFE6, ACCESS
112CA  0EA5     MOVLW 0xA5
112CC  6E0B     MOVWF 0xB, ACCESS
112CE  0E08     MOVLW 0x8
112D0  6E0C     MOVWF 0xC, ACCESS
112D2  0EE5     MOVLW 0xE5
112D4  50E3     MOVF 0xFE3, W, ACCESS
112D6  5E0B     SUBWF 0xB, F, ACCESS
112D8  0EE6     MOVLW 0xE6
112DA  50E3     MOVF 0xFE3, W, ACCESS
112DC  5A0C     SUBWFB 0xC, F, ACCESS
112DE  0EE7     MOVLW 0xE7
112E0  50E3     MOVF 0xFE3, W, ACCESS
112E2  260B     ADDWF 0xB, F, ACCESS
112E4  0EE8     MOVLW 0xE8
112E6  50E3     MOVF 0xFE3, W, ACCESS
112E8  220C     ADDWFC 0xC, F, ACCESS
112EA  0061     MOVFFL wtemp5, POSTINC1
112EC  F42C     NOP
112EE  F4E6     NOP
112F0  0061     MOVFFL 0x50C, POSTINC1
112F2  F430     NOP
112F4  F4E6     NOP
112F6  EC81     CALL 0x1E502, 0
112F8  F0F2     NOP
793:           	n = i-n;
112FA  0EEB     MOVLW 0xEB
112FC  0061     MOVFFL PLUSW1, wtemp5
112FE  F38C     NOP
11300  F50B     NOP
11302  0EEC     MOVLW 0xEC
11304  0061     MOVFFL PLUSW1, 0x50C
11306  F38C     NOP
11308  F50C     NOP
1130A  0EE9     MOVLW 0xE9
1130C  50E3     MOVF 0xFE3, W, ACCESS
1130E  5E0B     SUBWF 0xB, F, ACCESS
11310  0EEA     MOVLW 0xEA
11312  50E3     MOVF 0xFE3, W, ACCESS
11314  5A0C     SUBWFB 0xC, F, ACCESS
11316  0EE9     MOVLW 0xE9
11318  0061     MOVFFL wtemp5, PLUSW1
1131A  F42C     NOP
1131C  F4E3     NOP
1131E  0EEA     MOVLW 0xEA
11320  0061     MOVFFL 0x50C, PLUSW1
11322  F430     NOP
11324  F4E3     NOP
794:           	i = sign == 0 ? 0 : 1;
11326  0EFB     MOVLW 0xFB
11328  50E3     MOVF 0xFE3, W, ACCESS
1132A  B4D8     BTFSC 0xFD8, 2, ACCESS
1132C  D002     BRA 0x1332
1132E  0E01     MOVLW 0x1
11330  D001     BRA 0x1334
11332  0E00     MOVLW 0x0
11334  6E0B     MOVWF 0xB, ACCESS
11336  6A0C     CLRF 0xC, ACCESS
11338  0EEB     MOVLW 0xEB
1133A  0061     MOVFFL wtemp5, PLUSW1
1133C  F42C     NOP
1133E  F4E3     NOP
11340  0EEC     MOVLW 0xEC
11342  0061     MOVFFL 0x50C, PLUSW1
11344  F430     NOP
11346  F4E3     NOP
795:           #ifdef _VFPF_FILL
796:           	// fill with zeros before 0x
797:           	if (flags & ZERO_FLAG) {
11348  B227     BTFSC 0x27, 1, ACCESS
1134A  D023     BRA 0x1392
1134C  D048     BRA 0x13DE
798:           		while (w > i && n > i) {
11392  50E1     MOVF 0xFE1, W, ACCESS
11394  0FEB     ADDLW 0xEB
11396  6ED9     MOVWF 0xFD9, ACCESS
11398  50E2     MOVF 0xFE2, W, ACCESS
1139A  6EDA     MOVWF __end_of_UART2_tx_vect_isr, ACCESS
1139C  0EFF     MOVLW 0xFF
1139E  22DA     ADDWFC __end_of_UART2_tx_vect_isr, F, ACCESS
113A0  0EEF     MOVLW 0xEF
113A2  50E3     MOVF 0xFE3, W, ACCESS
113A4  5CDE     SUBWF 0xFDE, W, ACCESS
113A6  50DE     MOVF 0xFDE, W, ACCESS
113A8  0A80     XORLW 0x80
113AA  6E01     MOVWF __ptext283, ACCESS
113AC  0EF0     MOVLW 0xF0
113AE  50E3     MOVF 0xFE3, W, ACCESS
113B0  0A80     XORLW 0x80
113B2  5801     SUBWFB __ptext283, W, ACCESS
113B4  B0D8     BTFSC 0xFD8, 0, ACCESS
113B6  D013     BRA 0x13DE
113B8  50E1     MOVF 0xFE1, W, ACCESS
113BA  0FEB     ADDLW 0xEB
113BC  6ED9     MOVWF 0xFD9, ACCESS
113BE  50E2     MOVF 0xFE2, W, ACCESS
113C0  6EDA     MOVWF __end_of_UART2_tx_vect_isr, ACCESS
113C2  0EFF     MOVLW 0xFF
113C4  22DA     ADDWFC __end_of_UART2_tx_vect_isr, F, ACCESS
113C6  0EE9     MOVLW 0xE9
113C8  50E3     MOVF 0xFE3, W, ACCESS
113CA  5CDE     SUBWF 0xFDE, W, ACCESS
113CC  50DE     MOVF 0xFDE, W, ACCESS
113CE  0A80     XORLW 0x80
113D0  6E01     MOVWF __ptext283, ACCESS
113D2  0EEA     MOVLW 0xEA
113D4  50E3     MOVF 0xFE3, W, ACCESS
113D6  0A80     XORLW 0x80
113D8  5801     SUBWFB __ptext283, W, ACCESS
113DA  A0D8     BTFSS 0xFD8, 0, ACCESS
113DC  D7B8     BRA 0x134E
799:           			dbuf[--n] = '0';
1134E  50E1     MOVF 0xFE1, W, ACCESS
11350  0FE9     ADDLW 0xE9
11352  6ED9     MOVWF 0xFD9, ACCESS
11354  50E2     MOVF 0xFE2, W, ACCESS
11356  6EDA     MOVWF __end_of_UART2_tx_vect_isr, ACCESS
11358  0EFF     MOVLW 0xFF
1135A  22DA     ADDWFC __end_of_UART2_tx_vect_isr, F, ACCESS
1135C  06DE     DECF 0xFDE, F, ACCESS
1135E  0E00     MOVLW 0x0
11360  5ADD     SUBWFB 0xFDD, F, ACCESS
11362  0061     MOVFFL POSTINC2, wtemp5
11364  F378     NOP
11366  F50B     NOP
11368  0061     MOVFFL POSTDEC2, 0x50C
1136A  F374     NOP
1136C  F50C     NOP
1136E  0EA5     MOVLW 0xA5
11370  240B     ADDWF 0xB, W, ACCESS
11372  6ED9     MOVWF 0xFD9, ACCESS
11374  0E08     MOVLW 0x8
11376  200C     ADDWFC 0xC, W, ACCESS
11378  6EDA     MOVWF __end_of_UART2_tx_vect_isr, ACCESS
1137A  0E30     MOVLW 0x30
1137C  6EDF     MOVWF 0xFDF, ACCESS
800:           			w--;
1137E  50E1     MOVF 0xFE1, W, ACCESS
11380  0FEF     ADDLW 0xEF
11382  6ED9     MOVWF 0xFD9, ACCESS
11384  50E2     MOVF 0xFE2, W, ACCESS
11386  6EDA     MOVWF __end_of_UART2_tx_vect_isr, ACCESS
11388  0EFF     MOVLW 0xFF
1138A  22DA     ADDWFC __end_of_UART2_tx_vect_isr, F, ACCESS
1138C  06DE     DECF 0xFDE, F, ACCESS
1138E  0E00     MOVLW 0x0
11390  5ADD     SUBWFB 0xFDD, F, ACCESS
801:           		}
802:           	}
803:           #endif
804:           	// put on the sign
805:           	if (sign) {
113DE  0EFB     MOVLW 0xFB
113E0  50E3     MOVF 0xFE3, W, ACCESS
113E2  B4D8     BTFSC 0xFD8, 2, ACCESS
113E4  D019     BRA 0x1418
806:           		dbuf[--n] = sign;
113E6  50E1     MOVF 0xFE1, W, ACCESS
113E8  0FE9     ADDLW 0xE9
113EA  6ED9     MOVWF 0xFD9, ACCESS
113EC  50E2     MOVF 0xFE2, W, ACCESS
113EE  6EDA     MOVWF __end_of_UART2_tx_vect_isr, ACCESS
113F0  0EFF     MOVLW 0xFF
113F2  22DA     ADDWFC __end_of_UART2_tx_vect_isr, F, ACCESS
113F4  06DE     DECF 0xFDE, F, ACCESS
113F6  0E00     MOVLW 0x0
113F8  5ADD     SUBWFB 0xFDD, F, ACCESS
113FA  0061     MOVFFL POSTINC2, wtemp5
113FC  F378     NOP
113FE  F50B     NOP
11400  0061     MOVFFL POSTDEC2, 0x50C
11402  F374     NOP
11404  F50C     NOP
11406  0EA5     MOVLW 0xA5
11408  240B     ADDWF 0xB, W, ACCESS
1140A  6ED9     MOVWF 0xFD9, ACCESS
1140C  0E08     MOVLW 0x8
1140E  200C     ADDWFC 0xC, W, ACCESS
11410  6EDA     MOVWF __end_of_UART2_tx_vect_isr, ACCESS
11412  0EFB     MOVLW 0xFB
11414  C4E3     MOVFF PLUSW1, INDF2
11416  F4DF     NOP
807:           	}
808:           	w -= i;
11418  0EEF     MOVLW 0xEF
1141A  50E3     MOVF 0xFE3, W, ACCESS
1141C  6E01     MOVWF __ptext283, ACCESS
1141E  0EEB     MOVLW 0xEB
11420  50E3     MOVF 0xFE3, W, ACCESS
11422  5E01     SUBWF __ptext283, F, ACCESS
11424  0EEF     MOVLW 0xEF
11426  0061     MOVFFL ltemp0, PLUSW1
11428  F404     NOP
1142A  F4E3     NOP
1142C  0EF0     MOVLW 0xF0
1142E  50E3     MOVF 0xFE3, W, ACCESS
11430  6E01     MOVWF __ptext283, ACCESS
11432  0EEC     MOVLW 0xEC
11434  50E3     MOVF 0xFE3, W, ACCESS
11436  5A01     SUBWFB __ptext283, F, ACCESS
11438  0EF0     MOVLW 0xF0
1143A  0061     MOVFFL ltemp0, PLUSW1
1143C  F404     NOP
1143E  F4E3     NOP
809:           
810:               /* Put out padded string */
811:               return _COUNT_CAST pad(fp, &dbuf[n], w);
11440  0EEF     MOVLW 0xEF
11442  C4E3     MOVFF PLUSW1, POSTINC1
11444  F4E6     NOP
11446  C4E3     MOVFF PLUSW1, POSTINC1
11448  F4E6     NOP
1144A  0EA5     MOVLW 0xA5
1144C  6E0B     MOVWF 0xB, ACCESS
1144E  0E08     MOVLW 0x8
11450  6E0C     MOVWF 0xC, ACCESS
11452  0EE7     MOVLW 0xE7
11454  50E3     MOVF 0xFE3, W, ACCESS
11456  260B     ADDWF 0xB, F, ACCESS
11458  0EE8     MOVLW 0xE8
1145A  50E3     MOVF 0xFE3, W, ACCESS
1145C  220C     ADDWFC 0xC, F, ACCESS
1145E  0061     MOVFFL wtemp5, POSTINC1
11460  F42C     NOP
11462  F4E6     NOP
11464  0061     MOVFFL 0x50C, POSTINC1
11466  F430     NOP
11468  F4E6     NOP
1146A  0EC9     MOVLW 0xC9
1146C  C4E3     MOVFF PLUSW1, POSTINC1
1146E  F4E6     NOP
11470  C4E3     MOVFF PLUSW1, POSTINC1
11472  F4E6     NOP
11474  ECA3     CALL 0x1EF46, 0
11476  F0F7     NOP
812:           }
11478  0EC8     MOVLW 0xC8
11478  0EC8     MOVLW 0xC8
11478  0EC8     MOVLW 0xC8
11478  0EC8     MOVLW 0xC8
11478  0EC8     MOVLW 0xC8
813:           #endif
814:           
815:           #ifdef _VFPF_O
816:           static _INLINE _COUNT_TYPE otoa(FILE *fp, vfpf_uint_t d)
1BE70  0E07     MOVLW 0x7
1BE72  26E1     ADDWF 0xFE1, F, ACCESS
1BE74  0E00     MOVLW 0x0
1BE76  22E2     ADDWFC 0xFE2, F, ACCESS
817:           {
818:           	char t;
819:               int i, p, w;
820:           
821:           #ifdef _VFPF_FILL
822:               /* Adjust flags, precision, width */
823:               if (!(prec < 0)) {
1BE78  AE24     BTFSS 0x24, 7, ACCESS
824:                   flags &= ~ZERO_FLAG;
1BE7A  9227     BCF 0x27, 1, ACCESS
825:               }
826:           #endif
827:               p = (0 <= prec) ? prec : 1;
1BE7C  AE24     BTFSS 0x24, 7, ACCESS
1BE7E  D00D     BRA 0xBE9A
1BE80  0E01     MOVLW 0x1
1BE82  6E0B     MOVWF 0xB, ACCESS
1BE84  0E00     MOVLW 0x0
1BE86  6E0C     MOVWF 0xC, ACCESS
1BE88  0EFD     MOVLW 0xFD
1BE8A  0061     MOVFFL wtemp5, PLUSW1
1BE8C  F42C     NOP
1BE8E  F4E3     NOP
1BE90  0EFE     MOVLW 0xFE
1BE92  0061     MOVFFL 0x50C, PLUSW1
1BE94  F430     NOP
1BE96  F4E3     NOP
1BE98  D006     BRA 0xBEA6
1BE9A  0EFD     MOVLW 0xFD
1BE9C  C523     MOVFF prec, PLUSW1
1BE9E  F4E3     NOP
1BEA0  0EFE     MOVLW 0xFE
1BEA2  C524     MOVFF 0x524, PLUSW1
1BEA4  F4E3     NOP
828:               w = width;
1BEA6  0EFB     MOVLW 0xFB
1BEA8  C521     MOVFF width, PLUSW1
1BEAA  F4E3     NOP
1BEAC  0EFC     MOVLW 0xFC
1BEAE  C522     MOVFF 0x522, PLUSW1
1BEB0  F4E3     NOP
829:           
830:               /* Convert to octal, possibly filling on the left with zeroes */
831:               i = sizeof(dbuf) - 1;
1BEB2  0E4F     MOVLW 0x4F
1BEB4  6E0B     MOVWF 0xB, ACCESS
1BEB6  0E00     MOVLW 0x0
1BEB8  6E0C     MOVWF 0xC, ACCESS
1BEBA  0EF9     MOVLW 0xF9
1BEBC  0061     MOVFFL wtemp5, PLUSW1
1BEBE  F42C     NOP
1BEC0  F4E3     NOP
1BEC2  0EFA     MOVLW 0xFA
1BEC4  0061     MOVFFL 0x50C, PLUSW1
1BEC6  F430     NOP
1BEC8  F4E3     NOP
832:               dbuf[i] = '\0';
1BECA  0108     MOVLB 0x8
1BECC  6BF4     CLRF DMAnSPTR, BANKED
833:               t = 0;
1BECE  0EFF     MOVLW 0xFF
1BED0  6AE3     CLRF 0xFE3, ACCESS
834:               while (!(i < 1) && (d || (0 < p)
1BED2  D04F     BRA 0xBF72
1BF72  0EFA     MOVLW 0xFA
1BF74  BEE3     BTFSC 0xFE3, 7, ACCESS
1BF76  D02A     BRA 0xBFCC
1BF78  0EFA     MOVLW 0xFA
1BF7A  50E3     MOVF 0xFE3, W, ACCESS
1BF7C  E104     BNZ 0xBF86
1BF7E  0EF9     MOVLW 0xF9
1BF80  04E3     DECF 0xFE3, W, ACCESS
1BF82  A0D8     BTFSS 0xFD8, 0, ACCESS
1BF84  D023     BRA 0xBFCC
1BF86  0EF3     MOVLW 0xF3
1BF88  50E3     MOVF 0xFE3, W, ACCESS
1BF8A  E1A4     BNZ 0xBED4
1BF8C  0EF4     MOVLW 0xF4
1BF8E  50E3     MOVF 0xFE3, W, ACCESS
1BF90  E1A1     BNZ 0xBED4
1BF92  0EF5     MOVLW 0xF5
1BF94  50E3     MOVF 0xFE3, W, ACCESS
1BF96  E19E     BNZ 0xBED4
1BF98  0EF6     MOVLW 0xF6
1BF9A  50E3     MOVF 0xFE3, W, ACCESS
1BF9C  A4D8     BTFSS 0xFD8, 2, ACCESS
1BF9E  D79A     BRA 0xBED4
1BFA0  0EFE     MOVLW 0xFE
1BFA2  BEE3     BTFSC 0xFE3, 7, ACCESS
1BFA4  D007     BRA 0xBFB4
1BFA6  0EFE     MOVLW 0xFE
1BFA8  50E3     MOVF 0xFE3, W, ACCESS
1BFAA  E194     BNZ 0xBED4
1BFAC  0EFD     MOVLW 0xFD
1BFAE  04E3     DECF 0xFE3, W, ACCESS
1BFB0  B0D8     BTFSC 0xFD8, 0, ACCESS
1BFB2  D790     BRA 0xBED4
1BFB4  0EFC     MOVLW 0xFC
1BFB6  BEE3     BTFSC 0xFE3, 7, ACCESS
1BFB8  D009     BRA 0xBFCC
1BFBA  0EFC     MOVLW 0xFC
1BFBC  50E3     MOVF 0xFE3, W, ACCESS
1BFBE  E104     BNZ 0xBFC8
1BFC0  0EFB     MOVLW 0xFB
1BFC2  04E3     DECF 0xFE3, W, ACCESS
1BFC4  A0D8     BTFSS 0xFD8, 0, ACCESS
1BFC6  D002     BRA 0xBFCC
1BFC8  B227     BTFSC 0x27, 1, ACCESS
1BFCA  D784     BRA 0xBED4
835:           #ifdef _VFPF_FILL
836:           				|| ((0 < w) && (flags & ZERO_FLAG))
837:           #endif
838:           				)) {
839:                   --i;
1BED4  50E1     MOVF 0xFE1, W, ACCESS
1BED6  0FF9     ADDLW 0xF9
1BED8  6ED9     MOVWF 0xFD9, ACCESS
1BEDA  50E2     MOVF 0xFE2, W, ACCESS
1BEDC  6EDA     MOVWF __end_of_UART2_tx_vect_isr, ACCESS
1BEDE  0EFF     MOVLW 0xFF
1BEE0  22DA     ADDWFC __end_of_UART2_tx_vect_isr, F, ACCESS
1BEE2  06DE     DECF 0xFDE, F, ACCESS
1BEE4  0E00     MOVLW 0x0
1BEE6  5ADD     SUBWFB 0xFDD, F, ACCESS
840:                   t = d & 07;
1BEE8  0EF3     MOVLW 0xF3
1BEEA  0061     MOVFFL PLUSW1, 0x50C
1BEEC  F38C     NOP
1BEEE  F50C     NOP
1BEF0  0E07     MOVLW 0x7
1BEF2  160C     ANDWF 0xC, F, ACCESS
1BEF4  0EFF     MOVLW 0xFF
1BEF6  0061     MOVFFL 0x50C, PLUSW1
1BEF8  F430     NOP
1BEFA  F4E3     NOP
841:                   dbuf[i] = (char)((int)'0' + t);
1BEFC  0EF9     MOVLW 0xF9
1BEFE  0061     MOVFFL PLUSW1, wtemp5
1BF00  F38C     NOP
1BF02  F50B     NOP
1BF04  0EFA     MOVLW 0xFA
1BF06  0061     MOVFFL PLUSW1, 0x50C
1BF08  F38C     NOP
1BF0A  F50C     NOP
1BF0C  0EA5     MOVLW 0xA5
1BF0E  240B     ADDWF 0xB, W, ACCESS
1BF10  6ED9     MOVWF 0xFD9, ACCESS
1BF12  0E08     MOVLW 0x8
1BF14  200C     ADDWFC 0xC, W, ACCESS
1BF16  6EDA     MOVWF __end_of_UART2_tx_vect_isr, ACCESS
1BF18  0EFF     MOVLW 0xFF
1BF1A  50E3     MOVF 0xFE3, W, ACCESS
1BF1C  0F30     ADDLW 0x30
1BF1E  6EDF     MOVWF 0xFDF, ACCESS
842:                   --p;
1BF20  50E1     MOVF 0xFE1, W, ACCESS
1BF22  0FFD     ADDLW 0xFD
1BF24  6ED9     MOVWF 0xFD9, ACCESS
1BF26  50E2     MOVF 0xFE2, W, ACCESS
1BF28  6EDA     MOVWF __end_of_UART2_tx_vect_isr, ACCESS
1BF2A  0EFF     MOVLW 0xFF
1BF2C  22DA     ADDWFC __end_of_UART2_tx_vect_isr, F, ACCESS
1BF2E  06DE     DECF 0xFDE, F, ACCESS
1BF30  0E00     MOVLW 0x0
1BF32  5ADD     SUBWFB 0xFDD, F, ACCESS
843:                   --w;
1BF34  50E1     MOVF 0xFE1, W, ACCESS
1BF36  0FFB     ADDLW 0xFB
1BF38  6ED9     MOVWF 0xFD9, ACCESS
1BF3A  50E2     MOVF 0xFE2, W, ACCESS
1BF3C  6EDA     MOVWF __end_of_UART2_tx_vect_isr, ACCESS
1BF3E  0EFF     MOVLW 0xFF
1BF40  22DA     ADDWFC __end_of_UART2_tx_vect_isr, F, ACCESS
1BF42  06DE     DECF 0xFDE, F, ACCESS
1BF44  0E00     MOVLW 0x0
1BF46  5ADD     SUBWFB 0xFDD, F, ACCESS
844:                   d = d >> 3;
1BF48  0E03     MOVLW 0x3
1BF4A  6E0C     MOVWF 0xC, ACCESS
1BF4C  50E1     MOVF 0xFE1, W, ACCESS
1BF4E  0FF3     ADDLW 0xF3
1BF50  6ED9     MOVWF 0xFD9, ACCESS
1BF52  50E2     MOVF 0xFE2, W, ACCESS
1BF54  6EDA     MOVWF __end_of_UART2_tx_vect_isr, ACCESS
1BF56  0EFF     MOVLW 0xFF
1BF58  22DA     ADDWFC __end_of_UART2_tx_vect_isr, F, ACCESS
1BF5A  280C     INCF 0xC, W, ACCESS
1BF5C  52DE     MOVF 0xFDE, F, ACCESS
1BF5E  D007     BRA 0xBF6E
1BF60  52DE     MOVF 0xFDE, F, ACCESS
1BF62  52DE     MOVF 0xFDE, F, ACCESS
1BF64  90D8     BCF 0xFD8, 0, ACCESS
1BF66  32DD     RRCF 0xFDD, F, ACCESS
1BF68  32DD     RRCF 0xFDD, F, ACCESS
1BF6A  32DD     RRCF 0xFDD, F, ACCESS
1BF6C  32DE     RRCF 0xFDE, F, ACCESS
1BF6E  2EE8     DECFSZ 0xFE8, F, ACCESS
1BF70  D7F7     BRA 0xBF60
845:               }
846:           
847:           #ifdef _VFPF_ALTERN
848:               /* Display prefix if required */
849:               if ((t || prec == 0) && (flags & POUND_FLAG)) {
1BFCC  0EFF     MOVLW 0xFF
1BFCE  50E3     MOVF 0xFE3, W, ACCESS
1BFD0  A4D8     BTFSS 0xFD8, 2, ACCESS
1BFD2  D004     BRA 0xBFDC
1BFD4  5023     MOVF 0x23, W, ACCESS
1BFD6  1024     IORWF 0x24, W, ACCESS
1BFD8  A4D8     BTFSS 0xFD8, 2, ACCESS
1BFDA  D026     BRA 0xC028
1BFDC  A827     BTFSS 0x27, 4, ACCESS
1BFDE  D024     BRA 0xC028
850:                   --i;
1BFE0  50E1     MOVF 0xFE1, W, ACCESS
1BFE2  0FF9     ADDLW 0xF9
1BFE4  6ED9     MOVWF 0xFD9, ACCESS
1BFE6  50E2     MOVF 0xFE2, W, ACCESS
1BFE8  6EDA     MOVWF __end_of_UART2_tx_vect_isr, ACCESS
1BFEA  0EFF     MOVLW 0xFF
1BFEC  22DA     ADDWFC __end_of_UART2_tx_vect_isr, F, ACCESS
1BFEE  06DE     DECF 0xFDE, F, ACCESS
1BFF0  0E00     MOVLW 0x0
1BFF2  5ADD     SUBWFB 0xFDD, F, ACCESS
851:                   dbuf[i] = '0';
1BFF4  0EF9     MOVLW 0xF9
1BFF6  0061     MOVFFL PLUSW1, wtemp5
1BFF8  F38C     NOP
1BFFA  F50B     NOP
1BFFC  0EFA     MOVLW 0xFA
1BFFE  0061     MOVFFL PLUSW1, 0x50C
1C000  F38C     NOP
1C002  F50C     NOP
1C004  0EA5     MOVLW 0xA5
1C006  240B     ADDWF 0xB, W, ACCESS
1C008  6ED9     MOVWF 0xFD9, ACCESS
1C00A  0E08     MOVLW 0x8
1C00C  200C     ADDWFC 0xC, W, ACCESS
1C00E  6EDA     MOVWF __end_of_UART2_tx_vect_isr, ACCESS
1C010  0E30     MOVLW 0x30
1C012  6EDF     MOVWF 0xFDF, ACCESS
852:                   --w;
1C014  50E1     MOVF 0xFE1, W, ACCESS
1C016  0FFB     ADDLW 0xFB
1C018  6ED9     MOVWF 0xFD9, ACCESS
1C01A  50E2     MOVF 0xFE2, W, ACCESS
1C01C  6EDA     MOVWF __end_of_UART2_tx_vect_isr, ACCESS
1C01E  0EFF     MOVLW 0xFF
1C020  22DA     ADDWFC __end_of_UART2_tx_vect_isr, F, ACCESS
1C022  06DE     DECF 0xFDE, F, ACCESS
1C024  0E00     MOVLW 0x0
1C026  5ADD     SUBWFB 0xFDD, F, ACCESS
853:               }
854:           #endif
855:           
856:               /* Put out padded string */
857:               return _COUNT_CAST pad(fp, &dbuf[i], w);
1C028  0EFB     MOVLW 0xFB
1C02A  C4E3     MOVFF PLUSW1, POSTINC1
1C02C  F4E6     NOP
1C02E  C4E3     MOVFF PLUSW1, POSTINC1
1C030  F4E6     NOP
1C032  0EA5     MOVLW 0xA5
1C034  6E0B     MOVWF 0xB, ACCESS
1C036  0E08     MOVLW 0x8
1C038  6E0C     MOVWF 0xC, ACCESS
1C03A  0EF7     MOVLW 0xF7
1C03C  50E3     MOVF 0xFE3, W, ACCESS
1C03E  260B     ADDWF 0xB, F, ACCESS
1C040  0EF8     MOVLW 0xF8
1C042  50E3     MOVF 0xFE3, W, ACCESS
1C044  220C     ADDWFC 0xC, F, ACCESS
1C046  0061     MOVFFL wtemp5, POSTINC1
1C048  F42C     NOP
1C04A  F4E6     NOP
1C04C  0061     MOVFFL 0x50C, POSTINC1
1C04E  F430     NOP
1C050  F4E6     NOP
1C052  0EF3     MOVLW 0xF3
1C054  C4E3     MOVFF PLUSW1, POSTINC1
1C056  F4E6     NOP
1C058  C4E3     MOVFF PLUSW1, POSTINC1
1C05A  F4E6     NOP
1C05C  ECA3     CALL 0x1EF46, 0
1C05E  F0F7     NOP
858:           }
1C060  0EF3     MOVLW 0xF3
1C060  0EF3     MOVLW 0xF3
1C060  0EF3     MOVLW 0xF3
1C060  0EF3     MOVLW 0xF3
1C060  0EF3     MOVLW 0xF3
859:           #endif
860:           
861:           #ifdef _VFPF_S
862:           static _INLINE _COUNT_TYPE stoa(FILE *fp, char *s)
1B324  0E11     MOVLW 0x11
1B326  26E1     ADDWF 0xFE1, F, ACCESS
1B328  0E00     MOVLW 0x0
1B32A  22E2     ADDWFC 0xFE2, F, ACCESS
863:           {
864:               char *cp, nuls[] = "(null)";
1B32C  EE21     LFSR 2, 0x7C9
1B32E  F3C9     NOP
1B330  0E07     MOVLW 0x7
1B332  6E01     MOVWF __ptext283, ACCESS
1B334  0EEF     MOVLW 0xEF
1B336  C4DE     MOVFF POSTINC2, PLUSW1
1B338  F4E3     NOP
1B33A  28E8     INCF 0xFE8, W, ACCESS
1B33C  2E01     DECFSZ __ptext283, F, ACCESS
1B33E  D7FB     BRA 0xB336
865:               int i, l, p, w;
866:           
867:               /* Check for null string */
868:               cp = s;
1B340  0EEB     MOVLW 0xEB
1B342  0061     MOVFFL PLUSW1, wtemp5
1B344  F38C     NOP
1B346  F50B     NOP
1B348  0EEC     MOVLW 0xEC
1B34A  0061     MOVFFL PLUSW1, 0x50C
1B34C  F38C     NOP
1B34E  F50C     NOP
1B350  0EFB     MOVLW 0xFB
1B352  0061     MOVFFL 0x50C, PLUSW1
1B354  F430     NOP
1B356  F4E3     NOP
1B358  0EFA     MOVLW 0xFA
1B35A  0061     MOVFFL wtemp5, PLUSW1
1B35C  F42C     NOP
1B35E  F4E3     NOP
869:               if (!cp) {
1B360  0EFA     MOVLW 0xFA
1B362  0061     MOVFFL PLUSW1, ltemp0
1B364  F38C     NOP
1B366  F501     NOP
1B368  0EFB     MOVLW 0xFB
1B36A  50E3     MOVF 0xFE3, W, ACCESS
1B36C  1001     IORWF __ptext283, W, ACCESS
1B36E  A4D8     BTFSS 0xFD8, 2, ACCESS
1B370  D00E     BRA 0xB38E
870:                   cp = nuls;
1B372  0EEF     MOVLW 0xEF
1B374  24E1     ADDWF 0xFE1, W, ACCESS
1B376  6E0B     MOVWF 0xB, ACCESS
1B378  0EFF     MOVLW 0xFF
1B37A  20E2     ADDWFC 0xFE2, W, ACCESS
1B37C  6E0C     MOVWF 0xC, ACCESS
1B37E  0EFB     MOVLW 0xFB
1B380  0061     MOVFFL 0x50C, PLUSW1
1B382  F430     NOP
1B384  F4E3     NOP
1B386  0EFA     MOVLW 0xFA
1B388  0061     MOVFFL wtemp5, PLUSW1
1B38A  F42C     NOP
1B38C  F4E3     NOP
871:               }
872:           
873:               /* Get length, precision, width */
874:               l = (int)strlen(cp);
1B38E  0EFA     MOVLW 0xFA
1B390  C4E3     MOVFF PLUSW1, POSTINC1
1B392  F4E6     NOP
1B394  C4E3     MOVFF PLUSW1, POSTINC1
1B396  F4E6     NOP
1B398  ECC2     CALL 0x384, 0
1B39A  F001     NOP
1B39C  0EF6     MOVLW 0xF6
1B39E  0061     MOVFFL ltemp0, PLUSW1
1B3A0  F404     NOP
1B3A2  F4E3     NOP
1B3A4  0EF7     MOVLW 0xF7
1B3A6  0061     MOVFFL ttemp5, PLUSW1
1B3A8  F408     NOP
1B3AA  F4E3     NOP
875:               p = prec;
1B3AC  0EF8     MOVLW 0xF8
1B3AE  C523     MOVFF prec, PLUSW1
1B3B0  F4E3     NOP
1B3B2  0EF9     MOVLW 0xF9
1B3B4  C524     MOVFF 0x524, PLUSW1
1B3B6  F4E3     NOP
876:               l = (!(p < 0) && (p < l)) ? p : l;
1B3B8  0EF9     MOVLW 0xF9
1B3BA  BEE3     BTFSC 0xFE3, 7, ACCESS
1B3BC  D023     BRA 0xB404
1B3BE  50E1     MOVF 0xFE1, W, ACCESS
1B3C0  0FF8     ADDLW 0xF8
1B3C2  6ED9     MOVWF 0xFD9, ACCESS
1B3C4  50E2     MOVF 0xFE2, W, ACCESS
1B3C6  6EDA     MOVWF __end_of_UART2_tx_vect_isr, ACCESS
1B3C8  0EFF     MOVLW 0xFF
1B3CA  22DA     ADDWFC __end_of_UART2_tx_vect_isr, F, ACCESS
1B3CC  0EF6     MOVLW 0xF6
1B3CE  50E3     MOVF 0xFE3, W, ACCESS
1B3D0  5CDE     SUBWF 0xFDE, W, ACCESS
1B3D2  50DE     MOVF 0xFDE, W, ACCESS
1B3D4  0A80     XORLW 0x80
1B3D6  6E01     MOVWF __ptext283, ACCESS
1B3D8  0EF7     MOVLW 0xF7
1B3DA  50E3     MOVF 0xFE3, W, ACCESS
1B3DC  0A80     XORLW 0x80
1B3DE  5801     SUBWFB __ptext283, W, ACCESS
1B3E0  B0D8     BTFSC 0xFD8, 0, ACCESS
1B3E2  D010     BRA 0xB404
1B3E4  0EF8     MOVLW 0xF8
1B3E6  0061     MOVFFL PLUSW1, ltemp0
1B3E8  F38C     NOP
1B3EA  F501     NOP
1B3EC  0EF6     MOVLW 0xF6
1B3EE  0061     MOVFFL ltemp0, PLUSW1
1B3F0  F404     NOP
1B3F2  F4E3     NOP
1B3F4  0EF9     MOVLW 0xF9
1B3F6  0061     MOVFFL PLUSW1, ltemp0
1B3F8  F38C     NOP
1B3FA  F501     NOP
1B3FC  0EF7     MOVLW 0xF7
1B3FE  0061     MOVFFL ltemp0, PLUSW1
1B400  F404     NOP
1B402  F4E3     NOP
877:               p = l;
1B404  0EF6     MOVLW 0xF6
1B406  0061     MOVFFL PLUSW1, ltemp0
1B408  F38C     NOP
1B40A  F501     NOP
1B40C  0EF8     MOVLW 0xF8
1B40E  0061     MOVFFL ltemp0, PLUSW1
1B410  F404     NOP
1B412  F4E3     NOP
1B414  0EF7     MOVLW 0xF7
1B416  0061     MOVFFL PLUSW1, ltemp0
1B418  F38C     NOP
1B41A  F501     NOP
1B41C  0EF9     MOVLW 0xF9
1B41E  0061     MOVFFL ltemp0, PLUSW1
1B420  F404     NOP
1B422  F4E3     NOP
878:               w = width;
1B424  0EFC     MOVLW 0xFC
1B426  C521     MOVFF width, PLUSW1
1B428  F4E3     NOP
1B42A  0EFD     MOVLW 0xFD
1B42C  C522     MOVFF 0x522, PLUSW1
1B42E  F4E3     NOP
879:           
880:               /* Right justify, pad on left ? */
881:           #if defined(_VFPF_LEFT) || defined(_VFPF_WIDTH)
882:               if (!(flags & MINUS_FLAG)) {
1B430  A027     BTFSS 0x27, 0, ACCESS
1B432  D01D     BRA 0xB46E
1B434  D02F     BRA 0xB494
883:           #endif
884:                   while (l < w) {
1B46E  50E1     MOVF 0xFE1, W, ACCESS
1B470  0FF6     ADDLW 0xF6
1B472  6ED9     MOVWF 0xFD9, ACCESS
1B474  50E2     MOVF 0xFE2, W, ACCESS
1B476  6EDA     MOVWF __end_of_UART2_tx_vect_isr, ACCESS
1B478  0EFF     MOVLW 0xFF
1B47A  22DA     ADDWFC __end_of_UART2_tx_vect_isr, F, ACCESS
1B47C  0EFC     MOVLW 0xFC
1B47E  50E3     MOVF 0xFE3, W, ACCESS
1B480  5CDE     SUBWF 0xFDE, W, ACCESS
1B482  50DE     MOVF 0xFDE, W, ACCESS
1B484  0A80     XORLW 0x80
1B486  6E01     MOVWF __ptext283, ACCESS
1B488  0EFD     MOVLW 0xFD
1B48A  50E3     MOVF 0xFE3, W, ACCESS
1B48C  0A80     XORLW 0x80
1B48E  5801     SUBWFB __ptext283, W, ACCESS
1B490  A0D8     BTFSS 0xFD8, 0, ACCESS
1B492  D7D1     BRA 0xB436
885:                       fputc(' ', fp);
1B436  0EED     MOVLW 0xED
1B438  C4E3     MOVFF PLUSW1, POSTINC1
1B43A  F4E6     NOP
1B43C  C4E3     MOVFF PLUSW1, POSTINC1
1B43E  F4E6     NOP
1B440  0E20     MOVLW 0x20
1B442  6EE6     MOVWF 0xFE6, ACCESS
1B444  0E00     MOVLW 0x0
1B446  6EE6     MOVWF 0xFE6, ACCESS
1B448  ECCB     CALL 0x1DF96, 0
1B44A  F0EF     NOP
886:                       ++l;
1B44C  0EF6     MOVLW 0xF6
1B44E  50E3     MOVF 0xFE3, W, ACCESS
1B450  0F01     ADDLW 0x1
1B452  6E01     MOVWF __ptext283, ACCESS
1B454  0EF6     MOVLW 0xF6
1B456  0061     MOVFFL ltemp0, PLUSW1
1B458  F404     NOP
1B45A  F4E3     NOP
1B45C  6A01     CLRF __ptext283, ACCESS
1B45E  0EF7     MOVLW 0xF7
1B460  50E3     MOVF 0xFE3, W, ACCESS
1B462  2001     ADDWFC __ptext283, W, ACCESS
1B464  6E01     MOVWF __ptext283, ACCESS
1B466  0EF7     MOVLW 0xF7
1B468  0061     MOVFFL ltemp0, PLUSW1
1B46A  F404     NOP
1B46C  F4E3     NOP
887:                   }
888:           #if defined(_VFPF_LEFT) || defined(_VFPF_WIDTH)
889:               }
890:           #endif
891:           
892:               /* Put out string */
893:               i = 0;
1B494  0EFE     MOVLW 0xFE
1B496  6AE3     CLRF 0xFE3, ACCESS
1B498  0EFF     MOVLW 0xFF
1B49A  6AE3     CLRF 0xFE3, ACCESS
894:               while (i < p) {
1B49C  D03F     BRA 0xB51C
1B51C  50E1     MOVF 0xFE1, W, ACCESS
1B51E  0FFE     ADDLW 0xFE
1B520  6ED9     MOVWF 0xFD9, ACCESS
1B522  50E2     MOVF 0xFE2, W, ACCESS
1B524  6EDA     MOVWF __end_of_UART2_tx_vect_isr, ACCESS
1B526  0EFF     MOVLW 0xFF
1B528  22DA     ADDWFC __end_of_UART2_tx_vect_isr, F, ACCESS
1B52A  0EF8     MOVLW 0xF8
1B52C  50E3     MOVF 0xFE3, W, ACCESS
1B52E  5CDE     SUBWF 0xFDE, W, ACCESS
1B530  50DE     MOVF 0xFDE, W, ACCESS
1B532  0A80     XORLW 0x80
1B534  6E01     MOVWF __ptext283, ACCESS
1B536  0EF9     MOVLW 0xF9
1B538  50E3     MOVF 0xFE3, W, ACCESS
1B53A  0A80     XORLW 0x80
1B53C  5801     SUBWFB __ptext283, W, ACCESS
1B53E  A0D8     BTFSS 0xFD8, 0, ACCESS
1B540  D7AE     BRA 0xB49E
895:                   fputc(*cp, fp);
1B49E  0EED     MOVLW 0xED
1B4A0  C4E3     MOVFF PLUSW1, POSTINC1
1B4A2  F4E6     NOP
1B4A4  C4E3     MOVFF PLUSW1, POSTINC1
1B4A6  F4E6     NOP
1B4A8  0EF8     MOVLW 0xF8
1B4AA  C4E3     MOVFF PLUSW1, TBLPTR
1B4AC  F4F6     NOP
1B4AE  0EF9     MOVLW 0xF9
1B4B0  C4E3     MOVFF PLUSW1, TBLPTRH
1B4B2  F4F7     NOP
1B4B4  0E00     MOVLW 0x0
1B4B6  6EF8     MOVWF 0xFF8, ACCESS
1B4B8  0E3F     MOVLW 0x3F
1B4BA  64F7     CPFSGT 0xFF7, ACCESS
1B4BC  D003     BRA 0xB4C4
1B4BE  0008     TBLRD*
1B4C0  50F5     MOVF 0xFF5, W, ACCESS
1B4C2  D005     BRA 0xB4CE
1B4C4  C4F6     MOVFF TBLPTR, FSR0
1B4C6  F4E9     NOP
1B4C8  C4F7     MOVFF TBLPTRH, FSR0H
1B4CA  F4EA     NOP
1B4CC  50EF     MOVF 0xFEF, W, ACCESS
1B4CE  6EE6     MOVWF 0xFE6, ACCESS
1B4D0  0E00     MOVLW 0x0
1B4D2  6EE6     MOVWF 0xFE6, ACCESS
1B4D4  ECCB     CALL 0x1DF96, 0
1B4D6  F0EF     NOP
896:                   ++cp;
1B4D8  0EFA     MOVLW 0xFA
1B4DA  50E3     MOVF 0xFE3, W, ACCESS
1B4DC  0F01     ADDLW 0x1
1B4DE  6E01     MOVWF __ptext283, ACCESS
1B4E0  0EFA     MOVLW 0xFA
1B4E2  0061     MOVFFL ltemp0, PLUSW1
1B4E4  F404     NOP
1B4E6  F4E3     NOP
1B4E8  6A01     CLRF __ptext283, ACCESS
1B4EA  0EFB     MOVLW 0xFB
1B4EC  50E3     MOVF 0xFE3, W, ACCESS
1B4EE  2001     ADDWFC __ptext283, W, ACCESS
1B4F0  6E01     MOVWF __ptext283, ACCESS
1B4F2  0EFB     MOVLW 0xFB
1B4F4  0061     MOVFFL ltemp0, PLUSW1
1B4F6  F404     NOP
1B4F8  F4E3     NOP
897:                   ++i;
1B4FA  0EFE     MOVLW 0xFE
1B4FC  50E3     MOVF 0xFE3, W, ACCESS
1B4FE  0F01     ADDLW 0x1
1B500  6E01     MOVWF __ptext283, ACCESS
1B502  0EFE     MOVLW 0xFE
1B504  0061     MOVFFL ltemp0, PLUSW1
1B506  F404     NOP
1B508  F4E3     NOP
1B50A  6A01     CLRF __ptext283, ACCESS
1B50C  0EFF     MOVLW 0xFF
1B50E  50E3     MOVF 0xFE3, W, ACCESS
1B510  2001     ADDWFC __ptext283, W, ACCESS
1B512  6E01     MOVWF __ptext283, ACCESS
1B514  0EFF     MOVLW 0xFF
1B516  0061     MOVFFL ltemp0, PLUSW1
1B518  F404     NOP
1B51A  F4E3     NOP
898:               }
899:           
900:           #if defined(_VFPF_LEFT) || defined(_VFPF_WIDTH)
901:               /* Left justify, pad on right ? */
902:               if (flags & MINUS_FLAG) {
1B542  B027     BTFSC 0x27, 0, ACCESS
1B544  D01D     BRA 0xB580
1B546  D02F     BRA 0xB5A6
903:                   while (l < w) {
1B580  50E1     MOVF 0xFE1, W, ACCESS
1B582  0FF6     ADDLW 0xF6
1B584  6ED9     MOVWF 0xFD9, ACCESS
1B586  50E2     MOVF 0xFE2, W, ACCESS
1B588  6EDA     MOVWF __end_of_UART2_tx_vect_isr, ACCESS
1B58A  0EFF     MOVLW 0xFF
1B58C  22DA     ADDWFC __end_of_UART2_tx_vect_isr, F, ACCESS
1B58E  0EFC     MOVLW 0xFC
1B590  50E3     MOVF 0xFE3, W, ACCESS
1B592  5CDE     SUBWF 0xFDE, W, ACCESS
1B594  50DE     MOVF 0xFDE, W, ACCESS
1B596  0A80     XORLW 0x80
1B598  6E01     MOVWF __ptext283, ACCESS
1B59A  0EFD     MOVLW 0xFD
1B59C  50E3     MOVF 0xFE3, W, ACCESS
1B59E  0A80     XORLW 0x80
1B5A0  5801     SUBWFB __ptext283, W, ACCESS
1B5A2  A0D8     BTFSS 0xFD8, 0, ACCESS
1B5A4  D7D1     BRA 0xB548
904:                       fputc(' ', fp);
1B548  0EED     MOVLW 0xED
1B54A  C4E3     MOVFF PLUSW1, POSTINC1
1B54C  F4E6     NOP
1B54E  C4E3     MOVFF PLUSW1, POSTINC1
1B550  F4E6     NOP
1B552  0E20     MOVLW 0x20
1B554  6EE6     MOVWF 0xFE6, ACCESS
1B556  0E00     MOVLW 0x0
1B558  6EE6     MOVWF 0xFE6, ACCESS
1B55A  ECCB     CALL 0x1DF96, 0
1B55C  F0EF     NOP
905:                       ++l;
1B55E  0EF6     MOVLW 0xF6
1B560  50E3     MOVF 0xFE3, W, ACCESS
1B562  0F01     ADDLW 0x1
1B564  6E01     MOVWF __ptext283, ACCESS
1B566  0EF6     MOVLW 0xF6
1B568  0061     MOVFFL ltemp0, PLUSW1
1B56A  F404     NOP
1B56C  F4E3     NOP
1B56E  6A01     CLRF __ptext283, ACCESS
1B570  0EF7     MOVLW 0xF7
1B572  50E3     MOVF 0xFE3, W, ACCESS
1B574  2001     ADDWFC __ptext283, W, ACCESS
1B576  6E01     MOVWF __ptext283, ACCESS
1B578  0EF7     MOVLW 0xF7
1B57A  0061     MOVFFL ltemp0, PLUSW1
1B57C  F404     NOP
1B57E  F4E3     NOP
906:                   }
907:               }
908:           #endif
909:           
910:           #ifdef _VFPF_COUNT_CHARS
911:               return l;
1B5A6  0EF6     MOVLW 0xF6
1B5A8  0061     MOVFFL PLUSW1, ltemp0
1B5AA  F38C     NOP
1B5AC  F501     NOP
1B5AE  0EF7     MOVLW 0xF7
1B5B0  0061     MOVFFL PLUSW1, ttemp5
1B5B2  F38C     NOP
1B5B4  F502     NOP
912:           #endif
913:           }
1B5B6  0EEB     MOVLW 0xEB
1B5B6  0EEB     MOVLW 0xEB
1B5B6  0EEB     MOVLW 0xEB
1B5B6  0EEB     MOVLW 0xEB
1B5B6  0EEB     MOVLW 0xEB
914:           #endif
915:           
916:           #ifdef _VFPF_U
917:           static _INLINE _COUNT_TYPE utoa(FILE *fp, vfpf_uint_t d)
1C9D0  0E06     MOVLW 0x6
1C9D2  26E1     ADDWF 0xFE1, F, ACCESS
1C9D4  0E00     MOVLW 0x0
1C9D6  22E2     ADDWFC 0xFE2, F, ACCESS
918:           {
919:               int i, p, w;
920:           
921:               /* Adjust flags, precision, width */
922:           #ifdef _VFPF_FILL
923:               if (!(prec < 0)) {
1C9D8  AE24     BTFSS 0x24, 7, ACCESS
924:                   flags &= ~ZERO_FLAG;
1C9DA  9227     BCF 0x27, 1, ACCESS
925:               }
926:           #endif
927:               p = (0 <= prec) ? prec : 1;
1C9DC  AE24     BTFSS 0x24, 7, ACCESS
1C9DE  D00D     BRA 0xC9FA
1C9E0  0E01     MOVLW 0x1
1C9E2  6E0B     MOVWF 0xB, ACCESS
1C9E4  0E00     MOVLW 0x0
1C9E6  6E0C     MOVWF 0xC, ACCESS
1C9E8  0EFE     MOVLW 0xFE
1C9EA  0061     MOVFFL wtemp5, PLUSW1
1C9EC  F42C     NOP
1C9EE  F4E3     NOP
1C9F0  0EFF     MOVLW 0xFF
1C9F2  0061     MOVFFL 0x50C, PLUSW1
1C9F4  F430     NOP
1C9F6  F4E3     NOP
1C9F8  D006     BRA 0xCA06
1C9FA  0EFE     MOVLW 0xFE
1C9FC  C523     MOVFF prec, PLUSW1
1C9FE  F4E3     NOP
1CA00  0EFF     MOVLW 0xFF
1CA02  C524     MOVFF 0x524, PLUSW1
1CA04  F4E3     NOP
928:               w = width;
1CA06  0EFC     MOVLW 0xFC
1CA08  C521     MOVFF width, PLUSW1
1CA0A  F4E3     NOP
1CA0C  0EFD     MOVLW 0xFD
1CA0E  C522     MOVFF 0x522, PLUSW1
1CA10  F4E3     NOP
929:           
930:               /* Convert to decimal, possibly filling on the left with zeroes */
931:               i = sizeof(dbuf) - 1;
1CA12  0E4F     MOVLW 0x4F
1CA14  6E0B     MOVWF 0xB, ACCESS
1CA16  0E00     MOVLW 0x0
1CA18  6E0C     MOVWF 0xC, ACCESS
1CA1A  0EFA     MOVLW 0xFA
1CA1C  0061     MOVFFL wtemp5, PLUSW1
1CA1E  F42C     NOP
1CA20  F4E3     NOP
1CA22  0EFB     MOVLW 0xFB
1CA24  0061     MOVFFL 0x50C, PLUSW1
1CA26  F430     NOP
1CA28  F4E3     NOP
932:               dbuf[i] = '\0';
1CA2A  0108     MOVLB 0x8
1CA2C  6BF4     CLRF DMAnSPTR, BANKED
933:               while (i && (d || (0 < p)
1CA2E  D06A     BRA 0xCB04
1CB04  0EFA     MOVLW 0xFA
1CB06  0061     MOVFFL PLUSW1, ltemp0
1CB08  F38C     NOP
1CB0A  F501     NOP
1CB0C  0EFB     MOVLW 0xFB
1CB0E  50E3     MOVF 0xFE3, W, ACCESS
1CB10  1001     IORWF __ptext283, W, ACCESS
1CB12  B4D8     BTFSC 0xFD8, 2, ACCESS
1CB14  D023     BRA 0xCB5C
1CB16  0EF4     MOVLW 0xF4
1CB18  50E3     MOVF 0xFE3, W, ACCESS
1CB1A  E18A     BNZ 0xCA30
1CB1C  0EF5     MOVLW 0xF5
1CB1E  50E3     MOVF 0xFE3, W, ACCESS
1CB20  E187     BNZ 0xCA30
1CB22  0EF6     MOVLW 0xF6
1CB24  50E3     MOVF 0xFE3, W, ACCESS
1CB26  E184     BNZ 0xCA30
1CB28  0EF7     MOVLW 0xF7
1CB2A  50E3     MOVF 0xFE3, W, ACCESS
1CB2C  A4D8     BTFSS 0xFD8, 2, ACCESS
1CB2E  D780     BRA 0xCA30
1CB30  0EFF     MOVLW 0xFF
1CB32  BEE3     BTFSC 0xFE3, 7, ACCESS
1CB34  D007     BRA 0xCB44
1CB36  0EFF     MOVLW 0xFF
1CB38  50E3     MOVF 0xFE3, W, ACCESS
1CB3A  E103     BNZ 0xCB42
1CB3C  0EFE     MOVLW 0xFE
1CB3E  04E3     DECF 0xFE3, W, ACCESS
1CB40  B0D8     BTFSC 0xFD8, 0, ACCESS
1CB42  D776     BRA 0xCA30
1CB44  0EFD     MOVLW 0xFD
1CB46  BEE3     BTFSC 0xFE3, 7, ACCESS
1CB48  D009     BRA 0xCB5C
1CB4A  0EFD     MOVLW 0xFD
1CB4C  50E3     MOVF 0xFE3, W, ACCESS
1CB4E  E104     BNZ 0xCB58
1CB50  0EFC     MOVLW 0xFC
1CB52  04E3     DECF 0xFE3, W, ACCESS
1CB54  A0D8     BTFSS 0xFD8, 0, ACCESS
1CB56  D002     BRA 0xCB5C
1CB58  B227     BTFSC 0x27, 1, ACCESS
1CB5A  D76A     BRA 0xCA30
934:           #ifdef _VFPF_FILL
935:           				|| ((0 < w) && (flags & ZERO_FLAG))
936:           #endif
937:           				)) {
938:                   --i;
1CA30  50E1     MOVF 0xFE1, W, ACCESS
1CA32  0FFA     ADDLW 0xFA
1CA34  6ED9     MOVWF 0xFD9, ACCESS
1CA36  50E2     MOVF 0xFE2, W, ACCESS
1CA38  6EDA     MOVWF __end_of_UART2_tx_vect_isr, ACCESS
1CA3A  0EFF     MOVLW 0xFF
1CA3C  22DA     ADDWFC __end_of_UART2_tx_vect_isr, F, ACCESS
1CA3E  06DE     DECF 0xFDE, F, ACCESS
1CA40  0E00     MOVLW 0x0
1CA42  5ADD     SUBWFB 0xFDD, F, ACCESS
939:                   dbuf[i] = '0' + (d % 10);
1CA44  0E0A     MOVLW 0xA
1CA46  6EE6     MOVWF 0xFE6, ACCESS
1CA48  0E00     MOVLW 0x0
1CA4A  6EE6     MOVWF 0xFE6, ACCESS
1CA4C  0E00     MOVLW 0x0
1CA4E  6EE6     MOVWF 0xFE6, ACCESS
1CA50  0E00     MOVLW 0x0
1CA52  6EE6     MOVWF 0xFE6, ACCESS
1CA54  0EF0     MOVLW 0xF0
1CA56  C4E3     MOVFF PLUSW1, POSTINC1
1CA58  F4E6     NOP
1CA5A  C4E3     MOVFF PLUSW1, POSTINC1
1CA5C  F4E6     NOP
1CA5E  C4E3     MOVFF PLUSW1, POSTINC1
1CA60  F4E6     NOP
1CA62  C4E3     MOVFF PLUSW1, POSTINC1
1CA64  F4E6     NOP
1CA66  ECE7     CALL 0x1F5CE, 0
1CA68  F0FA     NOP
1CA6A  0061     MOVFFL ltemp0, 0x50C
1CA6C  F404     NOP
1CA6E  F50C     NOP
1CA70  0E30     MOVLW 0x30
1CA72  260C     ADDWF 0xC, F, ACCESS
1CA74  0EFA     MOVLW 0xFA
1CA76  0061     MOVFFL PLUSW1, ltemp2
1CA78  F38C     NOP
1CA7A  F509     NOP
1CA7C  0EFB     MOVLW 0xFB
1CA7E  0061     MOVFFL PLUSW1, ttemp3
1CA80  F38C     NOP
1CA82  F50A     NOP
1CA84  0EA5     MOVLW 0xA5
1CA86  2409     ADDWF 0x9, W, ACCESS
1CA88  6ED9     MOVWF 0xFD9, ACCESS
1CA8A  0E08     MOVLW 0x8
1CA8C  200A     ADDWFC 0xA, W, ACCESS
1CA8E  6EDA     MOVWF __end_of_UART2_tx_vect_isr, ACCESS
1CA90  0061     MOVFFL 0x50C, INDF2
1CA92  F430     NOP
1CA94  F4DF     NOP
940:                   --p;
1CA96  50E1     MOVF 0xFE1, W, ACCESS
1CA98  0FFE     ADDLW 0xFE
1CA9A  6ED9     MOVWF 0xFD9, ACCESS
1CA9C  50E2     MOVF 0xFE2, W, ACCESS
1CA9E  6EDA     MOVWF __end_of_UART2_tx_vect_isr, ACCESS
1CAA0  0EFF     MOVLW 0xFF
1CAA2  22DA     ADDWFC __end_of_UART2_tx_vect_isr, F, ACCESS
1CAA4  06DE     DECF 0xFDE, F, ACCESS
1CAA6  0E00     MOVLW 0x0
1CAA8  5ADD     SUBWFB 0xFDD, F, ACCESS
941:                   --w;
1CAAA  50E1     MOVF 0xFE1, W, ACCESS
1CAAC  0FFC     ADDLW 0xFC
1CAAE  6ED9     MOVWF 0xFD9, ACCESS
1CAB0  50E2     MOVF 0xFE2, W, ACCESS
1CAB2  6EDA     MOVWF __end_of_UART2_tx_vect_isr, ACCESS
1CAB4  0EFF     MOVLW 0xFF
1CAB6  22DA     ADDWFC __end_of_UART2_tx_vect_isr, F, ACCESS
1CAB8  06DE     DECF 0xFDE, F, ACCESS
1CABA  0E00     MOVLW 0x0
1CABC  5ADD     SUBWFB 0xFDD, F, ACCESS
942:                   d = d / 10;
1CABE  0E0A     MOVLW 0xA
1CAC0  6EE6     MOVWF 0xFE6, ACCESS
1CAC2  0E00     MOVLW 0x0
1CAC4  6EE6     MOVWF 0xFE6, ACCESS
1CAC6  0E00     MOVLW 0x0
1CAC8  6EE6     MOVWF 0xFE6, ACCESS
1CACA  0E00     MOVLW 0x0
1CACC  6EE6     MOVWF 0xFE6, ACCESS
1CACE  0EF0     MOVLW 0xF0
1CAD0  C4E3     MOVFF PLUSW1, POSTINC1
1CAD2  F4E6     NOP
1CAD4  C4E3     MOVFF PLUSW1, POSTINC1
1CAD6  F4E6     NOP
1CAD8  C4E3     MOVFF PLUSW1, POSTINC1
1CADA  F4E6     NOP
1CADC  C4E3     MOVFF PLUSW1, POSTINC1
1CADE  F4E6     NOP
1CAE0  EC8F     CALL 0x1E71E, 0
1CAE2  F0F3     NOP
1CAE4  0EF4     MOVLW 0xF4
1CAE6  0061     MOVFFL ltemp0, PLUSW1
1CAE8  F404     NOP
1CAEA  F4E3     NOP
1CAEC  0EF5     MOVLW 0xF5
1CAEE  0061     MOVFFL ttemp5, PLUSW1
1CAF0  F408     NOP
1CAF2  F4E3     NOP
1CAF4  0EF6     MOVLW 0xF6
1CAF6  0061     MOVFFL wtemp1, PLUSW1
1CAF8  F40C     NOP
1CAFA  F4E3     NOP
1CAFC  0EF7     MOVLW 0xF7
1CAFE  0061     MOVFFL ttemp1, PLUSW1
1CB00  F410     NOP
1CB02  F4E3     NOP
943:               }
944:           
945:               /* Put out padded string */
946:               return _COUNT_CAST pad(fp, &dbuf[i], w);
1CB5C  0EFC     MOVLW 0xFC
1CB5E  C4E3     MOVFF PLUSW1, POSTINC1
1CB60  F4E6     NOP
1CB62  C4E3     MOVFF PLUSW1, POSTINC1
1CB64  F4E6     NOP
1CB66  0EA5     MOVLW 0xA5
1CB68  6E0B     MOVWF 0xB, ACCESS
1CB6A  0E08     MOVLW 0x8
1CB6C  6E0C     MOVWF 0xC, ACCESS
1CB6E  0EF8     MOVLW 0xF8
1CB70  50E3     MOVF 0xFE3, W, ACCESS
1CB72  260B     ADDWF 0xB, F, ACCESS
1CB74  0EF9     MOVLW 0xF9
1CB76  50E3     MOVF 0xFE3, W, ACCESS
1CB78  220C     ADDWFC 0xC, F, ACCESS
1CB7A  0061     MOVFFL wtemp5, POSTINC1
1CB7C  F42C     NOP
1CB7E  F4E6     NOP
1CB80  0061     MOVFFL 0x50C, POSTINC1
1CB82  F430     NOP
1CB84  F4E6     NOP
1CB86  0EF4     MOVLW 0xF4
1CB88  C4E3     MOVFF PLUSW1, POSTINC1
1CB8A  F4E6     NOP
1CB8C  C4E3     MOVFF PLUSW1, POSTINC1
1CB8E  F4E6     NOP
1CB90  ECA3     CALL 0x1EF46, 0
1CB92  F0F7     NOP
947:           }
1CB94  0EF4     MOVLW 0xF4
1CB94  0EF4     MOVLW 0xF4
1CB94  0EF4     MOVLW 0xF4
1CB94  0EF4     MOVLW 0xF4
1CB94  0EF4     MOVLW 0xF4
948:           #endif
949:           
950:           #if defined(_VFPF_HEX_CONV) || defined(_VFPF_P)
951:           #if defined(_VFPF_X) && (defined(_VFPF_x) || defined(_VFPF_P))
952:           static _INLINE _COUNT_TYPE xtoa(FILE *fp, vfpf_uint_t d, char x)
1A4AA  0E0A     MOVLW 0xA
1A4AC  26E1     ADDWF 0xFE1, F, ACCESS
1A4AE  0E00     MOVLW 0x0
1A4B0  22E2     ADDWFC 0xFE2, F, ACCESS
953:           #define _XTOA(fp,d,x)	xtoa(fp,d,x)
954:           #else
955:           static _INLINE _COUNT_TYPE xtoa(FILE *fp, vfpf_uint_t d)
956:           #define _XTOA(fp,d,x)	xtoa(fp,d)
957:           #endif
958:           {
959:           	char c;
960:               int i, p, w;
961:           #if _VFPF_ALTERN
962:           	bool d_nonzero = false;
963:           #endif
964:           
965:               /* Adjust, flags, precision, width */
966:           #ifdef _VFPF_FILL
967:               if (!(prec < 0)) {
1A4B2  AE24     BTFSS 0x24, 7, ACCESS
968:                   flags &= ~ZERO_FLAG;
1A4B4  9227     BCF 0x27, 1, ACCESS
969:               }
970:           #endif
971:               p = (0 <= prec) ? prec : 1;
1A4B6  AE24     BTFSS 0x24, 7, ACCESS
1A4B8  D00D     BRA 0xA4D4
1A4BA  0E01     MOVLW 0x1
1A4BC  6E0B     MOVWF 0xB, ACCESS
1A4BE  0E00     MOVLW 0x0
1A4C0  6E0C     MOVWF 0xC, ACCESS
1A4C2  0EFC     MOVLW 0xFC
1A4C4  0061     MOVFFL wtemp5, PLUSW1
1A4C6  F42C     NOP
1A4C8  F4E3     NOP
1A4CA  0EFD     MOVLW 0xFD
1A4CC  0061     MOVFFL 0x50C, PLUSW1
1A4CE  F430     NOP
1A4D0  F4E3     NOP
1A4D2  D006     BRA 0xA4E0
1A4D4  0EFC     MOVLW 0xFC
1A4D6  C523     MOVFF prec, PLUSW1
1A4D8  F4E3     NOP
1A4DA  0EFD     MOVLW 0xFD
1A4DC  C524     MOVFF 0x524, PLUSW1
1A4DE  F4E3     NOP
972:               w = width;
1A4E0  0EFA     MOVLW 0xFA
1A4E2  C521     MOVFF width, PLUSW1
1A4E4  F4E3     NOP
1A4E6  0EFB     MOVLW 0xFB
1A4E8  C522     MOVFF 0x522, PLUSW1
1A4EA  F4E3     NOP
973:           #ifdef _VFPF_ALTERN
974:           	d_nonzero = d != 0;
1A4EC  0EF0     MOVLW 0xF0
1A4EE  50E3     MOVF 0xFE3, W, ACCESS
1A4F0  E10A     BNZ 0xA506
1A4F2  0EF1     MOVLW 0xF1
1A4F4  50E3     MOVF 0xFE3, W, ACCESS
1A4F6  E107     BNZ 0xA506
1A4F8  0EF2     MOVLW 0xF2
1A4FA  50E3     MOVF 0xFE3, W, ACCESS
1A4FC  E104     BNZ 0xA506
1A4FE  0EF3     MOVLW 0xF3
1A500  50E3     MOVF 0xFE3, W, ACCESS
1A502  B4D8     BTFSC 0xFD8, 2, ACCESS
1A504  D003     BRA 0xA50C
1A506  6A0C     CLRF 0xC, ACCESS
1A508  2A0C     INCF 0xC, F, ACCESS
1A50A  D001     BRA 0xA50E
1A50C  6A0C     CLRF 0xC, ACCESS
1A50E  0EFF     MOVLW 0xFF
1A510  0061     MOVFFL 0x50C, PLUSW1
1A512  F430     NOP
1A514  F4E3     NOP
975:               if ((flags & POUND_FLAG) && d_nonzero) {
1A516  A827     BTFSS 0x27, 4, ACCESS
1A518  D00F     BRA 0xA538
1A51A  0EFF     MOVLW 0xFF
1A51C  50E3     MOVF 0xFE3, W, ACCESS
1A51E  B4D8     BTFSC 0xFD8, 2, ACCESS
1A520  D00B     BRA 0xA538
976:                   w -= 2;
1A522  50E1     MOVF 0xFE1, W, ACCESS
1A524  0FFA     ADDLW 0xFA
1A526  6ED9     MOVWF 0xFD9, ACCESS
1A528  50E2     MOVF 0xFE2, W, ACCESS
1A52A  6EDA     MOVWF __end_of_UART2_tx_vect_isr, ACCESS
1A52C  0EFF     MOVLW 0xFF
1A52E  22DA     ADDWFC __end_of_UART2_tx_vect_isr, F, ACCESS
1A530  0EFE     MOVLW 0xFE
1A532  26DE     ADDWF 0xFDE, F, ACCESS
1A534  0EFF     MOVLW 0xFF
1A536  22DD     ADDWFC 0xFDD, F, ACCESS
977:               }
978:           #endif
979:           
980:               /* Convert to hexadecimal, possibly filling on the left with zeroes */
981:               i = sizeof(dbuf) - 1;
1A538  0E4F     MOVLW 0x4F
1A53A  6E0B     MOVWF 0xB, ACCESS
1A53C  0E00     MOVLW 0x0
1A53E  6E0C     MOVWF 0xC, ACCESS
1A540  0EF8     MOVLW 0xF8
1A542  0061     MOVFFL wtemp5, PLUSW1
1A544  F42C     NOP
1A546  F4E3     NOP
1A548  0EF9     MOVLW 0xF9
1A54A  0061     MOVFFL 0x50C, PLUSW1
1A54C  F430     NOP
1A54E  F4E3     NOP
982:               dbuf[i] = '\0';
1A550  0108     MOVLB 0x8
1A552  6BF4     CLRF DMAnSPTR, BANKED
983:               while (!(i < 2) && (d || (0 < p)
1A554  D0A2     BRA 0xA69A
1A69A  0EF9     MOVLW 0xF9
1A69C  BEE3     BTFSC 0xFE3, 7, ACCESS
1A69E  D02E     BRA 0xA6FC
1A6A0  0EF9     MOVLW 0xF9
1A6A2  50E3     MOVF 0xFE3, W, ACCESS
1A6A4  E108     BNZ 0xA6B6
1A6A6  0EF8     MOVLW 0xF8
1A6A8  0061     MOVFFL PLUSW1, ltemp0
1A6AA  F38C     NOP
1A6AC  F501     NOP
1A6AE  0E02     MOVLW 0x2
1A6B0  5E01     SUBWF __ptext283, F, ACCESS
1A6B2  A0D8     BTFSS 0xFD8, 0, ACCESS
1A6B4  D023     BRA 0xA6FC
1A6B6  0EF0     MOVLW 0xF0
1A6B8  50E3     MOVF 0xFE3, W, ACCESS
1A6BA  E109     BNZ 0xA6CE
1A6BC  0EF1     MOVLW 0xF1
1A6BE  50E3     MOVF 0xFE3, W, ACCESS
1A6C0  E106     BNZ 0xA6CE
1A6C2  0EF2     MOVLW 0xF2
1A6C4  50E3     MOVF 0xFE3, W, ACCESS
1A6C6  E103     BNZ 0xA6CE
1A6C8  0EF3     MOVLW 0xF3
1A6CA  50E3     MOVF 0xFE3, W, ACCESS
1A6CC  A4D8     BTFSS 0xFD8, 2, ACCESS
1A6CE  D743     BRA 0xA556
1A6D0  0EFD     MOVLW 0xFD
1A6D2  BEE3     BTFSC 0xFE3, 7, ACCESS
1A6D4  D007     BRA 0xA6E4
1A6D6  0EFD     MOVLW 0xFD
1A6D8  50E3     MOVF 0xFE3, W, ACCESS
1A6DA  E103     BNZ 0xA6E2
1A6DC  0EFC     MOVLW 0xFC
1A6DE  04E3     DECF 0xFE3, W, ACCESS
1A6E0  B0D8     BTFSC 0xFD8, 0, ACCESS
1A6E2  D739     BRA 0xA556
1A6E4  0EFB     MOVLW 0xFB
1A6E6  BEE3     BTFSC 0xFE3, 7, ACCESS
1A6E8  D009     BRA 0xA6FC
1A6EA  0EFB     MOVLW 0xFB
1A6EC  50E3     MOVF 0xFE3, W, ACCESS
1A6EE  E104     BNZ 0xA6F8
1A6F0  0EFA     MOVLW 0xFA
1A6F2  04E3     DECF 0xFE3, W, ACCESS
1A6F4  A0D8     BTFSS 0xFD8, 0, ACCESS
1A6F6  D002     BRA 0xA6FC
1A6F8  B227     BTFSC 0x27, 1, ACCESS
1A6FA  D72D     BRA 0xA556
984:           #ifdef _VFPF_FILL
985:           				|| ((0 < w) && (flags & ZERO_FLAG))
986:           #endif
987:           				)) {
988:                   --i;
1A556  50E1     MOVF 0xFE1, W, ACCESS
1A558  0FF8     ADDLW 0xF8
1A55A  6ED9     MOVWF 0xFD9, ACCESS
1A55C  50E2     MOVF 0xFE2, W, ACCESS
1A55E  6EDA     MOVWF __end_of_UART2_tx_vect_isr, ACCESS
1A560  0EFF     MOVLW 0xFF
1A562  22DA     ADDWFC __end_of_UART2_tx_vect_isr, F, ACCESS
1A564  06DE     DECF 0xFDE, F, ACCESS
1A566  0E00     MOVLW 0x0
1A568  5ADD     SUBWFB 0xFDD, F, ACCESS
989:                   c = d & 0x0f;
1A56A  0EF0     MOVLW 0xF0
1A56C  0061     MOVFFL PLUSW1, 0x50C
1A56E  F38C     NOP
1A570  F50C     NOP
1A572  0E0F     MOVLW 0xF
1A574  160C     ANDWF 0xC, F, ACCESS
1A576  0EFE     MOVLW 0xFE
1A578  0061     MOVFFL 0x50C, PLUSW1
1A57A  F430     NOP
1A57C  F4E3     NOP
990:           #if defined(_VFPF_x) || defined(_VFPF_P)
991:                   c = (c < 10) ? (int)'0' + c : (int)'a' + (c - 10);
1A57E  0EFE     MOVLW 0xFE
1A580  0061     MOVFFL PLUSW1, ltemp0
1A582  F38C     NOP
1A584  F501     NOP
1A586  0E09     MOVLW 0x9
1A588  6401     CPFSGT __ptext283, ACCESS
1A58A  D006     BRA 0xA598
1A58C  0EFE     MOVLW 0xFE
1A58E  50E3     MOVF 0xFE3, W, ACCESS
1A590  6E0B     MOVWF 0xB, ACCESS
1A592  6A0C     CLRF 0xC, ACCESS
1A594  0E57     MOVLW 0x57
1A596  D005     BRA 0xA5A2
1A598  0EFE     MOVLW 0xFE
1A59A  50E3     MOVF 0xFE3, W, ACCESS
1A59C  6E0B     MOVWF 0xB, ACCESS
1A59E  6A0C     CLRF 0xC, ACCESS
1A5A0  0E30     MOVLW 0x30
1A5A2  260B     ADDWF 0xB, F, ACCESS
1A5A4  0E00     MOVLW 0x0
1A5A6  220C     ADDWFC 0xC, F, ACCESS
1A5A8  0EF6     MOVLW 0xF6
1A5AA  0061     MOVFFL wtemp5, PLUSW1
1A5AC  F42C     NOP
1A5AE  F4E3     NOP
1A5B0  0EF7     MOVLW 0xF7
1A5B2  0061     MOVFFL 0x50C, PLUSW1
1A5B4  F430     NOP
1A5B6  F4E3     NOP
1A5B8  0EF6     MOVLW 0xF6
1A5BA  0061     MOVFFL PLUSW1, ltemp0
1A5BC  F38C     NOP
1A5BE  F501     NOP
1A5C0  0EFE     MOVLW 0xFE
1A5C2  0061     MOVFFL ltemp0, PLUSW1
1A5C4  F404     NOP
1A5C6  F4E3     NOP
992:           #if defined(_VFPF_X)
993:                   if (isupper((int)x) && isalpha(c)) {
1A5C8  0EEF     MOVLW 0xEF
1A5CA  0061     MOVFFL PLUSW1, 0x50C
1A5CC  F38C     NOP
1A5CE  F50C     NOP
1A5D0  0EBF     MOVLW 0xBF
1A5D2  240C     ADDWF 0xC, W, ACCESS
1A5D4  6E09     MOVWF 0x9, ACCESS
1A5D6  6A0A     CLRF 0xA, ACCESS
1A5D8  0EFF     MOVLW 0xFF
1A5DA  220A     ADDWFC 0xA, F, ACCESS
1A5DC  500A     MOVF 0xA, W, ACCESS
1A5DE  E123     BNZ 0xA626
1A5E0  0E1A     MOVLW 0x1A
1A5E2  5C09     SUBWF 0x9, W, ACCESS
1A5E4  B0D8     BTFSC 0xFD8, 0, ACCESS
1A5E6  D01F     BRA 0xA626
1A5E8  0EFE     MOVLW 0xFE
1A5EA  50E3     MOVF 0xFE3, W, ACCESS
1A5EC  6E0B     MOVWF 0xB, ACCESS
1A5EE  6A0C     CLRF 0xC, ACCESS
1A5F0  0E20     MOVLW 0x20
1A5F2  120B     IORWF 0xB, F, ACCESS
1A5F4  0E00     MOVLW 0x0
1A5F6  120C     IORWF 0xC, F, ACCESS
1A5F8  0E9F     MOVLW 0x9F
1A5FA  240B     ADDWF 0xB, W, ACCESS
1A5FC  6E09     MOVWF 0x9, ACCESS
1A5FE  0EFF     MOVLW 0xFF
1A600  200C     ADDWFC 0xC, W, ACCESS
1A602  6E0A     MOVWF 0xA, ACCESS
1A604  500A     MOVF 0xA, W, ACCESS
1A606  E10F     BNZ 0xA626
1A608  0E1A     MOVLW 0x1A
1A60A  5C09     SUBWF 0x9, W, ACCESS
1A60C  B0D8     BTFSC 0xFD8, 0, ACCESS
1A60E  D00B     BRA 0xA626
994:                       c = (char) toupper(c);
1A610  0EFE     MOVLW 0xFE
1A612  50E3     MOVF 0xFE3, W, ACCESS
1A614  6EE6     MOVWF 0xFE6, ACCESS
1A616  0E00     MOVLW 0x0
1A618  6EE6     MOVWF 0xFE6, ACCESS
1A61A  ECC5     CALL 0x118A, 0
1A61C  F008     NOP
1A61E  0EFE     MOVLW 0xFE
1A620  0061     MOVFFL ltemp0, PLUSW1
1A622  F404     NOP
1A624  F4E3     NOP
995:                   }
996:           #endif
997:           #else // _VFPF_X
998:                   c = (c < 10) ? (int)'0' + c : (int)'A' + (c - 10);
999:           #endif
1000:                  dbuf[i] = (char)c;
1A626  0EF8     MOVLW 0xF8
1A628  0061     MOVFFL PLUSW1, wtemp5
1A62A  F38C     NOP
1A62C  F50B     NOP
1A62E  0EF9     MOVLW 0xF9
1A630  0061     MOVFFL PLUSW1, 0x50C
1A632  F38C     NOP
1A634  F50C     NOP
1A636  0EA5     MOVLW 0xA5
1A638  240B     ADDWF 0xB, W, ACCESS
1A63A  6ED9     MOVWF 0xFD9, ACCESS
1A63C  0E08     MOVLW 0x8
1A63E  200C     ADDWFC 0xC, W, ACCESS
1A640  6EDA     MOVWF __end_of_UART2_tx_vect_isr, ACCESS
1A642  0EFE     MOVLW 0xFE
1A644  C4E3     MOVFF PLUSW1, INDF2
1A646  F4DF     NOP
1001:                  --p;
1A648  50E1     MOVF 0xFE1, W, ACCESS
1A64A  0FFC     ADDLW 0xFC
1A64C  6ED9     MOVWF 0xFD9, ACCESS
1A64E  50E2     MOVF 0xFE2, W, ACCESS
1A650  6EDA     MOVWF __end_of_UART2_tx_vect_isr, ACCESS
1A652  0EFF     MOVLW 0xFF
1A654  22DA     ADDWFC __end_of_UART2_tx_vect_isr, F, ACCESS
1A656  06DE     DECF 0xFDE, F, ACCESS
1A658  0E00     MOVLW 0x0
1A65A  5ADD     SUBWFB 0xFDD, F, ACCESS
1002:                  --w;
1A65C  50E1     MOVF 0xFE1, W, ACCESS
1A65E  0FFA     ADDLW 0xFA
1A660  6ED9     MOVWF 0xFD9, ACCESS
1A662  50E2     MOVF 0xFE2, W, ACCESS
1A664  6EDA     MOVWF __end_of_UART2_tx_vect_isr, ACCESS
1A666  0EFF     MOVLW 0xFF
1A668  22DA     ADDWFC __end_of_UART2_tx_vect_isr, F, ACCESS
1A66A  06DE     DECF 0xFDE, F, ACCESS
1A66C  0E00     MOVLW 0x0
1A66E  5ADD     SUBWFB 0xFDD, F, ACCESS
1003:                  d = d >> 4;
1A670  0E04     MOVLW 0x4
1A672  6E0C     MOVWF 0xC, ACCESS
1A674  50E1     MOVF 0xFE1, W, ACCESS
1A676  0FF0     ADDLW 0xF0
1A678  6ED9     MOVWF 0xFD9, ACCESS
1A67A  50E2     MOVF 0xFE2, W, ACCESS
1A67C  6EDA     MOVWF __end_of_UART2_tx_vect_isr, ACCESS
1A67E  0EFF     MOVLW 0xFF
1A680  22DA     ADDWFC __end_of_UART2_tx_vect_isr, F, ACCESS
1A682  280C     INCF 0xC, W, ACCESS
1A684  52DE     MOVF 0xFDE, F, ACCESS
1A686  D007     BRA 0xA696
1A688  52DE     MOVF 0xFDE, F, ACCESS
1A68A  52DE     MOVF 0xFDE, F, ACCESS
1A68C  90D8     BCF 0xFD8, 0, ACCESS
1A68E  32DD     RRCF 0xFDD, F, ACCESS
1A690  32DD     RRCF 0xFDD, F, ACCESS
1A692  32DD     RRCF 0xFDD, F, ACCESS
1A694  32DE     RRCF 0xFDE, F, ACCESS
1A696  2EE8     DECFSZ 0xFE8, F, ACCESS
1A698  D7F7     BRA 0xA688
1004:              }
1005:          
1006:          #ifdef _VFPF_ALTERN
1007:              /* Display prefix if required */
1008:              if (prec != 0 && (flags & POUND_FLAG) && d_nonzero) {
1A6FC  5023     MOVF 0x23, W, ACCESS
1A6FE  1024     IORWF 0x24, W, ACCESS
1A700  A4D8     BTFSS 0xFD8, 2, ACCESS
1A702  A827     BTFSS 0x27, 4, ACCESS
1A704  D039     BRA 0xA778
1A706  0EFF     MOVLW 0xFF
1A708  50E3     MOVF 0xFE3, W, ACCESS
1A70A  B4D8     BTFSC 0xFD8, 2, ACCESS
1A70C  D035     BRA 0xA778
1009:                  --i;
1A70E  50E1     MOVF 0xFE1, W, ACCESS
1A710  0FF8     ADDLW 0xF8
1A712  6ED9     MOVWF 0xFD9, ACCESS
1A714  50E2     MOVF 0xFE2, W, ACCESS
1A716  6EDA     MOVWF __end_of_UART2_tx_vect_isr, ACCESS
1A718  0EFF     MOVLW 0xFF
1A71A  22DA     ADDWFC __end_of_UART2_tx_vect_isr, F, ACCESS
1A71C  06DE     DECF 0xFDE, F, ACCESS
1A71E  0E00     MOVLW 0x0
1A720  5ADD     SUBWFB 0xFDD, F, ACCESS
1010:          #if defined(_VFPF_X) && (defined(_VFPF_x) || defined(_VFPF_P))
1011:                  dbuf[i] = x;
1A722  0EF8     MOVLW 0xF8
1A724  0061     MOVFFL PLUSW1, wtemp5
1A726  F38C     NOP
1A728  F50B     NOP
1A72A  0EF9     MOVLW 0xF9
1A72C  0061     MOVFFL PLUSW1, 0x50C
1A72E  F38C     NOP
1A730  F50C     NOP
1A732  0EA5     MOVLW 0xA5
1A734  240B     ADDWF 0xB, W, ACCESS
1A736  6ED9     MOVWF 0xFD9, ACCESS
1A738  0E08     MOVLW 0x8
1A73A  200C     ADDWFC 0xC, W, ACCESS
1A73C  6EDA     MOVWF __end_of_UART2_tx_vect_isr, ACCESS
1A73E  0EEF     MOVLW 0xEF
1A740  C4E3     MOVFF PLUSW1, INDF2
1A742  F4DF     NOP
1012:          #elif defined(_VFPF_X)
1013:          		dbuf[i] = 'X';
1014:          #else
1015:          		dbuf[i] = 'x';
1016:          #endif
1017:                  --i;
1A744  50E1     MOVF 0xFE1, W, ACCESS
1A746  0FF8     ADDLW 0xF8
1A748  6ED9     MOVWF 0xFD9, ACCESS
1A74A  50E2     MOVF 0xFE2, W, ACCESS
1A74C  6EDA     MOVWF __end_of_UART2_tx_vect_isr, ACCESS
1A74E  0EFF     MOVLW 0xFF
1A750  22DA     ADDWFC __end_of_UART2_tx_vect_isr, F, ACCESS
1A752  06DE     DECF 0xFDE, F, ACCESS
1A754  0E00     MOVLW 0x0
1A756  5ADD     SUBWFB 0xFDD, F, ACCESS
1018:                  dbuf[i] = '0';
1A758  0EF8     MOVLW 0xF8
1A75A  0061     MOVFFL PLUSW1, wtemp5
1A75C  F38C     NOP
1A75E  F50B     NOP
1A760  0EF9     MOVLW 0xF9
1A762  0061     MOVFFL PLUSW1, 0x50C
1A764  F38C     NOP
1A766  F50C     NOP
1A768  0EA5     MOVLW 0xA5
1A76A  240B     ADDWF 0xB, W, ACCESS
1A76C  6ED9     MOVWF 0xFD9, ACCESS
1A76E  0E08     MOVLW 0x8
1A770  200C     ADDWFC 0xC, W, ACCESS
1A772  6EDA     MOVWF __end_of_UART2_tx_vect_isr, ACCESS
1A774  0E30     MOVLW 0x30
1A776  6EDF     MOVWF 0xFDF, ACCESS
1019:              }
1020:          #endif
1021:          
1022:              /* Put out padded string */
1023:              return _COUNT_CAST pad(fp, &dbuf[i], w);
1A778  0EFA     MOVLW 0xFA
1A77A  C4E3     MOVFF PLUSW1, POSTINC1
1A77C  F4E6     NOP
1A77E  C4E3     MOVFF PLUSW1, POSTINC1
1A780  F4E6     NOP
1A782  0EA5     MOVLW 0xA5
1A784  6E0B     MOVWF 0xB, ACCESS
1A786  0E08     MOVLW 0x8
1A788  6E0C     MOVWF 0xC, ACCESS
1A78A  0EF6     MOVLW 0xF6
1A78C  50E3     MOVF 0xFE3, W, ACCESS
1A78E  260B     ADDWF 0xB, F, ACCESS
1A790  0EF7     MOVLW 0xF7
1A792  50E3     MOVF 0xFE3, W, ACCESS
1A794  220C     ADDWFC 0xC, F, ACCESS
1A796  0061     MOVFFL wtemp5, POSTINC1
1A798  F42C     NOP
1A79A  F4E6     NOP
1A79C  0061     MOVFFL 0x50C, POSTINC1
1A79E  F430     NOP
1A7A0  F4E6     NOP
1A7A2  0EF0     MOVLW 0xF0
1A7A4  C4E3     MOVFF PLUSW1, POSTINC1
1A7A6  F4E6     NOP
1A7A8  C4E3     MOVFF PLUSW1, POSTINC1
1A7AA  F4E6     NOP
1A7AC  ECA3     CALL 0x1EF46, 0
1A7AE  F0F7     NOP
1024:          }
1A7B0  0EEF     MOVLW 0xEF
1A7B0  0EEF     MOVLW 0xEF
1A7B0  0EEF     MOVLW 0xEF
1A7B0  0EEF     MOVLW 0xEF
1A7B0  0EEF     MOVLW 0xEF
1025:          #endif
1026:          
1027:          #if defined(_VFPF_WIDTH) || defined(_VFPF_PRECISION)
1028:          static int
1029:          read_prec_or_width (const char **fmt, va_list *ap) {
1DD38  52E6     MOVF 0xFE6, F, ACCESS
1DD3A  52E6     MOVF 0xFE6, F, ACCESS
1DD3C  52E6     MOVF 0xFE6, F, ACCESS
1030:              int n = 0;
1DD3E  0EFE     MOVLW 0xFE
1DD40  6AE3     CLRF 0xFE3, ACCESS
1DD42  0EFF     MOVLW 0xFF
1DD44  6AE3     CLRF 0xFE3, ACCESS
1031:              if ((*fmt)[0] == '*') {
1DD46  0EFB     MOVLW 0xFB
1DD48  C4E3     MOVFF PLUSW1, FSR2
1DD4A  F4D9     NOP
1DD4C  0EFC     MOVLW 0xFC
1DD4E  C4E3     MOVFF PLUSW1, FSR2H
1DD50  F4DA     NOP
1DD52  C4DE     MOVFF POSTINC2, TBLPTR
1DD54  F4F6     NOP
1DD56  C4DD     MOVFF POSTDEC2, TBLPTRH
1DD58  F4F7     NOP
1DD5A  0E00     MOVLW 0x0
1DD5C  6EF8     MOVWF 0xFF8, ACCESS
1DD5E  0008     TBLRD*
1DD60  50F5     MOVF 0xFF5, W, ACCESS
1DD62  0A2A     XORLW 0x2A
1DD64  A4D8     BTFSS 0xFD8, 2, ACCESS
1DD66  D057     BRA 0xDE16
1032:                  ++*fmt;
1DD68  0EFB     MOVLW 0xFB
1DD6A  C4E3     MOVFF PLUSW1, FSR2
1DD6C  F4D9     NOP
1DD6E  0EFC     MOVLW 0xFC
1DD70  C4E3     MOVFF PLUSW1, FSR2H
1DD72  F4DA     NOP
1DD74  2ADE     INCF 0xFDE, F, ACCESS
1DD76  0E00     MOVLW 0x0
1DD78  22DD     ADDWFC 0xFDD, F, ACCESS
1033:                  n = va_arg(*ap, int);
1DD7A  0EF9     MOVLW 0xF9
1DD7C  C4E3     MOVFF PLUSW1, FSR2
1DD7E  F4D9     NOP
1DD80  0EFA     MOVLW 0xFA
1DD82  C4E3     MOVFF PLUSW1, FSR2H
1DD84  F4DA     NOP
1DD86  0E02     MOVLW 0x2
1DD88  5EDE     SUBWF 0xFDE, F, ACCESS
1DD8A  0E00     MOVLW 0x0
1DD8C  5ADD     SUBWFB 0xFDD, F, ACCESS
1DD8E  0061     MOVFFL POSTINC2, wtemp5
1DD90  F378     NOP
1DD92  F50B     NOP
1DD94  0061     MOVFFL POSTDEC2, 0x50C
1DD96  F374     NOP
1DD98  F50C     NOP
1DD9A  0061     MOVFFL wtemp5, FSR2
1DD9C  F42C     NOP
1DD9E  F4D9     NOP
1DDA0  0061     MOVFFL 0x50C, FSR2H
1DDA2  F430     NOP
1DDA4  F4DA     NOP
1DDA6  0061     MOVFFL POSTINC2, wtemp5
1DDA8  F378     NOP
1DDAA  F50B     NOP
1DDAC  0061     MOVFFL POSTDEC2, 0x50C
1DDAE  F374     NOP
1DDB0  F50C     NOP
1DDB2  0EFE     MOVLW 0xFE
1DDB4  0061     MOVFFL wtemp5, PLUSW1
1DDB6  F42C     NOP
1DDB8  F4E3     NOP
1DDBA  0EFF     MOVLW 0xFF
1DDBC  0061     MOVFFL 0x50C, PLUSW1
1DDBE  F430     NOP
1DDC0  F4E3     NOP
1034:              } else {
1DDC2  D046     BRA 0xDE50
1035:                  unsigned char c;
1036:                  while ((c = ((unsigned)(*fmt)[0]) - '0') < 10) {
1DE16  0EFB     MOVLW 0xFB
1DE18  C4E3     MOVFF PLUSW1, FSR2
1DE1A  F4D9     NOP
1DE1C  0EFC     MOVLW 0xFC
1DE1E  C4E3     MOVFF PLUSW1, FSR2H
1DE20  F4DA     NOP
1DE22  C4DE     MOVFF POSTINC2, TBLPTR
1DE24  F4F6     NOP
1DE26  C4DD     MOVFF POSTDEC2, TBLPTRH
1DE28  F4F7     NOP
1DE2A  0E00     MOVLW 0x0
1DE2C  6EF8     MOVWF 0xFF8, ACCESS
1DE2E  0008     TBLRD*
1DE30  0061     MOVFFL TABLAT, 0x50C
1DE32  F3D4     NOP
1DE34  F50C     NOP
1DE36  0ED0     MOVLW 0xD0
1DE38  260C     ADDWF 0xC, F, ACCESS
1DE3A  0EFD     MOVLW 0xFD
1DE3C  0061     MOVFFL 0x50C, PLUSW1
1DE3E  F430     NOP
1DE40  F4E3     NOP
1DE42  0EFD     MOVLW 0xFD
1DE44  0061     MOVFFL PLUSW1, ltemp0
1DE46  F38C     NOP
1DE48  F501     NOP
1DE4A  0E09     MOVLW 0x9
1DE4C  6401     CPFSGT __ptext283, ACCESS
1DE4E  D7BA     BRA 0xDDC4
1037:                      n = n * 10 + c;
1DDC4  0EFE     MOVLW 0xFE
1DDC6  0061     MOVFFL PLUSW1, wtemp5
1DDC8  F38C     NOP
1DDCA  F50B     NOP
1DDCC  0EFF     MOVLW 0xFF
1DDCE  0061     MOVFFL PLUSW1, 0x50C
1DDD0  F38C     NOP
1DDD2  F50C     NOP
1DDD4  0E0A     MOVLW 0xA
1DDD6  020B     MULWF 0xB, ACCESS
1DDD8  0061     MOVFFL PROD, ltemp2
1DDDA  F3CC     NOP
1DDDC  F509     NOP
1DDDE  0061     MOVFFL PRODH, ttemp3
1DDE0  F3D0     NOP
1DDE2  F50A     NOP
1DDE4  020C     MULWF 0xC, ACCESS
1DDE6  50F3     MOVF 0xFF3, W, ACCESS
1DDE8  260A     ADDWF 0xA, F, ACCESS
1DDEA  0EFD     MOVLW 0xFD
1DDEC  50E3     MOVF 0xFE3, W, ACCESS
1DDEE  2609     ADDWF 0x9, F, ACCESS
1DDF0  0E00     MOVLW 0x0
1DDF2  220A     ADDWFC 0xA, F, ACCESS
1DDF4  0EFE     MOVLW 0xFE
1DDF6  0061     MOVFFL ltemp2, PLUSW1
1DDF8  F424     NOP
1DDFA  F4E3     NOP
1DDFC  0EFF     MOVLW 0xFF
1DDFE  0061     MOVFFL ttemp3, PLUSW1
1DE00  F428     NOP
1DE02  F4E3     NOP
1038:                      ++*fmt;
1DE04  0EFB     MOVLW 0xFB
1DE06  C4E3     MOVFF PLUSW1, FSR2
1DE08  F4D9     NOP
1DE0A  0EFC     MOVLW 0xFC
1DE0C  C4E3     MOVFF PLUSW1, FSR2H
1DE0E  F4DA     NOP
1DE10  2ADE     INCF 0xFDE, F, ACCESS
1DE12  0E00     MOVLW 0x0
1DE14  22DD     ADDWFC 0xFDD, F, ACCESS
1039:                  }
1040:              }
1041:              return n;
1DE50  0EFE     MOVLW 0xFE
1DE52  0061     MOVFFL PLUSW1, ltemp0
1DE54  F38C     NOP
1DE56  F501     NOP
1DE58  0EFF     MOVLW 0xFF
1DE5A  0061     MOVFFL PLUSW1, ttemp5
1DE5C  F38C     NOP
1DE5E  F502     NOP
1042:          }
1DE60  0EF9     MOVLW 0xF9
1DE60  0EF9     MOVLW 0xF9
1DE60  0EF9     MOVLW 0xF9
1DE60  0EF9     MOVLW 0xF9
1DE60  0EF9     MOVLW 0xF9
1043:          #endif
1044:          
1045:          /* Consume and convert the next part of the format string */
1046:          #ifdef _VFPF_CONVERT
1047:          static _INLINE _COUNT_TYPE
1048:          vfpfcnvrt(FILE *fp, char *fmt[], va_list ap)
126E6  0E0B     MOVLW 0xB
126E8  26E1     ADDWF 0xFE1, F, ACCESS
126EA  0E00     MOVLW 0x0
126EC  22E2     ADDWFC 0xFE2, F, ACCESS
1049:          {
1050:              char c, *cp;
1051:              int done, i;
1052:          	union {
1053:          #ifdef _VFPF_INT_LENGTH
1054:          		vfpf_sint_t	sint;
1055:          		vfpf_uint_t uint;
1056:          #endif
1057:          		void *vp;
1058:          		long double f;
1059:          	} convarg;
1060:          
1061:              /* Conversion ? */
1062:              if ((*fmt)[0] == '%') {
126EE  0EF1     MOVLW 0xF1
126F0  C4E3     MOVFF PLUSW1, FSR2
126F2  F4D9     NOP
126F4  0EF2     MOVLW 0xF2
126F6  C4E3     MOVFF PLUSW1, FSR2H
126F8  F4DA     NOP
126FA  C4DE     MOVFF POSTINC2, TBLPTR
126FC  F4F6     NOP
126FE  C4DD     MOVFF POSTDEC2, TBLPTRH
12700  F4F7     NOP
12702  0E00     MOVLW 0x0
12704  6EF8     MOVWF 0xFF8, ACCESS
12706  0008     TBLRD*
12708  50F5     MOVF 0xFF5, W, ACCESS
1270A  0A25     XORLW 0x25
1270C  A4D8     BTFSS 0xFD8, 2, ACCESS
1270E  EF70     GOTO 0x136E0
12710  F09B     NOP
1063:                  ++*fmt;
12712  0EF1     MOVLW 0xF1
12714  C4E3     MOVFF PLUSW1, FSR2
12716  F4D9     NOP
12718  0EF2     MOVLW 0xF2
1271A  C4E3     MOVFF PLUSW1, FSR2H
1271C  F4DA     NOP
1271E  2ADE     INCF 0xFDE, F, ACCESS
12720  0E00     MOVLW 0x0
12722  22DD     ADDWFC 0xFDD, F, ACCESS
1064:          
1065:                  flags = width = 0;
12724  0E00     MOVLW 0x0
12726  6E22     MOVWF 0x22, ACCESS
12728  0E00     MOVLW 0x0
1272A  6E21     MOVWF 0x21, ACCESS
1272C  C521     MOVFF width, flags
1272E  F527     NOP
1066:                  prec = -1;
12730  6823     SETF 0x23, ACCESS
12732  6824     SETF 0x24, ACCESS
1067:          
1068:          #ifdef _VFPF_FLAGS
1069:                  /* Get flags */
1070:                  done = 0;
12734  0EFD     MOVLW 0xFD
12736  6AE3     CLRF 0xFE3, ACCESS
12738  0EFE     MOVLW 0xFE
1273A  6AE3     CLRF 0xFE3, ACCESS
1071:                  while (!done) {
1273C  D045     BRA 0x27C8
127C8  0EFD     MOVLW 0xFD
127CA  0061     MOVFFL PLUSW1, ltemp0
127CC  F38C     NOP
127CE  F501     NOP
127D0  0EFE     MOVLW 0xFE
127D2  50E3     MOVF 0xFE3, W, ACCESS
127D4  1001     IORWF __ptext283, W, ACCESS
127D6  B4D8     BTFSC 0xFD8, 2, ACCESS
127D8  D7D2     BRA 0x277E
1072:                      switch ((*fmt)[0]) {
1073:          #ifdef _VFPF_LEFT
1074:                          case '-' :
1075:                              flags |= MINUS_FLAG;
1273E  8027     BSF 0x27, 0, ACCESS
1076:                              ++*fmt;
12740  0EF1     MOVLW 0xF1
12742  C4E3     MOVFF PLUSW1, FSR2
12744  F4D9     NOP
12746  0EF2     MOVLW 0xF2
12748  C4E3     MOVFF PLUSW1, FSR2H
1274A  F4DA     NOP
1274C  2ADE     INCF 0xFDE, F, ACCESS
1274E  0E00     MOVLW 0x0
12750  22DD     ADDWFC 0xFDD, F, ACCESS
1077:                              break;
12752  D03A     BRA 0x27C8
1078:          #endif
1079:          #ifdef _VFPF_FILL
1080:                          case '0' :
1081:                              flags |= ZERO_FLAG;
12754  8227     BSF 0x27, 1, ACCESS
12756  D7F4     BRA TMR5_StartTimer
1082:                              ++*fmt;
1083:                              break;
1084:          #endif
1085:          #ifdef _VFPF_MANSIGN
1086:                          case '+' :
1087:                              flags |= PLUS_FLAG;
12758  8427     BSF 0x27, 2, ACCESS
1275A  D7F2     BRA TMR5_StartTimer
1088:                              ++*fmt;
1089:                              break;
1090:          #endif
1091:          #ifdef _VFPF_SPCSIGN
1092:                          case ' ' :
1093:                              flags |= SPACE_FLAG;
1275C  8627     BSF 0x27, 3, ACCESS
1275E  D7F0     BRA TMR5_StartTimer
1094:                              ++*fmt;
1095:                              break;
1096:          #endif
1097:          #ifdef _VFPF_ALTERN
1098:                          case '#' :
1099:                              flags |= POUND_FLAG;
12760  8827     BSF 0x27, 4, ACCESS
12762  D7EE     BRA TMR5_StartTimer
1100:                              ++*fmt;
1101:                              break;
1102:          #endif
1103:                          default:
1104:                              done = 1;
12764  0E01     MOVLW 0x1
12766  6E0B     MOVWF 0xB, ACCESS
12768  0E00     MOVLW 0x0
1276A  6E0C     MOVWF 0xC, ACCESS
1276C  0EFD     MOVLW 0xFD
1276E  0061     MOVFFL wtemp5, PLUSW1
12770  F42C     NOP
12772  F4E3     NOP
12774  0EFE     MOVLW 0xFE
12776  0061     MOVFFL 0x50C, PLUSW1
12778  F430     NOP
1277A  F4E3     NOP
1105:                              break;
1277C  D025     BRA 0x27C8
1106:                      }
1277E  0EF1     MOVLW 0xF1
12780  C4E3     MOVFF PLUSW1, FSR2
12782  F4D9     NOP
12784  0EF2     MOVLW 0xF2
12786  C4E3     MOVFF PLUSW1, FSR2H
12788  F4DA     NOP
1278A  C4DE     MOVFF POSTINC2, TBLPTR
1278C  F4F6     NOP
1278E  C4DD     MOVFF POSTDEC2, TBLPTRH
12790  F4F7     NOP
12792  0E00     MOVLW 0x0
12794  6EF8     MOVWF 0xFF8, ACCESS
12796  0008     TBLRD*
12798  50F5     MOVF 0xFF5, W, ACCESS
1279A  6E0B     MOVWF 0xB, ACCESS
1279C  6A0C     CLRF 0xC, ACCESS
1279E  500C     MOVF 0xC, W, ACCESS
127A0  0A00     XORLW 0x0
127A2  A4D8     BTFSS 0xFD8, 2, ACCESS
127A4  D7DF     BRA TMR2_Start
127A6  500B     MOVF 0xB, W, ACCESS
127A8  0A20     XORLW 0x20
127AA  B4D8     BTFSC 0xFD8, 2, ACCESS
127AC  D7D7     BRA 0x275C
127AE  0A03     XORLW 0x3
127B0  B4D8     BTFSC 0xFD8, 2, ACCESS
127B2  D7D6     BRA 0x2760
127B4  0A08     XORLW 0x8
127B6  B4D8     BTFSC 0xFD8, 2, ACCESS
127B8  D7CF     BRA TMR4_Start
127BA  0A06     XORLW 0x6
127BC  B4D8     BTFSC 0xFD8, 2, ACCESS
127BE  D7BF     BRA 0x273E
127C0  0A1D     XORLW 0x1D
127C2  B4D8     BTFSC 0xFD8, 2, ACCESS
127C4  D7C7     BRA 0x2754
127C6  D7CE     BRA TMR2_Start
1107:                  }
1108:          #if defined(_VFPF_LEFT) && defined(_VFPF_FILL)
1109:                  if (flags & MINUS_FLAG) {
127DA  B027     BTFSC 0x27, 0, ACCESS
1110:                      flags &= ~ZERO_FLAG;
127DC  9227     BCF 0x27, 1, ACCESS
1111:                  }
1112:          #endif
1113:          #endif // _VFPF_FLAGS
1114:          
1115:          #ifdef _VFPF_WIDTH
1116:                  /* Get field width */
1117:          		width = read_prec_or_width(fmt, ap);
127DE  0EEF     MOVLW 0xEF
127E0  C4E3     MOVFF PLUSW1, POSTINC1
127E2  F4E6     NOP
127E4  C4E3     MOVFF PLUSW1, POSTINC1
127E6  F4E6     NOP
127E8  0EEF     MOVLW 0xEF
127EA  C4E3     MOVFF PLUSW1, POSTINC1
127EC  F4E6     NOP
127EE  C4E3     MOVFF PLUSW1, POSTINC1
127F0  F4E6     NOP
127F2  EC9C     CALL 0x1DD38, 0
127F4  F0EE     NOP
127F6  0061     MOVFFL ltemp0, width
127F8  F404     NOP
127FA  F521     NOP
127FC  0061     MOVFFL ttemp5, 0x522
127FE  F408     NOP
12800  F522     NOP
1118:          		if (width < 0) {
12802  AE22     BTFSS 0x22, 7, ACCESS
12804  D005     BRA 0x2810
1119:          			flags |= MINUS_FLAG;
12806  8027     BSF 0x27, 0, ACCESS
1120:          			width = -width;
12808  6C21     NEGF 0x21, ACCESS
1280A  1E22     COMF 0x22, F, ACCESS
1280C  B0D8     BTFSC 0xFD8, 0, ACCESS
1280E  2A22     INCF 0x22, F, ACCESS
1121:          		}
1122:          #endif
1123:          
1124:          #ifdef _VFPF_PRECISION
1125:                  /* Get precision */
1126:                  if ((*fmt)[0] == '.') {
12810  0EF1     MOVLW 0xF1
12812  C4E3     MOVFF PLUSW1, FSR2
12814  F4D9     NOP
12816  0EF2     MOVLW 0xF2
12818  C4E3     MOVFF PLUSW1, FSR2H
1281A  F4DA     NOP
1281C  C4DE     MOVFF POSTINC2, TBLPTR
1281E  F4F6     NOP
12820  C4DD     MOVFF POSTDEC2, TBLPTRH
12822  F4F7     NOP
12824  0E00     MOVLW 0x0
12826  6EF8     MOVWF 0xFF8, ACCESS
12828  0008     TBLRD*
1282A  50F5     MOVF 0xFF5, W, ACCESS
1282C  0A2E     XORLW 0x2E
1282E  A4D8     BTFSS 0xFD8, 2, ACCESS
12830  D01B     BRA 0x2868
1127:                      ++*fmt;
12832  0EF1     MOVLW 0xF1
12834  C4E3     MOVFF PLUSW1, FSR2
12836  F4D9     NOP
12838  0EF2     MOVLW 0xF2
1283A  C4E3     MOVFF PLUSW1, FSR2H
1283C  F4DA     NOP
1283E  2ADE     INCF 0xFDE, F, ACCESS
12840  0E00     MOVLW 0x0
12842  22DD     ADDWFC 0xFDD, F, ACCESS
1128:          			prec = read_prec_or_width(fmt, ap);
12844  0EEF     MOVLW 0xEF
12846  C4E3     MOVFF PLUSW1, POSTINC1
12848  F4E6     NOP
1284A  C4E3     MOVFF PLUSW1, POSTINC1
1284C  F4E6     NOP
1284E  0EEF     MOVLW 0xEF
12850  C4E3     MOVFF PLUSW1, POSTINC1
12852  F4E6     NOP
12854  C4E3     MOVFF PLUSW1, POSTINC1
12856  F4E6     NOP
12858  EC9C     CALL 0x1DD38, 0
1285A  F0EE     NOP
1285C  0061     MOVFFL ltemp0, prec
1285E  F404     NOP
12860  F523     NOP
12862  0061     MOVFFL ttemp5, 0x524
12864  F408     NOP
12866  F524     NOP
1129:          		}
1130:          #endif
1131:          
1132:          #ifdef _VFPF_C
1133:                  /* Character */
1134:                  if (*fmt[0] == 'c') {
12868  0EF1     MOVLW 0xF1
1286A  C4E3     MOVFF PLUSW1, FSR2
1286C  F4D9     NOP
1286E  0EF2     MOVLW 0xF2
12870  C4E3     MOVFF PLUSW1, FSR2H
12872  F4DA     NOP
12874  C4DE     MOVFF POSTINC2, TBLPTR
12876  F4F6     NOP
12878  C4DD     MOVFF POSTDEC2, TBLPTRH
1287A  F4F7     NOP
1287C  0E00     MOVLW 0x0
1287E  6EF8     MOVWF 0xFF8, ACCESS
12880  0008     TBLRD*
12882  50F5     MOVF 0xFF5, W, ACCESS
12884  0A63     XORLW 0x63
12886  A4D8     BTFSS 0xFD8, 2, ACCESS
12888  D031     BRA 0x28EC
1135:                      ++*fmt;
1288A  0EF1     MOVLW 0xF1
1288C  C4E3     MOVFF PLUSW1, FSR2
1288E  F4D9     NOP
12890  0EF2     MOVLW 0xF2
12892  C4E3     MOVFF PLUSW1, FSR2H
12894  F4DA     NOP
12896  2ADE     INCF 0xFDE, F, ACCESS
12898  0E00     MOVLW 0x0
1289A  22DD     ADDWFC 0xFDD, F, ACCESS
1136:                      c = (unsigned char)va_arg(ap, int);
1289C  0EEF     MOVLW 0xEF
1289E  C4E3     MOVFF PLUSW1, FSR2
128A0  F4D9     NOP
128A2  0EF0     MOVLW 0xF0
128A4  C4E3     MOVFF PLUSW1, FSR2H
128A6  F4DA     NOP
128A8  0E02     MOVLW 0x2
128AA  5EDE     SUBWF 0xFDE, F, ACCESS
128AC  0E00     MOVLW 0x0
128AE  5ADD     SUBWFB 0xFDD, F, ACCESS
128B0  0061     MOVFFL POSTINC2, wtemp5
128B2  F378     NOP
128B4  F50B     NOP
128B6  0061     MOVFFL POSTDEC2, 0x50C
128B8  F374     NOP
128BA  F50C     NOP
128BC  0061     MOVFFL wtemp5, FSR2
128BE  F42C     NOP
128C0  F4D9     NOP
128C2  0061     MOVFFL 0x50C, FSR2H
128C4  F430     NOP
128C6  F4DA     NOP
128C8  50DF     MOVF 0xFDF, W, ACCESS
128CA  6E0C     MOVWF 0xC, ACCESS
128CC  0EFF     MOVLW 0xFF
128CE  0061     MOVFFL 0x50C, PLUSW1
128D0  F430     NOP
128D2  F4E3     NOP
1137:                      return _COUNT_CAST ctoa(fp, c);
128D4  0EFF     MOVLW 0xFF
128D6  50E3     MOVF 0xFE3, W, ACCESS
128D8  6EE6     MOVWF 0xFE6, ACCESS
128DA  0EF2     MOVLW 0xF2
128DC  C4E3     MOVFF PLUSW1, POSTINC1
128DE  F4E6     NOP
128E0  C4E3     MOVFF PLUSW1, POSTINC1
128E2  F4E6     NOP
128E4  ECE6     CALL 0x1E1CC, 0
128E6  F0F0     NOP
128E8  EF92     GOTO 0x13724
128EA  F09B     NOP
1138:                  }
1139:          #endif
1140:          
1141:          		/* Integers and character count */
1142:          #if defined(_VFPF_SIGNED_CONV) || defined(_VFPF_UNSIGNED_CONV) || defined(_VFPF_N)
1143:          		cp = *fmt;
128EC  0EF1     MOVLW 0xF1
128EE  C4E3     MOVFF PLUSW1, FSR2
128F0  F4D9     NOP
128F2  0EF2     MOVLW 0xF2
128F4  C4E3     MOVFF PLUSW1, FSR2H
128F6  F4DA     NOP
128F8  0061     MOVFFL POSTINC2, wtemp5
128FA  F378     NOP
128FC  F50B     NOP
128FE  0061     MOVFFL POSTDEC2, 0x50C
12900  F374     NOP
12902  F50C     NOP
12904  0EFC     MOVLW 0xFC
12906  0061     MOVFFL 0x50C, PLUSW1
12908  F430     NOP
1290A  F4E3     NOP
1290C  0EFB     MOVLW 0xFB
1290E  0061     MOVFFL wtemp5, PLUSW1
12910  F42C     NOP
12912  F4E3     NOP
1144:          #ifdef _VFPF_LENGTH_MOD
1145:          		c = *cp;
12914  50E1     MOVF 0xFE1, W, ACCESS
12916  0FFB     ADDLW 0xFB
12918  6ED9     MOVWF 0xFD9, ACCESS
1291A  50E2     MOVF 0xFE2, W, ACCESS
1291C  6EDA     MOVWF __end_of_UART2_tx_vect_isr, ACCESS
1291E  0EFF     MOVLW 0xFF
12920  22DA     ADDWFC __end_of_UART2_tx_vect_isr, F, ACCESS
12922  C4DE     MOVFF POSTINC2, TBLPTR
12924  F4F6     NOP
12926  C4DD     MOVFF POSTDEC2, TBLPTRH
12928  F4F7     NOP
1292A  0E00     MOVLW 0x0
1292C  6EF8     MOVWF 0xFF8, ACCESS
1292E  0008     TBLRD*
12930  0EFF     MOVLW 0xFF
12932  C4F5     MOVFF TABLAT, PLUSW1
12934  F4E3     NOP
1146:          		switch(c) {
12936  D043     BRA 0x29BE
1147:          			// determine length modifiers
1148:          #if defined(_VFPF_H) || defined(_VFPF_HH)
1149:          			case 'h':
1150:          				cp++;
12938  0EFB     MOVLW 0xFB
1293A  50E3     MOVF 0xFE3, W, ACCESS
1293C  0F01     ADDLW 0x1
1293E  6E01     MOVWF __ptext283, ACCESS
12940  0EFB     MOVLW 0xFB
12942  0061     MOVFFL ltemp0, PLUSW1
12944  F404     NOP
12946  F4E3     NOP
12948  6A01     CLRF __ptext283, ACCESS
1294A  0EFC     MOVLW 0xFC
1294C  50E3     MOVF 0xFE3, W, ACCESS
1294E  2001     ADDWFC __ptext283, W, ACCESS
12950  6E01     MOVWF __ptext283, ACCESS
12952  0EFC     MOVLW 0xFC
12954  0061     MOVFFL ltemp0, PLUSW1
12956  F404     NOP
12958  F4E3     NOP
1151:          #ifdef _VFPF_HH
1152:          				if (*cp == 'h') {
1295A  50E1     MOVF 0xFE1, W, ACCESS
1295C  0FFB     ADDLW 0xFB
1295E  6ED9     MOVWF 0xFD9, ACCESS
12960  50E2     MOVF 0xFE2, W, ACCESS
12962  6EDA     MOVWF __end_of_UART2_tx_vect_isr, ACCESS
12964  0EFF     MOVLW 0xFF
12966  22DA     ADDWFC __end_of_UART2_tx_vect_isr, F, ACCESS
12968  C4DE     MOVFF POSTINC2, TBLPTR
1296A  F4F6     NOP
1296C  C4DD     MOVFF POSTDEC2, TBLPTRH
1296E  F4F7     NOP
12970  0E00     MOVLW 0x0
12972  6EF8     MOVWF 0xFF8, ACCESS
12974  0008     TBLRD*
12976  50F5     MOVF 0xFF5, W, ACCESS
12978  0A68     XORLW 0x68
1297A  A4D8     BTFSS 0xFD8, 2, ACCESS
1297C  D048     BRA 0x2A0E
1153:          					c = 'H';
1297E  0EFF     MOVLW 0xFF
12980  6AE3     CLRF 0xFE3, ACCESS
12982  86E3     BSF 0xFE3, 3, ACCESS
12984  8CE3     BSF 0xFE3, 6, ACCESS
1154:          					cp++;
12986  0EFB     MOVLW 0xFB
12988  50E3     MOVF 0xFE3, W, ACCESS
1298A  0F01     ADDLW 0x1
1298C  6E01     MOVWF __ptext283, ACCESS
1298E  0EFB     MOVLW 0xFB
12990  0061     MOVFFL ltemp0, PLUSW1
12992  F404     NOP
12994  F4E3     NOP
12996  6A01     CLRF __ptext283, ACCESS
12998  0EFC     MOVLW 0xFC
1299A  50E3     MOVF 0xFE3, W, ACCESS
1299C  2001     ADDWFC __ptext283, W, ACCESS
1299E  6E01     MOVWF __ptext283, ACCESS
129A0  0EFC     MOVLW 0xFC
129A2  0061     MOVFFL ltemp0, PLUSW1
129A4  F404     NOP
129A6  F4E3     NOP
129A8  D032     BRA 0x2A0E
1155:          				}
1156:          #endif
1157:          				break;
1158:          #endif
1159:          #if defined(_VFPF_L) || defined(_VFPF_LL)
1160:          			case 'l':
1161:          				cp++;
1162:          #if defined(_VFPF_LL)
1163:          				if (*cp == 'l') {
1164:          					c = 'L';
1165:          					cp++;
1166:          				}
1167:          #endif
1168:          				break;
1169:          #endif
1170:          #if defined(_VFPF_J) || defined(_VFPF_T) || defined(_VFPF_Z)
1171:          #ifdef _VFPF_J
1172:          			case 'j':
1173:          #endif
1174:          #ifdef _VFPF_T
1175:          			case 't':
1176:          #endif
1177:          #ifdef _VFPF_Z
1178:          			case 'z':
1179:          #endif
1180:          				cp++;
1181:          				break;
1182:          #endif
1183:          #ifdef _VFPF_O
1184:          			case 'o':
1185:          #endif
1186:          #ifdef _VFPF_U
1187:          			case 'u':
1188:          #endif
1189:          #ifdef _VFPF_D
1190:          			case 'i':
1191:          			case 'd':
1192:          #endif
1193:          #ifdef _VFPF_x
1194:          			case 'x':
1195:          #endif
1196:          #ifdef _VFPF_X
1197:          			case 'X':
1198:          #endif
1199:          #ifdef _VFPF_N
1200:          			case 'n':
1201:          #endif
1202:          				c = 'i';
129AA  0E69     MOVLW 0x69
129AC  6E0C     MOVWF 0xC, ACCESS
129AE  0EFF     MOVLW 0xFF
129B0  0061     MOVFFL 0x50C, PLUSW1
129B2  F430     NOP
129B4  F4E3     NOP
1203:          				break;
129B6  D02B     BRA 0x2A0E
1204:          			default :
1205:          				c = 0;
129B8  0EFF     MOVLW 0xFF
129BA  6AE3     CLRF 0xFE3, ACCESS
1206:          				break;
129BC  D028     BRA 0x2A0E
1207:          		}
129BE  0EFF     MOVLW 0xFF
129C0  50E3     MOVF 0xFE3, W, ACCESS
129C2  6E0B     MOVWF 0xB, ACCESS
129C4  6A0C     CLRF 0xC, ACCESS
129C6  500C     MOVF 0xC, W, ACCESS
129C8  0A00     XORLW 0x0
129CA  A4D8     BTFSS 0xFD8, 2, ACCESS
129CC  D7F5     BRA 0x29B8
129CE  500B     MOVF 0xB, W, ACCESS
129D0  0A58     XORLW 0x58
129D2  B4D8     BTFSC 0xFD8, 2, ACCESS
129D4  D7EA     BRA 0x29AA
129D6  0A3C     XORLW 0x3C
129D8  B4D8     BTFSC 0xFD8, 2, ACCESS
129DA  D7E7     BRA 0x29AA
129DC  0A0C     XORLW 0xC
129DE  B4D8     BTFSC 0xFD8, 2, ACCESS
129E0  D7AB     BRA 0x2938
129E2  0A01     XORLW 0x1
129E4  B4D8     BTFSC 0xFD8, 2, ACCESS
129E6  D7E1     BRA 0x29AA
129E8  0A07     XORLW 0x7
129EA  B4D8     BTFSC 0xFD8, 2, ACCESS
129EC  D7DE     BRA 0x29AA
129EE  0A01     XORLW 0x1
129F0  B4D8     BTFSC 0xFD8, 2, ACCESS
129F2  D7DB     BRA 0x29AA
129F4  0A1B     XORLW 0x1B
129F6  B4D8     BTFSC 0xFD8, 2, ACCESS
129F8  D7C6     BRA 0x2986
129FA  0A01     XORLW 0x1
129FC  B4D8     BTFSC 0xFD8, 2, ACCESS
129FE  D7D5     BRA 0x29AA
12A00  0A0D     XORLW 0xD
12A02  B4D8     BTFSC 0xFD8, 2, ACCESS
12A04  D7D2     BRA 0x29AA
12A06  0A02     XORLW 0x2
12A08  B4D8     BTFSC 0xFD8, 2, ACCESS
12A0A  D7BD     BRA 0x2986
12A0C  D7D5     BRA 0x29B8
1208:          		// At this point cp points to the conversion and c specifies the length
1209:          #endif // _VFPF_LENGTH_MOD
1210:          
1211:          		/* Signed integers */
1212:          #ifdef _VFPF_SIGNED_CONV
1213:          		if (*cp == 'd' || *cp == 'i') {
12A0E  50E1     MOVF 0xFE1, W, ACCESS
12A10  0FFB     ADDLW 0xFB
12A12  6ED9     MOVWF 0xFD9, ACCESS
12A14  50E2     MOVF 0xFE2, W, ACCESS
12A16  6EDA     MOVWF __end_of_UART2_tx_vect_isr, ACCESS
12A18  0EFF     MOVLW 0xFF
12A1A  22DA     ADDWFC __end_of_UART2_tx_vect_isr, F, ACCESS
12A1C  C4DE     MOVFF POSTINC2, TBLPTR
12A1E  F4F6     NOP
12A20  C4DD     MOVFF POSTDEC2, TBLPTRH
12A22  F4F7     NOP
12A24  0E00     MOVLW 0x0
12A26  6EF8     MOVWF 0xFF8, ACCESS
12A28  0008     TBLRD*
12A2A  50F5     MOVF 0xFF5, W, ACCESS
12A2C  0A64     XORLW 0x64
12A2E  B4D8     BTFSC 0xFD8, 2, ACCESS
12A30  D0A5     BRA 0x2B7C
12A32  50E1     MOVF 0xFE1, W, ACCESS
12A34  0FFB     ADDLW 0xFB
12A36  6ED9     MOVWF 0xFD9, ACCESS
12A38  50E2     MOVF 0xFE2, W, ACCESS
12A3A  6EDA     MOVWF __end_of_UART2_tx_vect_isr, ACCESS
12A3C  0EFF     MOVLW 0xFF
12A3E  22DA     ADDWFC __end_of_UART2_tx_vect_isr, F, ACCESS
12A40  C4DE     MOVFF POSTINC2, TBLPTR
12A42  F4F6     NOP
12A44  C4DD     MOVFF POSTDEC2, TBLPTRH
12A46  F4F7     NOP
12A48  0E00     MOVLW 0x0
12A4A  6EF8     MOVWF 0xFF8, ACCESS
12A4C  0008     TBLRD*
12A4E  50F5     MOVF 0xFF5, W, ACCESS
12A50  0A69     XORLW 0x69
12A52  B4D8     BTFSC 0xFD8, 2, ACCESS
12A54  D093     BRA 0x2B7C
12A56  D0D2     BRA 0x2BFC
1214:          #ifdef _VFPF_LENGTH_MOD
1215:          			switch (c) {
1216:          				case 'i':
1217:          					convarg.sint = (vfpf_sint_t)(int)va_arg(ap, int);
1218:          					break;
1219:          #ifdef _VFPF_H
1220:          				case 'h':
1221:          					convarg.sint = (vfpf_sint_t)(short)va_arg(ap, int);
1222:          					break;
1223:          #endif
1224:          #ifdef _VFPF_HH
1225:          				case 'H':
1226:          					convarg.sint = (vfpf_sint_t)(signed char)va_arg(ap, int);
12A58  0EEF     MOVLW 0xEF
12A5A  C4E3     MOVFF PLUSW1, FSR2
12A5C  F4D9     NOP
12A5E  0EF0     MOVLW 0xF0
12A60  C4E3     MOVFF PLUSW1, FSR2H
12A62  F4DA     NOP
12A64  0E02     MOVLW 0x2
12A66  5EDE     SUBWF 0xFDE, F, ACCESS
12A68  0E00     MOVLW 0x0
12A6A  5ADD     SUBWFB 0xFDD, F, ACCESS
12A6C  0061     MOVFFL POSTINC2, wtemp5
12A6E  F378     NOP
12A70  F50B     NOP
12A72  0061     MOVFFL POSTDEC2, 0x50C
12A74  F374     NOP
12A76  F50C     NOP
12A78  0061     MOVFFL wtemp5, FSR2
12A7A  F42C     NOP
12A7C  F4D9     NOP
12A7E  0061     MOVFFL 0x50C, FSR2H
12A80  F430     NOP
12A82  F4DA     NOP
12A84  50DF     MOVF 0xFDF, W, ACCESS
12A86  6E09     MOVWF 0x9, ACCESS
12A88  0E00     MOVLW 0x0
12A8A  BE09     BTFSC 0x9, 7, ACCESS
12A8C  0EFF     MOVLW 0xFF
12A8E  6E0A     MOVWF 0xA, ACCESS
12A90  6E0B     MOVWF 0xB, ACCESS
12A92  6E0C     MOVWF 0xC, ACCESS
12A94  0EF7     MOVLW 0xF7
12A96  0061     MOVFFL ltemp2, PLUSW1
12A98  F424     NOP
12A9A  F4E3     NOP
12A9C  0EF8     MOVLW 0xF8
12A9E  0061     MOVFFL ttemp3, PLUSW1
12AA0  F428     NOP
12AA2  F4E3     NOP
12AA4  0EF9     MOVLW 0xF9
12AA6  0061     MOVFFL wtemp5, PLUSW1
12AA8  F42C     NOP
12AAA  F4E3     NOP
12AAC  0EFA     MOVLW 0xFA
12AAE  0061     MOVFFL 0x50C, PLUSW1
12AB0  F430     NOP
12AB2  F4E3     NOP
1227:          					break;
12AB4  D07B     BRA 0x2BAC
1228:          #endif
1229:          #ifdef _VFPF_L
1230:          				case 'l':
1231:          					convarg.sint = (vfpf_sint_t)va_arg(ap, long);
1232:          					break;
1233:          #endif
1234:          #ifdef _VFPF_LL
1235:          				case 'L':
1236:          					convarg.sint = (vfpf_sint_t)va_arg(ap, long long);
1237:          					break;
1238:          #endif
1239:          #ifdef _VFPF_T
1240:          				case 't':
1241:          					convarg.sint = (vfpf_sint_t)va_arg(ap, ptrdiff_t);
12AB6  0EEF     MOVLW 0xEF
12AB8  C4E3     MOVFF PLUSW1, FSR2
12ABA  F4D9     NOP
12ABC  0EF0     MOVLW 0xF0
12ABE  C4E3     MOVFF PLUSW1, FSR2H
12AC0  F4DA     NOP
12AC2  0E02     MOVLW 0x2
12AC4  5EDE     SUBWF 0xFDE, F, ACCESS
12AC6  0E00     MOVLW 0x0
12AC8  5ADD     SUBWFB 0xFDD, F, ACCESS
12ACA  0061     MOVFFL POSTINC2, wtemp5
12ACC  F378     NOP
12ACE  F50B     NOP
12AD0  0061     MOVFFL POSTDEC2, 0x50C
12AD2  F374     NOP
12AD4  F50C     NOP
12AD6  0061     MOVFFL wtemp5, FSR2
12AD8  F42C     NOP
12ADA  F4D9     NOP
12ADC  0061     MOVFFL 0x50C, FSR2H
12ADE  F430     NOP
12AE0  F4DA     NOP
12AE2  0061     MOVFFL POSTINC2, wtemp5
12AE4  F378     NOP
12AE6  F50B     NOP
12AE8  0061     MOVFFL POSTDEC2, 0x50C
12AEA  F374     NOP
12AEC  F50C     NOP
12AEE  0EF7     MOVLW 0xF7
12AF0  0061     MOVFFL wtemp5, PLUSW1
12AF2  F42C     NOP
12AF4  F4E3     NOP
12AF6  0EF8     MOVLW 0xF8
12AF8  0061     MOVFFL 0x50C, PLUSW1
12AFA  F430     NOP
12AFC  F4E3     NOP
12AFE  6A01     CLRF __ptext283, ACCESS
12B00  BEE3     BTFSC 0xFE3, 7, ACCESS
12B02  6801     SETF __ptext283, ACCESS
12B04  0EF9     MOVLW 0xF9
12B06  0061     MOVFFL ltemp0, PLUSW1
12B08  F404     NOP
12B0A  F4E3     NOP
12B0C  0EFA     MOVLW 0xFA
12B0E  0061     MOVFFL ltemp0, PLUSW1
12B10  F404     NOP
12B12  F4E3     NOP
1242:          					break;
12B14  D04B     BRA 0x2BAC
1243:          #endif
1244:          #ifdef _VFPF_J
1245:          				case 'j':
1246:          					convarg.sint = (vfpf_sint_t)va_arg(ap, intmax_t);
1247:          					break;
1248:          #endif
1249:          #ifdef _VFPF_Z
1250:          				case 'z':
1251:          					convarg.sint = (vfpf_sint_t)va_arg(ap, size_t);
12B16  0EEF     MOVLW 0xEF
12B18  C4E3     MOVFF PLUSW1, FSR2
12B1A  F4D9     NOP
12B1C  0EF0     MOVLW 0xF0
12B1E  C4E3     MOVFF PLUSW1, FSR2H
12B20  F4DA     NOP
12B22  0E02     MOVLW 0x2
12B24  5EDE     SUBWF 0xFDE, F, ACCESS
12B26  0E00     MOVLW 0x0
12B28  5ADD     SUBWFB 0xFDD, F, ACCESS
12B2A  0061     MOVFFL POSTINC2, wtemp5
12B2C  F378     NOP
12B2E  F50B     NOP
12B30  0061     MOVFFL POSTDEC2, 0x50C
12B32  F374     NOP
12B34  F50C     NOP
12B36  0061     MOVFFL wtemp5, FSR2
12B38  F42C     NOP
12B3A  F4D9     NOP
12B3C  0061     MOVFFL 0x50C, FSR2H
12B3E  F430     NOP
12B40  F4DA     NOP
12B42  0061     MOVFFL POSTINC2, wtemp5
12B44  F378     NOP
12B46  F50B     NOP
12B48  0061     MOVFFL POSTDEC2, 0x50C
12B4A  F374     NOP
12B4C  F50C     NOP
12B4E  500B     MOVF 0xB, W, ACCESS
12B50  6E05     MOVWF 0x5, ACCESS
12B52  500C     MOVF 0xC, W, ACCESS
12B54  6E06     MOVWF 0x6, ACCESS
12B56  6A07     CLRF 0x7, ACCESS
12B58  6A08     CLRF 0x8, ACCESS
12B5A  0EF7     MOVLW 0xF7
12B5C  0061     MOVFFL ltemp1, PLUSW1
12B5E  F414     NOP
12B60  F4E3     NOP
12B62  0EF8     MOVLW 0xF8
12B64  0061     MOVFFL 0x506, PLUSW1
12B66  F418     NOP
12B68  F4E3     NOP
12B6A  0EF9     MOVLW 0xF9
12B6C  0061     MOVFFL ttemp2, PLUSW1
12B6E  F41C     NOP
12B70  F4E3     NOP
12B72  0EFA     MOVLW 0xFA
12B74  0061     MOVFFL 0x508, PLUSW1
12B76  F420     NOP
12B78  F4E3     NOP
1252:          					break;
12B7A  D018     BRA 0x2BAC
1253:          #endif
1254:          			}
12B7C  0EFF     MOVLW 0xFF
12B7E  50E3     MOVF 0xFE3, W, ACCESS
12B80  6E0B     MOVWF 0xB, ACCESS
12B82  6A0C     CLRF 0xC, ACCESS
12B84  500C     MOVF 0xC, W, ACCESS
12B86  0A00     XORLW 0x0
12B88  A4D8     BTFSS 0xFD8, 2, ACCESS
12B8A  D010     BRA 0x2BAC
12B8C  500B     MOVF 0xB, W, ACCESS
12B8E  0A48     XORLW 0x48
12B90  B4D8     BTFSC 0xFD8, 2, ACCESS
12B92  D762     BRA 0x2A58
12B94  0A20     XORLW 0x20
12B96  B4D8     BTFSC 0xFD8, 2, ACCESS
12B98  D78E     BRA 0x2AB6
12B9A  0A01     XORLW 0x1
12B9C  B4D8     BTFSC 0xFD8, 2, ACCESS
12B9E  D78B     BRA 0x2AB6
12BA0  0A1D     XORLW 0x1D
12BA2  B4D8     BTFSC 0xFD8, 2, ACCESS
12BA4  D788     BRA 0x2AB6
12BA6  0A0E     XORLW 0xE
12BA8  B4D8     BTFSC 0xFD8, 2, ACCESS
12BAA  D7B5     BRA 0x2B16
1255:          #else //!_VFPF_LENGTH_MOD
1256:          			convarg.sint = (vfpf_sint_t)(int)va_arg(ap, int);
1257:          #endif
1258:          			*fmt = cp+1;
12BAC  0EFB     MOVLW 0xFB
12BAE  50E3     MOVF 0xFE3, W, ACCESS
12BB0  0F01     ADDLW 0x1
12BB2  6E0B     MOVWF 0xB, ACCESS
12BB4  0EFC     MOVLW 0xFC
12BB6  0061     MOVFFL PLUSW1, 0x50C
12BB8  F38C     NOP
12BBA  F50C     NOP
12BBC  0E00     MOVLW 0x0
12BBE  220C     ADDWFC 0xC, F, ACCESS
12BC0  0EF1     MOVLW 0xF1
12BC2  C4E3     MOVFF PLUSW1, FSR2
12BC4  F4D9     NOP
12BC6  0EF2     MOVLW 0xF2
12BC8  C4E3     MOVFF PLUSW1, FSR2H
12BCA  F4DA     NOP
12BCC  0061     MOVFFL wtemp5, POSTINC2
12BCE  F42C     NOP
12BD0  F4DE     NOP
12BD2  0061     MOVFFL 0x50C, POSTDEC2
12BD4  F430     NOP
12BD6  F4DD     NOP
1259:          			return _COUNT_CAST dtoa(fp, convarg.sint);
12BD8  0EF7     MOVLW 0xF7
12BDA  C4E3     MOVFF PLUSW1, POSTINC1
12BDC  F4E6     NOP
12BDE  C4E3     MOVFF PLUSW1, POSTINC1
12BE0  F4E6     NOP
12BE2  C4E3     MOVFF PLUSW1, POSTINC1
12BE4  F4E6     NOP
12BE6  C4E3     MOVFF PLUSW1, POSTINC1
12BE8  F4E6     NOP
12BEA  0EEF     MOVLW 0xEF
12BEC  C4E3     MOVFF PLUSW1, POSTINC1
12BEE  F4E6     NOP
12BF0  C4E3     MOVFF PLUSW1, POSTINC1
12BF2  F4E6     NOP
12BF4  ECBD     CALL 0x1AD7A, 0
12BF6  F0D6     NOP
12BF8  EF92     GOTO 0x13724
12BFA  F09B     NOP
1260:          		}
1261:          #endif // _VFPF_SIGNED_CONV
1262:          
1263:          		/* Unsigned integers */
1264:          #ifdef _VFPF_UNSIGNED_CONV
1265:          		if (0
12BFC  50E1     MOVF 0xFE1, W, ACCESS
12BFE  0FFB     ADDLW 0xFB
12C00  6ED9     MOVWF 0xFD9, ACCESS
12C02  50E2     MOVF 0xFE2, W, ACCESS
12C04  6EDA     MOVWF __end_of_UART2_tx_vect_isr, ACCESS
12C06  0EFF     MOVLW 0xFF
12C08  22DA     ADDWFC __end_of_UART2_tx_vect_isr, F, ACCESS
12C0A  C4DE     MOVFF POSTINC2, TBLPTR
12C0C  F4F6     NOP
12C0E  C4DD     MOVFF POSTDEC2, TBLPTRH
12C10  F4F7     NOP
12C12  0E00     MOVLW 0x0
12C14  6EF8     MOVWF 0xFF8, ACCESS
12C16  0008     TBLRD*
12C18  50F5     MOVF 0xFF5, W, ACCESS
12C1A  0A78     XORLW 0x78
12C1C  B4D8     BTFSC 0xFD8, 2, ACCESS
12C1E  D0B7     BRA 0x2D8E
12C20  50E1     MOVF 0xFE1, W, ACCESS
12C22  0FFB     ADDLW 0xFB
12C24  6ED9     MOVWF 0xFD9, ACCESS
12C26  50E2     MOVF 0xFE2, W, ACCESS
12C28  6EDA     MOVWF __end_of_UART2_tx_vect_isr, ACCESS
12C2A  0EFF     MOVLW 0xFF
12C2C  22DA     ADDWFC __end_of_UART2_tx_vect_isr, F, ACCESS
12C2E  C4DE     MOVFF POSTINC2, TBLPTR
12C30  F4F6     NOP
12C32  C4DD     MOVFF POSTDEC2, TBLPTRH
12C34  F4F7     NOP
12C36  0E00     MOVLW 0x0
12C38  6EF8     MOVWF 0xFF8, ACCESS
12C3A  0008     TBLRD*
12C3C  50F5     MOVF 0xFF5, W, ACCESS
12C3E  0A58     XORLW 0x58
12C40  B4D8     BTFSC 0xFD8, 2, ACCESS
12C42  D0A5     BRA 0x2D8E
12C44  50E1     MOVF 0xFE1, W, ACCESS
12C46  0FFB     ADDLW 0xFB
12C48  6ED9     MOVWF 0xFD9, ACCESS
12C4A  50E2     MOVF 0xFE2, W, ACCESS
12C4C  6EDA     MOVWF __end_of_UART2_tx_vect_isr, ACCESS
12C4E  0EFF     MOVLW 0xFF
12C50  22DA     ADDWFC __end_of_UART2_tx_vect_isr, F, ACCESS
12C52  C4DE     MOVFF POSTINC2, TBLPTR
12C54  F4F6     NOP
12C56  C4DD     MOVFF POSTDEC2, TBLPTRH
12C58  F4F7     NOP
12C5A  0E00     MOVLW 0x0
12C5C  6EF8     MOVWF 0xFF8, ACCESS
12C5E  0008     TBLRD*
12C60  50F5     MOVF 0xFF5, W, ACCESS
12C62  0A6F     XORLW 0x6F
12C64  B4D8     BTFSC 0xFD8, 2, ACCESS
12C66  D093     BRA 0x2D8E
12C68  50E1     MOVF 0xFE1, W, ACCESS
12C6A  0FFB     ADDLW 0xFB
12C6C  6ED9     MOVWF 0xFD9, ACCESS
12C6E  50E2     MOVF 0xFE2, W, ACCESS
12C70  6EDA     MOVWF __end_of_UART2_tx_vect_isr, ACCESS
12C72  0EFF     MOVLW 0xFF
12C74  22DA     ADDWFC __end_of_UART2_tx_vect_isr, F, ACCESS
12C76  C4DE     MOVFF POSTINC2, TBLPTR
12C78  F4F6     NOP
12C7A  C4DD     MOVFF POSTDEC2, TBLPTRH
12C7C  F4F7     NOP
12C7E  0E00     MOVLW 0x0
12C80  6EF8     MOVWF 0xFF8, ACCESS
12C82  0008     TBLRD*
12C84  50F5     MOVF 0xFF5, W, ACCESS
12C86  0A75     XORLW 0x75
12C88  B4D8     BTFSC 0xFD8, 2, ACCESS
12C8A  D081     BRA 0x2D8E
12C8C  D117     BRA 0x2EBC
1266:          #ifdef _VFPF_x
1267:          				|| *cp == 'x'
1268:          #endif
1269:          #ifdef _VFPF_X
1270:          				|| *cp == 'X'
1271:          #endif
1272:          #ifdef _VFPF_O
1273:          				|| *cp == 'o'
1274:          #endif
1275:          #ifdef _VFPF_U
1276:          				|| *cp == 'u'
1277:          #endif
1278:          				) {
1279:          #ifdef _VFPF_LENGTH_MOD
1280:          			switch (c) {
1281:          				case 'i':
1282:          					convarg.uint = (vfpf_uint_t)(unsigned int)va_arg(ap, unsigned int);
1283:          					break;
1284:          #ifdef _VFPF_H
1285:          				case 'h':
1286:          					convarg.uint = (vfpf_uint_t)(unsigned short)va_arg(ap, unsigned int);
1287:          					break;
1288:          #endif
1289:          #ifdef _VFPF_HH
1290:          				case 'H':
1291:          					convarg.uint = (vfpf_uint_t)(unsigned char)va_arg(ap, unsigned int);
12C8E  0EEF     MOVLW 0xEF
12C90  C4E3     MOVFF PLUSW1, FSR2
12C92  F4D9     NOP
12C94  0EF0     MOVLW 0xF0
12C96  C4E3     MOVFF PLUSW1, FSR2H
12C98  F4DA     NOP
12C9A  0E02     MOVLW 0x2
12C9C  5EDE     SUBWF 0xFDE, F, ACCESS
12C9E  0E00     MOVLW 0x0
12CA0  5ADD     SUBWFB 0xFDD, F, ACCESS
12CA2  0061     MOVFFL POSTINC2, wtemp5
12CA4  F378     NOP
12CA6  F50B     NOP
12CA8  0061     MOVFFL POSTDEC2, 0x50C
12CAA  F374     NOP
12CAC  F50C     NOP
12CAE  0061     MOVFFL wtemp5, FSR2
12CB0  F42C     NOP
12CB2  F4D9     NOP
12CB4  0061     MOVFFL 0x50C, FSR2H
12CB6  F430     NOP
12CB8  F4DA     NOP
12CBA  50DF     MOVF 0xFDF, W, ACCESS
12CBC  6E0C     MOVWF 0xC, ACCESS
12CBE  0061     MOVFFL 0x50C, ltemp1
12CC0  F430     NOP
12CC2  F505     NOP
12CC4  6A06     CLRF 0x6, ACCESS
12CC6  D050     BRA 0x2D68
1292:          					break;
1293:          #endif
1294:          #ifdef _VFPF_L
1295:          				case 'l':
1296:          					convarg.uint = (vfpf_uint_t)va_arg(ap, unsigned long);
1297:          					break;
1298:          #endif
1299:          #ifdef _VFPF_LL
1300:          				case 'L':
1301:          					convarg.uint = (vfpf_uint_t)va_arg(ap, unsigned long long);
1302:          					break;
1303:          #endif
1304:          #ifdef _VFPF_T
1305:          				case 't':
1306:          					convarg.uint = (vfpf_uint_t)va_arg(ap, ptrdiff_t);
12CC8  0EEF     MOVLW 0xEF
12CCA  C4E3     MOVFF PLUSW1, FSR2
12CCC  F4D9     NOP
12CCE  0EF0     MOVLW 0xF0
12CD0  C4E3     MOVFF PLUSW1, FSR2H
12CD2  F4DA     NOP
12CD4  0E02     MOVLW 0x2
12CD6  5EDE     SUBWF 0xFDE, F, ACCESS
12CD8  0E00     MOVLW 0x0
12CDA  5ADD     SUBWFB 0xFDD, F, ACCESS
12CDC  0061     MOVFFL POSTINC2, wtemp5
12CDE  F378     NOP
12CE0  F50B     NOP
12CE2  0061     MOVFFL POSTDEC2, 0x50C
12CE4  F374     NOP
12CE6  F50C     NOP
12CE8  0061     MOVFFL wtemp5, FSR2
12CEA  F42C     NOP
12CEC  F4D9     NOP
12CEE  0061     MOVFFL 0x50C, FSR2H
12CF0  F430     NOP
12CF2  F4DA     NOP
12CF4  0061     MOVFFL POSTINC2, wtemp5
12CF6  F378     NOP
12CF8  F50B     NOP
12CFA  0061     MOVFFL POSTDEC2, 0x50C
12CFC  F374     NOP
12CFE  F50C     NOP
12D00  0EF7     MOVLW 0xF7
12D02  0061     MOVFFL wtemp5, PLUSW1
12D04  F42C     NOP
12D06  F4E3     NOP
12D08  0EF8     MOVLW 0xF8
12D0A  0061     MOVFFL 0x50C, PLUSW1
12D0C  F430     NOP
12D0E  F4E3     NOP
12D10  6A01     CLRF __ptext283, ACCESS
12D12  BEE3     BTFSC 0xFE3, 7, ACCESS
12D14  6801     SETF __ptext283, ACCESS
12D16  0EF9     MOVLW 0xF9
12D18  0061     MOVFFL ltemp0, PLUSW1
12D1A  F404     NOP
12D1C  F4E3     NOP
12D1E  0EFA     MOVLW 0xFA
12D20  0061     MOVFFL ltemp0, PLUSW1
12D22  F404     NOP
12D24  F4E3     NOP
1307:          					break;
12D26  D04B     BRA 0x2DBE
1308:          #endif
1309:          #ifdef _VFPF_J
1310:          				case 'j':
1311:          					convarg.uint = (vfpf_uint_t)va_arg(ap, uintmax_t);
1312:          					break;
1313:          #endif
1314:          #ifdef _VFPF_Z
1315:          				case 'z':
1316:          					convarg.uint = (vfpf_uint_t)va_arg(ap, size_t);
12D28  0EEF     MOVLW 0xEF
12D2A  C4E3     MOVFF PLUSW1, FSR2
12D2C  F4D9     NOP
12D2E  0EF0     MOVLW 0xF0
12D30  C4E3     MOVFF PLUSW1, FSR2H
12D32  F4DA     NOP
12D34  0E02     MOVLW 0x2
12D36  5EDE     SUBWF 0xFDE, F, ACCESS
12D38  0E00     MOVLW 0x0
12D3A  5ADD     SUBWFB 0xFDD, F, ACCESS
12D3C  0061     MOVFFL POSTINC2, wtemp5
12D3E  F378     NOP
12D40  F50B     NOP
12D42  0061     MOVFFL POSTDEC2, 0x50C
12D44  F374     NOP
12D46  F50C     NOP
12D48  0061     MOVFFL wtemp5, FSR2
12D4A  F42C     NOP
12D4C  F4D9     NOP
12D4E  0061     MOVFFL 0x50C, FSR2H
12D50  F430     NOP
12D52  F4DA     NOP
12D54  0061     MOVFFL POSTINC2, wtemp5
12D56  F378     NOP
12D58  F50B     NOP
12D5A  0061     MOVFFL POSTDEC2, 0x50C
12D5C  F374     NOP
12D5E  F50C     NOP
12D60  500B     MOVF 0xB, W, ACCESS
12D62  6E05     MOVWF 0x5, ACCESS
12D64  500C     MOVF 0xC, W, ACCESS
12D66  6E06     MOVWF 0x6, ACCESS
12D68  6A07     CLRF 0x7, ACCESS
12D6A  6A08     CLRF 0x8, ACCESS
12D6C  0EF7     MOVLW 0xF7
12D6E  0061     MOVFFL ltemp1, PLUSW1
12D70  F414     NOP
12D72  F4E3     NOP
12D74  0EF8     MOVLW 0xF8
12D76  0061     MOVFFL 0x506, PLUSW1
12D78  F418     NOP
12D7A  F4E3     NOP
12D7C  0EF9     MOVLW 0xF9
12D7E  0061     MOVFFL ttemp2, PLUSW1
12D80  F41C     NOP
12D82  F4E3     NOP
12D84  0EFA     MOVLW 0xFA
12D86  0061     MOVFFL 0x508, PLUSW1
12D88  F420     NOP
12D8A  F4E3     NOP
1317:          					break;
12D8C  D018     BRA 0x2DBE
1318:          #endif
1319:          			}
12D8E  0EFF     MOVLW 0xFF
12D90  50E3     MOVF 0xFE3, W, ACCESS
12D92  6E0B     MOVWF 0xB, ACCESS
12D94  6A0C     CLRF 0xC, ACCESS
12D96  500C     MOVF 0xC, W, ACCESS
12D98  0A00     XORLW 0x0
12D9A  A4D8     BTFSS 0xFD8, 2, ACCESS
12D9C  D010     BRA 0x2DBE
12D9E  500B     MOVF 0xB, W, ACCESS
12DA0  0A48     XORLW 0x48
12DA2  B4D8     BTFSC 0xFD8, 2, ACCESS
12DA4  D774     BRA 0x2C8E
12DA6  0A20     XORLW 0x20
12DA8  B4D8     BTFSC 0xFD8, 2, ACCESS
12DAA  D7BE     BRA 0x2D28
12DAC  0A01     XORLW 0x1
12DAE  B4D8     BTFSC 0xFD8, 2, ACCESS
12DB0  D7BB     BRA 0x2D28
12DB2  0A1D     XORLW 0x1D
12DB4  B4D8     BTFSC 0xFD8, 2, ACCESS
12DB6  D788     BRA 0x2CC8
12DB8  0A0E     XORLW 0xE
12DBA  B4D8     BTFSC 0xFD8, 2, ACCESS
12DBC  D7B5     BRA 0x2D28
1320:          #else // !_VFPF_LENGTH_MOD
1321:          			convarg.uint = (vfpf_uint_t)(unsigned int)va_arg(ap, unsigned int);
1322:          #endif
1323:          			*fmt = cp+1;
12DBE  0EFB     MOVLW 0xFB
12DC0  50E3     MOVF 0xFE3, W, ACCESS
12DC2  0F01     ADDLW 0x1
12DC4  6E0B     MOVWF 0xB, ACCESS
12DC6  0EFC     MOVLW 0xFC
12DC8  0061     MOVFFL PLUSW1, 0x50C
12DCA  F38C     NOP
12DCC  F50C     NOP
12DCE  0E00     MOVLW 0x0
12DD0  220C     ADDWFC 0xC, F, ACCESS
12DD2  0EF1     MOVLW 0xF1
12DD4  C4E3     MOVFF PLUSW1, FSR2
12DD6  F4D9     NOP
12DD8  0EF2     MOVLW 0xF2
12DDA  C4E3     MOVFF PLUSW1, FSR2H
12DDC  F4DA     NOP
12DDE  0061     MOVFFL wtemp5, POSTINC2
12DE0  F42C     NOP
12DE2  F4DE     NOP
12DE4  0061     MOVFFL 0x50C, POSTDEC2
12DE6  F430     NOP
12DE8  F4DD     NOP
1324:          			switch (*cp) {
12DEA  D046     BRA 0x2E78
1325:          #ifdef _VFPF_O
1326:          				case 'o':
1327:          					return _COUNT_CAST otoa(fp, convarg.uint);
12DEC  0EF7     MOVLW 0xF7
12DEE  C4E3     MOVFF PLUSW1, POSTINC1
12DF0  F4E6     NOP
12DF2  C4E3     MOVFF PLUSW1, POSTINC1
12DF4  F4E6     NOP
12DF6  C4E3     MOVFF PLUSW1, POSTINC1
12DF8  F4E6     NOP
12DFA  C4E3     MOVFF PLUSW1, POSTINC1
12DFC  F4E6     NOP
12DFE  0EEF     MOVLW 0xEF
12E00  C4E3     MOVFF PLUSW1, POSTINC1
12E02  F4E6     NOP
12E04  C4E3     MOVFF PLUSW1, POSTINC1
12E06  F4E6     NOP
12E08  EC38     CALL 0x1BE70, 0
12E0A  F0DF     NOP
12E0C  EF92     GOTO 0x13724
12E0E  F09B     NOP
1328:          #endif
1329:          #ifdef _VFPF_U
1330:          				case 'u':
1331:          					return _COUNT_CAST utoa(fp, convarg.uint);
12E10  0EF7     MOVLW 0xF7
12E12  C4E3     MOVFF PLUSW1, POSTINC1
12E14  F4E6     NOP
12E16  C4E3     MOVFF PLUSW1, POSTINC1
12E18  F4E6     NOP
12E1A  C4E3     MOVFF PLUSW1, POSTINC1
12E1C  F4E6     NOP
12E1E  C4E3     MOVFF PLUSW1, POSTINC1
12E20  F4E6     NOP
12E22  0EEF     MOVLW 0xEF
12E24  C4E3     MOVFF PLUSW1, POSTINC1
12E26  F4E6     NOP
12E28  C4E3     MOVFF PLUSW1, POSTINC1
12E2A  F4E6     NOP
12E2C  ECE8     CALL 0x1C9D0, 0
12E2E  F0E4     NOP
12E30  EF92     GOTO 0x13724
12E32  F09B     NOP
1332:          #endif
1333:          #ifdef _VFPF_HEX_CONV
1334:          #ifdef _VFPF_X
1335:          				case 'X':
1336:          #endif
1337:          #ifdef _VFPF_x
1338:          				case 'x':
1339:          #endif
1340:          					return _COUNT_CAST _XTOA(fp, convarg.uint, *cp);
12E34  50E1     MOVF 0xFE1, W, ACCESS
12E36  0FFB     ADDLW 0xFB
12E38  6ED9     MOVWF 0xFD9, ACCESS
12E3A  50E2     MOVF 0xFE2, W, ACCESS
12E3C  6EDA     MOVWF __end_of_UART2_tx_vect_isr, ACCESS
12E3E  0EFF     MOVLW 0xFF
12E40  22DA     ADDWFC __end_of_UART2_tx_vect_isr, F, ACCESS
12E42  C4DE     MOVFF POSTINC2, TBLPTR
12E44  F4F6     NOP
12E46  C4DD     MOVFF POSTDEC2, TBLPTRH
12E48  F4F7     NOP
12E4A  0E00     MOVLW 0x0
12E4C  6EF8     MOVWF 0xFF8, ACCESS
12E4E  0008     TBLRD*
12E50  50F5     MOVF 0xFF5, W, ACCESS
12E52  6EE6     MOVWF 0xFE6, ACCESS
12E54  0EF6     MOVLW 0xF6
12E56  C4E3     MOVFF PLUSW1, POSTINC1
12E58  F4E6     NOP
12E5A  C4E3     MOVFF PLUSW1, POSTINC1
12E5C  F4E6     NOP
12E5E  C4E3     MOVFF PLUSW1, POSTINC1
12E60  F4E6     NOP
12E62  C4E3     MOVFF PLUSW1, POSTINC1
12E64  F4E6     NOP
12E66  0EEE     MOVLW 0xEE
12E68  C4E3     MOVFF PLUSW1, POSTINC1
12E6A  F4E6     NOP
12E6C  C4E3     MOVFF PLUSW1, POSTINC1
12E6E  F4E6     NOP
12E70  EC55     CALL 0x1A4AA, 0
12E72  F0D2     NOP
12E74  EF92     GOTO 0x13724
12E76  F09B     NOP
1341:          #endif
1342:          			}
12E78  50E1     MOVF 0xFE1, W, ACCESS
12E7A  0FFB     ADDLW 0xFB
12E7C  6ED9     MOVWF 0xFD9, ACCESS
12E7E  50E2     MOVF 0xFE2, W, ACCESS
12E80  6EDA     MOVWF __end_of_UART2_tx_vect_isr, ACCESS
12E82  0EFF     MOVLW 0xFF
12E84  22DA     ADDWFC __end_of_UART2_tx_vect_isr, F, ACCESS
12E86  C4DE     MOVFF POSTINC2, TBLPTR
12E88  F4F6     NOP
12E8A  C4DD     MOVFF POSTDEC2, TBLPTRH
12E8C  F4F7     NOP
12E8E  0E00     MOVLW 0x0
12E90  6EF8     MOVWF 0xFF8, ACCESS
12E92  0008     TBLRD*
12E94  50F5     MOVF 0xFF5, W, ACCESS
12E96  6E0B     MOVWF 0xB, ACCESS
12E98  6A0C     CLRF 0xC, ACCESS
12E9A  500C     MOVF 0xC, W, ACCESS
12E9C  0A00     XORLW 0x0
12E9E  A4D8     BTFSS 0xFD8, 2, ACCESS
12EA0  D00D     BRA 0x2EBC
12EA2  500B     MOVF 0xB, W, ACCESS
12EA4  0A58     XORLW 0x58
12EA6  B4D8     BTFSC 0xFD8, 2, ACCESS
12EA8  D7C5     BRA 0x2E34
12EAA  0A37     XORLW 0x37
12EAC  B4D8     BTFSC 0xFD8, 2, ACCESS
12EAE  D79E     BRA 0x2DEC
12EB0  0A1A     XORLW 0x1A
12EB2  B4D8     BTFSC 0xFD8, 2, ACCESS
12EB4  D7AD     BRA 0x2E10
12EB6  0A0D     XORLW 0xD
12EB8  B4D8     BTFSC 0xFD8, 2, ACCESS
12EBA  D7BC     BRA 0x2E34
1343:          		}
1344:          #endif // _VFPF_UNSIGNED_CONV
1345:          
1346:          		/* Character count */
1347:          #ifdef _VFPF_N
1348:          		if (*cp == 'n') {
12EBC  50E1     MOVF 0xFE1, W, ACCESS
12EBE  0FFB     ADDLW 0xFB
12EC0  6ED9     MOVWF 0xFD9, ACCESS
12EC2  50E2     MOVF 0xFE2, W, ACCESS
12EC4  6EDA     MOVWF __end_of_UART2_tx_vect_isr, ACCESS
12EC6  0EFF     MOVLW 0xFF
12EC8  22DA     ADDWFC __end_of_UART2_tx_vect_isr, F, ACCESS
12ECA  C4DE     MOVFF POSTINC2, TBLPTR
12ECC  F4F6     NOP
12ECE  C4DD     MOVFF POSTDEC2, TBLPTRH
12ED0  F4F7     NOP
12ED2  0E00     MOVLW 0x0
12ED4  6EF8     MOVWF 0xFF8, ACCESS
12ED6  0008     TBLRD*
12ED8  50F5     MOVF 0xFF5, W, ACCESS
12EDA  0A6E     XORLW 0x6E
12EDC  B4D8     BTFSC 0xFD8, 2, ACCESS
12EDE  D0FA     BRA 0x30D4
12EE0  D129     BRA 0x3134
1349:          #ifdef _VFPF_LENGTH_MOD
1350:          			switch (c) {
1351:          				case 'i':
1352:          					*va_arg(ap, int*) = (int) nout;
12EE2  0EEF     MOVLW 0xEF
12EE4  C4E3     MOVFF PLUSW1, FSR2
12EE6  F4D9     NOP
12EE8  0EF0     MOVLW 0xF0
12EEA  C4E3     MOVFF PLUSW1, FSR2H
12EEC  F4DA     NOP
12EEE  0E02     MOVLW 0x2
12EF0  5EDE     SUBWF 0xFDE, F, ACCESS
12EF2  0E00     MOVLW 0x0
12EF4  5ADD     SUBWFB 0xFDD, F, ACCESS
12EF6  0061     MOVFFL POSTINC2, wtemp5
12EF8  F378     NOP
12EFA  F50B     NOP
12EFC  0061     MOVFFL POSTDEC2, 0x50C
12EFE  F374     NOP
12F00  F50C     NOP
12F02  0061     MOVFFL wtemp5, FSR2
12F04  F42C     NOP
12F06  F4D9     NOP
12F08  0061     MOVFFL 0x50C, FSR2H
12F0A  F430     NOP
12F0C  F4DA     NOP
12F0E  0061     MOVFFL POSTINC2, wtemp5
12F10  F378     NOP
12F12  F50B     NOP
12F14  0061     MOVFFL POSTDEC2, 0x50C
12F16  F374     NOP
12F18  F50C     NOP
12F1A  0061     MOVFFL wtemp5, TBLPTR
12F1C  F42C     NOP
12F1E  F4F6     NOP
12F20  0061     MOVFFL 0x50C, TBLPTRH
12F22  F430     NOP
12F24  F4F7     NOP
12F26  0E00     MOVLW 0x0
12F28  6EF8     MOVWF 0xFF8, ACCESS
12F2A  0E3F     MOVLW 0x3F
12F2C  64F7     CPFSGT 0xFF7, ACCESS
12F2E  D007     BRA 0x2F3E
12F30  C5CB     MOVFF nout, TABLAT
12F32  F4F5     NOP
12F34  000D     TBLWT*+
12F36  C5CC     MOVFF 0x5CC, TABLAT
12F38  F4F5     NOP
12F3A  000C     TBLWT*
12F3C  D001     BRA 0x2F40
12F3E  D0C1     BRA 0x30C2
1353:          					break;
12F40  D0E1     BRA 0x3104
1354:          #ifdef _VFPF_H
1355:          				case 'h':
1356:          					*va_arg(ap, short*) = (short) nout;
12F42  0EEF     MOVLW 0xEF
12F44  C4E3     MOVFF PLUSW1, FSR2
12F46  F4D9     NOP
12F48  0EF0     MOVLW 0xF0
12F4A  C4E3     MOVFF PLUSW1, FSR2H
12F4C  F4DA     NOP
12F4E  0E02     MOVLW 0x2
12F50  5EDE     SUBWF 0xFDE, F, ACCESS
12F52  0E00     MOVLW 0x0
12F54  5ADD     SUBWFB 0xFDD, F, ACCESS
12F56  0061     MOVFFL POSTINC2, wtemp5
12F58  F378     NOP
12F5A  F50B     NOP
12F5C  0061     MOVFFL POSTDEC2, 0x50C
12F5E  F374     NOP
12F60  F50C     NOP
12F62  0061     MOVFFL wtemp5, FSR2
12F64  F42C     NOP
12F66  F4D9     NOP
12F68  0061     MOVFFL 0x50C, FSR2H
12F6A  F430     NOP
12F6C  F4DA     NOP
12F6E  0061     MOVFFL POSTINC2, wtemp5
12F70  F378     NOP
12F72  F50B     NOP
12F74  0061     MOVFFL POSTDEC2, 0x50C
12F76  F374     NOP
12F78  F50C     NOP
12F7A  0061     MOVFFL wtemp5, TBLPTR
12F7C  F42C     NOP
12F7E  F4F6     NOP
12F80  0061     MOVFFL 0x50C, TBLPTRH
12F82  F430     NOP
12F84  F4F7     NOP
12F86  0E00     MOVLW 0x0
12F88  6EF8     MOVWF 0xFF8, ACCESS
12F8A  0E3F     MOVLW 0x3F
12F8C  64F7     CPFSGT 0xFF7, ACCESS
12F8E  D007     BRA 0x2F9E
12F90  C5CB     MOVFF nout, TABLAT
12F92  F4F5     NOP
12F94  000D     TBLWT*+
12F96  C5CC     MOVFF 0x5CC, TABLAT
12F98  F4F5     NOP
12F9A  000C     TBLWT*
12F9C  D001     BRA 0x2FA0
12F9E  D091     BRA 0x30C2
1357:          					break;
12FA0  D0B1     BRA 0x3104
1358:          #endif
1359:          #ifdef _VFPF_HH
1360:          				case 'H':
1361:          					*va_arg(ap, signed char*) = (signed char) nout;
12FA2  0EEF     MOVLW 0xEF
12FA4  C4E3     MOVFF PLUSW1, FSR2
12FA6  F4D9     NOP
12FA8  0EF0     MOVLW 0xF0
12FAA  C4E3     MOVFF PLUSW1, FSR2H
12FAC  F4DA     NOP
12FAE  0E02     MOVLW 0x2
12FB0  5EDE     SUBWF 0xFDE, F, ACCESS
12FB2  0E00     MOVLW 0x0
12FB4  5ADD     SUBWFB 0xFDD, F, ACCESS
12FB6  0061     MOVFFL POSTINC2, wtemp5
12FB8  F378     NOP
12FBA  F50B     NOP
12FBC  0061     MOVFFL POSTDEC2, 0x50C
12FBE  F374     NOP
12FC0  F50C     NOP
12FC2  0061     MOVFFL wtemp5, FSR2
12FC4  F42C     NOP
12FC6  F4D9     NOP
12FC8  0061     MOVFFL 0x50C, FSR2H
12FCA  F430     NOP
12FCC  F4DA     NOP
12FCE  0061     MOVFFL POSTINC2, wtemp5
12FD0  F378     NOP
12FD2  F50B     NOP
12FD4  0061     MOVFFL POSTDEC2, 0x50C
12FD6  F374     NOP
12FD8  F50C     NOP
12FDA  0061     MOVFFL wtemp5, TBLPTR
12FDC  F42C     NOP
12FDE  F4F6     NOP
12FE0  0061     MOVFFL 0x50C, TBLPTRH
12FE2  F430     NOP
12FE4  F4F7     NOP
12FE6  0E00     MOVLW 0x0
12FE8  6EF8     MOVWF 0xFF8, ACCESS
12FEA  0E3F     MOVLW 0x3F
12FEC  64F7     CPFSGT 0xFF7, ACCESS
12FEE  D004     BRA 0x2FF8
12FF0  C5CB     MOVFF nout, TABLAT
12FF2  F4F5     NOP
12FF4  000C     TBLWT*
12FF6  D006     BRA 0x3004
12FF8  C4F6     MOVFF TBLPTR, FSR0
12FFA  F4E9     NOP
12FFC  C4F7     MOVFF TBLPTRH, FSR0H
12FFE  F4EA     NOP
13000  C5CB     MOVFF nout, INDF0
13002  F4EF     NOP
1362:          					break;
13004  D07F     BRA 0x3104
1363:          #endif
1364:          #ifdef _VFPF_L
1365:          				case 'l':
1366:          					*va_arg(ap, long*) = (long) nout;
1367:          					break;
1368:          #endif
1369:          #ifdef _VFPF_LL
1370:          				case 'L':
1371:          					*va_arg(ap, long long*) = (long long) nout;
1372:          					break;
1373:          #endif
1374:          #ifdef _VFPF_T
1375:          				case 't':
1376:          					*va_arg(ap, ptrdiff_t*) = (ptrdiff_t) nout;
13006  0EEF     MOVLW 0xEF
13008  C4E3     MOVFF PLUSW1, FSR2
1300A  F4D9     NOP
1300C  0EF0     MOVLW 0xF0
1300E  C4E3     MOVFF PLUSW1, FSR2H
13010  F4DA     NOP
13012  0E02     MOVLW 0x2
13014  5EDE     SUBWF 0xFDE, F, ACCESS
13016  0E00     MOVLW 0x0
13018  5ADD     SUBWFB 0xFDD, F, ACCESS
1301A  0061     MOVFFL POSTINC2, wtemp5
1301C  F378     NOP
1301E  F50B     NOP
13020  0061     MOVFFL POSTDEC2, 0x50C
13022  F374     NOP
13024  F50C     NOP
13026  0061     MOVFFL wtemp5, FSR2
13028  F42C     NOP
1302A  F4D9     NOP
1302C  0061     MOVFFL 0x50C, FSR2H
1302E  F430     NOP
13030  F4DA     NOP
13032  0061     MOVFFL POSTINC2, wtemp5
13034  F378     NOP
13036  F50B     NOP
13038  0061     MOVFFL POSTDEC2, 0x50C
1303A  F374     NOP
1303C  F50C     NOP
1303E  0061     MOVFFL wtemp5, TBLPTR
13040  F42C     NOP
13042  F4F6     NOP
13044  0061     MOVFFL 0x50C, TBLPTRH
13046  F430     NOP
13048  F4F7     NOP
1304A  0E00     MOVLW 0x0
1304C  6EF8     MOVWF 0xFF8, ACCESS
1304E  0E3F     MOVLW 0x3F
13050  64F7     CPFSGT 0xFF7, ACCESS
13052  D007     BRA 0x3062
13054  C5CB     MOVFF nout, TABLAT
13056  F4F5     NOP
13058  000D     TBLWT*+
1305A  C5CC     MOVFF 0x5CC, TABLAT
1305C  F4F5     NOP
1305E  000C     TBLWT*
13060  D001     BRA 0x3064
13062  D02F     BRA 0x30C2
1377:          					break;
13064  D04F     BRA 0x3104
1378:          #endif
1379:          #ifdef _VFPF_J
1380:          				case 'j':
1381:          					*va_arg(ap, intmax_t*) = (intmax_t) nout;
1382:          					break;
1383:          #endif
1384:          #ifdef _VFPF_Z
1385:          				case 'z':
1386:          					*va_arg(ap, size_t*) = (size_t) nout;
13066  0EEF     MOVLW 0xEF
13068  C4E3     MOVFF PLUSW1, FSR2
1306A  F4D9     NOP
1306C  0EF0     MOVLW 0xF0
1306E  C4E3     MOVFF PLUSW1, FSR2H
13070  F4DA     NOP
13072  0E02     MOVLW 0x2
13074  5EDE     SUBWF 0xFDE, F, ACCESS
13076  0E00     MOVLW 0x0
13078  5ADD     SUBWFB 0xFDD, F, ACCESS
1307A  0061     MOVFFL POSTINC2, wtemp5
1307C  F378     NOP
1307E  F50B     NOP
13080  0061     MOVFFL POSTDEC2, 0x50C
13082  F374     NOP
13084  F50C     NOP
13086  0061     MOVFFL wtemp5, FSR2
13088  F42C     NOP
1308A  F4D9     NOP
1308C  0061     MOVFFL 0x50C, FSR2H
1308E  F430     NOP
13090  F4DA     NOP
13092  0061     MOVFFL POSTINC2, wtemp5
13094  F378     NOP
13096  F50B     NOP
13098  0061     MOVFFL POSTDEC2, 0x50C
1309A  F374     NOP
1309C  F50C     NOP
1309E  0061     MOVFFL wtemp5, TBLPTR
130A0  F42C     NOP
130A2  F4F6     NOP
130A4  0061     MOVFFL 0x50C, TBLPTRH
130A6  F430     NOP
130A8  F4F7     NOP
130AA  0E00     MOVLW 0x0
130AC  6EF8     MOVWF 0xFF8, ACCESS
130AE  0E3F     MOVLW 0x3F
130B0  64F7     CPFSGT 0xFF7, ACCESS
130B2  D007     BRA 0x30C2
130B4  C5CB     MOVFF nout, TABLAT
130B6  F4F5     NOP
130B8  000D     TBLWT*+
130BA  C5CC     MOVFF 0x5CC, TABLAT
130BC  F4F5     NOP
130BE  000C     TBLWT*
130C0  D008     BRA 0x30D2
130C2  C4F6     MOVFF TBLPTR, FSR0
130C4  F4E9     NOP
130C6  C4F7     MOVFF TBLPTRH, FSR0H
130C8  F4EA     NOP
130CA  C5CB     MOVFF nout, POSTINC0
130CC  F4EE     NOP
130CE  C5CC     MOVFF 0x5CC, INDF0
130D0  F4EF     NOP
1387:          					break;
130D2  D018     BRA 0x3104
1388:          #endif
1389:          			}
130D4  0EFF     MOVLW 0xFF
130D6  50E3     MOVF 0xFE3, W, ACCESS
130D8  6E0B     MOVWF 0xB, ACCESS
130DA  6A0C     CLRF 0xC, ACCESS
130DC  500C     MOVF 0xC, W, ACCESS
130DE  0A00     XORLW 0x0
130E0  A4D8     BTFSS 0xFD8, 2, ACCESS
130E2  D010     BRA 0x3104
130E4  500B     MOVF 0xB, W, ACCESS
130E6  0A48     XORLW 0x48
130E8  B4D8     BTFSC 0xFD8, 2, ACCESS
130EA  D75B     BRA 0x2FA2
130EC  0A20     XORLW 0x20
130EE  B4D8     BTFSC 0xFD8, 2, ACCESS
130F0  D728     BRA 0x2F42
130F2  0A01     XORLW 0x1
130F4  B4D8     BTFSC 0xFD8, 2, ACCESS
130F6  D6F5     BRA 0x2EE2
130F8  0A1D     XORLW 0x1D
130FA  B4D8     BTFSC 0xFD8, 2, ACCESS
130FC  D784     BRA 0x3006
130FE  0A0E     XORLW 0xE
13100  B4D8     BTFSC 0xFD8, 2, ACCESS
13102  D7B1     BRA 0x3066
1390:          #else // !_VFPF_LENGTH_MOD
1391:          			*va_arg(ap, int*) = (int) nout;
1392:          #endif
1393:          			*fmt = cp+1;
13104  0EFB     MOVLW 0xFB
13106  50E3     MOVF 0xFE3, W, ACCESS
13108  0F01     ADDLW 0x1
1310A  6E0B     MOVWF 0xB, ACCESS
1310C  0EFC     MOVLW 0xFC
1310E  0061     MOVFFL PLUSW1, 0x50C
13110  F38C     NOP
13112  F50C     NOP
13114  0E00     MOVLW 0x0
13116  220C     ADDWFC 0xC, F, ACCESS
13118  0EF1     MOVLW 0xF1
1311A  C4E3     MOVFF PLUSW1, FSR2
1311C  F4D9     NOP
1311E  0EF2     MOVLW 0xF2
13120  C4E3     MOVFF PLUSW1, FSR2H
13122  F4DA     NOP
13124  0061     MOVFFL wtemp5, POSTINC2
13126  F42C     NOP
13128  F4DE     NOP
1312A  0061     MOVFFL 0x50C, POSTDEC2
1312C  F430     NOP
1312E  F4DD     NOP
1394:          			return _COUNT_CAST 0;
13130  0E00     MOVLW 0x0
13132  D2C8     BRA 0x36C4
1395:          		}
1396:          #endif // _VFPF_N
1397:          #endif // _VFPF_SIGNED_CONV || _VFPF_UNSIGNED_CONV || _VFPF_N
1398:          
1399:          #ifdef _VFPF_P
1400:                  /* Pointer */
1401:                  if (*fmt[0] == 'p') {
13134  0EF1     MOVLW 0xF1
13136  C4E3     MOVFF PLUSW1, FSR2
13138  F4D9     NOP
1313A  0EF2     MOVLW 0xF2
1313C  C4E3     MOVFF PLUSW1, FSR2H
1313E  F4DA     NOP
13140  C4DE     MOVFF POSTINC2, TBLPTR
13142  F4F6     NOP
13144  C4DD     MOVFF POSTDEC2, TBLPTRH
13146  F4F7     NOP
13148  0E00     MOVLW 0x0
1314A  6EF8     MOVWF 0xFF8, ACCESS
1314C  0008     TBLRD*
1314E  50F5     MOVF 0xFF5, W, ACCESS
13150  0A70     XORLW 0x70
13152  A4D8     BTFSS 0xFD8, 2, ACCESS
13154  D041     BRA 0x31D8
1402:                      ++*fmt;
13156  0EF1     MOVLW 0xF1
13158  C4E3     MOVFF PLUSW1, FSR2
1315A  F4D9     NOP
1315C  0EF2     MOVLW 0xF2
1315E  C4E3     MOVFF PLUSW1, FSR2H
13160  F4DA     NOP
13162  2ADE     INCF 0xFDE, F, ACCESS
13164  0E00     MOVLW 0x0
13166  22DD     ADDWFC 0xFDD, F, ACCESS
1403:                      return _COUNT_CAST _XTOA(fp, (vfpf_uint_t)(uintptr_t)va_arg(ap, void *), 'x');
13168  0E78     MOVLW 0x78
1316A  6EE6     MOVWF 0xFE6, ACCESS
1316C  0EEE     MOVLW 0xEE
1316E  C4E3     MOVFF PLUSW1, FSR2
13170  F4D9     NOP
13172  0EEF     MOVLW 0xEF
13174  C4E3     MOVFF PLUSW1, FSR2H
13176  F4DA     NOP
13178  0E02     MOVLW 0x2
1317A  5EDE     SUBWF 0xFDE, F, ACCESS
1317C  0E00     MOVLW 0x0
1317E  5ADD     SUBWFB 0xFDD, F, ACCESS
13180  0061     MOVFFL POSTINC2, wtemp5
13182  F378     NOP
13184  F50B     NOP
13186  0061     MOVFFL POSTDEC2, 0x50C
13188  F374     NOP
1318A  F50C     NOP
1318C  0061     MOVFFL wtemp5, FSR2
1318E  F42C     NOP
13190  F4D9     NOP
13192  0061     MOVFFL 0x50C, FSR2H
13194  F430     NOP
13196  F4DA     NOP
13198  0061     MOVFFL POSTINC2, wtemp5
1319A  F378     NOP
1319C  F50B     NOP
1319E  0061     MOVFFL POSTDEC2, 0x50C
131A0  F374     NOP
131A2  F50C     NOP
131A4  500B     MOVF 0xB, W, ACCESS
131A6  6E05     MOVWF 0x5, ACCESS
131A8  500C     MOVF 0xC, W, ACCESS
131AA  6E06     MOVWF 0x6, ACCESS
131AC  6A07     CLRF 0x7, ACCESS
131AE  6A08     CLRF 0x8, ACCESS
131B0  0061     MOVFFL ltemp1, POSTINC1
131B2  F414     NOP
131B4  F4E6     NOP
131B6  0061     MOVFFL 0x506, POSTINC1
131B8  F418     NOP
131BA  F4E6     NOP
131BC  0061     MOVFFL ttemp2, POSTINC1
131BE  F41C     NOP
131C0  F4E6     NOP
131C2  0061     MOVFFL 0x508, POSTINC1
131C4  F420     NOP
131C6  F4E6     NOP
131C8  0EEE     MOVLW 0xEE
131CA  C4E3     MOVFF PLUSW1, POSTINC1
131CC  F4E6     NOP
131CE  C4E3     MOVFF PLUSW1, POSTINC1
131D0  F4E6     NOP
131D2  EC55     CALL 0x1A4AA, 0
131D4  F0D2     NOP
131D6  D2A6     BRA 0x3724
1404:                  }
1405:          #endif
1406:          
1407:          #ifdef _VFPF_S
1408:                  /* String */
1409:                  if (*fmt[0] == 's' || !strncmp(*fmt, "lls", CSTRLEN("lls"))) {
131D8  0EF1     MOVLW 0xF1
131DA  C4E3     MOVFF PLUSW1, FSR2
131DC  F4D9     NOP
131DE  0EF2     MOVLW 0xF2
131E0  C4E3     MOVFF PLUSW1, FSR2H
131E2  F4DA     NOP
131E4  C4DE     MOVFF POSTINC2, TBLPTR
131E6  F4F6     NOP
131E8  C4DD     MOVFF POSTDEC2, TBLPTRH
131EA  F4F7     NOP
131EC  0E00     MOVLW 0x0
131EE  6EF8     MOVWF 0xFF8, ACCESS
131F0  0008     TBLRD*
131F2  50F5     MOVF 0xFF5, W, ACCESS
131F4  0A73     XORLW 0x73
131F6  B4D8     BTFSC 0xFD8, 2, ACCESS
131F8  D020     BRA 0x323A
131FA  0E03     MOVLW 0x3
131FC  6EE6     MOVWF 0xFE6, ACCESS
131FE  0E00     MOVLW 0x0
13200  6EE6     MOVWF 0xFE6, ACCESS
13202  0EEF     MOVLW 0xEF
13204  6EE6     MOVWF 0xFE6, ACCESS
13206  0EFF     MOVLW 0xFF
13208  6EE6     MOVWF 0xFE6, ACCESS
1320A  0EED     MOVLW 0xED
1320C  C4E3     MOVFF PLUSW1, FSR2
1320E  F4D9     NOP
13210  0EEE     MOVLW 0xEE
13212  C4E3     MOVFF PLUSW1, FSR2H
13214  F4DA     NOP
13216  0061     MOVFFL POSTINC2, wtemp5
13218  F378     NOP
1321A  F50B     NOP
1321C  0061     MOVFFL POSTDEC2, 0x50C
1321E  F374     NOP
13220  F50C     NOP
13222  0061     MOVFFL wtemp5, POSTINC1
13224  F42C     NOP
13226  F4E6     NOP
13228  0061     MOVFFL 0x50C, POSTINC1
1322A  F430     NOP
1322C  F4E6     NOP
1322E  EC1F     CALL 0x1C43E, 0
13230  F0E2     NOP
13232  5001     MOVF __ptext283, W, ACCESS
13234  1002     IORWF ___rparam_used, W, ACCESS
13236  A4D8     BTFSS 0xFD8, 2, ACCESS
13238  D05B     BRA 0x32F0
1410:          
1411:          			*fmt += *fmt[0] == 's' ? 1 : CSTRLEN("lls");
1323A  0EF1     MOVLW 0xF1
1323C  C4E3     MOVFF PLUSW1, FSR2
1323E  F4D9     NOP
13240  0EF2     MOVLW 0xF2
13242  C4E3     MOVFF PLUSW1, FSR2H
13244  F4DA     NOP
13246  C4DE     MOVFF POSTINC2, TBLPTR
13248  F4F6     NOP
1324A  C4DD     MOVFF POSTDEC2, TBLPTRH
1324C  F4F7     NOP
1324E  0E00     MOVLW 0x0
13250  6EF8     MOVWF 0xFF8, ACCESS
13252  0008     TBLRD*
13254  50F5     MOVF 0xFF5, W, ACCESS
13256  0A73     XORLW 0x73
13258  B4D8     BTFSC 0xFD8, 2, ACCESS
1325A  D002     BRA 0x3260
1325C  0E03     MOVLW 0x3
1325E  D001     BRA 0x3262
13260  0E01     MOVLW 0x1
13262  6E0B     MOVWF 0xB, ACCESS
13264  0E00     MOVLW 0x0
13266  6E0C     MOVWF 0xC, ACCESS
13268  0EF5     MOVLW 0xF5
1326A  0061     MOVFFL wtemp5, PLUSW1
1326C  F42C     NOP
1326E  F4E3     NOP
13270  0EF6     MOVLW 0xF6
13272  0061     MOVFFL 0x50C, PLUSW1
13274  F430     NOP
13276  F4E3     NOP
13278  0EF5     MOVLW 0xF5
1327A  0061     MOVFFL PLUSW1, wtemp5
1327C  F38C     NOP
1327E  F50B     NOP
13280  0EF6     MOVLW 0xF6
13282  0061     MOVFFL PLUSW1, 0x50C
13284  F38C     NOP
13286  F50C     NOP
13288  0EF1     MOVLW 0xF1
1328A  C4E3     MOVFF PLUSW1, FSR2
1328C  F4D9     NOP
1328E  0EF2     MOVLW 0xF2
13290  C4E3     MOVFF PLUSW1, FSR2H
13292  F4DA     NOP
13294  500B     MOVF 0xB, W, ACCESS
13296  26DE     ADDWF 0xFDE, F, ACCESS
13298  500C     MOVF 0xC, W, ACCESS
1329A  22DD     ADDWFC 0xFDD, F, ACCESS
1412:                      return _COUNT_CAST stoa(fp, va_arg(ap, char *));
1329C  0EEF     MOVLW 0xEF
1329E  C4E3     MOVFF PLUSW1, FSR2
132A0  F4D9     NOP
132A2  0EF0     MOVLW 0xF0
132A4  C4E3     MOVFF PLUSW1, FSR2H
132A6  F4DA     NOP
132A8  0E02     MOVLW 0x2
132AA  5EDE     SUBWF 0xFDE, F, ACCESS
132AC  0E00     MOVLW 0x0
132AE  5ADD     SUBWFB 0xFDD, F, ACCESS
132B0  0061     MOVFFL POSTINC2, wtemp5
132B2  F378     NOP
132B4  F50B     NOP
132B6  0061     MOVFFL POSTDEC2, 0x50C
132B8  F374     NOP
132BA  F50C     NOP
132BC  0061     MOVFFL wtemp5, FSR2
132BE  F42C     NOP
132C0  F4D9     NOP
132C2  0061     MOVFFL 0x50C, FSR2H
132C4  F430     NOP
132C6  F4DA     NOP
132C8  0061     MOVFFL POSTINC2, wtemp5
132CA  F378     NOP
132CC  F50B     NOP
132CE  0061     MOVFFL POSTDEC2, 0x50C
132D0  F374     NOP
132D2  F50C     NOP
132D4  0061     MOVFFL wtemp5, POSTINC1
132D6  F42C     NOP
132D8  F4E6     NOP
132DA  0061     MOVFFL 0x50C, POSTINC1
132DC  F430     NOP
132DE  F4E6     NOP
132E0  0EF1     MOVLW 0xF1
132E2  C4E3     MOVFF PLUSW1, POSTINC1
132E4  F4E6     NOP
132E6  C4E3     MOVFF PLUSW1, POSTINC1
132E8  F4E6     NOP
132EA  EC92     CALL 0x1B324, 0
132EC  F0D9     NOP
132EE  D21A     BRA 0x3724
1413:                  }
1414:          #endif
1415:          
1416:          		/* Floats */
1417:          #ifdef _VFPF_FLOAT_CONV
1418:          		cp = *fmt;
132F0  0EF1     MOVLW 0xF1
132F2  C4E3     MOVFF PLUSW1, FSR2
132F4  F4D9     NOP
132F6  0EF2     MOVLW 0xF2
132F8  C4E3     MOVFF PLUSW1, FSR2H
132FA  F4DA     NOP
132FC  0061     MOVFFL POSTINC2, wtemp5
132FE  F378     NOP
13300  F50B     NOP
13302  0061     MOVFFL POSTDEC2, 0x50C
13304  F374     NOP
13306  F50C     NOP
13308  0EFC     MOVLW 0xFC
1330A  0061     MOVFFL 0x50C, PLUSW1
1330C  F430     NOP
1330E  F4E3     NOP
13310  0EFB     MOVLW 0xFB
13312  0061     MOVFFL wtemp5, PLUSW1
13314  F42C     NOP
13316  F4E3     NOP
1419:          		c = *cp;
13318  50E1     MOVF 0xFE1, W, ACCESS
1331A  0FFB     ADDLW 0xFB
1331C  6ED9     MOVWF 0xFD9, ACCESS
1331E  50E2     MOVF 0xFE2, W, ACCESS
13320  6EDA     MOVWF __end_of_UART2_tx_vect_isr, ACCESS
13322  0EFF     MOVLW 0xFF
13324  22DA     ADDWFC __end_of_UART2_tx_vect_isr, F, ACCESS
13326  C4DE     MOVFF POSTINC2, TBLPTR
13328  F4F6     NOP
1332A  C4DD     MOVFF POSTDEC2, TBLPTRH
1332C  F4F7     NOP
1332E  0E00     MOVLW 0x0
13330  6EF8     MOVWF 0xFF8, ACCESS
13332  0008     TBLRD*
13334  0EFF     MOVLW 0xFF
13336  C4F5     MOVFF TABLAT, PLUSW1
13338  F4E3     NOP
1420:          		switch(c) {
1333A  D01C     BRA 0x3374
1421:          			// length modifiers
1422:          			case 'l':
1423:          			case 'L':
1424:          				cp++;
1333C  0EFB     MOVLW 0xFB
1333E  50E3     MOVF 0xFE3, W, ACCESS
13340  0F01     ADDLW 0x1
13342  6E01     MOVWF __ptext283, ACCESS
13344  0EFB     MOVLW 0xFB
13346  0061     MOVFFL ltemp0, PLUSW1
13348  F404     NOP
1334A  F4E3     NOP
1334C  6A01     CLRF __ptext283, ACCESS
1334E  0EFC     MOVLW 0xFC
13350  50E3     MOVF 0xFE3, W, ACCESS
13352  2001     ADDWFC __ptext283, W, ACCESS
13354  6E01     MOVWF __ptext283, ACCESS
13356  0EFC     MOVLW 0xFC
13358  0061     MOVFFL ltemp0, PLUSW1
1335A  F404     NOP
1335C  F4E3     NOP
1425:          				break;
1335E  D032     BRA 0x33C4
1426:          #ifdef _VFPF_A
1427:          			case 'a':
1428:          #ifdef _VFPF_UPCASE
1429:          			case 'A':
1430:          #endif
1431:          #endif
1432:          #ifdef _VFPF_E
1433:          			case 'e':
1434:          #ifdef _VFPF_UPCASE
1435:          			case 'E':
1436:          #endif
1437:          #endif
1438:          #ifdef _VFPF_F
1439:          			case 'f':
1440:          #ifdef _VFPF_UPCASE
1441:          			case 'F':
1442:          #endif
1443:          #endif
1444:          #ifdef _VFPF_G
1445:          			case 'g':
1446:          #ifdef _VFPF_UPCASE
1447:          			case 'G':
1448:          #endif
1449:          #endif
1450:          				c = 'l';
13360  0E6C     MOVLW 0x6C
13362  6E0C     MOVWF 0xC, ACCESS
13364  0EFF     MOVLW 0xFF
13366  0061     MOVFFL 0x50C, PLUSW1
13368  F430     NOP
1336A  F4E3     NOP
1451:          				break;
1336C  D02B     BRA 0x33C4
1452:          			default:
1453:          				c = 0;
1336E  0EFF     MOVLW 0xFF
13370  6AE3     CLRF 0xFE3, ACCESS
1454:          				break;
13372  D028     BRA 0x33C4
1455:          		}
13374  0EFF     MOVLW 0xFF
13376  50E3     MOVF 0xFE3, W, ACCESS
13378  6E0B     MOVWF 0xB, ACCESS
1337A  6A0C     CLRF 0xC, ACCESS
1337C  500C     MOVF 0xC, W, ACCESS
1337E  0A00     XORLW 0x0
13380  A4D8     BTFSS 0xFD8, 2, ACCESS
13382  D7F5     BRA 0x336E
13384  500B     MOVF 0xB, W, ACCESS
13386  0A41     XORLW 0x41
13388  B4D8     BTFSC 0xFD8, 2, ACCESS
1338A  D7EA     BRA 0x3360
1338C  0A04     XORLW 0x4
1338E  B4D8     BTFSC 0xFD8, 2, ACCESS
13390  D7E7     BRA 0x3360
13392  0A03     XORLW 0x3
13394  B4D8     BTFSC 0xFD8, 2, ACCESS
13396  D7E4     BRA 0x3360
13398  0A01     XORLW 0x1
1339A  B4D8     BTFSC 0xFD8, 2, ACCESS
1339C  D7E1     BRA 0x3360
1339E  0A0B     XORLW 0xB
133A0  B4D8     BTFSC 0xFD8, 2, ACCESS
133A2  D7CC     BRA 0x333C
133A4  0A2D     XORLW 0x2D
133A6  B4D8     BTFSC 0xFD8, 2, ACCESS
133A8  D7DB     BRA 0x3360
133AA  0A04     XORLW 0x4
133AC  B4D8     BTFSC 0xFD8, 2, ACCESS
133AE  D7D8     BRA 0x3360
133B0  0A03     XORLW 0x3
133B2  B4D8     BTFSC 0xFD8, 2, ACCESS
133B4  D7D5     BRA 0x3360
133B6  0A01     XORLW 0x1
133B8  B4D8     BTFSC 0xFD8, 2, ACCESS
133BA  D7D2     BRA 0x3360
133BC  0A0B     XORLW 0xB
133BE  B4D8     BTFSC 0xFD8, 2, ACCESS
133C0  D7BD     BRA 0x333C
133C2  D7D5     BRA 0x336E
1456:          		// at this point cp points to the conversion and c specifies the length
1457:          		if (0
133C4  50E1     MOVF 0xFE1, W, ACCESS
133C6  0FFB     ADDLW 0xFB
133C8  6ED9     MOVWF 0xFD9, ACCESS
133CA  50E2     MOVF 0xFE2, W, ACCESS
133CC  6EDA     MOVWF __end_of_UART2_tx_vect_isr, ACCESS
133CE  0EFF     MOVLW 0xFF
133D0  22DA     ADDWFC __end_of_UART2_tx_vect_isr, F, ACCESS
133D2  C4DE     MOVFF POSTINC2, TBLPTR
133D4  F4F6     NOP
133D6  C4DD     MOVFF POSTDEC2, TBLPTRH
133D8  F4F7     NOP
133DA  0E00     MOVLW 0x0
133DC  6EF8     MOVWF 0xFF8, ACCESS
133DE  0008     TBLRD*
133E0  50F5     MOVF 0xFF5, W, ACCESS
133E2  0A61     XORLW 0x61
133E4  B4D8     BTFSC 0xFD8, 2, ACCESS
133E6  D0B2     BRA 0x354C
133E8  50E1     MOVF 0xFE1, W, ACCESS
133EA  0FFB     ADDLW 0xFB
133EC  6ED9     MOVWF 0xFD9, ACCESS
133EE  50E2     MOVF 0xFE2, W, ACCESS
133F0  6EDA     MOVWF __end_of_UART2_tx_vect_isr, ACCESS
133F2  0EFF     MOVLW 0xFF
133F4  22DA     ADDWFC __end_of_UART2_tx_vect_isr, F, ACCESS
133F6  C4DE     MOVFF POSTINC2, TBLPTR
133F8  F4F6     NOP
133FA  C4DD     MOVFF POSTDEC2, TBLPTRH
133FC  F4F7     NOP
133FE  0E00     MOVLW 0x0
13400  6EF8     MOVWF 0xFF8, ACCESS
13402  0008     TBLRD*
13404  50F5     MOVF 0xFF5, W, ACCESS
13406  0A41     XORLW 0x41
13408  B4D8     BTFSC 0xFD8, 2, ACCESS
1340A  D0A0     BRA 0x354C
1340C  50E1     MOVF 0xFE1, W, ACCESS
1340E  0FFB     ADDLW 0xFB
13410  6ED9     MOVWF 0xFD9, ACCESS
13412  50E2     MOVF 0xFE2, W, ACCESS
13414  6EDA     MOVWF __end_of_UART2_tx_vect_isr, ACCESS
13416  0EFF     MOVLW 0xFF
13418  22DA     ADDWFC __end_of_UART2_tx_vect_isr, F, ACCESS
1341A  C4DE     MOVFF POSTINC2, TBLPTR
1341C  F4F6     NOP
1341E  C4DD     MOVFF POSTDEC2, TBLPTRH
13420  F4F7     NOP
13422  0E00     MOVLW 0x0
13424  6EF8     MOVWF 0xFF8, ACCESS
13426  0008     TBLRD*
13428  50F5     MOVF 0xFF5, W, ACCESS
1342A  0A65     XORLW 0x65
1342C  B4D8     BTFSC 0xFD8, 2, ACCESS
1342E  D08E     BRA 0x354C
13430  50E1     MOVF 0xFE1, W, ACCESS
13432  0FFB     ADDLW 0xFB
13434  6ED9     MOVWF 0xFD9, ACCESS
13436  50E2     MOVF 0xFE2, W, ACCESS
13438  6EDA     MOVWF __end_of_UART2_tx_vect_isr, ACCESS
1343A  0EFF     MOVLW 0xFF
1343C  22DA     ADDWFC __end_of_UART2_tx_vect_isr, F, ACCESS
1343E  C4DE     MOVFF POSTINC2, TBLPTR
13440  F4F6     NOP
13442  C4DD     MOVFF POSTDEC2, TBLPTRH
13444  F4F7     NOP
13446  0E00     MOVLW 0x0
13448  6EF8     MOVWF 0xFF8, ACCESS
1344A  0008     TBLRD*
1344C  50F5     MOVF 0xFF5, W, ACCESS
1344E  0A45     XORLW 0x45
13450  B4D8     BTFSC 0xFD8, 2, ACCESS
13452  D07C     BRA 0x354C
13454  50E1     MOVF 0xFE1, W, ACCESS
13456  0FFB     ADDLW 0xFB
13458  6ED9     MOVWF 0xFD9, ACCESS
1345A  50E2     MOVF 0xFE2, W, ACCESS
1345C  6EDA     MOVWF __end_of_UART2_tx_vect_isr, ACCESS
1345E  0EFF     MOVLW 0xFF
13460  22DA     ADDWFC __end_of_UART2_tx_vect_isr, F, ACCESS
13462  C4DE     MOVFF POSTINC2, TBLPTR
13464  F4F6     NOP
13466  C4DD     MOVFF POSTDEC2, TBLPTRH
13468  F4F7     NOP
1346A  0E00     MOVLW 0x0
1346C  6EF8     MOVWF 0xFF8, ACCESS
1346E  0008     TBLRD*
13470  50F5     MOVF 0xFF5, W, ACCESS
13472  0A66     XORLW 0x66
13474  B4D8     BTFSC 0xFD8, 2, ACCESS
13476  D06A     BRA 0x354C
13478  50E1     MOVF 0xFE1, W, ACCESS
1347A  0FFB     ADDLW 0xFB
1347C  6ED9     MOVWF 0xFD9, ACCESS
1347E  50E2     MOVF 0xFE2, W, ACCESS
13480  6EDA     MOVWF __end_of_UART2_tx_vect_isr, ACCESS
13482  0EFF     MOVLW 0xFF
13484  22DA     ADDWFC __end_of_UART2_tx_vect_isr, F, ACCESS
13486  C4DE     MOVFF POSTINC2, TBLPTR
13488  F4F6     NOP
1348A  C4DD     MOVFF POSTDEC2, TBLPTRH
1348C  F4F7     NOP
1348E  0E00     MOVLW 0x0
13490  6EF8     MOVWF 0xFF8, ACCESS
13492  0008     TBLRD*
13494  50F5     MOVF 0xFF5, W, ACCESS
13496  0A46     XORLW 0x46
13498  B4D8     BTFSC 0xFD8, 2, ACCESS
1349A  D058     BRA 0x354C
1349C  50E1     MOVF 0xFE1, W, ACCESS
1349E  0FFB     ADDLW 0xFB
134A0  6ED9     MOVWF 0xFD9, ACCESS
134A2  50E2     MOVF 0xFE2, W, ACCESS
134A4  6EDA     MOVWF __end_of_UART2_tx_vect_isr, ACCESS
134A6  0EFF     MOVLW 0xFF
134A8  22DA     ADDWFC __end_of_UART2_tx_vect_isr, F, ACCESS
134AA  C4DE     MOVFF POSTINC2, TBLPTR
134AC  F4F6     NOP
134AE  C4DD     MOVFF POSTDEC2, TBLPTRH
134B0  F4F7     NOP
134B2  0E00     MOVLW 0x0
134B4  6EF8     MOVWF 0xFF8, ACCESS
134B6  0008     TBLRD*
134B8  50F5     MOVF 0xFF5, W, ACCESS
134BA  0A67     XORLW 0x67
134BC  B4D8     BTFSC 0xFD8, 2, ACCESS
134BE  D046     BRA 0x354C
134C0  50E1     MOVF 0xFE1, W, ACCESS
134C2  0FFB     ADDLW 0xFB
134C4  6ED9     MOVWF 0xFD9, ACCESS
134C6  50E2     MOVF 0xFE2, W, ACCESS
134C8  6EDA     MOVWF __end_of_UART2_tx_vect_isr, ACCESS
134CA  0EFF     MOVLW 0xFF
134CC  22DA     ADDWFC __end_of_UART2_tx_vect_isr, F, ACCESS
134CE  C4DE     MOVFF POSTINC2, TBLPTR
134D0  F4F6     NOP
134D2  C4DD     MOVFF POSTDEC2, TBLPTRH
134D4  F4F7     NOP
134D6  0E00     MOVLW 0x0
134D8  6EF8     MOVWF 0xFF8, ACCESS
134DA  0008     TBLRD*
134DC  50F5     MOVF 0xFF5, W, ACCESS
134DE  0A47     XORLW 0x47
134E0  B4D8     BTFSC 0xFD8, 2, ACCESS
134E2  D034     BRA 0x354C
134E4  D0C9     BRA 0x3678
1458:          #ifdef _VFPF_A
1459:          				|| *cp == 'a'
1460:          #ifdef _VFPF_UPCASE
1461:          				|| *cp == 'A'
1462:          #endif
1463:          #endif
1464:          #ifdef _VFPF_E
1465:          				|| *cp == 'e'
1466:          #ifdef _VFPF_UPCASE
1467:          				|| *cp == 'E'
1468:          #endif
1469:          #endif
1470:          #ifdef _VFPF_F
1471:          				|| *cp == 'f'
1472:          #ifdef _VFPF_UPCASE
1473:          				|| *cp == 'F'
1474:          #endif
1475:          #endif
1476:          #ifdef _VFPF_G
1477:          				|| *cp == 'g'
1478:          #ifdef _VFPF_UPCASE
1479:          				|| *cp == 'G'
1480:          #endif
1481:          #endif
1482:          				) {
1483:          			switch (c) {
1484:          				case 'l':
1485:          					convarg.f = (long double)va_arg(ap, double);
1486:          					break;
1487:          				case 'L':
1488:          					convarg.f = (long double)va_arg(ap, long double);
134E6  0EEF     MOVLW 0xEF
134E8  C4E3     MOVFF PLUSW1, FSR2
134EA  F4D9     NOP
134EC  0EF0     MOVLW 0xF0
134EE  C4E3     MOVFF PLUSW1, FSR2H
134F0  F4DA     NOP
134F2  0E04     MOVLW 0x4
134F4  5EDE     SUBWF 0xFDE, F, ACCESS
134F6  0E00     MOVLW 0x0
134F8  5ADD     SUBWFB 0xFDD, F, ACCESS
134FA  0061     MOVFFL POSTINC2, wtemp5
134FC  F378     NOP
134FE  F50B     NOP
13500  0061     MOVFFL POSTDEC2, 0x50C
13502  F374     NOP
13504  F50C     NOP
13506  0061     MOVFFL wtemp5, FSR2
13508  F42C     NOP
1350A  F4D9     NOP
1350C  0061     MOVFFL 0x50C, FSR2H
1350E  F430     NOP
13510  F4DA     NOP
13512  0061     MOVFFL POSTINC2, ltemp2
13514  F378     NOP
13516  F509     NOP
13518  0061     MOVFFL POSTINC2, ttemp3
1351A  F378     NOP
1351C  F50A     NOP
1351E  0061     MOVFFL POSTINC2, wtemp5
13520  F378     NOP
13522  F50B     NOP
13524  0061     MOVFFL POSTINC2, 0x50C
13526  F378     NOP
13528  F50C     NOP
1352A  0EF7     MOVLW 0xF7
1352C  0061     MOVFFL ltemp2, PLUSW1
1352E  F424     NOP
13530  F4E3     NOP
13532  0EF8     MOVLW 0xF8
13534  0061     MOVFFL ttemp3, PLUSW1
13536  F428     NOP
13538  F4E3     NOP
1353A  0EF9     MOVLW 0xF9
1353C  0061     MOVFFL wtemp5, PLUSW1
1353E  F42C     NOP
13540  F4E3     NOP
13542  0EFA     MOVLW 0xFA
13544  0061     MOVFFL 0x50C, PLUSW1
13546  F430     NOP
13548  F4E3     NOP
1489:          					break;
1354A  D00F     BRA 0x356A
1490:          			}
1354C  0EFF     MOVLW 0xFF
1354E  50E3     MOVF 0xFE3, W, ACCESS
13550  6E0B     MOVWF 0xB, ACCESS
13552  6A0C     CLRF 0xC, ACCESS
13554  500C     MOVF 0xC, W, ACCESS
13556  0A00     XORLW 0x0
13558  A4D8     BTFSS 0xFD8, 2, ACCESS
1355A  D007     BRA 0x356A
1355C  500B     MOVF 0xB, W, ACCESS
1355E  0A4C     XORLW 0x4C
13560  B4D8     BTFSC 0xFD8, 2, ACCESS
13562  D7C1     BRA 0x34E6
13564  0A20     XORLW 0x20
13566  B4D8     BTFSC 0xFD8, 2, ACCESS
13568  D7BE     BRA 0x34E6
1491:          			*fmt = cp+1;
1356A  0EFB     MOVLW 0xFB
1356C  50E3     MOVF 0xFE3, W, ACCESS
1356E  0F01     ADDLW 0x1
13570  6E0B     MOVWF 0xB, ACCESS
13572  0EFC     MOVLW 0xFC
13574  0061     MOVFFL PLUSW1, 0x50C
13576  F38C     NOP
13578  F50C     NOP
1357A  0E00     MOVLW 0x0
1357C  220C     ADDWFC 0xC, F, ACCESS
1357E  0EF1     MOVLW 0xF1
13580  C4E3     MOVFF PLUSW1, FSR2
13582  F4D9     NOP
13584  0EF2     MOVLW 0xF2
13586  C4E3     MOVFF PLUSW1, FSR2H
13588  F4DA     NOP
1358A  0061     MOVFFL wtemp5, POSTINC2
1358C  F42C     NOP
1358E  F4DE     NOP
13590  0061     MOVFFL 0x50C, POSTDEC2
13592  F430     NOP
13594  F4DD     NOP
1492:          			switch (*cp) {
13596  D042     BRA 0x361C
1493:          #ifdef _VFPF_A
1494:          				case 'a':
1495:          #ifdef _VFPF_UPCASE
1496:          				case 'A':
1497:          #endif
1498:          					return _COUNT_CAST _ATOA(fp, convarg.f, *cp);
13598  50E1     MOVF 0xFE1, W, ACCESS
1359A  0FFB     ADDLW 0xFB
1359C  6ED9     MOVWF 0xFD9, ACCESS
1359E  50E2     MOVF 0xFE2, W, ACCESS
135A0  6EDA     MOVWF __end_of_UART2_tx_vect_isr, ACCESS
135A2  0EFF     MOVLW 0xFF
135A4  22DA     ADDWFC __end_of_UART2_tx_vect_isr, F, ACCESS
135A6  C4DE     MOVFF POSTINC2, TBLPTR
135A8  F4F6     NOP
135AA  C4DD     MOVFF POSTDEC2, TBLPTRH
135AC  F4F7     NOP
135AE  0E00     MOVLW 0x0
135B0  6EF8     MOVWF 0xFF8, ACCESS
135B2  0008     TBLRD*
135B4  50F5     MOVF 0xFF5, W, ACCESS
135B6  6EE6     MOVWF 0xFE6, ACCESS
135B8  0EF6     MOVLW 0xF6
135BA  C4E3     MOVFF PLUSW1, POSTINC1
135BC  F4E6     NOP
135BE  C4E3     MOVFF PLUSW1, POSTINC1
135C0  F4E6     NOP
135C2  C4E3     MOVFF PLUSW1, POSTINC1
135C4  F4E6     NOP
135C6  C4E3     MOVFF PLUSW1, POSTINC1
135C8  F4E6     NOP
135CA  0EEE     MOVLW 0xEE
135CC  C4E3     MOVFF PLUSW1, POSTINC1
135CE  F4E6     NOP
135D0  C4E3     MOVFF PLUSW1, POSTINC1
135D2  F4E6     NOP
135D4  EC41     CALL 0x11482, 0
135D6  F08A     NOP
135D8  D0A5     BRA 0x3724
1499:          #endif
1500:          #if defined(_VFPF_E) || defined(_VFPF_F) || defined(_VFPF_G)
1501:          #ifdef _VFPF_E
1502:          				case 'e':
1503:          #ifdef _VFPF_UPCASE
1504:          				case 'E':
1505:          #endif
1506:          #endif
1507:          #ifdef _VFPF_F
1508:          				case 'f':
1509:          #ifdef _VFPF_UPCASE
1510:          				case 'F':
135DA  50E1     MOVF 0xFE1, W, ACCESS
135DC  0FFB     ADDLW 0xFB
135DE  6ED9     MOVWF 0xFD9, ACCESS
135E0  50E2     MOVF 0xFE2, W, ACCESS
135E2  6EDA     MOVWF __end_of_UART2_tx_vect_isr, ACCESS
135E4  0EFF     MOVLW 0xFF
135E6  22DA     ADDWFC __end_of_UART2_tx_vect_isr, F, ACCESS
135E8  C4DE     MOVFF POSTINC2, TBLPTR
135EA  F4F6     NOP
135EC  C4DD     MOVFF POSTDEC2, TBLPTRH
135EE  F4F7     NOP
135F0  0E00     MOVLW 0x0
135F2  6EF8     MOVWF 0xFF8, ACCESS
135F4  0008     TBLRD*
135F6  50F5     MOVF 0xFF5, W, ACCESS
1511:          #endif
1512:          #endif
1513:          #ifdef _VFPF_G
1514:          				case 'g':
1515:          #ifdef _VFPF_UPCASE
1516:          				case 'G':
1517:          #endif
1518:          #endif
1519:          					return _COUNT_CAST efgtoa(fp, convarg.f, *cp);
135F8  6EE6     MOVWF 0xFE6, ACCESS
135FA  0EF6     MOVLW 0xF6
135FC  C4E3     MOVFF PLUSW1, POSTINC1
135FE  F4E6     NOP
13600  C4E3     MOVFF PLUSW1, POSTINC1
13602  F4E6     NOP
13604  C4E3     MOVFF PLUSW1, POSTINC1
13606  F4E6     NOP
13608  C4E3     MOVFF PLUSW1, POSTINC1
1360A  F4E6     NOP
1360C  0EEE     MOVLW 0xEE
1360E  C4E3     MOVFF PLUSW1, POSTINC1
13610  F4E6     NOP
13612  C4E3     MOVFF PLUSW1, POSTINC1
13614  F4E6     NOP
13616  EC00     CALL 0x10000, 0
13618  F080     NOP
1361A  D084     BRA 0x3724
1520:          #endif
1521:          			}
1361C  50E1     MOVF 0xFE1, W, ACCESS
1361E  0FFB     ADDLW 0xFB
13620  6ED9     MOVWF 0xFD9, ACCESS
13622  50E2     MOVF 0xFE2, W, ACCESS
13624  6EDA     MOVWF __end_of_UART2_tx_vect_isr, ACCESS
13626  0EFF     MOVLW 0xFF
13628  22DA     ADDWFC __end_of_UART2_tx_vect_isr, F, ACCESS
1362A  C4DE     MOVFF POSTINC2, TBLPTR
1362C  F4F6     NOP
1362E  C4DD     MOVFF POSTDEC2, TBLPTRH
13630  F4F7     NOP
13632  0E00     MOVLW 0x0
13634  6EF8     MOVWF 0xFF8, ACCESS
13636  0008     TBLRD*
13638  50F5     MOVF 0xFF5, W, ACCESS
1363A  6E0B     MOVWF 0xB, ACCESS
1363C  6A0C     CLRF 0xC, ACCESS
1363E  500C     MOVF 0xC, W, ACCESS
13640  0A00     XORLW 0x0
13642  A4D8     BTFSS 0xFD8, 2, ACCESS
13644  D019     BRA 0x3678
13646  500B     MOVF 0xB, W, ACCESS
13648  0A41     XORLW 0x41
1364A  B4D8     BTFSC 0xFD8, 2, ACCESS
1364C  D7A5     BRA 0x3598
1364E  0A04     XORLW 0x4
13650  B4D8     BTFSC 0xFD8, 2, ACCESS
13652  D7C3     BRA 0x35DA
13654  0A03     XORLW 0x3
13656  B4D8     BTFSC 0xFD8, 2, ACCESS
13658  D7C0     BRA 0x35DA
1365A  0A01     XORLW 0x1
1365C  B4D8     BTFSC 0xFD8, 2, ACCESS
1365E  D7BD     BRA 0x35DA
13660  0A26     XORLW 0x26
13662  B4D8     BTFSC 0xFD8, 2, ACCESS
13664  D799     BRA 0x3598
13666  0A04     XORLW 0x4
13668  B4D8     BTFSC 0xFD8, 2, ACCESS
1366A  D7B7     BRA 0x35DA
1366C  0A03     XORLW 0x3
1366E  B4D8     BTFSC 0xFD8, 2, ACCESS
13670  D7B4     BRA 0x35DA
13672  0A01     XORLW 0x1
13674  B4D8     BTFSC 0xFD8, 2, ACCESS
13676  D7B1     BRA 0x35DA
1522:          		}
1523:          #endif // _VFPF_FLOAT_CONV
1524:          
1525:          #ifdef _VFPF_PERC
1526:                  /* 'Escaped' '%' character */
1527:                  if ((*fmt)[0] == '%') {
13678  0EF1     MOVLW 0xF1
1367A  C4E3     MOVFF PLUSW1, FSR2
1367C  F4D9     NOP
1367E  0EF2     MOVLW 0xF2
13680  C4E3     MOVFF PLUSW1, FSR2H
13682  F4DA     NOP
13684  C4DE     MOVFF POSTINC2, TBLPTR
13686  F4F6     NOP
13688  C4DD     MOVFF POSTDEC2, TBLPTRH
1368A  F4F7     NOP
1368C  0E00     MOVLW 0x0
1368E  6EF8     MOVWF 0xFF8, ACCESS
13690  0008     TBLRD*
13692  50F5     MOVF 0xFF5, W, ACCESS
13694  0A25     XORLW 0x25
13696  A4D8     BTFSS 0xFD8, 2, ACCESS
13698  D019     BRA 0x36CC
1528:                      ++*fmt;
1369A  0EF1     MOVLW 0xF1
1369C  C4E3     MOVFF PLUSW1, FSR2
1369E  F4D9     NOP
136A0  0EF2     MOVLW 0xF2
136A2  C4E3     MOVFF PLUSW1, FSR2H
136A4  F4DA     NOP
136A6  2ADE     INCF 0xFDE, F, ACCESS
136A8  0E00     MOVLW 0x0
136AA  22DD     ADDWFC 0xFDD, F, ACCESS
1529:                      fputc((int)'%', fp);
136AC  0EF3     MOVLW 0xF3
136AE  C4E3     MOVFF PLUSW1, POSTINC1
136B0  F4E6     NOP
136B2  C4E3     MOVFF PLUSW1, POSTINC1
136B4  F4E6     NOP
136B6  0E25     MOVLW 0x25
136B8  6EE6     MOVWF 0xFE6, ACCESS
136BA  0E00     MOVLW 0x0
136BC  6EE6     MOVWF 0xFE6, ACCESS
136BE  ECCB     CALL 0x1DF96, 0
136C0  F0EF     NOP
1530:                      return _COUNT_CAST 1;
136C2  0E01     MOVLW 0x1
136C4  6E01     MOVWF __ptext283, ACCESS
136C6  0E00     MOVLW 0x0
136C8  6E02     MOVWF ___rparam_used, ACCESS
136CA  D02C     BRA 0x3724
1531:                  }
1532:          #endif
1533:          
1534:                  /* Unrecognized conversion */
1535:                  ++*fmt;
136CC  0EF1     MOVLW 0xF1
136CE  C4E3     MOVFF PLUSW1, FSR2
136D0  F4D9     NOP
136D2  0EF2     MOVLW 0xF2
136D4  C4E3     MOVFF PLUSW1, FSR2H
136D6  F4DA     NOP
136D8  2ADE     INCF 0xFDE, F, ACCESS
136DA  0E00     MOVLW 0x0
136DC  22DD     ADDWFC 0xFDD, F, ACCESS
136DE  D528     BRA 0x3130
1536:                  return _COUNT_CAST 0;
1537:              }
1538:          
1539:              /* No conversion, just intervening text */
1540:              fputc((int)(*fmt)[0], fp);
136E0  0EF3     MOVLW 0xF3
136E2  C4E3     MOVFF PLUSW1, POSTINC1
136E4  F4E6     NOP
136E6  C4E3     MOVFF PLUSW1, POSTINC1
136E8  F4E6     NOP
136EA  0EEF     MOVLW 0xEF
136EC  C4E3     MOVFF PLUSW1, FSR2
136EE  F4D9     NOP
136F0  0EF0     MOVLW 0xF0
136F2  C4E3     MOVFF PLUSW1, FSR2H
136F4  F4DA     NOP
136F6  C4DE     MOVFF POSTINC2, TBLPTR
136F8  F4F6     NOP
136FA  C4DD     MOVFF POSTDEC2, TBLPTRH
136FC  F4F7     NOP
136FE  0E00     MOVLW 0x0
13700  6EF8     MOVWF 0xFF8, ACCESS
13702  0008     TBLRD*
13704  50F5     MOVF 0xFF5, W, ACCESS
13706  6EE6     MOVWF 0xFE6, ACCESS
13708  0E00     MOVLW 0x0
1370A  6EE6     MOVWF 0xFE6, ACCESS
1370C  ECCB     CALL 0x1DF96, 0
1370E  F0EF     NOP
1541:              ++*fmt;
13710  0EF1     MOVLW 0xF1
13712  C4E3     MOVFF PLUSW1, FSR2
13714  F4D9     NOP
13716  0EF2     MOVLW 0xF2
13718  C4E3     MOVFF PLUSW1, FSR2H
1371A  F4DA     NOP
1371C  2ADE     INCF 0xFDE, F, ACCESS
1371E  0E00     MOVLW 0x0
13720  22DD     ADDWFC 0xFDD, F, ACCESS
13722  D7CF     BRA 0x36C2
1542:              return _COUNT_CAST 1;
1543:          }
13724  0EEF     MOVLW 0xEF
13724  0EEF     MOVLW 0xEF
13724  0EEF     MOVLW 0xEF
13724  0EEF     MOVLW 0xEF
13724  0EEF     MOVLW 0xEF
1544:          #endif
1545:          
1546:          int vfprintf(FILE *fp, const char *fmt, va_list ap)
1FEC2  52E6     MOVF 0xFE6, F, ACCESS
1FEC4  52E6     MOVF 0xFE6, F, ACCESS
1547:          {
1548:          #ifdef _VFPF_CONVERT
1549:              char *cfmt;
1550:          
1551:              cfmt = (char *)fmt;
1FEC6  0EFA     MOVLW 0xFA
1FEC8  0061     MOVFFL PLUSW1, wtemp5
1FECA  F38C     NOP
1FECC  F50B     NOP
1FECE  0EFB     MOVLW 0xFB
1FED0  0061     MOVFFL PLUSW1, 0x50C
1FED2  F38C     NOP
1FED4  F50C     NOP
1FED6  0EFF     MOVLW 0xFF
1FED8  0061     MOVFFL 0x50C, PLUSW1
1FEDA  F430     NOP
1FEDC  F4E3     NOP
1FEDE  0EFE     MOVLW 0xFE
1FEE0  0061     MOVFFL wtemp5, PLUSW1
1FEE2  F42C     NOP
1FEE4  F4E3     NOP
1552:          #ifdef _VFPF_COUNT_CHARS
1553:              nout = 0;
1FEE6  0105     MOVLB 0x5
1FEE8  6BCB     CLRF 0xCB, BANKED
1FEEA  6BCC     CLRF 0xCC, BANKED
1554:          #endif
1555:              while (*cfmt) {
1FEEC  D01D     BRA 0xFF28
1FF28  50E1     MOVF 0xFE1, W, ACCESS
1FF2A  0FFE     ADDLW 0xFE
1FF2C  6ED9     MOVWF 0xFD9, ACCESS
1FF2E  50E2     MOVF 0xFE2, W, ACCESS
1FF30  6EDA     MOVWF __end_of_UART2_tx_vect_isr, ACCESS
1FF32  0EFF     MOVLW 0xFF
1FF34  22DA     ADDWFC __end_of_UART2_tx_vect_isr, F, ACCESS
1FF36  C4DE     MOVFF POSTINC2, TBLPTR
1FF38  F4F6     NOP
1FF3A  C4DD     MOVFF POSTDEC2, TBLPTRH
1FF3C  F4F7     NOP
1FF3E  0E00     MOVLW 0x0
1FF40  6EF8     MOVWF 0xFF8, ACCESS
1FF42  0008     TBLRD*
1FF44  50F5     MOVF 0xFF5, W, ACCESS
1FF46  0900     IORLW 0x0
1FF48  A4D8     BTFSS 0xFD8, 2, ACCESS
1FF4A  D7D1     BRA 0xFEEE
1556:          #ifdef _VFPF_COUNT_CHARS
1557:                  nout +=
1FEEE  0EF8     MOVLW 0xF8
1FEF0  C4E3     MOVFF PLUSW1, POSTINC1
1FEF2  F4E6     NOP
1FEF4  C4E3     MOVFF PLUSW1, POSTINC1
1FEF6  F4E6     NOP
1FEF8  0EFC     MOVLW 0xFC
1FEFA  24E1     ADDWF 0xFE1, W, ACCESS
1FEFC  6E01     MOVWF __ptext283, ACCESS
1FEFE  0EFF     MOVLW 0xFF
1FF00  20E2     ADDWFC 0xFE2, W, ACCESS
1FF02  6E02     MOVWF ___rparam_used, ACCESS
1FF04  0061     MOVFFL ltemp0, POSTINC1
1FF06  F404     NOP
1FF08  F4E6     NOP
1FF0A  0061     MOVFFL ttemp5, POSTINC1
1FF0C  F408     NOP
1FF0E  F4E6     NOP
1FF10  0EF8     MOVLW 0xF8
1FF12  C4E3     MOVFF PLUSW1, POSTINC1
1FF14  F4E6     NOP
1FF16  C4E3     MOVFF PLUSW1, POSTINC1
1FF18  F4E6     NOP
1FF1A  EC73     CALL 0x126E6, 0
1FF1C  F093     NOP
1FF1E  5001     MOVF __ptext283, W, ACCESS
1FF20  0105     MOVLB 0x5
1FF22  27CB     ADDWF 0xCB, F, BANKED
1FF24  5002     MOVF ___rparam_used, W, ACCESS
1FF26  23CC     ADDWFC 0xCC, F, BANKED
1558:          #endif
1559:          			vfpfcnvrt(fp, &cfmt, ap);
1560:              }
1561:          #ifdef _VFPF_RETVALUE
1562:              return nout;
1FF4C  0061     MOVFFL nout, ltemp0
1FF4E  F72C     NOP
1FF50  F501     NOP
1FF52  0061     MOVFFL 0x5CC, ttemp5
1FF54  F730     NOP
1FF56  F502     NOP
1563:          #else
1564:          	return 0;
1565:          #endif
1566:          #else
1567:              return fputs(fmt, fp);
1568:          #endif
1569:          }
1FF58  0EF8     MOVLW 0xF8
1FF5A  26E1     ADDWF 0xFE1, F, ACCESS
1FF5C  0EFF     MOVLW 0xFF
1FF5E  22E2     ADDWFC 0xFE2, F, ACCESS
1FF5E  22E2     ADDWFC 0xFE2, F, ACCESS
---  /opt/microchip/xc8/v2.41/pic/sources/c99/common/awmod.c  -------------------------------------------
1:             // integer signed unsigned modulus
2:             
3:             signed int
4:             #ifdef __PICC__
5:             __awmod(signed int divisor, signed int dividend)
6:             #else
7:             __awmod(signed int dividend, signed int divisor)
1E0B4  52E6     MOVF 0xFE6, F, ACCESS
1E0B6  52E6     MOVF 0xFE6, F, ACCESS
8:             #endif
9:             {
10:            	unsigned char	counter, sign;
11:            
12:            	sign = 0;
1E0B8  0EFE     MOVLW 0xFE
1E0BA  6AE3     CLRF 0xFE3, ACCESS
13:            	if(dividend < 0) {
1E0BC  0EFD     MOVLW 0xFD
1E0BE  AEE3     BTFSS 0xFE3, 7, ACCESS
1E0C0  D009     BRA 0xE0D4
14:            		dividend = -dividend;
1E0C2  0EFC     MOVLW 0xFC
1E0C4  6CE3     NEGF 0xFE3, ACCESS
1E0C6  0EFD     MOVLW 0xFD
1E0C8  1EE3     COMF 0xFE3, F, ACCESS
1E0CA  B0D8     BTFSC 0xFD8, 0, ACCESS
1E0CC  2AE3     INCF 0xFE3, F, ACCESS
15:            		sign = 1;
1E0CE  0EFE     MOVLW 0xFE
1E0D0  6AE3     CLRF 0xFE3, ACCESS
1E0D2  2AE3     INCF 0xFE3, F, ACCESS
16:            	}
17:            	if(divisor < 0)
1E0D4  0EFB     MOVLW 0xFB
1E0D6  AEE3     BTFSS 0xFE3, 7, ACCESS
1E0D8  D006     BRA 0xE0E6
18:            		divisor = -divisor;
1E0DA  0EFA     MOVLW 0xFA
1E0DC  6CE3     NEGF 0xFE3, ACCESS
1E0DE  0EFB     MOVLW 0xFB
1E0E0  1EE3     COMF 0xFE3, F, ACCESS
1E0E2  B0D8     BTFSC 0xFD8, 0, ACCESS
1E0E4  2AE3     INCF 0xFE3, F, ACCESS
19:            	if(divisor != 0) {
1E0E6  0EFA     MOVLW 0xFA
1E0E8  0061     MOVFFL PLUSW1, ltemp0
1E0EA  F38C     NOP
1E0EC  F501     NOP
1E0EE  0EFB     MOVLW 0xFB
1E0F0  50E3     MOVF 0xFE3, W, ACCESS
1E0F2  1001     IORWF __ptext283, W, ACCESS
1E0F4  B4D8     BTFSC 0xFD8, 2, ACCESS
1E0F6  D053     BRA 0xE19E
20:            		counter = 1;
1E0F8  0EFF     MOVLW 0xFF
1E0FA  6AE3     CLRF 0xFE3, ACCESS
1E0FC  D012     BRA 0xE122
21:            		while(((unsigned int)divisor & 0x8000U) == 0) {
1E124  0EFB     MOVLW 0xFB
1E126  AEE3     BTFSS 0xFE3, 7, ACCESS
1E128  D7EA     BRA 0xE0FE
22:            			divisor <<= 1;
1E0FE  0EFA     MOVLW 0xFA
1E100  50E3     MOVF 0xFE3, W, ACCESS
1E102  90D8     BCF 0xFD8, 0, ACCESS
1E104  34E8     RLCF 0xFE8, W, ACCESS
1E106  6E01     MOVWF __ptext283, ACCESS
1E108  0EFA     MOVLW 0xFA
1E10A  0061     MOVFFL ltemp0, PLUSW1
1E10C  F404     NOP
1E10E  F4E3     NOP
1E110  0EFB     MOVLW 0xFB
1E112  50E3     MOVF 0xFE3, W, ACCESS
1E114  34E8     RLCF 0xFE8, W, ACCESS
1E116  6E01     MOVWF __ptext283, ACCESS
1E118  0EFB     MOVLW 0xFB
1E11A  0061     MOVFFL ltemp0, PLUSW1
1E11C  F404     NOP
1E11E  F4E3     NOP
23:            			counter++;
1E120  0EFF     MOVLW 0xFF
1E122  2AE3     INCF 0xFE3, F, ACCESS
24:            		}
25:            		do {
26:            			if((unsigned int)divisor <= (unsigned int)dividend)
1E12A  0EFA     MOVLW 0xFA
1E12C  0061     MOVFFL PLUSW1, wtemp5
1E12E  F38C     NOP
1E130  F50B     NOP
1E132  0EFB     MOVLW 0xFB
1E134  0061     MOVFFL PLUSW1, 0x50C
1E136  F38C     NOP
1E138  F50C     NOP
1E13A  0EFC     MOVLW 0xFC
1E13C  0061     MOVFFL PLUSW1, ltemp2
1E13E  F38C     NOP
1E140  F509     NOP
1E142  0EFD     MOVLW 0xFD
1E144  0061     MOVFFL PLUSW1, ttemp3
1E146  F38C     NOP
1E148  F50A     NOP
1E14A  500B     MOVF 0xB, W, ACCESS
1E14C  5C09     SUBWF 0x9, W, ACCESS
1E14E  500C     MOVF 0xC, W, ACCESS
1E150  580A     SUBWFB 0xA, W, ACCESS
1E152  A0D8     BTFSS 0xFD8, 0, ACCESS
1E154  D014     BRA 0xE17E
27:            				dividend -= divisor;
1E156  0EFC     MOVLW 0xFC
1E158  50E3     MOVF 0xFE3, W, ACCESS
1E15A  6E01     MOVWF __ptext283, ACCESS
1E15C  0EFA     MOVLW 0xFA
1E15E  50E3     MOVF 0xFE3, W, ACCESS
1E160  5E01     SUBWF __ptext283, F, ACCESS
1E162  0EFC     MOVLW 0xFC
1E164  0061     MOVFFL ltemp0, PLUSW1
1E166  F404     NOP
1E168  F4E3     NOP
1E16A  0EFD     MOVLW 0xFD
1E16C  50E3     MOVF 0xFE3, W, ACCESS
1E16E  6E01     MOVWF __ptext283, ACCESS
1E170  0EFB     MOVLW 0xFB
1E172  50E3     MOVF 0xFE3, W, ACCESS
1E174  5A01     SUBWFB __ptext283, F, ACCESS
1E176  0EFD     MOVLW 0xFD
1E178  0061     MOVFFL ltemp0, PLUSW1
1E17A  F404     NOP
1E17C  F4E3     NOP
28:            			*(unsigned int *)&divisor >>= 1;
1E17E  90D8     BCF 0xFD8, 0, ACCESS
1E180  0EFB     MOVLW 0xFB
1E182  32E3     RRCF 0xFE3, F, ACCESS
1E184  0EFA     MOVLW 0xFA
1E186  32E3     RRCF 0xFE3, F, ACCESS
29:            		} while(--counter != 0);
1E188  0EFF     MOVLW 0xFF
1E18A  50E3     MOVF 0xFE3, W, ACCESS
1E18C  6E01     MOVWF __ptext283, ACCESS
1E18E  0E01     MOVLW 0x1
1E190  5E01     SUBWF __ptext283, F, ACCESS
1E192  0EFF     MOVLW 0xFF
1E194  0061     MOVFFL ltemp0, PLUSW1
1E196  F404     NOP
1E198  F4E3     NOP
1E19A  A4D8     BTFSS 0xFD8, 2, ACCESS
1E19C  D7C6     BRA 0xE12A
30:            	}
31:            	if(sign)
1E19E  0EFE     MOVLW 0xFE
1E1A0  50E3     MOVF 0xFE3, W, ACCESS
1E1A2  B4D8     BTFSC 0xFD8, 2, ACCESS
1E1A4  D006     BRA 0xE1B2
32:            		dividend = -dividend;
1E1A6  0EFC     MOVLW 0xFC
1E1A8  6CE3     NEGF 0xFE3, ACCESS
1E1AA  0EFD     MOVLW 0xFD
1E1AC  1EE3     COMF 0xFE3, F, ACCESS
1E1AE  B0D8     BTFSC 0xFD8, 0, ACCESS
1E1B0  2AE3     INCF 0xFE3, F, ACCESS
33:            	return dividend;
1E1B2  0EFC     MOVLW 0xFC
1E1B4  0061     MOVFFL PLUSW1, ltemp0
1E1B6  F38C     NOP
1E1B8  F501     NOP
1E1BA  0EFD     MOVLW 0xFD
1E1BC  0061     MOVFFL PLUSW1, ttemp5
1E1BE  F38C     NOP
1E1C0  F502     NOP
34:            }
1E1C2  0EFA     MOVLW 0xFA
1E1C4  26E1     ADDWF 0xFE1, F, ACCESS
1E1C6  0EFF     MOVLW 0xFF
1E1C8  22E2     ADDWFC 0xFE2, F, ACCESS
1E1C8  22E2     ADDWFC 0xFE2, F, ACCESS
---  /opt/microchip/xc8/v2.41/pic/sources/c99/common/awdiv.c  -------------------------------------------
1:             // integer signed division
2:             
3:             signed int
4:             #ifdef __PICC__
5:             __awdiv(signed int divisor, signed int dividend)
6:             #else
7:             __awdiv(signed int dividend, signed int divisor)
1D972  52E6     MOVF 0xFE6, F, ACCESS
1D974  52E6     MOVF 0xFE6, F, ACCESS
1D976  52E6     MOVF 0xFE6, F, ACCESS
1D978  52E6     MOVF 0xFE6, F, ACCESS
8:             #endif
9:             {
10:            	signed int	quotient;
11:            	unsigned char	counter, sign;
12:            
13:            	sign = 0;
1D97A  0EFE     MOVLW 0xFE
1D97C  6AE3     CLRF 0xFE3, ACCESS
14:            	if(divisor < 0) {
1D97E  0EF9     MOVLW 0xF9
1D980  AEE3     BTFSS 0xFE3, 7, ACCESS
1D982  D009     BRA 0xD996
15:            		divisor = -divisor;
1D984  0EF8     MOVLW 0xF8
1D986  6CE3     NEGF 0xFE3, ACCESS
1D988  0EF9     MOVLW 0xF9
1D98A  1EE3     COMF 0xFE3, F, ACCESS
1D98C  B0D8     BTFSC 0xFD8, 0, ACCESS
1D98E  2AE3     INCF 0xFE3, F, ACCESS
16:            		sign = 1;
1D990  0EFE     MOVLW 0xFE
1D992  6AE3     CLRF 0xFE3, ACCESS
1D994  2AE3     INCF 0xFE3, F, ACCESS
17:            	}
18:            	if(dividend < 0) {
1D996  0EFB     MOVLW 0xFB
1D998  AEE3     BTFSS 0xFE3, 7, ACCESS
1D99A  D008     BRA 0xD9AC
19:            		dividend = -dividend;
1D99C  0EFA     MOVLW 0xFA
1D99E  6CE3     NEGF 0xFE3, ACCESS
1D9A0  0EFB     MOVLW 0xFB
1D9A2  1EE3     COMF 0xFE3, F, ACCESS
1D9A4  B0D8     BTFSC 0xFD8, 0, ACCESS
1D9A6  2AE3     INCF 0xFE3, F, ACCESS
20:            		sign ^= 1;
1D9A8  0EFE     MOVLW 0xFE
1D9AA  70E3     BTG 0xFE3, 0, ACCESS
21:            	}
22:            	quotient = 0;
1D9AC  0EFC     MOVLW 0xFC
1D9AE  6AE3     CLRF 0xFE3, ACCESS
1D9B0  0EFD     MOVLW 0xFD
1D9B2  6AE3     CLRF 0xFE3, ACCESS
23:            	if(divisor != 0) {
1D9B4  0EF8     MOVLW 0xF8
1D9B6  0061     MOVFFL PLUSW1, ltemp0
1D9B8  F38C     NOP
1D9BA  F501     NOP
1D9BC  0EF9     MOVLW 0xF9
1D9BE  50E3     MOVF 0xFE3, W, ACCESS
1D9C0  1001     IORWF __ptext283, W, ACCESS
1D9C2  B4D8     BTFSC 0xFD8, 2, ACCESS
1D9C4  D066     BRA 0xDA92
24:            		counter = 1;
1D9C6  0EFF     MOVLW 0xFF
1D9C8  6AE3     CLRF 0xFE3, ACCESS
1D9CA  D012     BRA 0xD9F0
25:            		while(((unsigned int)divisor & 0x8000U) == 0) {
1D9F2  0EF9     MOVLW 0xF9
1D9F4  AEE3     BTFSS 0xFE3, 7, ACCESS
1D9F6  D7EA     BRA 0xD9CC
26:            			divisor <<= 1;
1D9CC  0EF8     MOVLW 0xF8
1D9CE  50E3     MOVF 0xFE3, W, ACCESS
1D9D0  90D8     BCF 0xFD8, 0, ACCESS
1D9D2  34E8     RLCF 0xFE8, W, ACCESS
1D9D4  6E01     MOVWF __ptext283, ACCESS
1D9D6  0EF8     MOVLW 0xF8
1D9D8  0061     MOVFFL ltemp0, PLUSW1
1D9DA  F404     NOP
1D9DC  F4E3     NOP
1D9DE  0EF9     MOVLW 0xF9
1D9E0  50E3     MOVF 0xFE3, W, ACCESS
1D9E2  34E8     RLCF 0xFE8, W, ACCESS
1D9E4  6E01     MOVWF __ptext283, ACCESS
1D9E6  0EF9     MOVLW 0xF9
1D9E8  0061     MOVFFL ltemp0, PLUSW1
1D9EA  F404     NOP
1D9EC  F4E3     NOP
27:            			counter++;
1D9EE  0EFF     MOVLW 0xFF
1D9F0  2AE3     INCF 0xFE3, F, ACCESS
28:            		}
29:            		do {
30:            			quotient <<= 1;
1D9F8  0EFC     MOVLW 0xFC
1D9FA  50E3     MOVF 0xFE3, W, ACCESS
1D9FC  90D8     BCF 0xFD8, 0, ACCESS
1D9FE  34E8     RLCF 0xFE8, W, ACCESS
1DA00  6E01     MOVWF __ptext283, ACCESS
1DA02  0EFC     MOVLW 0xFC
1DA04  0061     MOVFFL ltemp0, PLUSW1
1DA06  F404     NOP
1DA08  F4E3     NOP
1DA0A  0EFD     MOVLW 0xFD
1DA0C  50E3     MOVF 0xFE3, W, ACCESS
1DA0E  34E8     RLCF 0xFE8, W, ACCESS
1DA10  6E01     MOVWF __ptext283, ACCESS
1DA12  0EFD     MOVLW 0xFD
1DA14  0061     MOVFFL ltemp0, PLUSW1
1DA16  F404     NOP
1DA18  F4E3     NOP
31:            			if((unsigned int)divisor <= (unsigned int)dividend) {
1DA1A  0EF8     MOVLW 0xF8
1DA1C  0061     MOVFFL PLUSW1, wtemp5
1DA1E  F38C     NOP
1DA20  F50B     NOP
1DA22  0EF9     MOVLW 0xF9
1DA24  0061     MOVFFL PLUSW1, 0x50C
1DA26  F38C     NOP
1DA28  F50C     NOP
1DA2A  0EFA     MOVLW 0xFA
1DA2C  0061     MOVFFL PLUSW1, ltemp2
1DA2E  F38C     NOP
1DA30  F509     NOP
1DA32  0EFB     MOVLW 0xFB
1DA34  0061     MOVFFL PLUSW1, ttemp3
1DA36  F38C     NOP
1DA38  F50A     NOP
1DA3A  500B     MOVF 0xB, W, ACCESS
1DA3C  5C09     SUBWF 0x9, W, ACCESS
1DA3E  500C     MOVF 0xC, W, ACCESS
1DA40  580A     SUBWFB 0xA, W, ACCESS
1DA42  A0D8     BTFSS 0xFD8, 0, ACCESS
1DA44  D016     BRA 0xDA72
32:            				dividend -= divisor;
1DA46  0EFA     MOVLW 0xFA
1DA48  50E3     MOVF 0xFE3, W, ACCESS
1DA4A  6E01     MOVWF __ptext283, ACCESS
1DA4C  0EF8     MOVLW 0xF8
1DA4E  50E3     MOVF 0xFE3, W, ACCESS
1DA50  5E01     SUBWF __ptext283, F, ACCESS
1DA52  0EFA     MOVLW 0xFA
1DA54  0061     MOVFFL ltemp0, PLUSW1
1DA56  F404     NOP
1DA58  F4E3     NOP
1DA5A  0EFB     MOVLW 0xFB
1DA5C  50E3     MOVF 0xFE3, W, ACCESS
1DA5E  6E01     MOVWF __ptext283, ACCESS
1DA60  0EF9     MOVLW 0xF9
1DA62  50E3     MOVF 0xFE3, W, ACCESS
1DA64  5A01     SUBWFB __ptext283, F, ACCESS
1DA66  0EFB     MOVLW 0xFB
1DA68  0061     MOVFFL ltemp0, PLUSW1
1DA6A  F404     NOP
1DA6C  F4E3     NOP
33:            				quotient |= 1;
1DA6E  0EFC     MOVLW 0xFC
1DA70  80E3     BSF 0xFE3, 0, ACCESS
34:            			}
35:            			*(unsigned int *)&divisor >>= 1;
1DA72  90D8     BCF 0xFD8, 0, ACCESS
1DA74  0EF9     MOVLW 0xF9
1DA76  32E3     RRCF 0xFE3, F, ACCESS
1DA78  0EF8     MOVLW 0xF8
1DA7A  32E3     RRCF 0xFE3, F, ACCESS
36:            		} while(--counter != 0);
1DA7C  0EFF     MOVLW 0xFF
1DA7E  50E3     MOVF 0xFE3, W, ACCESS
1DA80  6E01     MOVWF __ptext283, ACCESS
1DA82  0E01     MOVLW 0x1
1DA84  5E01     SUBWF __ptext283, F, ACCESS
1DA86  0EFF     MOVLW 0xFF
1DA88  0061     MOVFFL ltemp0, PLUSW1
1DA8A  F404     NOP
1DA8C  F4E3     NOP
1DA8E  A4D8     BTFSS 0xFD8, 2, ACCESS
1DA90  D7B3     BRA 0xD9F8
37:            	}
38:            	if(sign)
1DA92  0EFE     MOVLW 0xFE
1DA94  50E3     MOVF 0xFE3, W, ACCESS
1DA96  B4D8     BTFSC 0xFD8, 2, ACCESS
1DA98  D006     BRA 0xDAA6
39:            		quotient = -quotient;
1DA9A  0EFC     MOVLW 0xFC
1DA9C  6CE3     NEGF 0xFE3, ACCESS
1DA9E  0EFD     MOVLW 0xFD
1DAA0  1EE3     COMF 0xFE3, F, ACCESS
1DAA2  B0D8     BTFSC 0xFD8, 0, ACCESS
1DAA4  2AE3     INCF 0xFE3, F, ACCESS
40:            	return quotient;
1DAA6  0EFC     MOVLW 0xFC
1DAA8  0061     MOVFFL PLUSW1, ltemp0
1DAAA  F38C     NOP
1DAAC  F501     NOP
1DAAE  0EFD     MOVLW 0xFD
1DAB0  0061     MOVFFL PLUSW1, ttemp5
1DAB2  F38C     NOP
1DAB4  F502     NOP
41:            }
1DAB6  0EF8     MOVLW 0xF8
1DAB8  26E1     ADDWF 0xFE1, F, ACCESS
1DABA  0EFF     MOVLW 0xFF
1DABC  22E2     ADDWFC 0xFE2, F, ACCESS
1DABC  22E2     ADDWFC 0xFE2, F, ACCESS
---  /opt/microchip/xc8/v2.41/pic/sources/c99/common/asctime.c  -----------------------------------------
1:             /*
2:              *	asctime - no daylight saving
3:              */
4:             
5:             #include	<time.h>
6:             
7:             static void
8:             put2d(char * cp, char  i, char  cl, char  ct)
9:             {
10:            	*cp = ct;
1E936  0EFE     MOVLW 0xFE
1E938  C4E3     MOVFF PLUSW1, FSR2
1E93A  F4D9     NOP
1E93C  0EFF     MOVLW 0xFF
1E93E  C4E3     MOVFF PLUSW1, FSR2H
1E940  F4DA     NOP
1E942  0EFB     MOVLW 0xFB
1E944  C4E3     MOVFF PLUSW1, INDF2
1E946  F4DF     NOP
11:            	*--cp = i%10 + '0';
1E948  0E0A     MOVLW 0xA
1E94A  6EE6     MOVWF 0xFE6, ACCESS
1E94C  0EFC     MOVLW 0xFC
1E94E  50E3     MOVF 0xFE3, W, ACCESS
1E950  6EE6     MOVWF 0xFE6, ACCESS
1E952  EC75     CALL 0x2EA, 0
1E954  F001     NOP
1E956  0E30     MOVLW 0x30
1E958  2601     ADDWF __ptext283, F, ACCESS
1E95A  0EFE     MOVLW 0xFE
1E95C  0061     MOVFFL PLUSW1, ttemp5
1E95E  F38C     NOP
1E960  F502     NOP
1E962  0E01     MOVLW 0x1
1E964  5E02     SUBWF ___rparam_used, F, ACCESS
1E966  0EFE     MOVLW 0xFE
1E968  0061     MOVFFL ttemp5, PLUSW1
1E96A  F408     NOP
1E96C  F4E3     NOP
1E96E  0EFF     MOVLW 0xFF
1E970  0061     MOVFFL PLUSW1, ttemp5
1E972  F38C     NOP
1E974  F502     NOP
1E976  0E00     MOVLW 0x0
1E978  5A02     SUBWFB ___rparam_used, F, ACCESS
1E97A  0EFF     MOVLW 0xFF
1E97C  0061     MOVFFL ttemp5, PLUSW1
1E97E  F408     NOP
1E980  F4E3     NOP
1E982  0EFE     MOVLW 0xFE
1E984  C4E3     MOVFF PLUSW1, FSR2
1E986  F4D9     NOP
1E988  0EFF     MOVLW 0xFF
1E98A  C4E3     MOVFF PLUSW1, FSR2H
1E98C  F4DA     NOP
1E98E  0061     MOVFFL ltemp0, INDF2
1E990  F404     NOP
1E992  F4DF     NOP
12:            	if(i /= 10)
1E994  0E0A     MOVLW 0xA
1E996  6EE6     MOVWF 0xFE6, ACCESS
1E998  0E00     MOVLW 0x0
1E99A  6EE6     MOVWF 0xFE6, ACCESS
1E99C  0EFB     MOVLW 0xFB
1E99E  50E3     MOVF 0xFE3, W, ACCESS
1E9A0  6EE6     MOVWF 0xFE6, ACCESS
1E9A2  0E00     MOVLW 0x0
1E9A4  6EE6     MOVWF 0xFE6, ACCESS
1E9A6  ECB9     CALL 0x1D972, 0
1E9A8  F0EC     NOP
1E9AA  0EFD     MOVLW 0xFD
1E9AC  0061     MOVFFL ltemp0, PLUSW1
1E9AE  F404     NOP
1E9B0  F4E3     NOP
1E9B2  0EFD     MOVLW 0xFD
1E9B4  50E3     MOVF 0xFE3, W, ACCESS
1E9B6  B4D8     BTFSC 0xFD8, 2, ACCESS
1E9B8  D01F     BRA 0xE9F8
13:            		*--cp = i + '0';
1E9BA  0EFE     MOVLW 0xFE
1E9BC  0061     MOVFFL PLUSW1, ltemp0
1E9BE  F38C     NOP
1E9C0  F501     NOP
1E9C2  0E01     MOVLW 0x1
1E9C4  5E01     SUBWF __ptext283, F, ACCESS
1E9C6  0EFE     MOVLW 0xFE
1E9C8  0061     MOVFFL ltemp0, PLUSW1
1E9CA  F404     NOP
1E9CC  F4E3     NOP
1E9CE  0EFF     MOVLW 0xFF
1E9D0  0061     MOVFFL PLUSW1, ltemp0
1E9D2  F38C     NOP
1E9D4  F501     NOP
1E9D6  0E00     MOVLW 0x0
1E9D8  5A01     SUBWFB __ptext283, F, ACCESS
1E9DA  0EFF     MOVLW 0xFF
1E9DC  0061     MOVFFL ltemp0, PLUSW1
1E9DE  F404     NOP
1E9E0  F4E3     NOP
1E9E2  0EFE     MOVLW 0xFE
1E9E4  C4E3     MOVFF PLUSW1, FSR2
1E9E6  F4D9     NOP
1E9E8  0EFF     MOVLW 0xFF
1E9EA  C4E3     MOVFF PLUSW1, FSR2H
1E9EC  F4DA     NOP
1E9EE  0EFD     MOVLW 0xFD
1E9F0  50E3     MOVF 0xFE3, W, ACCESS
1E9F2  0F30     ADDLW 0x30
1E9F4  6EDF     MOVWF 0xFDF, ACCESS
1E9F6  D01D     BRA 0xEA32
14:            	else
15:            		*--cp = cl;
1E9F8  0EFE     MOVLW 0xFE
1E9FA  0061     MOVFFL PLUSW1, ltemp0
1E9FC  F38C     NOP
1E9FE  F501     NOP
1EA00  0E01     MOVLW 0x1
1EA02  5E01     SUBWF __ptext283, F, ACCESS
1EA04  0EFE     MOVLW 0xFE
1EA06  0061     MOVFFL ltemp0, PLUSW1
1EA08  F404     NOP
1EA0A  F4E3     NOP
1EA0C  0EFF     MOVLW 0xFF
1EA0E  0061     MOVFFL PLUSW1, ltemp0
1EA10  F38C     NOP
1EA12  F501     NOP
1EA14  0E00     MOVLW 0x0
1EA16  5A01     SUBWFB __ptext283, F, ACCESS
1EA18  0EFF     MOVLW 0xFF
1EA1A  0061     MOVFFL ltemp0, PLUSW1
1EA1C  F404     NOP
1EA1E  F4E3     NOP
1EA20  0EFE     MOVLW 0xFE
1EA22  C4E3     MOVFF PLUSW1, FSR2
1EA24  F4D9     NOP
1EA26  0EFF     MOVLW 0xFF
1EA28  C4E3     MOVFF PLUSW1, FSR2H
1EA2A  F4DA     NOP
1EA2C  0EFC     MOVLW 0xFC
1EA2E  C4E3     MOVFF PLUSW1, INDF2
1EA30  F4DF     NOP
16:            }
1EA32  0EFB     MOVLW 0xFB
1EA34  26E1     ADDWF 0xFE1, F, ACCESS
1EA36  0EFF     MOVLW 0xFF
1EA38  22E2     ADDWFC 0xFE2, F, ACCESS
1EA38  22E2     ADDWFC 0xFE2, F, ACCESS
17:            
18:            char *
19:            asctime(const struct tm * tim)
18D1A  52E6     MOVF 0xFE6, F, ACCESS
18D1C  52E6     MOVF 0xFE6, F, ACCESS
18D1E  52E6     MOVF 0xFE6, F, ACCESS
18D20  52E6     MOVF 0xFE6, F, ACCESS
20:            {
21:            	register const char *	s;
22:            	char *			cp;
23:            	static char	buf[27];
24:            
25:            	s = &"SunMonTueWedThuFriSat"[tim->tm_wday*3];
18D22  0EFA     MOVLW 0xFA
18D24  0061     MOVFFL PLUSW1, wtemp5
18D26  F38C     NOP
18D28  F50B     NOP
18D2A  0EFB     MOVLW 0xFB
18D2C  0061     MOVFFL PLUSW1, 0x50C
18D2E  F38C     NOP
18D30  F50C     NOP
18D32  0E0C     MOVLW 0xC
18D34  240B     ADDWF 0xB, W, ACCESS
18D36  6ED9     MOVWF 0xFD9, ACCESS
18D38  0E00     MOVLW 0x0
18D3A  200C     ADDWFC 0xC, W, ACCESS
18D3C  6EDA     MOVWF __end_of_UART2_tx_vect_isr, ACCESS
18D3E  0061     MOVFFL POSTINC2, wtemp5
18D40  F378     NOP
18D42  F50B     NOP
18D44  0061     MOVFFL POSTDEC2, 0x50C
18D46  F374     NOP
18D48  F50C     NOP
18D4A  0E03     MOVLW 0x3
18D4C  020B     MULWF 0xB, ACCESS
18D4E  0061     MOVFFL PROD, ltemp2
18D50  F3CC     NOP
18D52  F509     NOP
18D54  0061     MOVFFL PRODH, ttemp3
18D56  F3D0     NOP
18D58  F50A     NOP
18D5A  020C     MULWF 0xC, ACCESS
18D5C  50F3     MOVF 0xFF3, W, ACCESS
18D5E  260A     ADDWF 0xA, F, ACCESS
18D60  0E8D     MOVLW 0x8D
18D62  2409     ADDWF 0x9, W, ACCESS
18D64  6E0B     MOVWF 0xB, ACCESS
18D66  0EFE     MOVLW 0xFE
18D68  200A     ADDWFC 0xA, W, ACCESS
18D6A  6E0C     MOVWF 0xC, ACCESS
18D6C  0EFF     MOVLW 0xFF
18D6E  0061     MOVFFL 0x50C, PLUSW1
18D70  F430     NOP
18D72  F4E3     NOP
18D74  0EFE     MOVLW 0xFE
18D76  0061     MOVFFL wtemp5, PLUSW1
18D78  F42C     NOP
18D7A  F4E3     NOP
26:            	cp = buf;
18D7C  0E09     MOVLW 0x9
18D7E  6E01     MOVWF __ptext283, ACCESS
18D80  0EFD     MOVLW 0xFD
18D82  0061     MOVFFL ltemp0, PLUSW1
18D84  F404     NOP
18D86  F4E3     NOP
18D88  0EC4     MOVLW 0xC4
18D8A  6E01     MOVWF __ptext283, ACCESS
18D8C  0EFC     MOVLW 0xFC
18D8E  0061     MOVFFL ltemp0, PLUSW1
18D90  F404     NOP
18D92  F4E3     NOP
27:            	*cp++ = *s++;
18D94  50E1     MOVF 0xFE1, W, ACCESS
18D96  0FFE     ADDLW 0xFE
18D98  6ED9     MOVWF 0xFD9, ACCESS
18D9A  50E2     MOVF 0xFE2, W, ACCESS
18D9C  6EDA     MOVWF __end_of_UART2_tx_vect_isr, ACCESS
18D9E  0EFF     MOVLW 0xFF
18DA0  22DA     ADDWFC __end_of_UART2_tx_vect_isr, F, ACCESS
18DA2  C4DE     MOVFF POSTINC2, TBLPTR
18DA4  F4F6     NOP
18DA6  C4DD     MOVFF POSTDEC2, TBLPTRH
18DA8  F4F7     NOP
18DAA  0E00     MOVLW 0x0
18DAC  6EF8     MOVWF 0xFF8, ACCESS
18DAE  0EFC     MOVLW 0xFC
18DB0  C4E3     MOVFF PLUSW1, FSR2
18DB2  F4D9     NOP
18DB4  0EFD     MOVLW 0xFD
18DB6  C4E3     MOVFF PLUSW1, FSR2H
18DB8  F4DA     NOP
18DBA  0008     TBLRD*
18DBC  C4F5     MOVFF TABLAT, INDF2
18DBE  F4DF     NOP
18DC0  0EFE     MOVLW 0xFE
18DC2  50E3     MOVF 0xFE3, W, ACCESS
18DC4  0F01     ADDLW 0x1
18DC6  6E01     MOVWF __ptext283, ACCESS
18DC8  0EFE     MOVLW 0xFE
18DCA  0061     MOVFFL ltemp0, PLUSW1
18DCC  F404     NOP
18DCE  F4E3     NOP
18DD0  6A01     CLRF __ptext283, ACCESS
18DD2  0EFF     MOVLW 0xFF
18DD4  50E3     MOVF 0xFE3, W, ACCESS
18DD6  2001     ADDWFC __ptext283, W, ACCESS
18DD8  6E01     MOVWF __ptext283, ACCESS
18DDA  0EFF     MOVLW 0xFF
18DDC  0061     MOVFFL ltemp0, PLUSW1
18DDE  F404     NOP
18DE0  F4E3     NOP
18DE2  0EFC     MOVLW 0xFC
18DE4  50E3     MOVF 0xFE3, W, ACCESS
18DE6  0F01     ADDLW 0x1
18DE8  6E01     MOVWF __ptext283, ACCESS
18DEA  0EFC     MOVLW 0xFC
18DEC  0061     MOVFFL ltemp0, PLUSW1
18DEE  F404     NOP
18DF0  F4E3     NOP
18DF2  6A01     CLRF __ptext283, ACCESS
18DF4  0EFD     MOVLW 0xFD
18DF6  50E3     MOVF 0xFE3, W, ACCESS
18DF8  2001     ADDWFC __ptext283, W, ACCESS
18DFA  6E01     MOVWF __ptext283, ACCESS
18DFC  0EFD     MOVLW 0xFD
18DFE  0061     MOVFFL ltemp0, PLUSW1
18E00  F404     NOP
18E02  F4E3     NOP
28:            	*cp++ = *s++;
18E04  50E1     MOVF 0xFE1, W, ACCESS
18E06  0FFE     ADDLW 0xFE
18E08  6ED9     MOVWF 0xFD9, ACCESS
18E0A  50E2     MOVF 0xFE2, W, ACCESS
18E0C  6EDA     MOVWF __end_of_UART2_tx_vect_isr, ACCESS
18E0E  0EFF     MOVLW 0xFF
18E10  22DA     ADDWFC __end_of_UART2_tx_vect_isr, F, ACCESS
18E12  C4DE     MOVFF POSTINC2, TBLPTR
18E14  F4F6     NOP
18E16  C4DD     MOVFF POSTDEC2, TBLPTRH
18E18  F4F7     NOP
18E1A  0E00     MOVLW 0x0
18E1C  6EF8     MOVWF 0xFF8, ACCESS
18E1E  0EFC     MOVLW 0xFC
18E20  C4E3     MOVFF PLUSW1, FSR2
18E22  F4D9     NOP
18E24  0EFD     MOVLW 0xFD
18E26  C4E3     MOVFF PLUSW1, FSR2H
18E28  F4DA     NOP
18E2A  0008     TBLRD*
18E2C  C4F5     MOVFF TABLAT, INDF2
18E2E  F4DF     NOP
18E30  0EFE     MOVLW 0xFE
18E32  50E3     MOVF 0xFE3, W, ACCESS
18E34  0F01     ADDLW 0x1
18E36  6E01     MOVWF __ptext283, ACCESS
18E38  0EFE     MOVLW 0xFE
18E3A  0061     MOVFFL ltemp0, PLUSW1
18E3C  F404     NOP
18E3E  F4E3     NOP
18E40  6A01     CLRF __ptext283, ACCESS
18E42  0EFF     MOVLW 0xFF
18E44  50E3     MOVF 0xFE3, W, ACCESS
18E46  2001     ADDWFC __ptext283, W, ACCESS
18E48  6E01     MOVWF __ptext283, ACCESS
18E4A  0EFF     MOVLW 0xFF
18E4C  0061     MOVFFL ltemp0, PLUSW1
18E4E  F404     NOP
18E50  F4E3     NOP
18E52  0EFC     MOVLW 0xFC
18E54  50E3     MOVF 0xFE3, W, ACCESS
18E56  0F01     ADDLW 0x1
18E58  6E01     MOVWF __ptext283, ACCESS
18E5A  0EFC     MOVLW 0xFC
18E5C  0061     MOVFFL ltemp0, PLUSW1
18E5E  F404     NOP
18E60  F4E3     NOP
18E62  6A01     CLRF __ptext283, ACCESS
18E64  0EFD     MOVLW 0xFD
18E66  50E3     MOVF 0xFE3, W, ACCESS
18E68  2001     ADDWFC __ptext283, W, ACCESS
18E6A  6E01     MOVWF __ptext283, ACCESS
18E6C  0EFD     MOVLW 0xFD
18E6E  0061     MOVFFL ltemp0, PLUSW1
18E70  F404     NOP
18E72  F4E3     NOP
29:            	*cp++ = *s;
18E74  50E1     MOVF 0xFE1, W, ACCESS
18E76  0FFE     ADDLW 0xFE
18E78  6ED9     MOVWF 0xFD9, ACCESS
18E7A  50E2     MOVF 0xFE2, W, ACCESS
18E7C  6EDA     MOVWF __end_of_UART2_tx_vect_isr, ACCESS
18E7E  0EFF     MOVLW 0xFF
18E80  22DA     ADDWFC __end_of_UART2_tx_vect_isr, F, ACCESS
18E82  C4DE     MOVFF POSTINC2, TBLPTR
18E84  F4F6     NOP
18E86  C4DD     MOVFF POSTDEC2, TBLPTRH
18E88  F4F7     NOP
18E8A  0E00     MOVLW 0x0
18E8C  6EF8     MOVWF 0xFF8, ACCESS
18E8E  0EFC     MOVLW 0xFC
18E90  C4E3     MOVFF PLUSW1, FSR2
18E92  F4D9     NOP
18E94  0EFD     MOVLW 0xFD
18E96  C4E3     MOVFF PLUSW1, FSR2H
18E98  F4DA     NOP
18E9A  0008     TBLRD*
18E9C  C4F5     MOVFF TABLAT, INDF2
18E9E  F4DF     NOP
18EA0  0EFC     MOVLW 0xFC
18EA2  50E3     MOVF 0xFE3, W, ACCESS
18EA4  0F01     ADDLW 0x1
18EA6  6E01     MOVWF __ptext283, ACCESS
18EA8  0EFC     MOVLW 0xFC
18EAA  0061     MOVFFL ltemp0, PLUSW1
18EAC  F404     NOP
18EAE  F4E3     NOP
18EB0  6A01     CLRF __ptext283, ACCESS
18EB2  0EFD     MOVLW 0xFD
18EB4  50E3     MOVF 0xFE3, W, ACCESS
18EB6  2001     ADDWFC __ptext283, W, ACCESS
18EB8  6E01     MOVWF __ptext283, ACCESS
18EBA  0EFD     MOVLW 0xFD
18EBC  0061     MOVFFL ltemp0, PLUSW1
18EBE  F404     NOP
18EC0  F4E3     NOP
30:            	*cp++ = ' ';
18EC2  0EFC     MOVLW 0xFC
18EC4  C4E3     MOVFF PLUSW1, FSR2
18EC6  F4D9     NOP
18EC8  0EFD     MOVLW 0xFD
18ECA  C4E3     MOVFF PLUSW1, FSR2H
18ECC  F4DA     NOP
18ECE  0E20     MOVLW 0x20
18ED0  6EDF     MOVWF 0xFDF, ACCESS
18ED2  0EFC     MOVLW 0xFC
18ED4  50E3     MOVF 0xFE3, W, ACCESS
18ED6  0F01     ADDLW 0x1
18ED8  6E01     MOVWF __ptext283, ACCESS
18EDA  0EFC     MOVLW 0xFC
18EDC  0061     MOVFFL ltemp0, PLUSW1
18EDE  F404     NOP
18EE0  F4E3     NOP
18EE2  6A01     CLRF __ptext283, ACCESS
18EE4  0EFD     MOVLW 0xFD
18EE6  50E3     MOVF 0xFE3, W, ACCESS
18EE8  2001     ADDWFC __ptext283, W, ACCESS
18EEA  6E01     MOVWF __ptext283, ACCESS
18EEC  0EFD     MOVLW 0xFD
18EEE  0061     MOVFFL ltemp0, PLUSW1
18EF0  F404     NOP
18EF2  F4E3     NOP
31:            	s = &"JanFebMarAprMayJunJulAugSepOctNovDec"[tim->tm_mon*3];
18EF4  0EFA     MOVLW 0xFA
18EF6  0061     MOVFFL PLUSW1, wtemp5
18EF8  F38C     NOP
18EFA  F50B     NOP
18EFC  0EFB     MOVLW 0xFB
18EFE  0061     MOVFFL PLUSW1, 0x50C
18F00  F38C     NOP
18F02  F50C     NOP
18F04  0E08     MOVLW 0x8
18F06  240B     ADDWF 0xB, W, ACCESS
18F08  6ED9     MOVWF 0xFD9, ACCESS
18F0A  0E00     MOVLW 0x0
18F0C  200C     ADDWFC 0xC, W, ACCESS
18F0E  6EDA     MOVWF __end_of_UART2_tx_vect_isr, ACCESS
18F10  0061     MOVFFL POSTINC2, wtemp5
18F12  F378     NOP
18F14  F50B     NOP
18F16  0061     MOVFFL POSTDEC2, 0x50C
18F18  F374     NOP
18F1A  F50C     NOP
18F1C  0E03     MOVLW 0x3
18F1E  020B     MULWF 0xB, ACCESS
18F20  0061     MOVFFL PROD, ltemp2
18F22  F3CC     NOP
18F24  F509     NOP
18F26  0061     MOVFFL PRODH, ttemp3
18F28  F3D0     NOP
18F2A  F50A     NOP
18F2C  020C     MULWF 0xC, ACCESS
18F2E  50F3     MOVF 0xFF3, W, ACCESS
18F30  260A     ADDWF 0xA, F, ACCESS
18F32  0E62     MOVLW 0x62
18F34  2409     ADDWF 0x9, W, ACCESS
18F36  6E0B     MOVWF 0xB, ACCESS
18F38  0EFC     MOVLW 0xFC
18F3A  200A     ADDWFC 0xA, W, ACCESS
18F3C  6E0C     MOVWF 0xC, ACCESS
18F3E  0EFF     MOVLW 0xFF
18F40  0061     MOVFFL 0x50C, PLUSW1
18F42  F430     NOP
18F44  F4E3     NOP
18F46  0EFE     MOVLW 0xFE
18F48  0061     MOVFFL wtemp5, PLUSW1
18F4A  F42C     NOP
18F4C  F4E3     NOP
32:            	*cp++ = *s++;
18F4E  50E1     MOVF 0xFE1, W, ACCESS
18F50  0FFE     ADDLW 0xFE
18F52  6ED9     MOVWF 0xFD9, ACCESS
18F54  50E2     MOVF 0xFE2, W, ACCESS
18F56  6EDA     MOVWF __end_of_UART2_tx_vect_isr, ACCESS
18F58  0EFF     MOVLW 0xFF
18F5A  22DA     ADDWFC __end_of_UART2_tx_vect_isr, F, ACCESS
18F5C  C4DE     MOVFF POSTINC2, TBLPTR
18F5E  F4F6     NOP
18F60  C4DD     MOVFF POSTDEC2, TBLPTRH
18F62  F4F7     NOP
18F64  0E00     MOVLW 0x0
18F66  6EF8     MOVWF 0xFF8, ACCESS
18F68  0EFC     MOVLW 0xFC
18F6A  C4E3     MOVFF PLUSW1, FSR2
18F6C  F4D9     NOP
18F6E  0EFD     MOVLW 0xFD
18F70  C4E3     MOVFF PLUSW1, FSR2H
18F72  F4DA     NOP
18F74  0008     TBLRD*
18F76  C4F5     MOVFF TABLAT, INDF2
18F78  F4DF     NOP
18F7A  0EFE     MOVLW 0xFE
18F7C  50E3     MOVF 0xFE3, W, ACCESS
18F7E  0F01     ADDLW 0x1
18F80  6E01     MOVWF __ptext283, ACCESS
18F82  0EFE     MOVLW 0xFE
18F84  0061     MOVFFL ltemp0, PLUSW1
18F86  F404     NOP
18F88  F4E3     NOP
18F8A  6A01     CLRF __ptext283, ACCESS
18F8C  0EFF     MOVLW 0xFF
18F8E  50E3     MOVF 0xFE3, W, ACCESS
18F90  2001     ADDWFC __ptext283, W, ACCESS
18F92  6E01     MOVWF __ptext283, ACCESS
18F94  0EFF     MOVLW 0xFF
18F96  0061     MOVFFL ltemp0, PLUSW1
18F98  F404     NOP
18F9A  F4E3     NOP
18F9C  0EFC     MOVLW 0xFC
18F9E  50E3     MOVF 0xFE3, W, ACCESS
18FA0  0F01     ADDLW 0x1
18FA2  6E01     MOVWF __ptext283, ACCESS
18FA4  0EFC     MOVLW 0xFC
18FA6  0061     MOVFFL ltemp0, PLUSW1
18FA8  F404     NOP
18FAA  F4E3     NOP
18FAC  6A01     CLRF __ptext283, ACCESS
18FAE  0EFD     MOVLW 0xFD
18FB0  50E3     MOVF 0xFE3, W, ACCESS
18FB2  2001     ADDWFC __ptext283, W, ACCESS
18FB4  6E01     MOVWF __ptext283, ACCESS
18FB6  0EFD     MOVLW 0xFD
18FB8  0061     MOVFFL ltemp0, PLUSW1
18FBA  F404     NOP
18FBC  F4E3     NOP
33:            	*cp++ = *s++;
18FBE  50E1     MOVF 0xFE1, W, ACCESS
18FC0  0FFE     ADDLW 0xFE
18FC2  6ED9     MOVWF 0xFD9, ACCESS
18FC4  50E2     MOVF 0xFE2, W, ACCESS
18FC6  6EDA     MOVWF __end_of_UART2_tx_vect_isr, ACCESS
18FC8  0EFF     MOVLW 0xFF
18FCA  22DA     ADDWFC __end_of_UART2_tx_vect_isr, F, ACCESS
18FCC  C4DE     MOVFF POSTINC2, TBLPTR
18FCE  F4F6     NOP
18FD0  C4DD     MOVFF POSTDEC2, TBLPTRH
18FD2  F4F7     NOP
18FD4  0E00     MOVLW 0x0
18FD6  6EF8     MOVWF 0xFF8, ACCESS
18FD8  0EFC     MOVLW 0xFC
18FDA  C4E3     MOVFF PLUSW1, FSR2
18FDC  F4D9     NOP
18FDE  0EFD     MOVLW 0xFD
18FE0  C4E3     MOVFF PLUSW1, FSR2H
18FE2  F4DA     NOP
18FE4  0008     TBLRD*
18FE6  C4F5     MOVFF TABLAT, INDF2
18FE8  F4DF     NOP
18FEA  0EFE     MOVLW 0xFE
18FEC  50E3     MOVF 0xFE3, W, ACCESS
18FEE  0F01     ADDLW 0x1
18FF0  6E01     MOVWF __ptext283, ACCESS
18FF2  0EFE     MOVLW 0xFE
18FF4  0061     MOVFFL ltemp0, PLUSW1
18FF6  F404     NOP
18FF8  F4E3     NOP
18FFA  6A01     CLRF __ptext283, ACCESS
18FFC  0EFF     MOVLW 0xFF
18FFE  50E3     MOVF 0xFE3, W, ACCESS
19000  2001     ADDWFC __ptext283, W, ACCESS
19002  6E01     MOVWF __ptext283, ACCESS
19004  0EFF     MOVLW 0xFF
19006  0061     MOVFFL ltemp0, PLUSW1
19008  F404     NOP
1900A  F4E3     NOP
1900C  0EFC     MOVLW 0xFC
1900E  50E3     MOVF 0xFE3, W, ACCESS
19010  0F01     ADDLW 0x1
19012  6E01     MOVWF __ptext283, ACCESS
19014  0EFC     MOVLW 0xFC
19016  0061     MOVFFL ltemp0, PLUSW1
19018  F404     NOP
1901A  F4E3     NOP
1901C  6A01     CLRF __ptext283, ACCESS
1901E  0EFD     MOVLW 0xFD
19020  50E3     MOVF 0xFE3, W, ACCESS
19022  2001     ADDWFC __ptext283, W, ACCESS
19024  6E01     MOVWF __ptext283, ACCESS
19026  0EFD     MOVLW 0xFD
19028  0061     MOVFFL ltemp0, PLUSW1
1902A  F404     NOP
1902C  F4E3     NOP
34:            	*cp = *s;
1902E  50E1     MOVF 0xFE1, W, ACCESS
19030  0FFE     ADDLW 0xFE
19032  6ED9     MOVWF 0xFD9, ACCESS
19034  50E2     MOVF 0xFE2, W, ACCESS
19036  6EDA     MOVWF __end_of_UART2_tx_vect_isr, ACCESS
19038  0EFF     MOVLW 0xFF
1903A  22DA     ADDWFC __end_of_UART2_tx_vect_isr, F, ACCESS
1903C  C4DE     MOVFF POSTINC2, TBLPTR
1903E  F4F6     NOP
19040  C4DD     MOVFF POSTDEC2, TBLPTRH
19042  F4F7     NOP
19044  0E00     MOVLW 0x0
19046  6EF8     MOVWF 0xFF8, ACCESS
19048  0EFC     MOVLW 0xFC
1904A  C4E3     MOVFF PLUSW1, FSR2
1904C  F4D9     NOP
1904E  0EFD     MOVLW 0xFD
19050  C4E3     MOVFF PLUSW1, FSR2H
19052  F4DA     NOP
19054  0008     TBLRD*
19056  C4F5     MOVFF TABLAT, INDF2
19058  F4DF     NOP
35:            	buf[7] = ' ';
1905A  0E20     MOVLW 0x20
1905C  0109     MOVLB 0x9
1905E  6FCB     MOVWF 0xCB, BANKED
36:            	put2d(buf+10, (char)tim->tm_mday, ' ', ' ');
19060  0E20     MOVLW 0x20
19062  6EE6     MOVWF 0xFE6, ACCESS
19064  0E20     MOVLW 0x20
19066  6EE6     MOVWF 0xFE6, ACCESS
19068  0EF8     MOVLW 0xF8
1906A  0061     MOVFFL PLUSW1, wtemp5
1906C  F38C     NOP
1906E  F50B     NOP
19070  0EF9     MOVLW 0xF9
19072  0061     MOVFFL PLUSW1, 0x50C
19074  F38C     NOP
19076  F50C     NOP
19078  0E06     MOVLW 0x6
1907A  240B     ADDWF 0xB, W, ACCESS
1907C  6ED9     MOVWF 0xFD9, ACCESS
1907E  0E00     MOVLW 0x0
19080  200C     ADDWFC 0xC, W, ACCESS
19082  6EDA     MOVWF __end_of_UART2_tx_vect_isr, ACCESS
19084  50DF     MOVF 0xFDF, W, ACCESS
19086  6EE6     MOVWF 0xFE6, ACCESS
19088  0ECE     MOVLW 0xCE
1908A  6EE6     MOVWF 0xFE6, ACCESS
1908C  0E09     MOVLW 0x9
1908E  6EE6     MOVWF 0xFE6, ACCESS
19090  EC9B     CALL 0x1E936, 0
19092  F0F4     NOP
37:            	put2d(buf+13, (char)tim->tm_hour, '0', ':');
19094  0E3A     MOVLW 0x3A
19096  6EE6     MOVWF 0xFE6, ACCESS
19098  0E30     MOVLW 0x30
1909A  6EE6     MOVWF 0xFE6, ACCESS
1909C  0EF8     MOVLW 0xF8
1909E  0061     MOVFFL PLUSW1, wtemp5
190A0  F38C     NOP
190A2  F50B     NOP
190A4  0EF9     MOVLW 0xF9
190A6  0061     MOVFFL PLUSW1, 0x50C
190A8  F38C     NOP
190AA  F50C     NOP
190AC  0E04     MOVLW 0x4
190AE  240B     ADDWF 0xB, W, ACCESS
190B0  6ED9     MOVWF 0xFD9, ACCESS
190B2  0E00     MOVLW 0x0
190B4  200C     ADDWFC 0xC, W, ACCESS
190B6  6EDA     MOVWF __end_of_UART2_tx_vect_isr, ACCESS
190B8  50DF     MOVF 0xFDF, W, ACCESS
190BA  6EE6     MOVWF 0xFE6, ACCESS
190BC  0ED1     MOVLW 0xD1
190BE  6EE6     MOVWF 0xFE6, ACCESS
190C0  0E09     MOVLW 0x9
190C2  6EE6     MOVWF 0xFE6, ACCESS
190C4  EC9B     CALL 0x1E936, 0
190C6  F0F4     NOP
38:            	put2d(buf+16, (char)tim->tm_min, '0', ':');
190C8  0E3A     MOVLW 0x3A
190CA  6EE6     MOVWF 0xFE6, ACCESS
190CC  0E30     MOVLW 0x30
190CE  6EE6     MOVWF 0xFE6, ACCESS
190D0  0EF8     MOVLW 0xF8
190D2  0061     MOVFFL PLUSW1, wtemp5
190D4  F38C     NOP
190D6  F50B     NOP
190D8  0EF9     MOVLW 0xF9
190DA  0061     MOVFFL PLUSW1, 0x50C
190DC  F38C     NOP
190DE  F50C     NOP
190E0  0E02     MOVLW 0x2
190E2  240B     ADDWF 0xB, W, ACCESS
190E4  6ED9     MOVWF 0xFD9, ACCESS
190E6  0E00     MOVLW 0x0
190E8  200C     ADDWFC 0xC, W, ACCESS
190EA  6EDA     MOVWF __end_of_UART2_tx_vect_isr, ACCESS
190EC  50DF     MOVF 0xFDF, W, ACCESS
190EE  6EE6     MOVWF 0xFE6, ACCESS
190F0  0ED4     MOVLW 0xD4
190F2  6EE6     MOVWF 0xFE6, ACCESS
190F4  0E09     MOVLW 0x9
190F6  6EE6     MOVWF 0xFE6, ACCESS
190F8  EC9B     CALL 0x1E936, 0
190FA  F0F4     NOP
39:            	put2d(buf+19, (char)tim->tm_sec, '0', ' ');
190FC  0E20     MOVLW 0x20
190FE  6EE6     MOVWF 0xFE6, ACCESS
19100  0E30     MOVLW 0x30
19102  6EE6     MOVWF 0xFE6, ACCESS
19104  0EF8     MOVLW 0xF8
19106  C4E3     MOVFF PLUSW1, FSR2
19108  F4D9     NOP
1910A  0EF9     MOVLW 0xF9
1910C  C4E3     MOVFF PLUSW1, FSR2H
1910E  F4DA     NOP
19110  50DF     MOVF 0xFDF, W, ACCESS
19112  6EE6     MOVWF 0xFE6, ACCESS
19114  0ED7     MOVLW 0xD7
19116  6EE6     MOVWF 0xFE6, ACCESS
19118  0E09     MOVLW 0x9
1911A  6EE6     MOVWF 0xFE6, ACCESS
1911C  EC9B     CALL 0x1E936, 0
1911E  F0F4     NOP
40:            	put2d(buf+22, (char)(tim->tm_year/100 + 19), ' ', 0);
19120  0E00     MOVLW 0x0
19122  6EE6     MOVWF 0xFE6, ACCESS
19124  0E20     MOVLW 0x20
19126  6EE6     MOVWF 0xFE6, ACCESS
19128  0E64     MOVLW 0x64
1912A  6EE6     MOVWF 0xFE6, ACCESS
1912C  0E00     MOVLW 0x0
1912E  6EE6     MOVWF 0xFE6, ACCESS
19130  0EF6     MOVLW 0xF6
19132  0061     MOVFFL PLUSW1, wtemp5
19134  F38C     NOP
19136  F50B     NOP
19138  0EF7     MOVLW 0xF7
1913A  0061     MOVFFL PLUSW1, 0x50C
1913C  F38C     NOP
1913E  F50C     NOP
19140  0E0A     MOVLW 0xA
19142  240B     ADDWF 0xB, W, ACCESS
19144  6ED9     MOVWF 0xFD9, ACCESS
19146  0E00     MOVLW 0x0
19148  200C     ADDWFC 0xC, W, ACCESS
1914A  6EDA     MOVWF __end_of_UART2_tx_vect_isr, ACCESS
1914C  0061     MOVFFL POSTINC2, wtemp5
1914E  F378     NOP
19150  F50B     NOP
19152  0061     MOVFFL POSTDEC2, 0x50C
19154  F374     NOP
19156  F50C     NOP
19158  0061     MOVFFL wtemp5, POSTINC1
1915A  F42C     NOP
1915C  F4E6     NOP
1915E  0061     MOVFFL 0x50C, POSTINC1
19160  F430     NOP
19162  F4E6     NOP
19164  ECB9     CALL 0x1D972, 0
19166  F0EC     NOP
19168  5001     MOVF __ptext283, W, ACCESS
1916A  0F13     ADDLW 0x13
1916C  6EE6     MOVWF 0xFE6, ACCESS
1916E  0EDA     MOVLW 0xDA
19170  6EE6     MOVWF 0xFE6, ACCESS
19172  0E09     MOVLW 0x9
19174  6EE6     MOVWF 0xFE6, ACCESS
19176  EC9B     CALL 0x1E936, 0
19178  F0F4     NOP
41:            	put2d(buf+24, tim->tm_year%100, '0', '\n');
1917A  0E0A     MOVLW 0xA
1917C  6EE6     MOVWF 0xFE6, ACCESS
1917E  0E30     MOVLW 0x30
19180  6EE6     MOVWF 0xFE6, ACCESS
19182  0E64     MOVLW 0x64
19184  6EE6     MOVWF 0xFE6, ACCESS
19186  0E00     MOVLW 0x0
19188  6EE6     MOVWF 0xFE6, ACCESS
1918A  0EF6     MOVLW 0xF6
1918C  0061     MOVFFL PLUSW1, wtemp5
1918E  F38C     NOP
19190  F50B     NOP
19192  0EF7     MOVLW 0xF7
19194  0061     MOVFFL PLUSW1, 0x50C
19196  F38C     NOP
19198  F50C     NOP
1919A  0E0A     MOVLW 0xA
1919C  240B     ADDWF 0xB, W, ACCESS
1919E  6ED9     MOVWF 0xFD9, ACCESS
191A0  0E00     MOVLW 0x0
191A2  200C     ADDWFC 0xC, W, ACCESS
191A4  6EDA     MOVWF __end_of_UART2_tx_vect_isr, ACCESS
191A6  0061     MOVFFL POSTINC2, wtemp5
191A8  F378     NOP
191AA  F50B     NOP
191AC  0061     MOVFFL POSTDEC2, 0x50C
191AE  F374     NOP
191B0  F50C     NOP
191B2  0061     MOVFFL wtemp5, POSTINC1
191B4  F42C     NOP
191B6  F4E6     NOP
191B8  0061     MOVFFL 0x50C, POSTINC1
191BA  F430     NOP
191BC  F4E6     NOP
191BE  EC5A     CALL 0x1E0B4, 0
191C0  F0F0     NOP
191C2  5001     MOVF __ptext283, W, ACCESS
191C4  6EE6     MOVWF 0xFE6, ACCESS
191C6  0EDC     MOVLW 0xDC
191C8  6EE6     MOVWF 0xFE6, ACCESS
191CA  0E09     MOVLW 0x9
191CC  6EE6     MOVWF 0xFE6, ACCESS
191CE  EC9B     CALL 0x1E936, 0
191D0  F0F4     NOP
42:            	return(buf);
191D2  0EC4     MOVLW 0xC4
191D4  6E01     MOVWF __ptext283, ACCESS
191D6  0E09     MOVLW 0x9
191D8  6E02     MOVWF ___rparam_used, ACCESS
43:            }
191DA  0EFA     MOVLW 0xFA
191DA  0EFA     MOVLW 0xFA
191DA  0EFA     MOVLW 0xFA
191DA  0EFA     MOVLW 0xFA
191DA  0EFA     MOVLW 0xFA
44:            
---  /opt/microchip/xc8/v2.41/pic/sources/c99/common/almod.c  -------------------------------------------
1:             // long signed unsigned modulus
2:             
3:             signed long int
4:             #ifdef __PICC__
5:             __almod(signed long int divisor, signed long int dividend)
6:             #else
7:             __almod(signed long int dividend, signed long int divisor)
1D55A  52E6     MOVF 0xFE6, F, ACCESS
1D55C  52E6     MOVF 0xFE6, F, ACCESS
8:             #endif
9:             {
10:            	unsigned char	counter, sign;
11:            
12:            	sign = 0;
1D55E  0EFE     MOVLW 0xFE
1D560  6AE3     CLRF 0xFE3, ACCESS
13:            	if(dividend < 0) {
1D562  0EFD     MOVLW 0xFD
1D564  AEE3     BTFSS 0xFE3, 7, ACCESS
1D566  D014     BRA 0xD590
14:            		dividend = -dividend;
1D568  0EFA     MOVLW 0xFA
1D56A  6CE3     NEGF 0xFE3, ACCESS
1D56C  0EFB     MOVLW 0xFB
1D56E  1EE3     COMF 0xFE3, F, ACCESS
1D570  0EFC     MOVLW 0xFC
1D572  1EE3     COMF 0xFE3, F, ACCESS
1D574  0EFD     MOVLW 0xFD
1D576  1EE3     COMF 0xFE3, F, ACCESS
1D578  E308     BNC 0xD58A
1D57A  0EFB     MOVLW 0xFB
1D57C  2AE3     INCF 0xFE3, F, ACCESS
1D57E  E305     BNC 0xD58A
1D580  0EFC     MOVLW 0xFC
1D582  2AE3     INCF 0xFE3, F, ACCESS
1D584  E302     BNC 0xD58A
1D586  0EFD     MOVLW 0xFD
1D588  2AE3     INCF 0xFE3, F, ACCESS
15:            		sign = 1;
1D58A  0EFE     MOVLW 0xFE
1D58C  6AE3     CLRF 0xFE3, ACCESS
1D58E  2AE3     INCF 0xFE3, F, ACCESS
16:            	}
17:            	if(divisor < 0)
1D590  0EF9     MOVLW 0xF9
1D592  AEE3     BTFSS 0xFE3, 7, ACCESS
1D594  D011     BRA 0xD5B8
18:            		divisor = -divisor;
1D596  0EF6     MOVLW 0xF6
1D598  6CE3     NEGF 0xFE3, ACCESS
1D59A  0EF7     MOVLW 0xF7
1D59C  1EE3     COMF 0xFE3, F, ACCESS
1D59E  0EF8     MOVLW 0xF8
1D5A0  1EE3     COMF 0xFE3, F, ACCESS
1D5A2  0EF9     MOVLW 0xF9
1D5A4  1EE3     COMF 0xFE3, F, ACCESS
1D5A6  E308     BNC 0xD5B8
1D5A8  0EF7     MOVLW 0xF7
1D5AA  2AE3     INCF 0xFE3, F, ACCESS
1D5AC  E305     BNC 0xD5B8
1D5AE  0EF8     MOVLW 0xF8
1D5B0  2AE3     INCF 0xFE3, F, ACCESS
1D5B2  E302     BNC 0xD5B8
1D5B4  0EF9     MOVLW 0xF9
1D5B6  2AE3     INCF 0xFE3, F, ACCESS
19:            	if(divisor != 0) {
1D5B8  0EF6     MOVLW 0xF6
1D5BA  50E3     MOVF 0xFE3, W, ACCESS
1D5BC  E10A     BNZ 0xD5D2
1D5BE  0EF7     MOVLW 0xF7
1D5C0  50E3     MOVF 0xFE3, W, ACCESS
1D5C2  E107     BNZ 0xD5D2
1D5C4  0EF8     MOVLW 0xF8
1D5C6  50E3     MOVF 0xFE3, W, ACCESS
1D5C8  E104     BNZ 0xD5D2
1D5CA  0EF9     MOVLW 0xF9
1D5CC  50E3     MOVF 0xFE3, W, ACCESS
1D5CE  B4D8     BTFSC 0xFD8, 2, ACCESS
1D5D0  D04D     BRA 0xD66C
20:            		counter = 1;
1D5D2  0EFF     MOVLW 0xFF
1D5D4  6AE3     CLRF 0xFE3, ACCESS
1D5D6  D00A     BRA 0xD5EC
21:            		while(((unsigned long)divisor & 0x80000000UL) == 0) {
1D5EE  0EF9     MOVLW 0xF9
1D5F0  AEE3     BTFSS 0xFE3, 7, ACCESS
1D5F2  D7F2     BRA 0xD5D8
22:            			divisor <<= 1;
1D5D8  90D8     BCF 0xFD8, 0, ACCESS
1D5DA  0EF6     MOVLW 0xF6
1D5DC  36E3     RLCF 0xFE3, F, ACCESS
1D5DE  0EF7     MOVLW 0xF7
1D5E0  36E3     RLCF 0xFE3, F, ACCESS
1D5E2  0EF8     MOVLW 0xF8
1D5E4  36E3     RLCF 0xFE3, F, ACCESS
1D5E6  0EF9     MOVLW 0xF9
1D5E8  36E3     RLCF 0xFE3, F, ACCESS
23:            			counter++;
1D5EA  0EFF     MOVLW 0xFF
1D5EC  2AE3     INCF 0xFE3, F, ACCESS
24:            		}
25:            		do {
26:            			if((unsigned long)divisor <= (unsigned long)dividend)
1D5F4  50E1     MOVF 0xFE1, W, ACCESS
1D5F6  0FFA     ADDLW 0xFA
1D5F8  6ED9     MOVWF 0xFD9, ACCESS
1D5FA  50E2     MOVF 0xFE2, W, ACCESS
1D5FC  6EDA     MOVWF __end_of_UART2_tx_vect_isr, ACCESS
1D5FE  0EFF     MOVLW 0xFF
1D600  22DA     ADDWFC __end_of_UART2_tx_vect_isr, F, ACCESS
1D602  0EF6     MOVLW 0xF6
1D604  50E3     MOVF 0xFE3, W, ACCESS
1D606  5CDE     SUBWF 0xFDE, W, ACCESS
1D608  0EF7     MOVLW 0xF7
1D60A  50E3     MOVF 0xFE3, W, ACCESS
1D60C  58DE     SUBWFB 0xFDE, W, ACCESS
1D60E  0EF8     MOVLW 0xF8
1D610  50E3     MOVF 0xFE3, W, ACCESS
1D612  58DE     SUBWFB 0xFDE, W, ACCESS
1D614  0EF9     MOVLW 0xF9
1D616  50E3     MOVF 0xFE3, W, ACCESS
1D618  58DE     SUBWFB 0xFDE, W, ACCESS
1D61A  A0D8     BTFSS 0xFD8, 0, ACCESS
1D61C  D013     BRA 0xD644
27:            				dividend -= divisor;
1D61E  50E1     MOVF 0xFE1, W, ACCESS
1D620  0FFA     ADDLW 0xFA
1D622  6ED9     MOVWF 0xFD9, ACCESS
1D624  50E2     MOVF 0xFE2, W, ACCESS
1D626  6EDA     MOVWF __end_of_UART2_tx_vect_isr, ACCESS
1D628  0EFF     MOVLW 0xFF
1D62A  22DA     ADDWFC __end_of_UART2_tx_vect_isr, F, ACCESS
1D62C  0EF6     MOVLW 0xF6
1D62E  50E3     MOVF 0xFE3, W, ACCESS
1D630  5EDE     SUBWF 0xFDE, F, ACCESS
1D632  0EF7     MOVLW 0xF7
1D634  50E3     MOVF 0xFE3, W, ACCESS
1D636  5ADE     SUBWFB 0xFDE, F, ACCESS
1D638  0EF8     MOVLW 0xF8
1D63A  50E3     MOVF 0xFE3, W, ACCESS
1D63C  5ADE     SUBWFB 0xFDE, F, ACCESS
1D63E  0EF9     MOVLW 0xF9
1D640  50E3     MOVF 0xFE3, W, ACCESS
1D642  5ADE     SUBWFB 0xFDE, F, ACCESS
28:            			*(unsigned long int *)&divisor >>= 1;
1D644  90D8     BCF 0xFD8, 0, ACCESS
1D646  0EF9     MOVLW 0xF9
1D648  32E3     RRCF 0xFE3, F, ACCESS
1D64A  0EF8     MOVLW 0xF8
1D64C  32E3     RRCF 0xFE3, F, ACCESS
1D64E  0EF7     MOVLW 0xF7
1D650  32E3     RRCF 0xFE3, F, ACCESS
1D652  0EF6     MOVLW 0xF6
1D654  32E3     RRCF 0xFE3, F, ACCESS
29:            		} while(--counter != 0);
1D656  0EFF     MOVLW 0xFF
1D658  50E3     MOVF 0xFE3, W, ACCESS
1D65A  6E01     MOVWF __ptext283, ACCESS
1D65C  0E01     MOVLW 0x1
1D65E  5E01     SUBWF __ptext283, F, ACCESS
1D660  0EFF     MOVLW 0xFF
1D662  0061     MOVFFL ltemp0, PLUSW1
1D664  F404     NOP
1D666  F4E3     NOP
1D668  A4D8     BTFSS 0xFD8, 2, ACCESS
1D66A  D7C4     BRA 0xD5F4
30:            	}
31:            	if(sign)
1D66C  0EFE     MOVLW 0xFE
1D66E  50E3     MOVF 0xFE3, W, ACCESS
1D670  B4D8     BTFSC 0xFD8, 2, ACCESS
1D672  D011     BRA 0xD696
32:            		dividend = -dividend;
1D674  0EFA     MOVLW 0xFA
1D676  6CE3     NEGF 0xFE3, ACCESS
1D678  0EFB     MOVLW 0xFB
1D67A  1EE3     COMF 0xFE3, F, ACCESS
1D67C  0EFC     MOVLW 0xFC
1D67E  1EE3     COMF 0xFE3, F, ACCESS
1D680  0EFD     MOVLW 0xFD
1D682  1EE3     COMF 0xFE3, F, ACCESS
1D684  E308     BNC 0xD696
1D686  0EFB     MOVLW 0xFB
1D688  2AE3     INCF 0xFE3, F, ACCESS
1D68A  E305     BNC 0xD696
1D68C  0EFC     MOVLW 0xFC
1D68E  2AE3     INCF 0xFE3, F, ACCESS
1D690  E302     BNC 0xD696
1D692  0EFD     MOVLW 0xFD
1D694  2AE3     INCF 0xFE3, F, ACCESS
33:            	return dividend;
1D696  0EFA     MOVLW 0xFA
1D698  0061     MOVFFL PLUSW1, ltemp0
1D69A  F38C     NOP
1D69C  F501     NOP
1D69E  0EFB     MOVLW 0xFB
1D6A0  0061     MOVFFL PLUSW1, ttemp5
1D6A2  F38C     NOP
1D6A4  F502     NOP
1D6A6  0EFC     MOVLW 0xFC
1D6A8  0061     MOVFFL PLUSW1, wtemp1
1D6AA  F38C     NOP
1D6AC  F503     NOP
1D6AE  0EFD     MOVLW 0xFD
1D6B0  0061     MOVFFL PLUSW1, ttemp1
1D6B2  F38C     NOP
1D6B4  F504     NOP
34:            }
1D6B6  0EF6     MOVLW 0xF6
1D6B8  26E1     ADDWF 0xFE1, F, ACCESS
1D6BA  0EFF     MOVLW 0xFF
1D6BC  22E2     ADDWFC 0xFE2, F, ACCESS
1D6BC  22E2     ADDWFC 0xFE2, F, ACCESS
---  /opt/microchip/xc8/v2.41/pic/sources/c99/common/aldiv.c  -------------------------------------------
1:             // long signed unsigned division
2:             
3:             signed long int
4:             #ifdef __PICC__
5:             __aldiv(signed long int divisor, signed long int dividend)
6:             #else
7:             __aldiv(signed long int dividend, signed long int divisor)
1D254  0E06     MOVLW 0x6
1D256  26E1     ADDWF 0xFE1, F, ACCESS
1D258  0E00     MOVLW 0x0
1D25A  22E2     ADDWFC 0xFE2, F, ACCESS
8:             #endif
9:             {
10:            	signed long int	quotient;
11:            	unsigned char	counter, sign;
12:            
13:            	sign = 0;
1D25C  0EFE     MOVLW 0xFE
1D25E  6AE3     CLRF 0xFE3, ACCESS
14:            	if(divisor < 0) {
1D260  0EF5     MOVLW 0xF5
1D262  AEE3     BTFSS 0xFE3, 7, ACCESS
1D264  D014     BRA 0xD28E
15:            		divisor = -divisor;
1D266  0EF2     MOVLW 0xF2
1D268  6CE3     NEGF 0xFE3, ACCESS
1D26A  0EF3     MOVLW 0xF3
1D26C  1EE3     COMF 0xFE3, F, ACCESS
1D26E  0EF4     MOVLW 0xF4
1D270  1EE3     COMF 0xFE3, F, ACCESS
1D272  0EF5     MOVLW 0xF5
1D274  1EE3     COMF 0xFE3, F, ACCESS
1D276  E308     BNC 0xD288
1D278  0EF3     MOVLW 0xF3
1D27A  2AE3     INCF 0xFE3, F, ACCESS
1D27C  E305     BNC 0xD288
1D27E  0EF4     MOVLW 0xF4
1D280  2AE3     INCF 0xFE3, F, ACCESS
1D282  E302     BNC 0xD288
1D284  0EF5     MOVLW 0xF5
1D286  2AE3     INCF 0xFE3, F, ACCESS
16:            		sign = 1;
1D288  0EFE     MOVLW 0xFE
1D28A  6AE3     CLRF 0xFE3, ACCESS
1D28C  2AE3     INCF 0xFE3, F, ACCESS
17:            	}
18:            	if(dividend < 0) {
1D28E  0EF9     MOVLW 0xF9
1D290  AEE3     BTFSS 0xFE3, 7, ACCESS
1D292  D013     BRA 0xD2BA
19:            		dividend = -dividend;
1D294  0EF6     MOVLW 0xF6
1D296  6CE3     NEGF 0xFE3, ACCESS
1D298  0EF7     MOVLW 0xF7
1D29A  1EE3     COMF 0xFE3, F, ACCESS
1D29C  0EF8     MOVLW 0xF8
1D29E  1EE3     COMF 0xFE3, F, ACCESS
1D2A0  0EF9     MOVLW 0xF9
1D2A2  1EE3     COMF 0xFE3, F, ACCESS
1D2A4  E308     BNC 0xD2B6
1D2A6  0EF7     MOVLW 0xF7
1D2A8  2AE3     INCF 0xFE3, F, ACCESS
1D2AA  E305     BNC 0xD2B6
1D2AC  0EF8     MOVLW 0xF8
1D2AE  2AE3     INCF 0xFE3, F, ACCESS
1D2B0  E302     BNC 0xD2B6
1D2B2  0EF9     MOVLW 0xF9
1D2B4  2AE3     INCF 0xFE3, F, ACCESS
20:            		sign ^= 1;
1D2B6  0EFE     MOVLW 0xFE
1D2B8  70E3     BTG 0xFE3, 0, ACCESS
21:            	}
22:            	quotient = 0;
1D2BA  0EFA     MOVLW 0xFA
1D2BC  6AE3     CLRF 0xFE3, ACCESS
1D2BE  0EFB     MOVLW 0xFB
1D2C0  6AE3     CLRF 0xFE3, ACCESS
1D2C2  0EFC     MOVLW 0xFC
1D2C4  6AE3     CLRF 0xFE3, ACCESS
1D2C6  0EFD     MOVLW 0xFD
1D2C8  6AE3     CLRF 0xFE3, ACCESS
23:            	if(divisor != 0) {
1D2CA  0EF2     MOVLW 0xF2
1D2CC  50E3     MOVF 0xFE3, W, ACCESS
1D2CE  E10A     BNZ 0xD2E4
1D2D0  0EF3     MOVLW 0xF3
1D2D2  50E3     MOVF 0xFE3, W, ACCESS
1D2D4  E107     BNZ 0xD2E4
1D2D6  0EF4     MOVLW 0xF4
1D2D8  50E3     MOVF 0xFE3, W, ACCESS
1D2DA  E104     BNZ 0xD2E4
1D2DC  0EF5     MOVLW 0xF5
1D2DE  50E3     MOVF 0xFE3, W, ACCESS
1D2E0  B4D8     BTFSC 0xFD8, 2, ACCESS
1D2E2  D058     BRA 0xD394
24:            		counter = 1;
1D2E4  0EFF     MOVLW 0xFF
1D2E6  6AE3     CLRF 0xFE3, ACCESS
1D2E8  D00A     BRA 0xD2FE
25:            		while(((unsigned long)divisor & 0x80000000UL) == 0) {
1D300  0EF5     MOVLW 0xF5
1D302  AEE3     BTFSS 0xFE3, 7, ACCESS
1D304  D7F2     BRA 0xD2EA
26:            			divisor <<= 1;
1D2EA  90D8     BCF 0xFD8, 0, ACCESS
1D2EC  0EF2     MOVLW 0xF2
1D2EE  36E3     RLCF 0xFE3, F, ACCESS
1D2F0  0EF3     MOVLW 0xF3
1D2F2  36E3     RLCF 0xFE3, F, ACCESS
1D2F4  0EF4     MOVLW 0xF4
1D2F6  36E3     RLCF 0xFE3, F, ACCESS
1D2F8  0EF5     MOVLW 0xF5
1D2FA  36E3     RLCF 0xFE3, F, ACCESS
27:            			counter++;
1D2FC  0EFF     MOVLW 0xFF
1D2FE  2AE3     INCF 0xFE3, F, ACCESS
28:            		}
29:            		do {
30:            			quotient <<= 1;
1D306  90D8     BCF 0xFD8, 0, ACCESS
1D308  0EFA     MOVLW 0xFA
1D30A  36E3     RLCF 0xFE3, F, ACCESS
1D30C  0EFB     MOVLW 0xFB
1D30E  36E3     RLCF 0xFE3, F, ACCESS
1D310  0EFC     MOVLW 0xFC
1D312  36E3     RLCF 0xFE3, F, ACCESS
1D314  0EFD     MOVLW 0xFD
1D316  36E3     RLCF 0xFE3, F, ACCESS
31:            			if((unsigned long)divisor <= (unsigned long)dividend) {
1D318  50E1     MOVF 0xFE1, W, ACCESS
1D31A  0FF6     ADDLW 0xF6
1D31C  6ED9     MOVWF 0xFD9, ACCESS
1D31E  50E2     MOVF 0xFE2, W, ACCESS
1D320  6EDA     MOVWF __end_of_UART2_tx_vect_isr, ACCESS
1D322  0EFF     MOVLW 0xFF
1D324  22DA     ADDWFC __end_of_UART2_tx_vect_isr, F, ACCESS
1D326  0EF2     MOVLW 0xF2
1D328  50E3     MOVF 0xFE3, W, ACCESS
1D32A  5CDE     SUBWF 0xFDE, W, ACCESS
1D32C  0EF3     MOVLW 0xF3
1D32E  50E3     MOVF 0xFE3, W, ACCESS
1D330  58DE     SUBWFB 0xFDE, W, ACCESS
1D332  0EF4     MOVLW 0xF4
1D334  50E3     MOVF 0xFE3, W, ACCESS
1D336  58DE     SUBWFB 0xFDE, W, ACCESS
1D338  0EF5     MOVLW 0xF5
1D33A  50E3     MOVF 0xFE3, W, ACCESS
1D33C  58DE     SUBWFB 0xFDE, W, ACCESS
1D33E  A0D8     BTFSS 0xFD8, 0, ACCESS
1D340  D015     BRA 0xD36C
32:            				dividend -= divisor;
1D342  50E1     MOVF 0xFE1, W, ACCESS
1D344  0FF6     ADDLW 0xF6
1D346  6ED9     MOVWF 0xFD9, ACCESS
1D348  50E2     MOVF 0xFE2, W, ACCESS
1D34A  6EDA     MOVWF __end_of_UART2_tx_vect_isr, ACCESS
1D34C  0EFF     MOVLW 0xFF
1D34E  22DA     ADDWFC __end_of_UART2_tx_vect_isr, F, ACCESS
1D350  0EF2     MOVLW 0xF2
1D352  50E3     MOVF 0xFE3, W, ACCESS
1D354  5EDE     SUBWF 0xFDE, F, ACCESS
1D356  0EF3     MOVLW 0xF3
1D358  50E3     MOVF 0xFE3, W, ACCESS
1D35A  5ADE     SUBWFB 0xFDE, F, ACCESS
1D35C  0EF4     MOVLW 0xF4
1D35E  50E3     MOVF 0xFE3, W, ACCESS
1D360  5ADE     SUBWFB 0xFDE, F, ACCESS
1D362  0EF5     MOVLW 0xF5
1D364  50E3     MOVF 0xFE3, W, ACCESS
1D366  5ADE     SUBWFB 0xFDE, F, ACCESS
33:            				quotient |= 1;
1D368  0EFA     MOVLW 0xFA
1D36A  80E3     BSF 0xFE3, 0, ACCESS
34:            			}
35:            			*(unsigned long int *)&divisor >>= 1;
1D36C  90D8     BCF 0xFD8, 0, ACCESS
1D36E  0EF5     MOVLW 0xF5
1D370  32E3     RRCF 0xFE3, F, ACCESS
1D372  0EF4     MOVLW 0xF4
1D374  32E3     RRCF 0xFE3, F, ACCESS
1D376  0EF3     MOVLW 0xF3
1D378  32E3     RRCF 0xFE3, F, ACCESS
1D37A  0EF2     MOVLW 0xF2
1D37C  32E3     RRCF 0xFE3, F, ACCESS
36:            		} while(--counter != 0);
1D37E  0EFF     MOVLW 0xFF
1D380  50E3     MOVF 0xFE3, W, ACCESS
1D382  6E01     MOVWF __ptext283, ACCESS
1D384  0E01     MOVLW 0x1
1D386  5E01     SUBWF __ptext283, F, ACCESS
1D388  0EFF     MOVLW 0xFF
1D38A  0061     MOVFFL ltemp0, PLUSW1
1D38C  F404     NOP
1D38E  F4E3     NOP
1D390  A4D8     BTFSS 0xFD8, 2, ACCESS
1D392  D7B9     BRA 0xD306
37:            	}
38:            	if(sign)
1D394  0EFE     MOVLW 0xFE
1D396  50E3     MOVF 0xFE3, W, ACCESS
1D398  B4D8     BTFSC 0xFD8, 2, ACCESS
1D39A  D011     BRA 0xD3BE
39:            		quotient = -quotient;
1D39C  0EFA     MOVLW 0xFA
1D39E  6CE3     NEGF 0xFE3, ACCESS
1D3A0  0EFB     MOVLW 0xFB
1D3A2  1EE3     COMF 0xFE3, F, ACCESS
1D3A4  0EFC     MOVLW 0xFC
1D3A6  1EE3     COMF 0xFE3, F, ACCESS
1D3A8  0EFD     MOVLW 0xFD
1D3AA  1EE3     COMF 0xFE3, F, ACCESS
1D3AC  E308     BNC 0xD3BE
1D3AE  0EFB     MOVLW 0xFB
1D3B0  2AE3     INCF 0xFE3, F, ACCESS
1D3B2  E305     BNC 0xD3BE
1D3B4  0EFC     MOVLW 0xFC
1D3B6  2AE3     INCF 0xFE3, F, ACCESS
1D3B8  E302     BNC 0xD3BE
1D3BA  0EFD     MOVLW 0xFD
1D3BC  2AE3     INCF 0xFE3, F, ACCESS
40:            	return quotient;
1D3BE  0EFA     MOVLW 0xFA
1D3C0  0061     MOVFFL PLUSW1, ltemp0
1D3C2  F38C     NOP
1D3C4  F501     NOP
1D3C6  0EFB     MOVLW 0xFB
1D3C8  0061     MOVFFL PLUSW1, ttemp5
1D3CA  F38C     NOP
1D3CC  F502     NOP
1D3CE  0EFC     MOVLW 0xFC
1D3D0  0061     MOVFFL PLUSW1, wtemp1
1D3D2  F38C     NOP
1D3D4  F503     NOP
1D3D6  0EFD     MOVLW 0xFD
1D3D8  0061     MOVFFL PLUSW1, ttemp1
1D3DA  F38C     NOP
1D3DC  F504     NOP
41:            }
1D3DE  0EF2     MOVLW 0xF2
1D3E0  26E1     ADDWF 0xFE1, F, ACCESS
1D3E2  0EFF     MOVLW 0xFF
1D3E4  22E2     ADDWFC 0xFE2, F, ACCESS
1D3E4  22E2     ADDWFC 0xFE2, F, ACCESS
---  /opt/microchip/xc8/v2.41/pic/sources/c99/common/abs.c  ---------------------------------------------
1:             int abs(int a)
2:             {
3:             	return a>0 ? a : -a;
156C  0EFF     MOVLW 0xFF
156E  BEE3     BTFSC 0xFE3, 7, ACCESS
1570  D007     BRA 0x1580
1572  0EFF     MOVLW 0xFF
1574  50E3     MOVF 0xFE3, W, ACCESS
1576  E112     BNZ 0x159C
1578  0EFE     MOVLW 0xFE
157A  04E3     DECF 0xFE3, W, ACCESS
157C  B0D8     BTFSC 0xFD8, 0, ACCESS
157E  D00E     BRA 0x159C
1580  0EFE     MOVLW 0xFE
1582  0061     MOVFFL PLUSW1, ltemp0
1584  F38C     NOP
1586  F501     NOP
1588  1E01     COMF __ptext283, F, ACCESS
158A  0EFF     MOVLW 0xFF
158C  0061     MOVFFL PLUSW1, ttemp5
158E  F38C     NOP
1590  F502     NOP
1592  1E02     COMF ___rparam_used, F, ACCESS
1594  2A01     INCF __ptext283, F, ACCESS
1596  B4D8     BTFSC 0xFD8, 2, ACCESS
1598  2A02     INCF ___rparam_used, F, ACCESS
159A  D008     BRA 0x15AC
159C  0EFE     MOVLW 0xFE
159E  0061     MOVFFL PLUSW1, ltemp0
15A0  F38C     NOP
15A2  F501     NOP
15A4  0EFF     MOVLW 0xFF
15A6  0061     MOVFFL PLUSW1, ttemp5
15A8  F38C     NOP
15AA  F502     NOP
4:             }
15AC  52E5     MOVF 0xFE5, F, ACCESS
15AE  52E5     MOVF 0xFE5, F, ACCESS
15AE  52E5     MOVF 0xFE5, F, ACCESS
---  /opt/microchip/xc8/v2.41/pic/sources/c99/common/__secs_to_tm.c  ------------------------------------
1:             #include "../time_impl.h"
2:             
3:             /* 2000-03-01 (mod 400 year, immediately after feb29 */
4:             #define LEAPOCH (946684800 + 86400*(31+29))
5:             
6:             #define DAYS_PER_400Y (365*400L + 97)
7:             #define DAYS_PER_100Y (365*100L + 24)
8:             #define DAYS_PER_4Y   (365*4L   + 1)
9:             
10:            int __secs_to_tm(unsigned long t, struct tm *tm)
15CBE  0E2D     MOVLW 0x2D
15CC0  26E1     ADDWF 0xFE1, F, ACCESS
15CC2  0E00     MOVLW 0x0
15CC4  22E2     ADDWFC 0xFE2, F, ACCESS
11:            {
12:            	long days, years;
13:            	long remdays, remsecs, remyears;
14:            	long qc_cycles, c_cycles, q_cycles;
15:            	int months;
16:            	int wday, yday, leap;
17:            	static const char days_in_month[] = {31,30,31,30,31,31,30,31,30,31,31,29};
18:            
19:            	unsigned long diffsecs = t - ((unsigned long)LEAPOCH);
15CC6  0ECF     MOVLW 0xCF
15CC8  50E3     MOVF 0xFE3, W, ACCESS
15CCA  0F80     ADDLW 0x80
15CCC  6E09     MOVWF 0x9, ACCESS
15CCE  0ED0     MOVLW 0xD0
15CD0  0061     MOVFFL PLUSW1, ttemp3
15CD2  F38C     NOP
15CD4  F50A     NOP
15CD6  0EA2     MOVLW 0xA2
15CD8  220A     ADDWFC 0xA, F, ACCESS
15CDA  0ED1     MOVLW 0xD1
15CDC  0061     MOVFFL PLUSW1, wtemp5
15CDE  F38C     NOP
15CE0  F50B     NOP
15CE2  0E43     MOVLW 0x43
15CE4  220B     ADDWFC 0xB, F, ACCESS
15CE6  0ED2     MOVLW 0xD2
15CE8  0061     MOVFFL PLUSW1, 0x50C
15CEA  F38C     NOP
15CEC  F50C     NOP
15CEE  0EC7     MOVLW 0xC7
15CF0  220C     ADDWFC 0xC, F, ACCESS
15CF2  0EE8     MOVLW 0xE8
15CF4  0061     MOVFFL ltemp2, PLUSW1
15CF6  F424     NOP
15CF8  F4E3     NOP
15CFA  0EE9     MOVLW 0xE9
15CFC  0061     MOVFFL ttemp3, PLUSW1
15CFE  F428     NOP
15D00  F4E3     NOP
15D02  0EEA     MOVLW 0xEA
15D04  0061     MOVFFL wtemp5, PLUSW1
15D06  F42C     NOP
15D08  F4E3     NOP
15D0A  0EEB     MOVLW 0xEB
15D0C  0061     MOVFFL 0x50C, PLUSW1
15D0E  F430     NOP
15D10  F4E3     NOP
20:            	/* If t is greater than LEAPOCH, then t - LEAPOCH can overflow
21:                   signed long, but not unsigned long. So compute difference using
22:                   unsigned arithmetic. The quotient and remainder after dividing
23:                   by 86400 will fit in a signed long. */
24:                if (t > LEAPOCH) {
15D12  0ECF     MOVLW 0xCF
15D14  0061     MOVFFL PLUSW1, ltemp0
15D16  F38C     NOP
15D18  F501     NOP
15D1A  0E81     MOVLW 0x81
15D1C  5E01     SUBWF __ptext283, F, ACCESS
15D1E  0ED0     MOVLW 0xD0
15D20  0061     MOVFFL PLUSW1, ltemp0
15D22  F38C     NOP
15D24  F501     NOP
15D26  0E5D     MOVLW 0x5D
15D28  5A01     SUBWFB __ptext283, F, ACCESS
15D2A  0ED1     MOVLW 0xD1
15D2C  0061     MOVFFL PLUSW1, ltemp0
15D2E  F38C     NOP
15D30  F501     NOP
15D32  0EBC     MOVLW 0xBC
15D34  5A01     SUBWFB __ptext283, F, ACCESS
15D36  0ED2     MOVLW 0xD2
15D38  0061     MOVFFL PLUSW1, ltemp0
15D3A  F38C     NOP
15D3C  F501     NOP
15D3E  0E38     MOVLW 0x38
15D40  5A01     SUBWFB __ptext283, F, ACCESS
15D42  A0D8     BTFSS 0xFD8, 0, ACCESS
15D44  D037     BRA 0x5DB4
25:                    days = diffsecs / 86400;
15D46  0E80     MOVLW 0x80
15D48  6EE6     MOVWF 0xFE6, ACCESS
15D4A  0E51     MOVLW 0x51
15D4C  6EE6     MOVWF 0xFE6, ACCESS
15D4E  0E01     MOVLW 0x1
15D50  6EE6     MOVWF 0xFE6, ACCESS
15D52  0E00     MOVLW 0x0
15D54  6EE6     MOVWF 0xFE6, ACCESS
15D56  0EE4     MOVLW 0xE4
15D58  C4E3     MOVFF PLUSW1, POSTINC1
15D5A  F4E6     NOP
15D5C  C4E3     MOVFF PLUSW1, POSTINC1
15D5E  F4E6     NOP
15D60  C4E3     MOVFF PLUSW1, POSTINC1
15D62  F4E6     NOP
15D64  C4E3     MOVFF PLUSW1, POSTINC1
15D66  F4E6     NOP
15D68  EC8F     CALL 0x1E71E, 0
15D6A  F0F3     NOP
15D6C  0EEC     MOVLW 0xEC
15D6E  0061     MOVFFL ltemp0, PLUSW1
15D70  F404     NOP
15D72  F4E3     NOP
15D74  0EED     MOVLW 0xED
15D76  0061     MOVFFL ttemp5, PLUSW1
15D78  F408     NOP
15D7A  F4E3     NOP
15D7C  0EEE     MOVLW 0xEE
15D7E  0061     MOVFFL wtemp1, PLUSW1
15D80  F40C     NOP
15D82  F4E3     NOP
15D84  0EEF     MOVLW 0xEF
15D86  0061     MOVFFL ttemp1, PLUSW1
15D88  F410     NOP
15D8A  F4E3     NOP
26:            		remsecs = diffsecs % 86400;
15D8C  0E80     MOVLW 0x80
15D8E  6EE6     MOVWF 0xFE6, ACCESS
15D90  0E51     MOVLW 0x51
15D92  6EE6     MOVWF 0xFE6, ACCESS
15D94  0E01     MOVLW 0x1
15D96  6EE6     MOVWF 0xFE6, ACCESS
15D98  0E00     MOVLW 0x0
15D9A  6EE6     MOVWF 0xFE6, ACCESS
15D9C  0EE4     MOVLW 0xE4
15D9E  C4E3     MOVFF PLUSW1, POSTINC1
15DA0  F4E6     NOP
15DA2  C4E3     MOVFF PLUSW1, POSTINC1
15DA4  F4E6     NOP
15DA6  C4E3     MOVFF PLUSW1, POSTINC1
15DA8  F4E6     NOP
15DAA  C4E3     MOVFF PLUSW1, POSTINC1
15DAC  F4E6     NOP
15DAE  ECE7     CALL 0x1F5CE, 0
15DB0  F0FA     NOP
15DB2  D036     BRA 0x5E20
27:                } else {
28:            	   days = (long)diffsecs / 86400;
15DB4  0E80     MOVLW 0x80
15DB6  6EE6     MOVWF 0xFE6, ACCESS
15DB8  0E51     MOVLW 0x51
15DBA  6EE6     MOVWF 0xFE6, ACCESS
15DBC  0E01     MOVLW 0x1
15DBE  6EE6     MOVWF 0xFE6, ACCESS
15DC0  0E00     MOVLW 0x0
15DC2  6EE6     MOVWF 0xFE6, ACCESS
15DC4  0EE4     MOVLW 0xE4
15DC6  C4E3     MOVFF PLUSW1, POSTINC1
15DC8  F4E6     NOP
15DCA  C4E3     MOVFF PLUSW1, POSTINC1
15DCC  F4E6     NOP
15DCE  C4E3     MOVFF PLUSW1, POSTINC1
15DD0  F4E6     NOP
15DD2  C4E3     MOVFF PLUSW1, POSTINC1
15DD4  F4E6     NOP
15DD6  EC2A     CALL 0x1D254, 0
15DD8  F0E9     NOP
15DDA  0EEC     MOVLW 0xEC
15DDC  0061     MOVFFL ltemp0, PLUSW1
15DDE  F404     NOP
15DE0  F4E3     NOP
15DE2  0EED     MOVLW 0xED
15DE4  0061     MOVFFL ttemp5, PLUSW1
15DE6  F408     NOP
15DE8  F4E3     NOP
15DEA  0EEE     MOVLW 0xEE
15DEC  0061     MOVFFL wtemp1, PLUSW1
15DEE  F40C     NOP
15DF0  F4E3     NOP
15DF2  0EEF     MOVLW 0xEF
15DF4  0061     MOVFFL ttemp1, PLUSW1
15DF6  F410     NOP
15DF8  F4E3     NOP
29:            	   remsecs = (long)diffsecs % 86400;
15DFA  0E80     MOVLW 0x80
15DFC  6EE6     MOVWF 0xFE6, ACCESS
15DFE  0E51     MOVLW 0x51
15E00  6EE6     MOVWF 0xFE6, ACCESS
15E02  0E01     MOVLW 0x1
15E04  6EE6     MOVWF 0xFE6, ACCESS
15E06  0E00     MOVLW 0x0
15E08  6EE6     MOVWF 0xFE6, ACCESS
15E0A  0EE4     MOVLW 0xE4
15E0C  C4E3     MOVFF PLUSW1, POSTINC1
15E0E  F4E6     NOP
15E10  C4E3     MOVFF PLUSW1, POSTINC1
15E12  F4E6     NOP
15E14  C4E3     MOVFF PLUSW1, POSTINC1
15E16  F4E6     NOP
15E18  C4E3     MOVFF PLUSW1, POSTINC1
15E1A  F4E6     NOP
15E1C  ECAD     CALL 0x1D55A, 0
15E1E  F0EA     NOP
15E20  0ED8     MOVLW 0xD8
15E22  0061     MOVFFL ltemp0, PLUSW1
15E24  F404     NOP
15E26  F4E3     NOP
15E28  0ED9     MOVLW 0xD9
15E2A  0061     MOVFFL ttemp5, PLUSW1
15E2C  F408     NOP
15E2E  F4E3     NOP
15E30  0EDA     MOVLW 0xDA
15E32  0061     MOVFFL wtemp1, PLUSW1
15E34  F40C     NOP
15E36  F4E3     NOP
15E38  0EDB     MOVLW 0xDB
15E3A  0061     MOVFFL ttemp1, PLUSW1
15E3C  F410     NOP
15E3E  F4E3     NOP
30:                }
31:            
32:            	if (remsecs < 0) {
15E40  0EDB     MOVLW 0xDB
15E42  AEE3     BTFSS 0xFE3, 7, ACCESS
15E44  D01B     BRA 0x5E7C
33:            		remsecs += 86400;
15E46  50E1     MOVF 0xFE1, W, ACCESS
15E48  0FD8     ADDLW 0xD8
15E4A  6ED9     MOVWF 0xFD9, ACCESS
15E4C  50E2     MOVF 0xFE2, W, ACCESS
15E4E  6EDA     MOVWF __end_of_UART2_tx_vect_isr, ACCESS
15E50  0EFF     MOVLW 0xFF
15E52  22DA     ADDWFC __end_of_UART2_tx_vect_isr, F, ACCESS
15E54  0E80     MOVLW 0x80
15E56  26DE     ADDWF 0xFDE, F, ACCESS
15E58  0E51     MOVLW 0x51
15E5A  22DE     ADDWFC 0xFDE, F, ACCESS
15E5C  0E01     MOVLW 0x1
15E5E  22DE     ADDWFC 0xFDE, F, ACCESS
15E60  0E00     MOVLW 0x0
15E62  22DE     ADDWFC 0xFDE, F, ACCESS
34:            		days--;
15E64  50E1     MOVF 0xFE1, W, ACCESS
15E66  0FEC     ADDLW 0xEC
15E68  6ED9     MOVWF 0xFD9, ACCESS
15E6A  50E2     MOVF 0xFE2, W, ACCESS
15E6C  6EDA     MOVWF __end_of_UART2_tx_vect_isr, ACCESS
15E6E  0EFF     MOVLW 0xFF
15E70  22DA     ADDWFC __end_of_UART2_tx_vect_isr, F, ACCESS
15E72  06DE     DECF 0xFDE, F, ACCESS
15E74  0E00     MOVLW 0x0
15E76  5ADE     SUBWFB 0xFDE, F, ACCESS
15E78  5ADE     SUBWFB 0xFDE, F, ACCESS
15E7A  5ADE     SUBWFB 0xFDE, F, ACCESS
35:            	}
36:            
37:            	wday = (3+days)%7;
15E7C  0E07     MOVLW 0x7
15E7E  6EE6     MOVWF 0xFE6, ACCESS
15E80  0E00     MOVLW 0x0
15E82  6EE6     MOVWF 0xFE6, ACCESS
15E84  0E00     MOVLW 0x0
15E86  6EE6     MOVWF 0xFE6, ACCESS
15E88  0E00     MOVLW 0x0
15E8A  6EE6     MOVWF 0xFE6, ACCESS
15E8C  0EE8     MOVLW 0xE8
15E8E  50E3     MOVF 0xFE3, W, ACCESS
15E90  0F03     ADDLW 0x3
15E92  6E09     MOVWF 0x9, ACCESS
15E94  0EE9     MOVLW 0xE9
15E96  0061     MOVFFL PLUSW1, ttemp3
15E98  F38C     NOP
15E9A  F50A     NOP
15E9C  0E00     MOVLW 0x0
15E9E  220A     ADDWFC 0xA, F, ACCESS
15EA0  0EEA     MOVLW 0xEA
15EA2  0061     MOVFFL PLUSW1, wtemp5
15EA4  F38C     NOP
15EA6  F50B     NOP
15EA8  0E00     MOVLW 0x0
15EAA  220B     ADDWFC 0xB, F, ACCESS
15EAC  0EEB     MOVLW 0xEB
15EAE  0061     MOVFFL PLUSW1, 0x50C
15EB0  F38C     NOP
15EB2  F50C     NOP
15EB4  0E00     MOVLW 0x0
15EB6  220C     ADDWFC 0xC, F, ACCESS
15EB8  0061     MOVFFL ltemp2, POSTINC1
15EBA  F424     NOP
15EBC  F4E6     NOP
15EBE  0061     MOVFFL ttemp3, POSTINC1
15EC0  F428     NOP
15EC2  F4E6     NOP
15EC4  0061     MOVFFL wtemp5, POSTINC1
15EC6  F42C     NOP
15EC8  F4E6     NOP
15ECA  0061     MOVFFL 0x50C, POSTINC1
15ECC  F430     NOP
15ECE  F4E6     NOP
15ED0  ECAD     CALL 0x1D55A, 0
15ED2  F0EA     NOP
15ED4  0061     MOVFFL ltemp0, wtemp5
15ED6  F404     NOP
15ED8  F50B     NOP
15EDA  0061     MOVFFL ttemp5, 0x50C
15EDC  F408     NOP
15EDE  F50C     NOP
15EE0  0EFE     MOVLW 0xFE
15EE2  0061     MOVFFL wtemp5, PLUSW1
15EE4  F42C     NOP
15EE6  F4E3     NOP
15EE8  0EFF     MOVLW 0xFF
15EEA  0061     MOVFFL 0x50C, PLUSW1
15EEC  F430     NOP
15EEE  F4E3     NOP
38:            	if (wday < 0) wday += 7;
15EF0  0EFF     MOVLW 0xFF
15EF2  AEE3     BTFSS 0xFE3, 7, ACCESS
15EF4  D011     BRA 0x5F18
15EF6  0EFE     MOVLW 0xFE
15EF8  50E3     MOVF 0xFE3, W, ACCESS
15EFA  0F07     ADDLW 0x7
15EFC  6E01     MOVWF __ptext283, ACCESS
15EFE  0EFE     MOVLW 0xFE
15F00  0061     MOVFFL ltemp0, PLUSW1
15F02  F404     NOP
15F04  F4E3     NOP
15F06  6A01     CLRF __ptext283, ACCESS
15F08  0EFF     MOVLW 0xFF
15F0A  50E3     MOVF 0xFE3, W, ACCESS
15F0C  2001     ADDWFC __ptext283, W, ACCESS
15F0E  6E01     MOVWF __ptext283, ACCESS
15F10  0EFF     MOVLW 0xFF
15F12  0061     MOVFFL ltemp0, PLUSW1
15F14  F404     NOP
15F16  F4E3     NOP
39:            
40:            	qc_cycles = (long)(days / DAYS_PER_400Y);
15F18  0EB1     MOVLW 0xB1
15F1A  6EE6     MOVWF 0xFE6, ACCESS
15F1C  0E3A     MOVLW 0x3A
15F1E  6EE6     MOVWF 0xFE6, ACCESS
15F20  0E02     MOVLW 0x2
15F22  6EE6     MOVWF 0xFE6, ACCESS
15F24  0E00     MOVLW 0x0
15F26  6EE6     MOVWF 0xFE6, ACCESS
15F28  0EE8     MOVLW 0xE8
15F2A  C4E3     MOVFF PLUSW1, POSTINC1
15F2C  F4E6     NOP
15F2E  C4E3     MOVFF PLUSW1, POSTINC1
15F30  F4E6     NOP
15F32  C4E3     MOVFF PLUSW1, POSTINC1
15F34  F4E6     NOP
15F36  C4E3     MOVFF PLUSW1, POSTINC1
15F38  F4E6     NOP
15F3A  EC2A     CALL 0x1D254, 0
15F3C  F0E9     NOP
15F3E  0EF0     MOVLW 0xF0
15F40  0061     MOVFFL ltemp0, PLUSW1
15F42  F404     NOP
15F44  F4E3     NOP
15F46  0EF1     MOVLW 0xF1
15F48  0061     MOVFFL ttemp5, PLUSW1
15F4A  F408     NOP
15F4C  F4E3     NOP
15F4E  0EF2     MOVLW 0xF2
15F50  0061     MOVFFL wtemp1, PLUSW1
15F52  F40C     NOP
15F54  F4E3     NOP
15F56  0EF3     MOVLW 0xF3
15F58  0061     MOVFFL ttemp1, PLUSW1
15F5A  F410     NOP
15F5C  F4E3     NOP
41:            	remdays = days % DAYS_PER_400Y;
15F5E  0EB1     MOVLW 0xB1
15F60  6EE6     MOVWF 0xFE6, ACCESS
15F62  0E3A     MOVLW 0x3A
15F64  6EE6     MOVWF 0xFE6, ACCESS
15F66  0E02     MOVLW 0x2
15F68  6EE6     MOVWF 0xFE6, ACCESS
15F6A  0E00     MOVLW 0x0
15F6C  6EE6     MOVWF 0xFE6, ACCESS
15F6E  0EE8     MOVLW 0xE8
15F70  C4E3     MOVFF PLUSW1, POSTINC1
15F72  F4E6     NOP
15F74  C4E3     MOVFF PLUSW1, POSTINC1
15F76  F4E6     NOP
15F78  C4E3     MOVFF PLUSW1, POSTINC1
15F7A  F4E6     NOP
15F7C  C4E3     MOVFF PLUSW1, POSTINC1
15F7E  F4E6     NOP
15F80  ECAD     CALL 0x1D55A, 0
15F82  F0EA     NOP
15F84  0ED4     MOVLW 0xD4
15F86  0061     MOVFFL ltemp0, PLUSW1
15F88  F404     NOP
15F8A  F4E3     NOP
15F8C  0ED5     MOVLW 0xD5
15F8E  0061     MOVFFL ttemp5, PLUSW1
15F90  F408     NOP
15F92  F4E3     NOP
15F94  0ED6     MOVLW 0xD6
15F96  0061     MOVFFL wtemp1, PLUSW1
15F98  F40C     NOP
15F9A  F4E3     NOP
15F9C  0ED7     MOVLW 0xD7
15F9E  0061     MOVFFL ttemp1, PLUSW1
15FA0  F410     NOP
15FA2  F4E3     NOP
42:            	if (remdays < 0) {
15FA4  0ED7     MOVLW 0xD7
15FA6  AEE3     BTFSS 0xFE3, 7, ACCESS
15FA8  D01B     BRA 0x5FE0
43:            		remdays += DAYS_PER_400Y;
15FAA  50E1     MOVF 0xFE1, W, ACCESS
15FAC  0FD4     ADDLW 0xD4
15FAE  6ED9     MOVWF 0xFD9, ACCESS
15FB0  50E2     MOVF 0xFE2, W, ACCESS
15FB2  6EDA     MOVWF __end_of_UART2_tx_vect_isr, ACCESS
15FB4  0EFF     MOVLW 0xFF
15FB6  22DA     ADDWFC __end_of_UART2_tx_vect_isr, F, ACCESS
15FB8  0EB1     MOVLW 0xB1
15FBA  26DE     ADDWF 0xFDE, F, ACCESS
15FBC  0E3A     MOVLW 0x3A
15FBE  22DE     ADDWFC 0xFDE, F, ACCESS
15FC0  0E02     MOVLW 0x2
15FC2  22DE     ADDWFC 0xFDE, F, ACCESS
15FC4  0E00     MOVLW 0x0
15FC6  22DE     ADDWFC 0xFDE, F, ACCESS
44:            		qc_cycles--;
15FC8  50E1     MOVF 0xFE1, W, ACCESS
15FCA  0FF0     ADDLW 0xF0
15FCC  6ED9     MOVWF 0xFD9, ACCESS
15FCE  50E2     MOVF 0xFE2, W, ACCESS
15FD0  6EDA     MOVWF __end_of_UART2_tx_vect_isr, ACCESS
15FD2  0EFF     MOVLW 0xFF
15FD4  22DA     ADDWFC __end_of_UART2_tx_vect_isr, F, ACCESS
15FD6  06DE     DECF 0xFDE, F, ACCESS
15FD8  0E00     MOVLW 0x0
15FDA  5ADE     SUBWFB 0xFDE, F, ACCESS
15FDC  5ADE     SUBWFB 0xFDE, F, ACCESS
15FDE  5ADE     SUBWFB 0xFDE, F, ACCESS
45:            	}
46:            
47:            	c_cycles = remdays / DAYS_PER_100Y;
15FE0  0EAC     MOVLW 0xAC
15FE2  6EE6     MOVWF 0xFE6, ACCESS
15FE4  0E8E     MOVLW 0x8E
15FE6  6EE6     MOVWF 0xFE6, ACCESS
15FE8  0E00     MOVLW 0x0
15FEA  6EE6     MOVWF 0xFE6, ACCESS
15FEC  0E00     MOVLW 0x0
15FEE  6EE6     MOVWF 0xFE6, ACCESS
15FF0  0ED0     MOVLW 0xD0
15FF2  C4E3     MOVFF PLUSW1, POSTINC1
15FF4  F4E6     NOP
15FF6  C4E3     MOVFF PLUSW1, POSTINC1
15FF8  F4E6     NOP
15FFA  C4E3     MOVFF PLUSW1, POSTINC1
15FFC  F4E6     NOP
15FFE  C4E3     MOVFF PLUSW1, POSTINC1
16000  F4E6     NOP
16002  EC2A     CALL 0x1D254, 0
16004  F0E9     NOP
16006  0EE0     MOVLW 0xE0
16008  0061     MOVFFL ltemp0, PLUSW1
1600A  F404     NOP
1600C  F4E3     NOP
1600E  0EE1     MOVLW 0xE1
16010  0061     MOVFFL ttemp5, PLUSW1
16012  F408     NOP
16014  F4E3     NOP
16016  0EE2     MOVLW 0xE2
16018  0061     MOVFFL wtemp1, PLUSW1
1601A  F40C     NOP
1601C  F4E3     NOP
1601E  0EE3     MOVLW 0xE3
16020  0061     MOVFFL ttemp1, PLUSW1
16022  F410     NOP
16024  F4E3     NOP
48:            	if (c_cycles == 4) c_cycles--;
16026  0EE0     MOVLW 0xE0
16028  0061     MOVFFL PLUSW1, ltemp0
1602A  F38C     NOP
1602C  F501     NOP
1602E  0E04     MOVLW 0x4
16030  1801     XORWF __ptext283, W, ACCESS
16032  E116     BNZ 0x6060
16034  0EE1     MOVLW 0xE1
16036  50E3     MOVF 0xFE3, W, ACCESS
16038  E113     BNZ 0x6060
1603A  0EE2     MOVLW 0xE2
1603C  50E3     MOVF 0xFE3, W, ACCESS
1603E  E110     BNZ 0x6060
16040  0EE3     MOVLW 0xE3
16042  50E3     MOVF 0xFE3, W, ACCESS
16044  A4D8     BTFSS 0xFD8, 2, ACCESS
16046  D00C     BRA 0x6060
16048  50E1     MOVF 0xFE1, W, ACCESS
1604A  0FE0     ADDLW 0xE0
1604C  6ED9     MOVWF 0xFD9, ACCESS
1604E  50E2     MOVF 0xFE2, W, ACCESS
16050  6EDA     MOVWF __end_of_UART2_tx_vect_isr, ACCESS
16052  0EFF     MOVLW 0xFF
16054  22DA     ADDWFC __end_of_UART2_tx_vect_isr, F, ACCESS
16056  06DE     DECF 0xFDE, F, ACCESS
16058  0E00     MOVLW 0x0
1605A  5ADE     SUBWFB 0xFDE, F, ACCESS
1605C  5ADE     SUBWFB 0xFDE, F, ACCESS
1605E  5ADE     SUBWFB 0xFDE, F, ACCESS
49:            	remdays -= c_cycles * DAYS_PER_100Y;
16060  0EAC     MOVLW 0xAC
16062  6EE6     MOVWF 0xFE6, ACCESS
16064  0E8E     MOVLW 0x8E
16066  6EE6     MOVWF 0xFE6, ACCESS
16068  0E00     MOVLW 0x0
1606A  6EE6     MOVWF 0xFE6, ACCESS
1606C  0E00     MOVLW 0x0
1606E  6EE6     MOVWF 0xFE6, ACCESS
16070  0EDC     MOVLW 0xDC
16072  C4E3     MOVFF PLUSW1, POSTINC1
16074  F4E6     NOP
16076  C4E3     MOVFF PLUSW1, POSTINC1
16078  F4E6     NOP
1607A  C4E3     MOVFF PLUSW1, POSTINC1
1607C  F4E6     NOP
1607E  C4E3     MOVFF PLUSW1, POSTINC1
16080  F4E6     NOP
16082  EC57     CALL 0x1F6AE, 0
16084  F0FB     NOP
16086  50E1     MOVF 0xFE1, W, ACCESS
16088  0FD4     ADDLW 0xD4
1608A  6ED9     MOVWF 0xFD9, ACCESS
1608C  50E2     MOVF 0xFE2, W, ACCESS
1608E  6EDA     MOVWF __end_of_UART2_tx_vect_isr, ACCESS
16090  0EFF     MOVLW 0xFF
16092  22DA     ADDWFC __end_of_UART2_tx_vect_isr, F, ACCESS
16094  5001     MOVF __ptext283, W, ACCESS
16096  5EDE     SUBWF 0xFDE, F, ACCESS
16098  5002     MOVF ___rparam_used, W, ACCESS
1609A  5ADE     SUBWFB 0xFDE, F, ACCESS
1609C  5003     MOVF __activetblptr, W, ACCESS
1609E  5ADE     SUBWFB 0xFDE, F, ACCESS
160A0  5004     MOVF __activetblptr, W, ACCESS
160A2  5ADE     SUBWFB 0xFDE, F, ACCESS
50:            
51:            	q_cycles = remdays / DAYS_PER_4Y;
160A4  0EB5     MOVLW 0xB5
160A6  6EE6     MOVWF 0xFE6, ACCESS
160A8  0E05     MOVLW 0x5
160AA  6EE6     MOVWF 0xFE6, ACCESS
160AC  0E00     MOVLW 0x0
160AE  6EE6     MOVWF 0xFE6, ACCESS
160B0  0E00     MOVLW 0x0
160B2  6EE6     MOVWF 0xFE6, ACCESS
160B4  0ED0     MOVLW 0xD0
160B6  C4E3     MOVFF PLUSW1, POSTINC1
160B8  F4E6     NOP
160BA  C4E3     MOVFF PLUSW1, POSTINC1
160BC  F4E6     NOP
160BE  C4E3     MOVFF PLUSW1, POSTINC1
160C0  F4E6     NOP
160C2  C4E3     MOVFF PLUSW1, POSTINC1
160C4  F4E6     NOP
160C6  EC2A     CALL 0x1D254, 0
160C8  F0E9     NOP
160CA  0EDC     MOVLW 0xDC
160CC  0061     MOVFFL ltemp0, PLUSW1
160CE  F404     NOP
160D0  F4E3     NOP
160D2  0EDD     MOVLW 0xDD
160D4  0061     MOVFFL ttemp5, PLUSW1
160D6  F408     NOP
160D8  F4E3     NOP
160DA  0EDE     MOVLW 0xDE
160DC  0061     MOVFFL wtemp1, PLUSW1
160DE  F40C     NOP
160E0  F4E3     NOP
160E2  0EDF     MOVLW 0xDF
160E4  0061     MOVFFL ttemp1, PLUSW1
160E6  F410     NOP
160E8  F4E3     NOP
52:            	if (q_cycles == 25) q_cycles--;
160EA  0EDC     MOVLW 0xDC
160EC  0061     MOVFFL PLUSW1, ltemp0
160EE  F38C     NOP
160F0  F501     NOP
160F2  0E19     MOVLW 0x19
160F4  1801     XORWF __ptext283, W, ACCESS
160F6  E116     BNZ 0x6124
160F8  0EDD     MOVLW 0xDD
160FA  50E3     MOVF 0xFE3, W, ACCESS
160FC  E113     BNZ 0x6124
160FE  0EDE     MOVLW 0xDE
16100  50E3     MOVF 0xFE3, W, ACCESS
16102  E110     BNZ 0x6124
16104  0EDF     MOVLW 0xDF
16106  50E3     MOVF 0xFE3, W, ACCESS
16108  A4D8     BTFSS 0xFD8, 2, ACCESS
1610A  D00C     BRA 0x6124
1610C  50E1     MOVF 0xFE1, W, ACCESS
1610E  0FDC     ADDLW 0xDC
16110  6ED9     MOVWF 0xFD9, ACCESS
16112  50E2     MOVF 0xFE2, W, ACCESS
16114  6EDA     MOVWF __end_of_UART2_tx_vect_isr, ACCESS
16116  0EFF     MOVLW 0xFF
16118  22DA     ADDWFC __end_of_UART2_tx_vect_isr, F, ACCESS
1611A  06DE     DECF 0xFDE, F, ACCESS
1611C  0E00     MOVLW 0x0
1611E  5ADE     SUBWFB 0xFDE, F, ACCESS
16120  5ADE     SUBWFB 0xFDE, F, ACCESS
16122  5ADE     SUBWFB 0xFDE, F, ACCESS
53:            	remdays -= q_cycles * DAYS_PER_4Y;
16124  0EB5     MOVLW 0xB5
16126  6EE6     MOVWF 0xFE6, ACCESS
16128  0E05     MOVLW 0x5
1612A  6EE6     MOVWF 0xFE6, ACCESS
1612C  0E00     MOVLW 0x0
1612E  6EE6     MOVWF 0xFE6, ACCESS
16130  0E00     MOVLW 0x0
16132  6EE6     MOVWF 0xFE6, ACCESS
16134  0ED8     MOVLW 0xD8
16136  C4E3     MOVFF PLUSW1, POSTINC1
16138  F4E6     NOP
1613A  C4E3     MOVFF PLUSW1, POSTINC1
1613C  F4E6     NOP
1613E  C4E3     MOVFF PLUSW1, POSTINC1
16140  F4E6     NOP
16142  C4E3     MOVFF PLUSW1, POSTINC1
16144  F4E6     NOP
16146  EC57     CALL 0x1F6AE, 0
16148  F0FB     NOP
1614A  50E1     MOVF 0xFE1, W, ACCESS
1614C  0FD4     ADDLW 0xD4
1614E  6ED9     MOVWF 0xFD9, ACCESS
16150  50E2     MOVF 0xFE2, W, ACCESS
16152  6EDA     MOVWF __end_of_UART2_tx_vect_isr, ACCESS
16154  0EFF     MOVLW 0xFF
16156  22DA     ADDWFC __end_of_UART2_tx_vect_isr, F, ACCESS
16158  5001     MOVF __ptext283, W, ACCESS
1615A  5EDE     SUBWF 0xFDE, F, ACCESS
1615C  5002     MOVF ___rparam_used, W, ACCESS
1615E  5ADE     SUBWFB 0xFDE, F, ACCESS
16160  5003     MOVF __activetblptr, W, ACCESS
16162  5ADE     SUBWFB 0xFDE, F, ACCESS
16164  5004     MOVF __activetblptr, W, ACCESS
16166  5ADE     SUBWFB 0xFDE, F, ACCESS
54:            
55:            	remyears = remdays / 365;
16168  0E6D     MOVLW 0x6D
1616A  6EE6     MOVWF 0xFE6, ACCESS
1616C  0E01     MOVLW 0x1
1616E  6EE6     MOVWF 0xFE6, ACCESS
16170  0E00     MOVLW 0x0
16172  6EE6     MOVWF 0xFE6, ACCESS
16174  0E00     MOVLW 0x0
16176  6EE6     MOVWF 0xFE6, ACCESS
16178  0ED0     MOVLW 0xD0
1617A  C4E3     MOVFF PLUSW1, POSTINC1
1617C  F4E6     NOP
1617E  C4E3     MOVFF PLUSW1, POSTINC1
16180  F4E6     NOP
16182  C4E3     MOVFF PLUSW1, POSTINC1
16184  F4E6     NOP
16186  C4E3     MOVFF PLUSW1, POSTINC1
16188  F4E6     NOP
1618A  EC2A     CALL 0x1D254, 0
1618C  F0E9     NOP
1618E  0EE4     MOVLW 0xE4
16190  0061     MOVFFL ltemp0, PLUSW1
16192  F404     NOP
16194  F4E3     NOP
16196  0EE5     MOVLW 0xE5
16198  0061     MOVFFL ttemp5, PLUSW1
1619A  F408     NOP
1619C  F4E3     NOP
1619E  0EE6     MOVLW 0xE6
161A0  0061     MOVFFL wtemp1, PLUSW1
161A2  F40C     NOP
161A4  F4E3     NOP
161A6  0EE7     MOVLW 0xE7
161A8  0061     MOVFFL ttemp1, PLUSW1
161AA  F410     NOP
161AC  F4E3     NOP
56:            	if (remyears == 4) remyears--;
161AE  0EE4     MOVLW 0xE4
161B0  0061     MOVFFL PLUSW1, ltemp0
161B2  F38C     NOP
161B4  F501     NOP
161B6  0E04     MOVLW 0x4
161B8  1801     XORWF __ptext283, W, ACCESS
161BA  E116     BNZ 0x61E8
161BC  0EE5     MOVLW 0xE5
161BE  50E3     MOVF 0xFE3, W, ACCESS
161C0  E113     BNZ 0x61E8
161C2  0EE6     MOVLW 0xE6
161C4  50E3     MOVF 0xFE3, W, ACCESS
161C6  E110     BNZ 0x61E8
161C8  0EE7     MOVLW 0xE7
161CA  50E3     MOVF 0xFE3, W, ACCESS
161CC  A4D8     BTFSS 0xFD8, 2, ACCESS
161CE  D00C     BRA 0x61E8
161D0  50E1     MOVF 0xFE1, W, ACCESS
161D2  0FE4     ADDLW 0xE4
161D4  6ED9     MOVWF 0xFD9, ACCESS
161D6  50E2     MOVF 0xFE2, W, ACCESS
161D8  6EDA     MOVWF __end_of_UART2_tx_vect_isr, ACCESS
161DA  0EFF     MOVLW 0xFF
161DC  22DA     ADDWFC __end_of_UART2_tx_vect_isr, F, ACCESS
161DE  06DE     DECF 0xFDE, F, ACCESS
161E0  0E00     MOVLW 0x0
161E2  5ADE     SUBWFB 0xFDE, F, ACCESS
161E4  5ADE     SUBWFB 0xFDE, F, ACCESS
161E6  5ADE     SUBWFB 0xFDE, F, ACCESS
57:            	remdays -= remyears * 365;
161E8  0E6D     MOVLW 0x6D
161EA  6EE6     MOVWF 0xFE6, ACCESS
161EC  0E01     MOVLW 0x1
161EE  6EE6     MOVWF 0xFE6, ACCESS
161F0  0E00     MOVLW 0x0
161F2  6EE6     MOVWF 0xFE6, ACCESS
161F4  0E00     MOVLW 0x0
161F6  6EE6     MOVWF 0xFE6, ACCESS
161F8  0EE0     MOVLW 0xE0
161FA  C4E3     MOVFF PLUSW1, POSTINC1
161FC  F4E6     NOP
161FE  C4E3     MOVFF PLUSW1, POSTINC1
16200  F4E6     NOP
16202  C4E3     MOVFF PLUSW1, POSTINC1
16204  F4E6     NOP
16206  C4E3     MOVFF PLUSW1, POSTINC1
16208  F4E6     NOP
1620A  EC57     CALL 0x1F6AE, 0
1620C  F0FB     NOP
1620E  50E1     MOVF 0xFE1, W, ACCESS
16210  0FD4     ADDLW 0xD4
16212  6ED9     MOVWF 0xFD9, ACCESS
16214  50E2     MOVF 0xFE2, W, ACCESS
16216  6EDA     MOVWF __end_of_UART2_tx_vect_isr, ACCESS
16218  0EFF     MOVLW 0xFF
1621A  22DA     ADDWFC __end_of_UART2_tx_vect_isr, F, ACCESS
1621C  5001     MOVF __ptext283, W, ACCESS
1621E  5EDE     SUBWF 0xFDE, F, ACCESS
16220  5002     MOVF ___rparam_used, W, ACCESS
16222  5ADE     SUBWFB 0xFDE, F, ACCESS
16224  5003     MOVF __activetblptr, W, ACCESS
16226  5ADE     SUBWFB 0xFDE, F, ACCESS
16228  5004     MOVF __activetblptr, W, ACCESS
1622A  5ADE     SUBWFB 0xFDE, F, ACCESS
58:            
59:            	leap = !remyears && (q_cycles || !c_cycles);
1622C  0ED3     MOVLW 0xD3
1622E  6AE3     CLRF 0xFE3, ACCESS
16230  0EE4     MOVLW 0xE4
16232  50E3     MOVF 0xFE3, W, ACCESS
16234  E127     BNZ 0x6284
16236  0EE5     MOVLW 0xE5
16238  50E3     MOVF 0xFE3, W, ACCESS
1623A  E124     BNZ 0x6284
1623C  0EE6     MOVLW 0xE6
1623E  50E3     MOVF 0xFE3, W, ACCESS
16240  E121     BNZ 0x6284
16242  0EE7     MOVLW 0xE7
16244  50E3     MOVF 0xFE3, W, ACCESS
16246  A4D8     BTFSS 0xFD8, 2, ACCESS
16248  D01D     BRA 0x6284
1624A  0EDC     MOVLW 0xDC
1624C  50E3     MOVF 0xFE3, W, ACCESS
1624E  E117     BNZ 0x627E
16250  0EDD     MOVLW 0xDD
16252  50E3     MOVF 0xFE3, W, ACCESS
16254  E114     BNZ 0x627E
16256  0EDE     MOVLW 0xDE
16258  50E3     MOVF 0xFE3, W, ACCESS
1625A  E111     BNZ 0x627E
1625C  0EDF     MOVLW 0xDF
1625E  50E3     MOVF 0xFE3, W, ACCESS
16260  A4D8     BTFSS 0xFD8, 2, ACCESS
16262  D00D     BRA 0x627E
16264  0EE0     MOVLW 0xE0
16266  50E3     MOVF 0xFE3, W, ACCESS
16268  E10D     BNZ 0x6284
1626A  0EE1     MOVLW 0xE1
1626C  50E3     MOVF 0xFE3, W, ACCESS
1626E  E10A     BNZ 0x6284
16270  0EE2     MOVLW 0xE2
16272  50E3     MOVF 0xFE3, W, ACCESS
16274  E107     BNZ 0x6284
16276  0EE3     MOVLW 0xE3
16278  50E3     MOVF 0xFE3, W, ACCESS
1627A  A4D8     BTFSS 0xFD8, 2, ACCESS
1627C  D003     BRA 0x6284
1627E  0ED3     MOVLW 0xD3
16280  6AE3     CLRF 0xFE3, ACCESS
16282  2AE3     INCF 0xFE3, F, ACCESS
16284  0ED3     MOVLW 0xD3
16286  50E3     MOVF 0xFE3, W, ACCESS
16288  6E0B     MOVWF 0xB, ACCESS
1628A  6A0C     CLRF 0xC, ACCESS
1628C  0EFA     MOVLW 0xFA
1628E  0061     MOVFFL wtemp5, PLUSW1
16290  F42C     NOP
16292  F4E3     NOP
16294  0EFB     MOVLW 0xFB
16296  0061     MOVFFL 0x50C, PLUSW1
16298  F430     NOP
1629A  F4E3     NOP
60:            	yday = (int)(remdays + 31 + 28 + leap);
1629C  0EFA     MOVLW 0xFA
1629E  0061     MOVFFL PLUSW1, wtemp5
162A0  F38C     NOP
162A2  F50B     NOP
162A4  0EFB     MOVLW 0xFB
162A6  0061     MOVFFL PLUSW1, 0x50C
162A8  F38C     NOP
162AA  F50C     NOP
162AC  0ED4     MOVLW 0xD4
162AE  50E3     MOVF 0xFE3, W, ACCESS
162B0  260B     ADDWF 0xB, F, ACCESS
162B2  0ED5     MOVLW 0xD5
162B4  50E3     MOVF 0xFE3, W, ACCESS
162B6  220C     ADDWFC 0xC, F, ACCESS
162B8  0E3B     MOVLW 0x3B
162BA  260B     ADDWF 0xB, F, ACCESS
162BC  0E00     MOVLW 0x0
162BE  220C     ADDWFC 0xC, F, ACCESS
162C0  0EFC     MOVLW 0xFC
162C2  0061     MOVFFL wtemp5, PLUSW1
162C4  F42C     NOP
162C6  F4E3     NOP
162C8  0EFD     MOVLW 0xFD
162CA  0061     MOVFFL 0x50C, PLUSW1
162CC  F430     NOP
162CE  F4E3     NOP
61:            	if (yday >= 365+leap) yday -= 365+leap;
162D0  0EFA     MOVLW 0xFA
162D2  50E3     MOVF 0xFE3, W, ACCESS
162D4  0F6D     ADDLW 0x6D
162D6  6E0B     MOVWF 0xB, ACCESS
162D8  0EFB     MOVLW 0xFB
162DA  0061     MOVFFL PLUSW1, 0x50C
162DC  F38C     NOP
162DE  F50C     NOP
162E0  0E01     MOVLW 0x1
162E2  220C     ADDWFC 0xC, F, ACCESS
162E4  0EFC     MOVLW 0xFC
162E6  0061     MOVFFL PLUSW1, ltemp0
162E8  F38C     NOP
162EA  F501     NOP
162EC  500B     MOVF 0xB, W, ACCESS
162EE  5C01     SUBWF __ptext283, W, ACCESS
162F0  0EFD     MOVLW 0xFD
162F2  50E3     MOVF 0xFE3, W, ACCESS
162F4  0A80     XORLW 0x80
162F6  6E01     MOVWF __ptext283, ACCESS
162F8  500C     MOVF 0xC, W, ACCESS
162FA  0A80     XORLW 0x80
162FC  5801     SUBWFB __ptext283, W, ACCESS
162FE  A0D8     BTFSS 0xFD8, 0, ACCESS
16300  D01E     BRA 0x633E
16302  0EFA     MOVLW 0xFA
16304  50E3     MOVF 0xFE3, W, ACCESS
16306  0F6D     ADDLW 0x6D
16308  6E0B     MOVWF 0xB, ACCESS
1630A  0EFB     MOVLW 0xFB
1630C  0061     MOVFFL PLUSW1, 0x50C
1630E  F38C     NOP
16310  F50C     NOP
16312  0E01     MOVLW 0x1
16314  220C     ADDWFC 0xC, F, ACCESS
16316  0EFC     MOVLW 0xFC
16318  0061     MOVFFL PLUSW1, ltemp0
1631A  F38C     NOP
1631C  F501     NOP
1631E  500B     MOVF 0xB, W, ACCESS
16320  5E01     SUBWF __ptext283, F, ACCESS
16322  0EFC     MOVLW 0xFC
16324  0061     MOVFFL ltemp0, PLUSW1
16326  F404     NOP
16328  F4E3     NOP
1632A  0EFD     MOVLW 0xFD
1632C  0061     MOVFFL PLUSW1, ltemp0
1632E  F38C     NOP
16330  F501     NOP
16332  500C     MOVF 0xC, W, ACCESS
16334  5A01     SUBWFB __ptext283, F, ACCESS
16336  0EFD     MOVLW 0xFD
16338  0061     MOVFFL ltemp0, PLUSW1
1633A  F404     NOP
1633C  F4E3     NOP
62:            
63:            	years = remyears + 4*q_cycles + 100*c_cycles + 400L*qc_cycles;
1633E  0EDC     MOVLW 0xDC
16340  0061     MOVFFL PLUSW1, ltemp2
16342  F38C     NOP
16344  F509     NOP
16346  0EDD     MOVLW 0xDD
16348  0061     MOVFFL PLUSW1, ttemp3
1634A  F38C     NOP
1634C  F50A     NOP
1634E  0EDE     MOVLW 0xDE
16350  0061     MOVFFL PLUSW1, wtemp5
16352  F38C     NOP
16354  F50B     NOP
16356  0EDF     MOVLW 0xDF
16358  0061     MOVFFL PLUSW1, 0x50C
1635A  F38C     NOP
1635C  F50C     NOP
1635E  0E02     MOVLW 0x2
16360  90D8     BCF 0xFD8, 0, ACCESS
16362  3609     RLCF 0x9, F, ACCESS
16364  360A     RLCF 0xA, F, ACCESS
16366  360B     RLCF 0xB, F, ACCESS
16368  360C     RLCF 0xC, F, ACCESS
1636A  2EE8     DECFSZ 0xFE8, F, ACCESS
1636C  D7F9     BRA 0x6360
1636E  0E90     MOVLW 0x90
16370  6EE6     MOVWF 0xFE6, ACCESS
16372  0E01     MOVLW 0x1
16374  6EE6     MOVWF 0xFE6, ACCESS
16376  0E00     MOVLW 0x0
16378  6EE6     MOVWF 0xFE6, ACCESS
1637A  0E00     MOVLW 0x0
1637C  6EE6     MOVWF 0xFE6, ACCESS
1637E  0EEC     MOVLW 0xEC
16380  C4E3     MOVFF PLUSW1, POSTINC1
16382  F4E6     NOP
16384  C4E3     MOVFF PLUSW1, POSTINC1
16386  F4E6     NOP
16388  C4E3     MOVFF PLUSW1, POSTINC1
1638A  F4E6     NOP
1638C  C4E3     MOVFF PLUSW1, POSTINC1
1638E  F4E6     NOP
16390  EC57     CALL 0x1F6AE, 0
16392  F0FB     NOP
16394  0061     MOVFFL ltemp0, ltemp1
16396  F404     NOP
16398  F505     NOP
1639A  0061     MOVFFL ttemp5, 0x506
1639C  F408     NOP
1639E  F506     NOP
163A0  0061     MOVFFL wtemp1, ttemp2
163A2  F40C     NOP
163A4  F507     NOP
163A6  0061     MOVFFL ttemp1, 0x508
163A8  F410     NOP
163AA  F508     NOP
163AC  0E64     MOVLW 0x64
163AE  6EE6     MOVWF 0xFE6, ACCESS
163B0  0E00     MOVLW 0x0
163B2  6EE6     MOVWF 0xFE6, ACCESS
163B4  0E00     MOVLW 0x0
163B6  6EE6     MOVWF 0xFE6, ACCESS
163B8  0E00     MOVLW 0x0
163BA  6EE6     MOVWF 0xFE6, ACCESS
163BC  0EDC     MOVLW 0xDC
163BE  C4E3     MOVFF PLUSW1, POSTINC1
163C0  F4E6     NOP
163C2  C4E3     MOVFF PLUSW1, POSTINC1
163C4  F4E6     NOP
163C6  C4E3     MOVFF PLUSW1, POSTINC1
163C8  F4E6     NOP
163CA  C4E3     MOVFF PLUSW1, POSTINC1
163CC  F4E6     NOP
163CE  EC57     CALL 0x1F6AE, 0
163D0  F0FB     NOP
163D2  5001     MOVF __ptext283, W, ACCESS
163D4  2605     ADDWF 0x5, F, ACCESS
163D6  5002     MOVF ___rparam_used, W, ACCESS
163D8  2206     ADDWFC 0x6, F, ACCESS
163DA  5003     MOVF __activetblptr, W, ACCESS
163DC  2207     ADDWFC 0x7, F, ACCESS
163DE  5004     MOVF __activetblptr, W, ACCESS
163E0  2208     ADDWFC 0x8, F, ACCESS
163E2  5009     MOVF 0x9, W, ACCESS
163E4  2405     ADDWF 0x5, W, ACCESS
163E6  6E01     MOVWF __ptext283, ACCESS
163E8  500A     MOVF 0xA, W, ACCESS
163EA  2006     ADDWFC 0x6, W, ACCESS
163EC  6E02     MOVWF ___rparam_used, ACCESS
163EE  500B     MOVF 0xB, W, ACCESS
163F0  2007     ADDWFC 0x7, W, ACCESS
163F2  6E03     MOVWF __activetblptr, ACCESS
163F4  500C     MOVF 0xC, W, ACCESS
163F6  2008     ADDWFC 0x8, W, ACCESS
163F8  6E04     MOVWF __activetblptr, ACCESS
163FA  0EE4     MOVLW 0xE4
163FC  50E3     MOVF 0xFE3, W, ACCESS
163FE  2601     ADDWF __ptext283, F, ACCESS
16400  0EE5     MOVLW 0xE5
16402  50E3     MOVF 0xFE3, W, ACCESS
16404  2202     ADDWFC ___rparam_used, F, ACCESS
16406  0EE6     MOVLW 0xE6
16408  50E3     MOVF 0xFE3, W, ACCESS
1640A  2203     ADDWFC __activetblptr, F, ACCESS
1640C  0EE7     MOVLW 0xE7
1640E  50E3     MOVF 0xFE3, W, ACCESS
16410  2204     ADDWFC __activetblptr, F, ACCESS
16412  0EF4     MOVLW 0xF4
16414  0061     MOVFFL ltemp0, PLUSW1
16416  F404     NOP
16418  F4E3     NOP
1641A  0EF5     MOVLW 0xF5
1641C  0061     MOVFFL ttemp5, PLUSW1
1641E  F408     NOP
16420  F4E3     NOP
16422  0EF6     MOVLW 0xF6
16424  0061     MOVFFL wtemp1, PLUSW1
16426  F40C     NOP
16428  F4E3     NOP
1642A  0EF7     MOVLW 0xF7
1642C  0061     MOVFFL ttemp1, PLUSW1
1642E  F410     NOP
16430  F4E3     NOP
64:            
65:            	for (months=0; days_in_month[months] <= remdays; months++)
16432  0EF8     MOVLW 0xF8
16434  6AE3     CLRF 0xFE3, ACCESS
16436  0EF9     MOVLW 0xF9
16438  6AE3     CLRF 0xFE3, ACCESS
1643A  D030     BRA 0x649C
66:            		remdays -= days_in_month[months];
1643C  50E1     MOVF 0xFE1, W, ACCESS
1643E  0FD4     ADDLW 0xD4
16440  6ED9     MOVWF 0xFD9, ACCESS
16442  50E2     MOVF 0xFE2, W, ACCESS
16444  6EDA     MOVWF __end_of_UART2_tx_vect_isr, ACCESS
16446  0EFF     MOVLW 0xFF
16448  22DA     ADDWFC __end_of_UART2_tx_vect_isr, F, ACCESS
1644A  0EF8     MOVLW 0xF8
1644C  0061     MOVFFL PLUSW1, wtemp5
1644E  F38C     NOP
16450  F50B     NOP
16452  0EF9     MOVLW 0xF9
16454  0061     MOVFFL PLUSW1, 0x50C
16456  F38C     NOP
16458  F50C     NOP
1645A  0E51     MOVLW 0x51
1645C  240B     ADDWF 0xB, W, ACCESS
1645E  6EF6     MOVWF 0xFF6, ACCESS
16460  0EFA     MOVLW 0xFA
16462  200C     ADDWFC 0xC, W, ACCESS
16464  6EF7     MOVWF 0xFF7, ACCESS
16466  6AF8     CLRF 0xFF8, ACCESS
16468  0E00     MOVLW 0x0
1646A  22F8     ADDWFC 0xFF8, F, ACCESS
1646C  0008     TBLRD*
1646E  50F5     MOVF 0xFF5, W, ACCESS
16470  5EDE     SUBWF 0xFDE, F, ACCESS
16472  0E00     MOVLW 0x0
16474  5ADE     SUBWFB 0xFDE, F, ACCESS
16476  5ADE     SUBWFB 0xFDE, F, ACCESS
16478  5ADE     SUBWFB 0xFDE, F, ACCESS
1647A  0EF8     MOVLW 0xF8
1647C  50E3     MOVF 0xFE3, W, ACCESS
1647E  0F01     ADDLW 0x1
16480  6E01     MOVWF __ptext283, ACCESS
16482  0EF8     MOVLW 0xF8
16484  0061     MOVFFL ltemp0, PLUSW1
16486  F404     NOP
16488  F4E3     NOP
1648A  6A01     CLRF __ptext283, ACCESS
1648C  0EF9     MOVLW 0xF9
1648E  50E3     MOVF 0xFE3, W, ACCESS
16490  2001     ADDWFC __ptext283, W, ACCESS
16492  6E01     MOVWF __ptext283, ACCESS
16494  0EF9     MOVLW 0xF9
16496  0061     MOVFFL ltemp0, PLUSW1
16498  F404     NOP
1649A  F4E3     NOP
1649C  0EF8     MOVLW 0xF8
1649E  0061     MOVFFL PLUSW1, wtemp5
164A0  F38C     NOP
164A2  F50B     NOP
164A4  0EF9     MOVLW 0xF9
164A6  0061     MOVFFL PLUSW1, 0x50C
164A8  F38C     NOP
164AA  F50C     NOP
164AC  0E51     MOVLW 0x51
164AE  240B     ADDWF 0xB, W, ACCESS
164B0  6EF6     MOVWF 0xFF6, ACCESS
164B2  0EFA     MOVLW 0xFA
164B4  200C     ADDWFC 0xC, W, ACCESS
164B6  6EF7     MOVWF 0xFF7, ACCESS
164B8  6AF8     CLRF 0xFF8, ACCESS
164BA  0E00     MOVLW 0x0
164BC  22F8     ADDWFC 0xFF8, F, ACCESS
164BE  0008     TBLRD*
164C0  0061     MOVFFL TABLAT, 0x50C
164C2  F3D4     NOP
164C4  F50C     NOP
164C6  0061     MOVFFL 0x50C, ltemp1
164C8  F430     NOP
164CA  F505     NOP
164CC  6A06     CLRF 0x6, ACCESS
164CE  6A07     CLRF 0x7, ACCESS
164D0  6A08     CLRF 0x8, ACCESS
164D2  0ED4     MOVLW 0xD4
164D4  0061     MOVFFL PLUSW1, ltemp0
164D6  F38C     NOP
164D8  F501     NOP
164DA  5005     MOVF 0x5, W, ACCESS
164DC  5C01     SUBWF __ptext283, W, ACCESS
164DE  0ED5     MOVLW 0xD5
164E0  0061     MOVFFL PLUSW1, ltemp0
164E2  F38C     NOP
164E4  F501     NOP
164E6  5006     MOVF 0x6, W, ACCESS
164E8  5801     SUBWFB __ptext283, W, ACCESS
164EA  0ED6     MOVLW 0xD6
164EC  0061     MOVFFL PLUSW1, ltemp0
164EE  F38C     NOP
164F0  F501     NOP
164F2  5007     MOVF 0x7, W, ACCESS
164F4  5801     SUBWFB __ptext283, W, ACCESS
164F6  0ED7     MOVLW 0xD7
164F8  50E3     MOVF 0xFE3, W, ACCESS
164FA  0A80     XORLW 0x80
164FC  6E01     MOVWF __ptext283, ACCESS
164FE  5008     MOVF 0x8, W, ACCESS
16500  0A80     XORLW 0x80
16502  5801     SUBWFB __ptext283, W, ACCESS
16504  B0D8     BTFSC 0xFD8, 0, ACCESS
16506  D79A     BRA 0x643C
67:            
68:            	if (months >= 10) {
16508  0EF9     MOVLW 0xF9
1650A  BEE3     BTFSC 0xFE3, 7, ACCESS
1650C  D022     BRA 0x6552
1650E  0EF9     MOVLW 0xF9
16510  50E3     MOVF 0xFE3, W, ACCESS
16512  E108     BNZ 0x6524
16514  0EF8     MOVLW 0xF8
16516  0061     MOVFFL PLUSW1, ltemp0
16518  F38C     NOP
1651A  F501     NOP
1651C  0E0A     MOVLW 0xA
1651E  5E01     SUBWF __ptext283, F, ACCESS
16520  A0D8     BTFSS 0xFD8, 0, ACCESS
16522  D017     BRA 0x6552
69:            		months -= 12;
16524  50E1     MOVF 0xFE1, W, ACCESS
16526  0FF8     ADDLW 0xF8
16528  6ED9     MOVWF 0xFD9, ACCESS
1652A  50E2     MOVF 0xFE2, W, ACCESS
1652C  6EDA     MOVWF __end_of_UART2_tx_vect_isr, ACCESS
1652E  0EFF     MOVLW 0xFF
16530  22DA     ADDWFC __end_of_UART2_tx_vect_isr, F, ACCESS
16532  0EF4     MOVLW 0xF4
16534  26DE     ADDWF 0xFDE, F, ACCESS
16536  0EFF     MOVLW 0xFF
16538  22DD     ADDWFC 0xFDD, F, ACCESS
70:            		years++;
1653A  50E1     MOVF 0xFE1, W, ACCESS
1653C  0FF4     ADDLW 0xF4
1653E  6ED9     MOVWF 0xFD9, ACCESS
16540  50E2     MOVF 0xFE2, W, ACCESS
16542  6EDA     MOVWF __end_of_UART2_tx_vect_isr, ACCESS
16544  0EFF     MOVLW 0xFF
16546  22DA     ADDWFC __end_of_UART2_tx_vect_isr, F, ACCESS
16548  2ADE     INCF 0xFDE, F, ACCESS
1654A  0E00     MOVLW 0x0
1654C  22DE     ADDWFC 0xFDE, F, ACCESS
1654E  22DE     ADDWFC 0xFDE, F, ACCESS
16550  22DE     ADDWFC 0xFDE, F, ACCESS
71:            	}
72:            
73:            	tm->tm_year = (int)(years + 100);
16552  0EF4     MOVLW 0xF4
16554  50E3     MOVF 0xFE3, W, ACCESS
16556  0F64     ADDLW 0x64
16558  6E0B     MOVWF 0xB, ACCESS
1655A  0EF5     MOVLW 0xF5
1655C  0061     MOVFFL PLUSW1, 0x50C
1655E  F38C     NOP
16560  F50C     NOP
16562  0E00     MOVLW 0x0
16564  220C     ADDWFC 0xC, F, ACCESS
16566  0ECD     MOVLW 0xCD
16568  0061     MOVFFL PLUSW1, ltemp2
1656A  F38C     NOP
1656C  F509     NOP
1656E  0ECE     MOVLW 0xCE
16570  0061     MOVFFL PLUSW1, ttemp3
16572  F38C     NOP
16574  F50A     NOP
16576  0E0A     MOVLW 0xA
16578  2409     ADDWF 0x9, W, ACCESS
1657A  6ED9     MOVWF 0xFD9, ACCESS
1657C  0E00     MOVLW 0x0
1657E  200A     ADDWFC 0xA, W, ACCESS
16580  6EDA     MOVWF __end_of_UART2_tx_vect_isr, ACCESS
16582  0061     MOVFFL wtemp5, POSTINC2
16584  F42C     NOP
16586  F4DE     NOP
16588  0061     MOVFFL 0x50C, POSTDEC2
1658A  F430     NOP
1658C  F4DD     NOP
74:            	tm->tm_mon = months + 2;
1658E  0EF8     MOVLW 0xF8
16590  50E3     MOVF 0xFE3, W, ACCESS
16592  0F02     ADDLW 0x2
16594  6E0B     MOVWF 0xB, ACCESS
16596  0EF9     MOVLW 0xF9
16598  0061     MOVFFL PLUSW1, 0x50C
1659A  F38C     NOP
1659C  F50C     NOP
1659E  0E00     MOVLW 0x0
165A0  220C     ADDWFC 0xC, F, ACCESS
165A2  0ECD     MOVLW 0xCD
165A4  0061     MOVFFL PLUSW1, ltemp2
165A6  F38C     NOP
165A8  F509     NOP
165AA  0ECE     MOVLW 0xCE
165AC  0061     MOVFFL PLUSW1, ttemp3
165AE  F38C     NOP
165B0  F50A     NOP
165B2  0E08     MOVLW 0x8
165B4  2409     ADDWF 0x9, W, ACCESS
165B6  6ED9     MOVWF 0xFD9, ACCESS
165B8  0E00     MOVLW 0x0
165BA  200A     ADDWFC 0xA, W, ACCESS
165BC  6EDA     MOVWF __end_of_UART2_tx_vect_isr, ACCESS
165BE  0061     MOVFFL wtemp5, POSTINC2
165C0  F42C     NOP
165C2  F4DE     NOP
165C4  0061     MOVFFL 0x50C, POSTDEC2
165C6  F430     NOP
165C8  F4DD     NOP
75:            	tm->tm_mday = (int)(remdays + 1);
165CA  0ED4     MOVLW 0xD4
165CC  50E3     MOVF 0xFE3, W, ACCESS
165CE  0F01     ADDLW 0x1
165D0  6E0B     MOVWF 0xB, ACCESS
165D2  0ED5     MOVLW 0xD5
165D4  0061     MOVFFL PLUSW1, 0x50C
165D6  F38C     NOP
165D8  F50C     NOP
165DA  0E00     MOVLW 0x0
165DC  220C     ADDWFC 0xC, F, ACCESS
165DE  0ECD     MOVLW 0xCD
165E0  0061     MOVFFL PLUSW1, ltemp2
165E2  F38C     NOP
165E4  F509     NOP
165E6  0ECE     MOVLW 0xCE
165E8  0061     MOVFFL PLUSW1, ttemp3
165EA  F38C     NOP
165EC  F50A     NOP
165EE  0E06     MOVLW 0x6
165F0  2409     ADDWF 0x9, W, ACCESS
165F2  6ED9     MOVWF 0xFD9, ACCESS
165F4  0E00     MOVLW 0x0
165F6  200A     ADDWFC 0xA, W, ACCESS
165F8  6EDA     MOVWF __end_of_UART2_tx_vect_isr, ACCESS
165FA  0061     MOVFFL wtemp5, POSTINC2
165FC  F42C     NOP
165FE  F4DE     NOP
16600  0061     MOVFFL 0x50C, POSTDEC2
16602  F430     NOP
16604  F4DD     NOP
76:            	tm->tm_wday = wday;
16606  50E1     MOVF 0xFE1, W, ACCESS
16608  0FFE     ADDLW 0xFE
1660A  6ED9     MOVWF 0xFD9, ACCESS
1660C  50E2     MOVF 0xFE2, W, ACCESS
1660E  6EDA     MOVWF __end_of_UART2_tx_vect_isr, ACCESS
16610  0EFF     MOVLW 0xFF
16612  22DA     ADDWFC __end_of_UART2_tx_vect_isr, F, ACCESS
16614  0ECD     MOVLW 0xCD
16616  0061     MOVFFL PLUSW1, wtemp5
16618  F38C     NOP
1661A  F50B     NOP
1661C  0ECE     MOVLW 0xCE
1661E  0061     MOVFFL PLUSW1, 0x50C
16620  F38C     NOP
16622  F50C     NOP
16624  0E0C     MOVLW 0xC
16626  240B     ADDWF 0xB, W, ACCESS
16628  6EE9     MOVWF 0xFE9, ACCESS
1662A  0E00     MOVLW 0x0
1662C  200C     ADDWFC 0xC, W, ACCESS
1662E  6EEA     MOVWF 0xFEA, ACCESS
16630  C4DE     MOVFF POSTINC2, POSTINC0
16632  F4EE     NOP
16634  C4DD     MOVFF POSTDEC2, POSTDEC0
16636  F4ED     NOP
77:            	tm->tm_yday = yday;
16638  50E1     MOVF 0xFE1, W, ACCESS
1663A  0FFC     ADDLW 0xFC
1663C  6ED9     MOVWF 0xFD9, ACCESS
1663E  50E2     MOVF 0xFE2, W, ACCESS
16640  6EDA     MOVWF __end_of_UART2_tx_vect_isr, ACCESS
16642  0EFF     MOVLW 0xFF
16644  22DA     ADDWFC __end_of_UART2_tx_vect_isr, F, ACCESS
16646  0ECD     MOVLW 0xCD
16648  0061     MOVFFL PLUSW1, wtemp5
1664A  F38C     NOP
1664C  F50B     NOP
1664E  0ECE     MOVLW 0xCE
16650  0061     MOVFFL PLUSW1, 0x50C
16652  F38C     NOP
16654  F50C     NOP
16656  0E0E     MOVLW 0xE
16658  240B     ADDWF 0xB, W, ACCESS
1665A  6EE9     MOVWF 0xFE9, ACCESS
1665C  0E00     MOVLW 0x0
1665E  200C     ADDWFC 0xC, W, ACCESS
16660  6EEA     MOVWF 0xFEA, ACCESS
16662  C4DE     MOVFF POSTINC2, POSTINC0
16664  F4EE     NOP
16666  C4DD     MOVFF POSTDEC2, POSTDEC0
16668  F4ED     NOP
78:            
79:            	tm->tm_hour = (int)(remsecs / 3600);
1666A  0E10     MOVLW 0x10
1666C  6EE6     MOVWF 0xFE6, ACCESS
1666E  0E0E     MOVLW 0xE
16670  6EE6     MOVWF 0xFE6, ACCESS
16672  0E00     MOVLW 0x0
16674  6EE6     MOVWF 0xFE6, ACCESS
16676  0E00     MOVLW 0x0
16678  6EE6     MOVWF 0xFE6, ACCESS
1667A  0ED4     MOVLW 0xD4
1667C  C4E3     MOVFF PLUSW1, POSTINC1
1667E  F4E6     NOP
16680  C4E3     MOVFF PLUSW1, POSTINC1
16682  F4E6     NOP
16684  C4E3     MOVFF PLUSW1, POSTINC1
16686  F4E6     NOP
16688  C4E3     MOVFF PLUSW1, POSTINC1
1668A  F4E6     NOP
1668C  EC2A     CALL 0x1D254, 0
1668E  F0E9     NOP
16690  0061     MOVFFL ltemp0, wtemp5
16692  F404     NOP
16694  F50B     NOP
16696  0061     MOVFFL ttemp5, 0x50C
16698  F408     NOP
1669A  F50C     NOP
1669C  0ECD     MOVLW 0xCD
1669E  0061     MOVFFL PLUSW1, ltemp2
166A0  F38C     NOP
166A2  F509     NOP
166A4  0ECE     MOVLW 0xCE
166A6  0061     MOVFFL PLUSW1, ttemp3
166A8  F38C     NOP
166AA  F50A     NOP
166AC  0E04     MOVLW 0x4
166AE  2409     ADDWF 0x9, W, ACCESS
166B0  6ED9     MOVWF 0xFD9, ACCESS
166B2  0E00     MOVLW 0x0
166B4  200A     ADDWFC 0xA, W, ACCESS
166B6  6EDA     MOVWF __end_of_UART2_tx_vect_isr, ACCESS
166B8  0061     MOVFFL wtemp5, POSTINC2
166BA  F42C     NOP
166BC  F4DE     NOP
166BE  0061     MOVFFL 0x50C, POSTDEC2
166C0  F430     NOP
166C2  F4DD     NOP
80:            	tm->tm_min = remsecs / 60 % 60;
166C4  0E3C     MOVLW 0x3C
166C6  6EE6     MOVWF 0xFE6, ACCESS
166C8  0E00     MOVLW 0x0
166CA  6EE6     MOVWF 0xFE6, ACCESS
166CC  0E00     MOVLW 0x0
166CE  6EE6     MOVWF 0xFE6, ACCESS
166D0  0E00     MOVLW 0x0
166D2  6EE6     MOVWF 0xFE6, ACCESS
166D4  0E3C     MOVLW 0x3C
166D6  6EE6     MOVWF 0xFE6, ACCESS
166D8  0E00     MOVLW 0x0
166DA  6EE6     MOVWF 0xFE6, ACCESS
166DC  0E00     MOVLW 0x0
166DE  6EE6     MOVWF 0xFE6, ACCESS
166E0  0E00     MOVLW 0x0
166E2  6EE6     MOVWF 0xFE6, ACCESS
166E4  0ED0     MOVLW 0xD0
166E6  C4E3     MOVFF PLUSW1, POSTINC1
166E8  F4E6     NOP
166EA  C4E3     MOVFF PLUSW1, POSTINC1
166EC  F4E6     NOP
166EE  C4E3     MOVFF PLUSW1, POSTINC1
166F0  F4E6     NOP
166F2  C4E3     MOVFF PLUSW1, POSTINC1
166F4  F4E6     NOP
166F6  EC2A     CALL 0x1D254, 0
166F8  F0E9     NOP
166FA  0061     MOVFFL ltemp0, POSTINC1
166FC  F404     NOP
166FE  F4E6     NOP
16700  0061     MOVFFL ttemp5, POSTINC1
16702  F408     NOP
16704  F4E6     NOP
16706  0061     MOVFFL wtemp1, POSTINC1
16708  F40C     NOP
1670A  F4E6     NOP
1670C  0061     MOVFFL ttemp1, POSTINC1
1670E  F410     NOP
16710  F4E6     NOP
16712  ECAD     CALL 0x1D55A, 0
16714  F0EA     NOP
16716  0061     MOVFFL ltemp0, wtemp5
16718  F404     NOP
1671A  F50B     NOP
1671C  0061     MOVFFL ttemp5, 0x50C
1671E  F408     NOP
16720  F50C     NOP
16722  0ECD     MOVLW 0xCD
16724  0061     MOVFFL PLUSW1, ltemp2
16726  F38C     NOP
16728  F509     NOP
1672A  0ECE     MOVLW 0xCE
1672C  0061     MOVFFL PLUSW1, ttemp3
1672E  F38C     NOP
16730  F50A     NOP
16732  0E02     MOVLW 0x2
16734  2409     ADDWF 0x9, W, ACCESS
16736  6ED9     MOVWF 0xFD9, ACCESS
16738  0E00     MOVLW 0x0
1673A  200A     ADDWFC 0xA, W, ACCESS
1673C  6EDA     MOVWF __end_of_UART2_tx_vect_isr, ACCESS
1673E  0061     MOVFFL wtemp5, POSTINC2
16740  F42C     NOP
16742  F4DE     NOP
16744  0061     MOVFFL 0x50C, POSTDEC2
16746  F430     NOP
16748  F4DD     NOP
81:            	tm->tm_sec = remsecs % 60;
1674A  0E3C     MOVLW 0x3C
1674C  6EE6     MOVWF 0xFE6, ACCESS
1674E  0E00     MOVLW 0x0
16750  6EE6     MOVWF 0xFE6, ACCESS
16752  0E00     MOVLW 0x0
16754  6EE6     MOVWF 0xFE6, ACCESS
16756  0E00     MOVLW 0x0
16758  6EE6     MOVWF 0xFE6, ACCESS
1675A  0ED4     MOVLW 0xD4
1675C  C4E3     MOVFF PLUSW1, POSTINC1
1675E  F4E6     NOP
16760  C4E3     MOVFF PLUSW1, POSTINC1
16762  F4E6     NOP
16764  C4E3     MOVFF PLUSW1, POSTINC1
16766  F4E6     NOP
16768  C4E3     MOVFF PLUSW1, POSTINC1
1676A  F4E6     NOP
1676C  ECAD     CALL 0x1D55A, 0
1676E  F0EA     NOP
16770  0061     MOVFFL ltemp0, wtemp5
16772  F404     NOP
16774  F50B     NOP
16776  0061     MOVFFL ttemp5, 0x50C
16778  F408     NOP
1677A  F50C     NOP
1677C  0ECD     MOVLW 0xCD
1677E  C4E3     MOVFF PLUSW1, FSR2
16780  F4D9     NOP
16782  0ECE     MOVLW 0xCE
16784  C4E3     MOVFF PLUSW1, FSR2H
16786  F4DA     NOP
16788  0061     MOVFFL wtemp5, POSTINC2
1678A  F42C     NOP
1678C  F4DE     NOP
1678E  0061     MOVFFL 0x50C, POSTDEC2
16790  F430     NOP
16792  F4DD     NOP
82:            
83:            	return 0;
16794  0E00     MOVLW 0x0
16796  6E01     MOVWF __ptext283, ACCESS
16798  0E00     MOVLW 0x0
1679A  6E02     MOVWF ___rparam_used, ACCESS
84:            }
1679C  0ECD     MOVLW 0xCD
1679E  26E1     ADDWF 0xFE1, F, ACCESS
167A0  0EFF     MOVLW 0xFF
167A2  22E2     ADDWFC 0xFE2, F, ACCESS
167A2  22E2     ADDWFC 0xFE2, F, ACCESS
---  /opt/microchip/xc8/v2.41/pic/sources/c99/common/__lldiv.c  -----------------------------------------
1:             // long unsigned unsigned division
2:             
3:             unsigned long int
4:             #ifdef __PICC__
5:             __lldiv(unsigned long int divisor, unsigned long int dividend)
6:             #else
7:             __lldiv(unsigned long int dividend, unsigned long int divisor)
1E71E  0E05     MOVLW 0x5
1E720  26E1     ADDWF 0xFE1, F, ACCESS
1E722  0E00     MOVLW 0x0
1E724  22E2     ADDWFC 0xFE2, F, ACCESS
8:             #endif
9:             {
10:            	unsigned long int	quotient;
11:            	unsigned char	counter;
12:            
13:            	quotient = 0;
1E726  0EFB     MOVLW 0xFB
1E728  6AE3     CLRF 0xFE3, ACCESS
1E72A  0EFC     MOVLW 0xFC
1E72C  6AE3     CLRF 0xFE3, ACCESS
1E72E  0EFD     MOVLW 0xFD
1E730  6AE3     CLRF 0xFE3, ACCESS
1E732  0EFE     MOVLW 0xFE
1E734  6AE3     CLRF 0xFE3, ACCESS
14:            	if(divisor != 0) {
1E736  0EF3     MOVLW 0xF3
1E738  50E3     MOVF 0xFE3, W, ACCESS
1E73A  E10A     BNZ 0xE750
1E73C  0EF4     MOVLW 0xF4
1E73E  50E3     MOVF 0xFE3, W, ACCESS
1E740  E107     BNZ 0xE750
1E742  0EF5     MOVLW 0xF5
1E744  50E3     MOVF 0xFE3, W, ACCESS
1E746  E104     BNZ 0xE750
1E748  0EF6     MOVLW 0xF6
1E74A  50E3     MOVF 0xFE3, W, ACCESS
1E74C  B4D8     BTFSC 0xFD8, 2, ACCESS
1E74E  D058     BRA 0xE800
15:            		counter = 1;
1E750  0EFF     MOVLW 0xFF
1E752  6AE3     CLRF 0xFE3, ACCESS
1E754  D00A     BRA 0xE76A
16:            		while((divisor & 0x80000000UL) == 0) {
1E76C  0EF6     MOVLW 0xF6
1E76E  AEE3     BTFSS 0xFE3, 7, ACCESS
1E770  D7F2     BRA 0xE756
17:            			divisor <<= 1;
1E756  90D8     BCF 0xFD8, 0, ACCESS
1E758  0EF3     MOVLW 0xF3
1E75A  36E3     RLCF 0xFE3, F, ACCESS
1E75C  0EF4     MOVLW 0xF4
1E75E  36E3     RLCF 0xFE3, F, ACCESS
1E760  0EF5     MOVLW 0xF5
1E762  36E3     RLCF 0xFE3, F, ACCESS
1E764  0EF6     MOVLW 0xF6
1E766  36E3     RLCF 0xFE3, F, ACCESS
18:            			counter++;
1E768  0EFF     MOVLW 0xFF
1E76A  2AE3     INCF 0xFE3, F, ACCESS
19:            		}
20:            		do {
21:            			quotient <<= 1;
1E772  90D8     BCF 0xFD8, 0, ACCESS
1E774  0EFB     MOVLW 0xFB
1E776  36E3     RLCF 0xFE3, F, ACCESS
1E778  0EFC     MOVLW 0xFC
1E77A  36E3     RLCF 0xFE3, F, ACCESS
1E77C  0EFD     MOVLW 0xFD
1E77E  36E3     RLCF 0xFE3, F, ACCESS
1E780  0EFE     MOVLW 0xFE
1E782  36E3     RLCF 0xFE3, F, ACCESS
22:            			if(divisor <= dividend) {
1E784  50E1     MOVF 0xFE1, W, ACCESS
1E786  0FF7     ADDLW 0xF7
1E788  6ED9     MOVWF 0xFD9, ACCESS
1E78A  50E2     MOVF 0xFE2, W, ACCESS
1E78C  6EDA     MOVWF __end_of_UART2_tx_vect_isr, ACCESS
1E78E  0EFF     MOVLW 0xFF
1E790  22DA     ADDWFC __end_of_UART2_tx_vect_isr, F, ACCESS
1E792  0EF3     MOVLW 0xF3
1E794  50E3     MOVF 0xFE3, W, ACCESS
1E796  5CDE     SUBWF 0xFDE, W, ACCESS
1E798  0EF4     MOVLW 0xF4
1E79A  50E3     MOVF 0xFE3, W, ACCESS
1E79C  58DE     SUBWFB 0xFDE, W, ACCESS
1E79E  0EF5     MOVLW 0xF5
1E7A0  50E3     MOVF 0xFE3, W, ACCESS
1E7A2  58DE     SUBWFB 0xFDE, W, ACCESS
1E7A4  0EF6     MOVLW 0xF6
1E7A6  50E3     MOVF 0xFE3, W, ACCESS
1E7A8  58DE     SUBWFB 0xFDE, W, ACCESS
1E7AA  A0D8     BTFSS 0xFD8, 0, ACCESS
1E7AC  D015     BRA 0xE7D8
23:            				dividend -= divisor;
1E7AE  50E1     MOVF 0xFE1, W, ACCESS
1E7B0  0FF7     ADDLW 0xF7
1E7B2  6ED9     MOVWF 0xFD9, ACCESS
1E7B4  50E2     MOVF 0xFE2, W, ACCESS
1E7B6  6EDA     MOVWF __end_of_UART2_tx_vect_isr, ACCESS
1E7B8  0EFF     MOVLW 0xFF
1E7BA  22DA     ADDWFC __end_of_UART2_tx_vect_isr, F, ACCESS
1E7BC  0EF3     MOVLW 0xF3
1E7BE  50E3     MOVF 0xFE3, W, ACCESS
1E7C0  5EDE     SUBWF 0xFDE, F, ACCESS
1E7C2  0EF4     MOVLW 0xF4
1E7C4  50E3     MOVF 0xFE3, W, ACCESS
1E7C6  5ADE     SUBWFB 0xFDE, F, ACCESS
1E7C8  0EF5     MOVLW 0xF5
1E7CA  50E3     MOVF 0xFE3, W, ACCESS
1E7CC  5ADE     SUBWFB 0xFDE, F, ACCESS
1E7CE  0EF6     MOVLW 0xF6
1E7D0  50E3     MOVF 0xFE3, W, ACCESS
1E7D2  5ADE     SUBWFB 0xFDE, F, ACCESS
24:            				quotient |= 1;
1E7D4  0EFB     MOVLW 0xFB
1E7D6  80E3     BSF 0xFE3, 0, ACCESS
25:            			}
26:            			divisor >>= 1;
1E7D8  90D8     BCF 0xFD8, 0, ACCESS
1E7DA  0EF6     MOVLW 0xF6
1E7DC  32E3     RRCF 0xFE3, F, ACCESS
1E7DE  0EF5     MOVLW 0xF5
1E7E0  32E3     RRCF 0xFE3, F, ACCESS
1E7E2  0EF4     MOVLW 0xF4
1E7E4  32E3     RRCF 0xFE3, F, ACCESS
1E7E6  0EF3     MOVLW 0xF3
1E7E8  32E3     RRCF 0xFE3, F, ACCESS
27:            		} while(--counter != 0);
1E7EA  0EFF     MOVLW 0xFF
1E7EC  50E3     MOVF 0xFE3, W, ACCESS
1E7EE  6E01     MOVWF __ptext283, ACCESS
1E7F0  0E01     MOVLW 0x1
1E7F2  5E01     SUBWF __ptext283, F, ACCESS
1E7F4  0EFF     MOVLW 0xFF
1E7F6  0061     MOVFFL ltemp0, PLUSW1
1E7F8  F404     NOP
1E7FA  F4E3     NOP
1E7FC  A4D8     BTFSS 0xFD8, 2, ACCESS
1E7FE  D7B9     BRA 0xE772
28:            	}
29:            	return quotient;
1E800  0EFB     MOVLW 0xFB
1E802  0061     MOVFFL PLUSW1, ltemp0
1E804  F38C     NOP
1E806  F501     NOP
1E808  0EFC     MOVLW 0xFC
1E80A  0061     MOVFFL PLUSW1, ttemp5
1E80C  F38C     NOP
1E80E  F502     NOP
1E810  0EFD     MOVLW 0xFD
1E812  0061     MOVFFL PLUSW1, wtemp1
1E814  F38C     NOP
1E816  F503     NOP
1E818  0EFE     MOVLW 0xFE
1E81A  0061     MOVFFL PLUSW1, ttemp1
1E81C  F38C     NOP
1E81E  F504     NOP
30:            }
1E820  0EF3     MOVLW 0xF3
1E822  26E1     ADDWF 0xFE1, F, ACCESS
1E824  0EFF     MOVLW 0xFF
1E826  22E2     ADDWFC 0xFE2, F, ACCESS
1E826  22E2     ADDWFC 0xFE2, F, ACCESS
---  /opt/microchip/xc8/v2.41/pic/sources/c99/common/__fpclassifyf.c  -----------------------------------
1:             #include <math.h>
2:             #include <stdint.h>
3:             
4:             int __fpclassifyf(float x)
1D0BE  0E06     MOVLW 0x6
1D0C0  26E1     ADDWF 0xFE1, F, ACCESS
1D0C2  0E00     MOVLW 0x0
1D0C4  22E2     ADDWFC 0xFE2, F, ACCESS
5:             {
6:             	union {float f; uint32_t i;} u = {x};
1D0C6  0061     MOVFFL F465, ltemp2
1D0C8  FCA4     NOP
1D0CA  F509     NOP
1D0CC  0061     MOVFFL 0x72A, ttemp3
1D0CE  FCA8     NOP
1D0D0  F50A     NOP
1D0D2  0061     MOVFFL 0x72B, wtemp5
1D0D4  FCAC     NOP
1D0D6  F50B     NOP
1D0D8  0061     MOVFFL 0x72C, 0x50C
1D0DA  FCB0     NOP
1D0DC  F50C     NOP
1D0DE  0EFA     MOVLW 0xFA
1D0E0  0061     MOVFFL ltemp2, PLUSW1
1D0E2  F424     NOP
1D0E4  F4E3     NOP
1D0E6  0EFB     MOVLW 0xFB
1D0E8  0061     MOVFFL ttemp3, PLUSW1
1D0EA  F428     NOP
1D0EC  F4E3     NOP
1D0EE  0EFC     MOVLW 0xFC
1D0F0  0061     MOVFFL wtemp5, PLUSW1
1D0F2  F42C     NOP
1D0F4  F4E3     NOP
1D0F6  0EFD     MOVLW 0xFD
1D0F8  0061     MOVFFL 0x50C, PLUSW1
1D0FA  F430     NOP
1D0FC  F4E3     NOP
1D0FE  0EF6     MOVLW 0xF6
1D100  0061     MOVFFL PLUSW1, ltemp2
1D102  F38C     NOP
1D104  F509     NOP
1D106  0EF7     MOVLW 0xF7
1D108  0061     MOVFFL PLUSW1, ttemp3
1D10A  F38C     NOP
1D10C  F50A     NOP
1D10E  0EF8     MOVLW 0xF8
1D110  0061     MOVFFL PLUSW1, wtemp5
1D112  F38C     NOP
1D114  F50B     NOP
1D116  0EF9     MOVLW 0xF9
1D118  0061     MOVFFL PLUSW1, 0x50C
1D11A  F38C     NOP
1D11C  F50C     NOP
1D11E  0EFA     MOVLW 0xFA
1D120  0061     MOVFFL ltemp2, PLUSW1
1D122  F424     NOP
1D124  F4E3     NOP
1D126  0EFB     MOVLW 0xFB
1D128  0061     MOVFFL ttemp3, PLUSW1
1D12A  F428     NOP
1D12C  F4E3     NOP
1D12E  0EFC     MOVLW 0xFC
1D130  0061     MOVFFL wtemp5, PLUSW1
1D132  F42C     NOP
1D134  F4E3     NOP
1D136  0EFD     MOVLW 0xFD
1D138  0061     MOVFFL 0x50C, PLUSW1
1D13A  F430     NOP
1D13C  F4E3     NOP
7:             	int e = u.i>>23 & 0xff;
1D13E  0EFA     MOVLW 0xFA
1D140  0061     MOVFFL PLUSW1, ltemp2
1D142  F38C     NOP
1D144  F509     NOP
1D146  0EFB     MOVLW 0xFB
1D148  0061     MOVFFL PLUSW1, ttemp3
1D14A  F38C     NOP
1D14C  F50A     NOP
1D14E  0EFC     MOVLW 0xFC
1D150  0061     MOVFFL PLUSW1, wtemp5
1D152  F38C     NOP
1D154  F50B     NOP
1D156  0EFD     MOVLW 0xFD
1D158  0061     MOVFFL PLUSW1, 0x50C
1D15A  F38C     NOP
1D15C  F50C     NOP
1D15E  0E18     MOVLW 0x18
1D160  D005     BRA 0xD16C
1D162  90D8     BCF 0xFD8, 0, ACCESS
1D164  320C     RRCF 0xC, F, ACCESS
1D166  320B     RRCF 0xB, F, ACCESS
1D168  320A     RRCF 0xA, F, ACCESS
1D16A  3209     RRCF 0x9, F, ACCESS
1D16C  2EE8     DECFSZ 0xFE8, F, ACCESS
1D16E  D7F9     BRA 0xD162
1D170  0061     MOVFFL ltemp2, ttemp2
1D172  F424     NOP
1D174  F507     NOP
1D176  0061     MOVFFL ttemp3, 0x508
1D178  F428     NOP
1D17A  F508     NOP
1D17C  0EFF     MOVLW 0xFF
1D17E  1607     ANDWF 0x7, F, ACCESS
1D180  0E00     MOVLW 0x0
1D182  1608     ANDWF 0x8, F, ACCESS
1D184  0EFE     MOVLW 0xFE
1D186  0061     MOVFFL ttemp2, PLUSW1
1D188  F41C     NOP
1D18A  F4E3     NOP
1D18C  0EFF     MOVLW 0xFF
1D18E  0061     MOVFFL 0x508, PLUSW1
1D190  F420     NOP
1D192  F4E3     NOP
8:             	if (!e) return u.i<<1 ? FP_SUBNORMAL : FP_ZERO;
1D194  0EFE     MOVLW 0xFE
1D196  0061     MOVFFL PLUSW1, ltemp0
1D198  F38C     NOP
1D19A  F501     NOP
1D19C  0EFF     MOVLW 0xFF
1D19E  50E3     MOVF 0xFE3, W, ACCESS
1D1A0  1001     IORWF __ptext283, W, ACCESS
1D1A2  A4D8     BTFSS 0xFD8, 2, ACCESS
1D1A4  D023     BRA 0xD1EC
1D1A6  0EFA     MOVLW 0xFA
1D1A8  0061     MOVFFL PLUSW1, ltemp2
1D1AA  F38C     NOP
1D1AC  F509     NOP
1D1AE  0EFB     MOVLW 0xFB
1D1B0  0061     MOVFFL PLUSW1, ttemp3
1D1B2  F38C     NOP
1D1B4  F50A     NOP
1D1B6  0EFC     MOVLW 0xFC
1D1B8  0061     MOVFFL PLUSW1, wtemp5
1D1BA  F38C     NOP
1D1BC  F50B     NOP
1D1BE  0EFD     MOVLW 0xFD
1D1C0  0061     MOVFFL PLUSW1, 0x50C
1D1C2  F38C     NOP
1D1C4  F50C     NOP
1D1C6  90D8     BCF 0xFD8, 0, ACCESS
1D1C8  3409     RLCF 0x9, W, ACCESS
1D1CA  6E05     MOVWF 0x5, ACCESS
1D1CC  340A     RLCF 0xA, W, ACCESS
1D1CE  6E06     MOVWF 0x6, ACCESS
1D1D0  340B     RLCF 0xB, W, ACCESS
1D1D2  6E07     MOVWF 0x7, ACCESS
1D1D4  340C     RLCF 0xC, W, ACCESS
1D1D6  6E08     MOVWF 0x8, ACCESS
1D1D8  5005     MOVF 0x5, W, ACCESS
1D1DA  1006     IORWF 0x6, W, ACCESS
1D1DC  1007     IORWF 0x7, W, ACCESS
1D1DE  1008     IORWF 0x8, W, ACCESS
1D1E0  A4D8     BTFSS 0xFD8, 2, ACCESS
1D1E2  D002     BRA 0xD1E8
1D1E4  0E02     MOVLW 0x2
1D1E6  D02E     BRA 0xD244
1D1E8  0E03     MOVLW 0x3
1D1EA  D02C     BRA 0xD244
9:             	if (e==0xff) return u.i<<9 ? FP_NAN : FP_INFINITE;
1D1EC  0EFE     MOVLW 0xFE
1D1EE  28E3     INCF 0xFE3, W, ACCESS
1D1F0  E128     BNZ 0xD242
1D1F2  0EFF     MOVLW 0xFF
1D1F4  50E3     MOVF 0xFE3, W, ACCESS
1D1F6  A4D8     BTFSS 0xFD8, 2, ACCESS
1D1F8  D024     BRA 0xD242
1D1FA  0EFA     MOVLW 0xFA
1D1FC  0061     MOVFFL PLUSW1, ltemp2
1D1FE  F38C     NOP
1D200  F509     NOP
1D202  0EFB     MOVLW 0xFB
1D204  0061     MOVFFL PLUSW1, ttemp3
1D206  F38C     NOP
1D208  F50A     NOP
1D20A  0EFC     MOVLW 0xFC
1D20C  0061     MOVFFL PLUSW1, wtemp5
1D20E  F38C     NOP
1D210  F50B     NOP
1D212  0EFD     MOVLW 0xFD
1D214  0061     MOVFFL PLUSW1, 0x50C
1D216  F38C     NOP
1D218  F50C     NOP
1D21A  0E09     MOVLW 0x9
1D21C  90D8     BCF 0xFD8, 0, ACCESS
1D21E  3609     RLCF 0x9, F, ACCESS
1D220  360A     RLCF 0xA, F, ACCESS
1D222  360B     RLCF 0xB, F, ACCESS
1D224  360C     RLCF 0xC, F, ACCESS
1D226  2EE8     DECFSZ 0xFE8, F, ACCESS
1D228  D7F9     BRA 0xD21C
1D22A  5009     MOVF 0x9, W, ACCESS
1D22C  100A     IORWF 0xA, W, ACCESS
1D22E  100B     IORWF 0xB, W, ACCESS
1D230  100C     IORWF 0xC, W, ACCESS
1D232  A4D8     BTFSS 0xFD8, 2, ACCESS
1D234  D002     BRA 0xD23A
1D236  0E01     MOVLW 0x1
1D238  D001     BRA 0xD23C
1D23A  0E00     MOVLW 0x0
1D23C  6E01     MOVWF __ptext283, ACCESS
1D23E  6A02     CLRF ___rparam_used, ACCESS
1D240  D004     BRA 0xD24A
10:            	return FP_NORMAL;
1D242  0E04     MOVLW 0x4
1D244  6E01     MOVWF __ptext283, ACCESS
1D246  0E00     MOVLW 0x0
1D248  6E02     MOVWF ___rparam_used, ACCESS
11:            }
1D24A  0EF6     MOVLW 0xF6
1D24C  26E1     ADDWF 0xFE1, F, ACCESS
1D24E  0EFF     MOVLW 0xFF
1D250  22E2     ADDWFC 0xFE2, F, ACCESS
1D250  22E2     ADDWFC 0xFE2, F, ACCESS
---  /opt/microchip/xc8/v2.41/pic/sources/c99/common/Umul32.c  ------------------------------------------
1:             // 32 x 32 bit multiplication with 32 bit result
2:             #ifdef _PIC18
3:             #define _Has_hardware_multiply 1
4:             #else
5:             #define _Has_hardware_multiply 0
6:             #endif
7:             
8:             #if defined(_PIC14E) || defined(_PIC14EX) || defined(_PIC18)
9:             #define _Has_large_call_stack 1
10:            #else
11:            #define _Has_large_call_stack 0
12:            #endif
13:            
14:            unsigned long
15:            __lmul(unsigned long multiplier, unsigned long multiplicand)
1F6AE  52E6     MOVF 0xFE6, F, ACCESS
1F6B0  52E6     MOVF 0xFE6, F, ACCESS
1F6B2  52E6     MOVF 0xFE6, F, ACCESS
1F6B4  52E6     MOVF 0xFE6, F, ACCESS
16:            {
17:            	unsigned long product;
18:            
19:            #define LOWBYTE(x)  (*(unsigned char *)(&x))
20:            #define LMIDBYTE(x) (*(((unsigned char *)(&x))+1))
21:            #define HMIDBYTE(x) (*(((unsigned char *)(&x))+2))
22:            #define HIGHBYTE(x) (*(((unsigned char *)(&x))+3))
23:            
24:            #if (_Has_hardware_multiply || _Has_large_call_stack) && defined(__OPTIMIZE_SPEED__)
25:            	{
26:            
27:            #define USE_SHRINK
28:            
29:            /*
30:            a 32-bit multiply can be decomposed into the sum of ten 8-bit multiplies
31:                         a  b  c  d
32:            *            e  f  g  h
33:            -----------------------
34:                       |         dh
35:                       |      ch  0
36:                       |   bh  0  0
37:                       |ah  0  0  0
38:                       |      dg  0
39:                       |   cg  0  0
40:                       |bg  0  0  0
41:                     ag| 0  0  0  0 (we ignore this intermediate product
42:                                     because it does not affect the low 32 bits of the result)
43:                       |   df  0  0
44:                       |cf  0  0  0
45:                     bf| 0  0  0  0 (ignore)
46:                  af  0| 0  0  0  0 (ignore)
47:                       |de  0  0  0
48:                     ce| 0  0  0  0 (ignore)
49:                  be  0| 0  0  0  0 (ignore)
50:            +  ae  0  0| 0  0  0  0 (ignore)
51:            =======================
52:             */
53:            		product =  (unsigned int)LOWBYTE(multiplier) * LOWBYTE(multiplicand);
54:            
55:            #if defined(USE_MASKS)
56:            		product += ((unsigned long)
57:            			     ((unsigned int)LOWBYTE(multiplier) * LMIDBYTE(multiplicand))
58:            			     +
59:            			     ((unsigned int)LMIDBYTE(multiplier) * LOWBYTE(multiplicand)))
60:            			<< 8;
61:            
62:            		product += ((unsigned long)
63:            			    ((unsigned int)LOWBYTE(multiplier) * HMIDBYTE(multiplicand))
64:            			    +
65:            			    ((unsigned int)LMIDBYTE(multiplier) * LMIDBYTE(multiplicand))
66:            			    +
67:            			    ((unsigned int)HMIDBYTE(multiplier) * LOWBYTE(multiplicand)))
68:            			<< 16;
69:            
70:            		/* cast to smaller type to avoid adding high bits just to discard */
71:            		product += ((unsigned long)
72:            			    (unsigned char)
73:            			    ((unsigned int)LOWBYTE(multiplier) * HIGHBYTE(multiplicand))
74:            			    +
75:            			    (unsigned char)
76:            			    ((unsigned int)LMIDBYTE(multiplier) * HMIDBYTE(multiplicand))
77:            			    +
78:            			    (unsigned char)
79:            			    ((unsigned int)HMIDBYTE(multiplier) * LMIDBYTE(multiplicand))
80:            			    +
81:            			    (unsigned char)
82:            			    ((unsigned int)HIGHBYTE(multiplier) * LOWBYTE(multiplicand)))
83:            			<< 24;
84:            
85:            #elif defined(USE_SHRINK)
86:            		/* add direct to upper bytes, rather than shift and add all bytes */
87:            		*((__uint24 *)(((unsigned char*)&product)+1)) +=
88:            			((unsigned int)LOWBYTE(multiplier) * LMIDBYTE(multiplicand));
89:            		*((__uint24 *)(((unsigned char*)&product)+1)) +=
90:            			((unsigned int)LMIDBYTE(multiplier) * LOWBYTE(multiplicand));
91:            
92:            
93:            		*((unsigned int*)(((unsigned char*)&product)+2)) +=
94:            			((unsigned int)LOWBYTE(multiplier) * HMIDBYTE(multiplicand));
95:            		*((unsigned int*)(((unsigned char*)&product)+2)) +=
96:            			((unsigned int)LMIDBYTE(multiplier) * LMIDBYTE(multiplicand));
97:            		*((unsigned int*)(((unsigned char*)&product)+2)) +=
98:            			((unsigned int)HMIDBYTE(multiplier) * LOWBYTE(multiplicand));
99:            
100:           		*(((unsigned char*)&product)+3) +=
101:           			(unsigned char)
102:           			((unsigned int)LOWBYTE(multiplier) * HIGHBYTE(multiplicand));
103:           		*(((unsigned char*)&product)+3) +=
104:           			(unsigned char)
105:           			((unsigned int)LMIDBYTE(multiplier) * HMIDBYTE(multiplicand));
106:           		*(((unsigned char*)&product)+3) +=
107:           			(unsigned char)
108:           			((unsigned int)HMIDBYTE(multiplier) * LMIDBYTE(multiplicand));
109:           		*(((unsigned char*)&product)+3) +=
110:           			(unsigned char)
111:           			((unsigned int)HIGHBYTE(multiplier) * LOWBYTE(multiplicand));
112:           
113:           #else
114:           #error No method chosen
115:           #endif
116:           	}
117:           #else
118:           
119:           	product = 0;
1F6B6  0EFC     MOVLW 0xFC
1F6B8  6AE3     CLRF 0xFE3, ACCESS
1F6BA  0EFD     MOVLW 0xFD
1F6BC  6AE3     CLRF 0xFE3, ACCESS
1F6BE  0EFE     MOVLW 0xFE
1F6C0  6AE3     CLRF 0xFE3, ACCESS
1F6C2  0EFF     MOVLW 0xFF
1F6C4  6AE3     CLRF 0xFE3, ACCESS
120:           	do {
121:           		if(multiplier & 1)
1F6C6  0EF8     MOVLW 0xF8
1F6C8  A0E3     BTFSS 0xFE3, 0, ACCESS
1F6CA  D028     BRA 0xF71C
122:           			product += multiplicand;
1F6CC  0EFC     MOVLW 0xFC
1F6CE  50E3     MOVF 0xFE3, W, ACCESS
1F6D0  6E01     MOVWF __ptext283, ACCESS
1F6D2  0EF4     MOVLW 0xF4
1F6D4  50E3     MOVF 0xFE3, W, ACCESS
1F6D6  2601     ADDWF __ptext283, F, ACCESS
1F6D8  0EFC     MOVLW 0xFC
1F6DA  0061     MOVFFL ltemp0, PLUSW1
1F6DC  F404     NOP
1F6DE  F4E3     NOP
1F6E0  0EFD     MOVLW 0xFD
1F6E2  50E3     MOVF 0xFE3, W, ACCESS
1F6E4  6E01     MOVWF __ptext283, ACCESS
1F6E6  0EF5     MOVLW 0xF5
1F6E8  50E3     MOVF 0xFE3, W, ACCESS
1F6EA  2201     ADDWFC __ptext283, F, ACCESS
1F6EC  0EFD     MOVLW 0xFD
1F6EE  0061     MOVFFL ltemp0, PLUSW1
1F6F0  F404     NOP
1F6F2  F4E3     NOP
1F6F4  0EFE     MOVLW 0xFE
1F6F6  50E3     MOVF 0xFE3, W, ACCESS
1F6F8  6E01     MOVWF __ptext283, ACCESS
1F6FA  0EF6     MOVLW 0xF6
1F6FC  50E3     MOVF 0xFE3, W, ACCESS
1F6FE  2201     ADDWFC __ptext283, F, ACCESS
1F700  0EFE     MOVLW 0xFE
1F702  0061     MOVFFL ltemp0, PLUSW1
1F704  F404     NOP
1F706  F4E3     NOP
1F708  0EFF     MOVLW 0xFF
1F70A  50E3     MOVF 0xFE3, W, ACCESS
1F70C  6E01     MOVWF __ptext283, ACCESS
1F70E  0EF7     MOVLW 0xF7
1F710  50E3     MOVF 0xFE3, W, ACCESS
1F712  2201     ADDWFC __ptext283, F, ACCESS
1F714  0EFF     MOVLW 0xFF
1F716  0061     MOVFFL ltemp0, PLUSW1
1F718  F404     NOP
1F71A  F4E3     NOP
123:           		multiplicand <<= 1;
1F71C  90D8     BCF 0xFD8, 0, ACCESS
1F71E  0EF4     MOVLW 0xF4
1F720  36E3     RLCF 0xFE3, F, ACCESS
1F722  0EF5     MOVLW 0xF5
1F724  36E3     RLCF 0xFE3, F, ACCESS
1F726  0EF6     MOVLW 0xF6
1F728  36E3     RLCF 0xFE3, F, ACCESS
1F72A  0EF7     MOVLW 0xF7
1F72C  36E3     RLCF 0xFE3, F, ACCESS
124:           		multiplier >>= 1;
1F72E  90D8     BCF 0xFD8, 0, ACCESS
1F730  0EFB     MOVLW 0xFB
1F732  32E3     RRCF 0xFE3, F, ACCESS
1F734  0EFA     MOVLW 0xFA
1F736  32E3     RRCF 0xFE3, F, ACCESS
1F738  0EF9     MOVLW 0xF9
1F73A  32E3     RRCF 0xFE3, F, ACCESS
1F73C  0EF8     MOVLW 0xF8
1F73E  32E3     RRCF 0xFE3, F, ACCESS
125:           	} while(multiplier != 0);
1F740  0EF8     MOVLW 0xF8
1F742  50E3     MOVF 0xFE3, W, ACCESS
1F744  E1C0     BNZ 0xF6C6
1F746  0EF9     MOVLW 0xF9
1F748  50E3     MOVF 0xFE3, W, ACCESS
1F74A  E1BD     BNZ 0xF6C6
1F74C  0EFA     MOVLW 0xFA
1F74E  50E3     MOVF 0xFE3, W, ACCESS
1F750  E1BA     BNZ 0xF6C6
1F752  0EFB     MOVLW 0xFB
1F754  50E3     MOVF 0xFE3, W, ACCESS
1F756  A4D8     BTFSS 0xFD8, 2, ACCESS
1F758  D7B6     BRA 0xF6C6
126:           
127:           #endif
128:           	return product;
1F75A  0EFC     MOVLW 0xFC
1F75C  0061     MOVFFL PLUSW1, ltemp0
1F75E  F38C     NOP
1F760  F501     NOP
1F762  0EFD     MOVLW 0xFD
1F764  0061     MOVFFL PLUSW1, ttemp5
1F766  F38C     NOP
1F768  F502     NOP
1F76A  0EFE     MOVLW 0xFE
1F76C  0061     MOVFFL PLUSW1, wtemp1
1F76E  F38C     NOP
1F770  F503     NOP
1F772  0EFF     MOVLW 0xFF
1F774  0061     MOVFFL PLUSW1, ttemp1
1F776  F38C     NOP
1F778  F504     NOP
129:           }
1F77A  0EF4     MOVLW 0xF4
1F77C  26E1     ADDWF 0xFE1, F, ACCESS
1F77E  0EFF     MOVLW 0xFF
1F780  22E2     ADDWFC 0xFE2, F, ACCESS
1F780  22E2     ADDWFC 0xFE2, F, ACCESS
